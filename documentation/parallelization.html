<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
    <title>Parallelization &#8212; FreeFem++ 3.61.2 documentation</title>

    <link rel="stylesheet" href="../_static/material-icons.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/extra.css" />
    <link rel="stylesheet" type="text/css" href="../_static/notosanscjkjp.css" />
    <link rel="stylesheet" type="text/css" href="../_static/roboto.css" />
    <link rel="stylesheet" type="text/css" href="../_static/material-design-lite-1.3.0/material.indigo-pink.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_materialdesign_theme.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/sphinx_materialdesign_theme.js"></script>
    <link rel="canonical" href="doc.freefem.org/dev/documentation/parallelization.html" />
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Plugins" href="plugins.html" />
    <link rel="prev" title="Algorithms &amp; Optimization" href="algorithmsOptimization.html" /> 
  </head>
<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header mdl-layout--fixed-drawer"><header class="mdl-layout__header mdl-layout__header--waterfall ">
    <div class="mdl-layout__header-row">
        
        <nav class="mdl-navigation breadcrumb">
            <a class="mdl-navigation__link" href="index.html">Documentation</a><i class="material-icons">navigate_next</i>
            <a class="mdl-navigation__link is-active">Parallelization</a>
        </nav>
        <div class="mdl-layout-spacer"></div>
        <nav class="mdl-navigation">
        
<form class="form-inline pull-sm-right" action="../search.html" method="get">
      <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right">
        <label id="quick-search-icon" class="mdl-button mdl-js-button mdl-button--icon"  for="waterfall-exp">
            <i class="material-icons">search</i>
        </label>
        <div class="mdl-textfield__expandable-holder">
          <input class="mdl-textfield__input" type="text" name="q"  id="waterfall-exp" placeholder="Search" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </div>
      </div>
      <div class="mdl-tooltip" data-mdl-for="quick-search-icon">
      Quick search
      </div>
</form>
        
<a id="button-show-source"
    class="mdl-button mdl-js-button mdl-button--icon"
    href="../_sources/documentation/parallelization.rst.txt" rel="nofollow">
<i class="material-icons">code</i>
</a>
<div class="mdl-tooltip" data-mdl-for="button-show-source">
Show Source
</div>
        </nav>
    </div>
    <div class="mdl-layout__header-row header-links">
      <div class="mdl-layout-spacer"></div>
      <nav class="mdl-navigation">
      </nav>
    </div>
</header><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <span class="title-text">
                  FreeFem++
              </span>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <p class="caption"><span class="caption-text">Table of contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../introduction/introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/download.html">Download FreeFem++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/installation.html">Installation guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/contributing.html">Contributing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/citation.html">Citation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/authors.html">Authors</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="documentation.html">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="notations.html">Notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="meshGeneration.html">Mesh Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="finiteElement.html">Finite element</a></li>
<li class="toctree-l2"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithmsOptimization.html">Algorithms &amp; Optimization</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="plugins.html">Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="developers.html">Developers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Language references</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/reference.html">Language reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/globalVariables.html">Global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/quadratureFormulae.html">Quadrature formulae</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/operators.html">Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/loops.html">Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/IO.html">I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/externalLibraries.html">External libraries</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/tutorial.html">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/poisson.html">Solving Poisson’s equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/equationsClassification.html">Classification of partial differential equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/membrane.html">Membrane</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/heatExchanger.html">Heat Exchanger</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/acoustics.html">Acoustics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/thermalConduction.html">Thermal Conduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/fanBlade.html">Irrotational Fan Blade Flow and Thermal effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/rotatingHill.html">Pure Convection : The Rotating Hill</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/elasticity.html">The System of elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/stokes.html">The System of Stokes for Fluids</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/navierStokesProjection.html">A projection algorithm for the Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/navierStokesNewton.html">Newton Method for the Steady Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/aLargeFluidProblem.html">A Large Fluid Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/complexNumbers.html">An Example with Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/optimalControl.html">Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/flowWithShocks.html">A Flow with Shocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/heatEquationOptimization.html">Time dependent schema optimization for heat equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/timeDependentStokes.html">Tutorial to write a transient Stokes solver in matrix form</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/wifiPropagation.html">Wifi Propagation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/matlabOctavePlot.html">Plotting in Matlab and Octave</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../example/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model/index.html">Mathematical Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../model/model.html">Mathematical Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/staticProblems.html">Static problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/elasticity.html">Elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/nonLinearStaticProblems.html">Non-linear static problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/eigenValueProblems.html">Eigen value problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/evolutionProblems.html">Evolution problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/navierStokesEquations.html">Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/variationalInequality.html">Variational Inequality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/domainDecomposition.html">Domain decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/fluidStructureCoupledProblem.html">Fluid-structure coupled problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/transmissionProblem.html">Transmission problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/freeBoundaryProblem.html">Free boundary problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/nonLinearElasticity.html">Non-linear elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/compressibleNeoHookeanMaterials.html">Compressible Neo-Hookean materials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/whisperingGalleryModes.html">Whispering gallery modes</a></li>
</ul>
</li>
</ul>

            </nav>
        
        </div>
    
</header>
        <main class="mdl-layout__content" tabIndex="0">
<header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <span class="title-text">
                  FreeFem++
              </span>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <p class="caption"><span class="caption-text">Table of contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../introduction/introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/download.html">Download FreeFem++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/installation.html">Installation guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/contributing.html">Contributing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/citation.html">Citation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/authors.html">Authors</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="documentation.html">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="notations.html">Notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="meshGeneration.html">Mesh Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="finiteElement.html">Finite element</a></li>
<li class="toctree-l2"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithmsOptimization.html">Algorithms &amp; Optimization</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="plugins.html">Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="developers.html">Developers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Language references</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/reference.html">Language reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/globalVariables.html">Global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/quadratureFormulae.html">Quadrature formulae</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/operators.html">Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/loops.html">Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/IO.html">I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/externalLibraries.html">External libraries</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/tutorial.html">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/poisson.html">Solving Poisson’s equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/equationsClassification.html">Classification of partial differential equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/membrane.html">Membrane</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/heatExchanger.html">Heat Exchanger</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/acoustics.html">Acoustics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/thermalConduction.html">Thermal Conduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/fanBlade.html">Irrotational Fan Blade Flow and Thermal effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/rotatingHill.html">Pure Convection : The Rotating Hill</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/elasticity.html">The System of elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/stokes.html">The System of Stokes for Fluids</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/navierStokesProjection.html">A projection algorithm for the Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/navierStokesNewton.html">Newton Method for the Steady Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/aLargeFluidProblem.html">A Large Fluid Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/complexNumbers.html">An Example with Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/optimalControl.html">Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/flowWithShocks.html">A Flow with Shocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/heatEquationOptimization.html">Time dependent schema optimization for heat equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/timeDependentStokes.html">Tutorial to write a transient Stokes solver in matrix form</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/wifiPropagation.html">Wifi Propagation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/matlabOctavePlot.html">Plotting in Matlab and Octave</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../example/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model/index.html">Mathematical Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../model/model.html">Mathematical Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/staticProblems.html">Static problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/elasticity.html">Elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/nonLinearStaticProblems.html">Non-linear static problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/eigenValueProblems.html">Eigen value problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/evolutionProblems.html">Evolution problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/navierStokesEquations.html">Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/variationalInequality.html">Variational Inequality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/domainDecomposition.html">Domain decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/fluidStructureCoupledProblem.html">Fluid-structure coupled problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/transmissionProblem.html">Transmission problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/freeBoundaryProblem.html">Free boundary problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/nonLinearElasticity.html">Non-linear elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/compressibleNeoHookeanMaterials.html">Compressible Neo-Hookean materials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/whisperingGalleryModes.html">Whispering gallery modes</a></li>
</ul>
</li>
</ul>

            </nav>
        
        </div>
    
</header>

    <div class="document">
        <div class="page-content">
        
  <div class="section" id="parallelization">
<h1>Parallelization<a class="headerlink" href="#parallelization" title="Permalink to this headline">¶</a></h1>
<p>A first attempt of parallelization of FreeFem++ is made here with <strong>MPI</strong>.
An extended interface with MPI has been added to FreeFem++ version 3.5, (see the <a class="reference external" href="http://mpi-forum.org/docs/">MPI documentation</a> for the functionality of the language).</p>
<div class="section" id="mpi">
<h2>MPI<a class="headerlink" href="#mpi" title="Permalink to this headline">¶</a></h2>
<div class="section" id="mpi-keywords">
<h3>MPI Keywords<a class="headerlink" href="#mpi-keywords" title="Permalink to this headline">¶</a></h3>
<p>The following keywords and concepts are used:</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiComm</code> to defined a <em>communication world</em></li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiGroup</code> to defined a group of <em>processors</em> in the communication world</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiRequest</code> to defined a request to wait for the end of the communication</li>
</ul>
</div>
<div class="section" id="mpi-constants">
<h3>MPI Constants<a class="headerlink" href="#mpi-constants" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpisize</code> The total number of <em>processes</em>,</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpirank</code> the id-number of my current process in <code class="docutils literal highlight highlight-freefem"><span></span>{0, ..., mpisize-1}</code>,</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiUndefined</code> The <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">MPI_Undefined</span></code> constant,</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiAnySource</code> The <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">MPI_ANY_SOURCE</span></code> constant,</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiCommWorld</code> The <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">MPI_COMM_WORLD</span></code> constant,</li>
<li>[ … ] and all the keywords of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>MPI_Op</code> for the <em>reduce</em> operator: <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiMAX</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiMIN</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiSUM</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiPROD</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiLAND</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiLOR</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiLXOR</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiBAND</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiBXOR</code>.</li>
</ul>
</div>
<div class="section" id="mpi-constructor">
<h3>MPI Constructor<a class="headerlink" href="#mpi-constructor" title="Permalink to this headline">¶</a></h3>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
int[int] proc1 = [1, 2], proc2 = [0, 3];
int color = 1;
int key = 1;

// MPI ranks
cout &lt;&lt; &quot;MPI rank = &quot; &lt;&lt; mpirank &lt;&lt; endl;

// MPI
mpiComm comm(mpiCommWorld, 0, 0); //set a MPI_Comm to MPI_COMM_WORLD

mpiGroup grp(proc1); //set MPI_Group to proc 1,2 in MPI_COMM_WORLD
mpiGroup grp1(comm, proc1); //set MPI_Group to proc 1,2 in comm

mpiComm ncomm1(mpiCommWorld, grp); //set the MPI_Comm form grp

mpiComm ncomm2(comm, color, key); //MPI_Comm_split(MPI_Comm comm, int color, int key, MPI_Comm *ncomm)

mpiRequest rq; //defined an MPI_Request
mpiRequest[int] arq(10); //defined an array of 10 MPI_Request
</pre></div>
</div>
</div>
<div class="section" id="mpi-functions">
<h3>MPI Functions<a class="headerlink" href="#mpi-functions" title="Permalink to this headline">¶</a></h3>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mpiComm Comm(mpiCommWorld, 0, 0);

int MPICommSize = mpiSize(Comm);
int MPIRank = mpiRank(Comm);

if (MPIRank == 0) cout &lt;&lt; &quot;MPI Comm size = &quot; &lt;&lt; MPICommSize &lt;&lt; endl;
cout &lt;&lt; &quot;MPI rank in Comm = &quot; &lt;&lt; mpiRank(Comm) &lt;&lt; endl;

mpiRequest Req;
mpiRequest[int] ReqArray(10);

for (int i = 0; i &lt; MPICommSize; i++){
     //return processor i with no Resquest in MPI_COMM_WORLD
    processor(i);
    //return processor any source with no Resquest in MPI_COMM_WORLD
    processor(mpiAnySource);
    //return processor i with no Resquest in Comm
    processor(i, Comm);
    //return processor i with no Resquest in Comm
    processor(Comm, i);
    //return processor i with Resquest rq in Comm
    /* processor(i, Req, Comm);
    //return processor i with Resquest rq in MPI_COMM_WORLD
    processor(i, Req); */
    //return processor i in MPI_COMM_WORLD in block mode for synchronously communication
    processorblock(i);
    //return processor any source in MPI_COMM_WORLD in block mode for synchronously communication
    processorblock(mpiAnySource);
    //return processor i in in Comm in block mode
    processorblock(i, Comm);
}

mpiBarrier(Comm); //do a MPI_Barrier on communicator Comm
mpiWaitAny(ReqArray); //wait add of Request array,
mpiWait(Req); //wait on a Request
real t = mpiWtime(); //return MPIWtime in second
real tick = mpiWtick(); //return MPIWTick in second
</pre></div>
</div>
<p>where a <code class="code freefem docutils literal highlight highlight-freefem"><span></span>processor</code> is just a integer rank, pointer to a <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">MPI_comm</span></code> and pointer to a <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">MPI_Request</span></code>, and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>processorblock</code> with a special <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">MPI_Request</span></code>.</p>
</div>
<div class="section" id="mpi-communicator-operator">
<h3>MPI Communicator operator<a class="headerlink" href="#mpi-communicator-operator" title="Permalink to this headline">¶</a></h3>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>int status; //to get the MPI status of send / recv
real a, b;

mpiComm comm(mpiCommWorld, 0, 0);
mpiRequest req;

//send a,b asynchronously to the process 1
processor(1) &lt;&lt; a &lt;&lt; b;
//receive a,b synchronously from the process 10
processor(10) &gt;&gt; a &gt;&gt; b;

//broadcast from processor of comm to other comm processor
// broadcast(processor(10, comm), a);
//send synchronously to the process 10 the data a
status = Send(processor(10, comm), a);
//receive synchronously from the process 10 the data a
status = Recv(processor(10, comm), a);

//send asynchronously to the process 10 the data a without request
status = Isend(processor(10, comm), a);
//send asynchronously to the process 10 the data a with request
status = Isend(processor(10, comm, req), a);
//receive asynchronously from the process 10 the data a
status = Irecv(processor(10, req), a);
//Error asynchronously without request.
// status = Irecv(processor(10), a);
</pre></div>
</div>
<p>where the data type of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>a</code> can be of type of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>int</code>,<code class="code freefem docutils literal highlight highlight-freefem"><span></span>real</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>int[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>real[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>int[int,int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>double[int,int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex[int,int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mesh</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mesh3</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mesh[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mesh3[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>matrix</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>matrix&lt;complex&gt;</code></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>//send asynchronously to the process 10 the data a with request
processor(10, req) &lt;&lt; a ;
//receive asynchronously from the process 10 the data a with request
processor(10, req) &gt;&gt; a ;
</pre></div>
</div>
<p>If <code class="code freefem docutils literal highlight highlight-freefem"><span></span>a, b</code> are arrays or full matrices of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>int</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>real</code>, or <code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex</code>, we can use the following MPI functions:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mpiAlltoall(a, b, [comm]);
mpiAllgather(a, b, [comm]);
mpiGather(a, b, processor(..) );
mpiScatter(a, b, processor(..));
mpiReduce(a, b, processor(..), mpiMAX);
mpiAllReduce(a, b, comm, mpiMAX);
</pre></div>
</div>
<p>Thank you to Guy-Antoine Atenekeng Kahou for his help to code this interface.</p>
</div>
<div class="section" id="schwarz-example-in-parallel">
<h3>Schwarz example in parallel<a class="headerlink" href="#schwarz-example-in-parallel" title="Permalink to this headline">¶</a></h3>
<p>This example is a rewritting of example <a class="reference external" href="/models/DomainDecomposition/#schwarz-overlapping">Schwarz overlapping</a>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ff-mpirun -np <span class="m">2</span> SchwarzParallel.edp
<span class="c1"># OR</span>
mpirun -np <span class="m">2</span> FreeFem++-mpi SchwarzParallel.edp
</pre></div>
</div>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>if (mpisize != 2){
    cout &lt;&lt; &quot; sorry, number of processors !=2 &quot; &lt;&lt; endl;
    exit(1);
}

// Parameters
verbosity = 0;
int interior = 2;
int exterior = 1;
int n = 4;

// Mesh
border a(t=1, 2){x=t; y=0; label=exterior;}
border b(t=0, 1){x=2; y=t; label=exterior;}
border c(t=2, 0){x=t; y=1; label=exterior;}
border d(t=1, 0){x=1-t; y=t; label=interior;}
border e(t=0, pi/2){x=cos(t); y=sin(t); label=interior;}
border e1(t=pi/2, 2*pi){x=cos(t); y=sin(t); label=exterior;}
mesh[int] Th(mpisize);
if (mpirank == 0)
    Th[0] = buildmesh(a(5*n) + b(5*n) + c(10*n) + d(5*n));
else
    Th[1] = buildmesh(e(5*n) + e1(25*n));

broadcast(processor(0), Th[0]);
broadcast(processor(1), Th[1]);

// Fespace
fespace Vh(Th[mpirank], P1);
Vh u = 0, v;

fespace Vhother(Th[1-mpirank], P1);
Vhother U = 0;

//Problem
int i = 0;
problem pb (u, v, init=i, solver=Cholesky)
    = int2d(Th[mpirank])(
          dx(u)*dx(v)
        + dy(u)*dy(v)
    )
    - int2d(Th[mpirank])(
          v
    )
    + on(interior, u=U)
    + on(exterior, u= 0 )
    ;

// Loop
for (i = 0; i &lt; 20; i++){
    cout &lt;&lt; mpirank &lt;&lt; &quot; - Loop &quot; &lt;&lt; i &lt;&lt; endl;

    // Solve
    pb;
    //send u to the other proc, receive in U
    processor(1-mpirank) &lt;&lt; u[];
    processor(1-mpirank) &gt;&gt; U[];

    // Error
    real err0, err1;
    err0 = int1d(Th[mpirank],interior)(square(U - u));
    // send err0 to the other proc, receive in err1
    processor(1-mpirank) &lt;&lt; err0;
    processor(1-mpirank) &gt;&gt; err1;
    real err = sqrt(err0 + err1);
    cout &lt;&lt; &quot; err = &quot; &lt;&lt; err &lt;&lt; &quot; - err0 = &quot; &lt;&lt; err0 &lt;&lt; &quot; - err1 = &quot; &lt;&lt; err1 &lt;&lt; endl;
    if (err &lt; 1e-3) break;
}
if (mpirank == 0)
    plot(u, U);
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">script freeze in the loop</p>
</div>
<div class="section" id="true-parallel-schwarz-example">
<h4>True parallel Schwarz example<a class="headerlink" href="#true-parallel-schwarz-example" title="Permalink to this headline">¶</a></h4>
<p><em>Thank you to F. Nataf</em></p>
<p>This is a explanation of the two examples <a class="reference external" href="/examples/#mpi-gmres-2d">MPI-GMRES 2D</a> and <a class="reference external" href="/examples/#mpi-gmres-3d">MPI-GMRES 3D</a>, a Schwarz parallel with a complexity almost independent of the number of process (with a coarse grid preconditioner).</p>
<p>To solve the following Poisson problem on domain <span class="math notranslate nohighlight">\(\Omega\)</span> with boundary <span class="math notranslate nohighlight">\(\Gamma\)</span> in <span class="math notranslate nohighlight">\(L^2(\Omega)\)</span> :</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rcll}
    -\Delta u &amp;=&amp; f &amp; \mbox{ in } \Omega\\
    u &amp;=&amp; g &amp; \mbox{ on } \Gamma
\end{array}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are two given functions of <span class="math notranslate nohighlight">\(L^2(\Omega)\)</span> and of <span class="math notranslate nohighlight">\(H^{\frac12}(\Gamma)\)</span>,</p>
<p>Lets introduce <span class="math notranslate nohighlight">\((\pi_i)_{i=1,.., N_p}\)</span> a regular partition of the unity of <span class="math notranslate nohighlight">\(\Omega\)</span>, q-e-d:</p>
<div class="math notranslate nohighlight">
\[\pi_i \in \mathcal{C}^0(\Omega) : \quad \pi_i\ge 0 \mbox{ and } \sum_{i=1}^{N_p} \pi_i =1 .\]</div>
<p>Denote <span class="math notranslate nohighlight">\(\Omega_i\)</span> the sub domain which is the support of <span class="math notranslate nohighlight">\(\pi_i\)</span> function and also denote <span class="math notranslate nohighlight">\(\Gamma_i\)</span> the boundary of <span class="math notranslate nohighlight">\(\Omega_i\)</span>.</p>
<p>The parallel Schwarz method is:</p>
<p>Let <span class="math notranslate nohighlight">\(\ell=0\)</span> the iterator and a initial guest <span class="math notranslate nohighlight">\(u^0\)</span> respecting the boundary condition (i.e.&nbsp;<span class="math notranslate nohighlight">\(u^0_{|\Gamma} = g\)</span>).</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rcll}
    \forall i = 1 .., N_p:&amp;\nonumber\\
    \displaystyle -\Delta u_i^\ell &amp;=&amp; f &amp;\mbox{ in } \Omega_i\\
    u_i^\ell &amp;=&amp; u^\ell &amp; \mbox{ on } \Gamma_i \setminus \Gamma\\
    u_i^\ell &amp;=&amp; g &amp; \mbox{ on } \Gamma_i \cap \Gamma
    :label: eq:lapl
\end{array}\end{split}\]</div>
<div class="math notranslate nohighlight" id="equation-eq-pu1">
<span class="eqno">(30)<a class="headerlink" href="#equation-eq-pu1" title="Permalink to this equation">¶</a></span>\[u^{\ell+1} = \sum_{i=1}^{N_p} \pi_i u_i^\ell\]</div>
<p>After discretization with the Lagrange finite element method, with a compatible mesh <span class="math notranslate nohighlight">\({\mathcal{T}_h}_i\)</span> of <span class="math notranslate nohighlight">\(\Omega_i\)</span>, i. e., the exist a global mesh <span class="math notranslate nohighlight">\({\mathcal{T}_h}\)</span> such that <span class="math notranslate nohighlight">\({\mathcal{T}_h}_i\)</span> is include in <span class="math notranslate nohighlight">\({\mathcal{T}_h}\)</span>.</p>
<p>Let us denote:</p>
<ul>
<li><p class="first"><span class="math notranslate nohighlight">\({V_h}_i\)</span> the finite element space corresponding to domain <span class="math notranslate nohighlight">\(\Omega_i\)</span>,</p>
</li>
<li><p class="first"><span class="math notranslate nohighlight">\({\mathcal{N}_h}_i\)</span> is the set of the degree of freedom <span class="math notranslate nohighlight">\(\sigma_i^k\)</span>,</p>
</li>
<li><p class="first"><span class="math notranslate nohighlight">\({\mathcal{N}^{\Gamma_i}_{hi}}\)</span> is the set of the degree of freedom of <span class="math notranslate nohighlight">\({V_h}_i\)</span> on the boundary <span class="math notranslate nohighlight">\(\Gamma_i\)</span> of <span class="math notranslate nohighlight">\(\Omega_i\)</span>,</p>
</li>
<li><p class="first"><span class="math notranslate nohighlight">\(\sigma_i^k({v_h})\)</span> is the value the degree of freedom <span class="math notranslate nohighlight">\(k\)</span>,</p>
</li>
<li><p class="first"><span class="math notranslate nohighlight">\({V_{0h}}_i= \{ {v_h} \in {V_h}_i :\forall k \in {\mathcal{N}^{\Gamma_i}_{hi}}, \quad \sigma_i^k({v_h})=0 \}\)</span>,</p>
</li>
<li><p class="first">The conditional expression <span class="math notranslate nohighlight">\(a\;?\;b:c\)</span> is defined like in :c`C` of <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">C</span><span class="o">++</span></code> language by</p>
<div class="math notranslate nohighlight">
\[\begin{split}a?b: c \equiv
\left\{
\begin{array}{l}
\mbox{if $a$ is true then return $b$}\\
\mbox{else return $c$}\\
\end{array}
\right..\end{split}\]</div>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We never use finite element space associated to the full domain <span class="math notranslate nohighlight">\(\Omega\)</span> because it is too expensive.</p>
</div>
<p>We have to defined to operator to build the previous algorithm:</p>
<p>We denote <span class="math notranslate nohighlight">\({u_h^{\ell}}_{|i}\)</span> the restriction of <span class="math notranslate nohighlight">\(u_h^\ell\)</span> on <span class="math notranslate nohighlight">\({V_h}_i\)</span>, so the discrete problem on <span class="math notranslate nohighlight">\(\Omega_i\)</span> of problem <tt class="xref eq docutils literal">eq:lapl</tt> is find <span class="math notranslate nohighlight">\({u_h^{\ell}}_{i}\in {V_h}_i\)</span> such that:</p>
<div class="math notranslate nohighlight">
\[\forall {v_h}_i\in V_{0i}:
\int_{\Omega_i} \nabla {v_h}_i \cdot \nabla {u_h}^{\ell}_{i}
= \int_{\Omega_i} f {v_h}_i ,\quad \forall k \in {\mathcal{N}^{\Gamma_i}_{hi}}\;:\; \sigma_i^k({u_h}^\ell_i) = (k\in \Gamma) \; ? \; g_i^k : \sigma_i^k({u_h}^{\ell}_{|i})\]</div>
<p>where <span class="math notranslate nohighlight">\(g_i^k\)</span> is the value of <span class="math notranslate nohighlight">\(g\)</span> associated to the degree of freedom <span class="math notranslate nohighlight">\(k\in {\mathcal{N}^{\Gamma_i}_{hi}}\)</span>.</p>
<p>In FreeFem++, it can be written has with <code class="code freefem docutils literal highlight highlight-freefem"><span></span>U</code> is the vector corresponding to <span class="math notranslate nohighlight">\({u_h^{\ell}}_{|i}\)</span> and the vector <code class="code freefem docutils literal highlight highlight-freefem"><span></span>U1</code> is the vector corresponding to <span class="math notranslate nohighlight">\({u_h^{\ell}}_{i}\)</span> is the solution of:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>real[int] U1(Ui.n);
real[int] b = onG .* U;
b = onG ? b : Bi ;
U1 = Ai^-1*b;
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(\mathtt{onG}[i] =(i \in \Gamma_i\setminus\Gamma) ? 1 : 0\)</span>, and <span class="math notranslate nohighlight">\(\mathtt{Bi}\)</span> the right of side of the problem, are defined by</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Fespace
fespace Whi(Thi, P2);

// Problem
varf vPb (U, V)
    = int3d(Thi)(
          grad(U)&#39;*grad(V)
    )
    + int3d(Thi)(
          F*V
    )
    + on(1, U=g)
    + on(10, U=G)
    ;

varf vPbon (U, V) = on(10, U=1) + on(1, U=0);

matrix Ai = vPb (Whi, Whi, solver=sparsesolver);
real[int] onG = vPbon(0, Whi);
real[int] Bi=vPb(0, Whi);
</pre></div>
</div>
<p>where the FreeFem++ label of <span class="math notranslate nohighlight">\(\Gamma\)</span> is 1 and the label of <span class="math notranslate nohighlight">\(\Gamma_i\setminus \Gamma\)</span> is <span class="math notranslate nohighlight">\(10\)</span>.</p>
<p>To build the transfer/update part corresponding to <a class="reference internal" href="#equation-eq-pu1">(30)</a> equation on process <span class="math notranslate nohighlight">\(i\)</span>, let us call <code class="code freefem docutils literal highlight highlight-freefem"><span></span>njpart</code> the number the neighborhood of domain of <span class="math notranslate nohighlight">\(\Omega_i\)</span> (i.e: <span class="math notranslate nohighlight">\(\pi_j\)</span> is none <span class="math notranslate nohighlight">\(0\)</span> of <span class="math notranslate nohighlight">\(\Omega_i\)</span>), we store in an array <code class="code freefem docutils literal highlight highlight-freefem"><span></span>jpart</code> of size <code class="code freefem docutils literal highlight highlight-freefem"><span></span>njpart</code> all this neighborhood.</p>
<p>Let us introduce two array of matrix, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Smj[j]</code> to defined the vector to send from <span class="math notranslate nohighlight">\(i\)</span> to <span class="math notranslate nohighlight">\(j\)</span> a neighborhood process, and the matrix <span class="math notranslate nohighlight">\(rMj[j]\)</span> to after to reduce owith neighborhood <span class="math notranslate nohighlight">\(j\)</span> domain.</p>
<p>So the tranfert and update part compute <span class="math notranslate nohighlight">\(v_i= \pi_i u_i + \sum_{j\in J_i} \pi_j u_j\)</span> and can be write the FreeFem++ function Update:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>func bool Update (real[int] &amp;ui, real[int] &amp;vi){
    int n = jpart.n;
    for (int j = 0; j &lt; njpart; ++j) Usend[j][] = sMj[j]*ui;
    mpiRequest[int] rq(n*2);
    for (int j = 0; j &lt; n; ++j) Irecv(processor(jpart[j], comm,rq[j]), Ri[j][]);
    for (int j = 0; j &lt; n; ++j) Isend(processor(jpart[j], comm, rq[j+n]), Si[j][]);
    for (int j = 0; j &lt; n*2; ++j) int k = mpiWaitAny(rq);
    // apply the unity local partition
    vi = Pii*ui; //set to pi_i u_i
    for (int j = 0; j &lt; njpart; ++j) vi += rMj[j]*Vrecv[j][]; //add pi_j u_j
    return true;
}
</pre></div>
</div>
<p>where the buffer are defined by:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>InitU(njpart, Whij, Thij, aThij, Usend) //defined the send buffer
InitU(njpart, Whij, Thij, aThij, Vrecv) //defined the revc buffer
</pre></div>
</div>
<p>with the following macro definition:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>macro InitU(n, Vh, Th, aTh, U) Vh[int] U(n); for (int j = 0; j &lt; n; ++j){Th = aTh[j]; U[j] = 0;}
</pre></div>
</div>
<p><em>First GMRES algorithm:</em> you can easily accelerate the fixed point algorithm by using a parallel GMRES algorithm after the introduction the following affine <span class="math notranslate nohighlight">\(\mathcal{A}_i\)</span> operator sub domain <span class="math notranslate nohighlight">\(\Omega_i\)</span>.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>func real[int] DJ0 (real[int]&amp; U){
    real[int] V(U.n), b = onG .* U;
    b = onG ? b : Bi ;
    V = Ai^-1*b;
    Update(V, U);
    V -= U;
    return V;
}
</pre></div>
</div>
<p>Where the parallel <code class="code freefem docutils literal highlight highlight-freefem"><span></span>MPIGMRES</code> or <code class="code freefem docutils literal highlight highlight-freefem"><span></span>MPICG</code> algorithm is just a simple way to solve in parallel the following <span class="math notranslate nohighlight">\(A_i x_i = b_i, i = 1, .., N_p\)</span> by just changing the dot product by reduce the local dot product of all process with the following MPI code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">R</span><span class="o">&gt;</span> <span class="n">R</span> <span class="n">ReduceSum1</span><span class="p">(</span><span class="n">R</span> <span class="n">s</span><span class="p">,</span> <span class="n">MPI_Comm</span> <span class="o">*</span><span class="n">comm</span><span class="p">){</span>
    <span class="n">R</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">MPI_Allreduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_TYPE</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;::</span><span class="n">TYPE</span><span class="p">(),</span> <span class="n">MPI_SUM</span><span class="p">,</span> <span class="o">*</span><span class="n">comm</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is done in <code class="code freefem docutils literal highlight highlight-freefem"><span></span>MPIGC</code> dynamics library tool.</p>
<p><em>Second GMRES algorithm:</em> Use scharwz algorithm as a preconditioner of basic GMRES method to solving the parallel problem.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>func real[int] DJ (real[int]&amp; U){ //the original problem
    ++kiter;
    real[int] V(U.n);
    V = Ai*U;
    V = onGi ? 0.: V; //remove boundary term
    return V;
}

func real[int] PDJ (real[int]&amp; U){ //the preconditioner
    real[int] V(U.n);
    real[int] b = onG ? 0. : U;
    V = Ai^-1*b;
    Update(V, U);
    return U;
}
</pre></div>
</div>
<p><em>Third GMRES algorithm:</em> Add a coarse solver to the previous algorithm</p>
<p>First build a coarse grid on processor 0, and the</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>matrix AC, Rci, Pci;
if (mpiRank(comm) == 0)
    AC = vPbC(VhC, VhC, solver=sparsesolver); //the coarse problem

Pci = interpolate(Whi, VhC); //the projection on coarse grid
Rci = Pci&#39;*Pii; //the restriction on Process i grid with the partition pi_i

func bool CoarseSolve (real[int]&amp; V, real[int]&amp; U, mpiComm&amp; comm){
    // solving the coarse problem
    real[int] Uc(Rci.n), Bc(Uc.n);
    Uc = Rci*U;
    mpiReduce(Uc, Bc, processor(0, comm), mpiSUM);
    if (mpiRank(comm) == 0)
    Uc = AC^-1*Bc;
    broadcast(processor(0, comm), Uc);
    V = Pci*Uc;
}
</pre></div>
</div>
<p>The New preconditionner</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>func real[int] PDJC (real[int]&amp; U){
    // Idea: F. Nataf.
    // 0 ~ (I C1A)(I-C2A) =&gt; I ~ - C1AC2A +C1A +C2A
    // New Prec P= C1+C2 - C1AC2 = C1(I- A C2) +C2
    // ( C1(I- A C2) +C2 ) Uo
    // V = - C2*Uo
    // ....
    real[int] V(U.n);
    CoarseSolve(V, U, comm);
    V = -V; //-C2*Uo
    U += Ai*V; //U = (I-A C2) Uo
    real[int] b = onG ? 0. : U;
    U = Ai^-1*b; //C1( I -A C2) Uo
    V = U - V;
    Update(V, U);
    return U;
}
</pre></div>
</div>
<p>The code of the 4 algorithms:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>real epss = 1e-6;
int rgmres = 0;
if (gmres == 1){
    rgmres = MPIAffineGMRES(DJ0, u[], veps=epss, nbiter=300,
        comm=comm, dimKrylov=100, verbosity=ipart?0: 50);
    real[int] b = onG .* u[];
    b = onG ? b : Bi ;
    v[] = Ai^-1*b;
    Update(v[], u[]);
}
else if (gmres == 2)
    rgmres = MPILinearGMRES(DJ, precon=PDJ, u[], Bi, veps=epss,
        nbiter=300, comm=comm, dimKrylov=100, verbosity=ipart?0: 50);
else if (gmres == 3)
    rgmres = MPILinearGMRES(DJ, precon=PDJC, u[], Bi, veps=epss,
        nbiter=300, comm=comm, dimKrylov=100, verbosity=ipart?0: 50);
else //algo Shwarz for demo
    for(int iter = 0; iter &lt; 10; ++iter)
        ...
</pre></div>
</div>
<p>We have all ingredient to solve in parallel if we have et the partitions of the unity.
To build this partition we do:</p>
<p>The initial step on process <span class="math notranslate nohighlight">\(1\)</span> to build a coarse mesh, <span class="math notranslate nohighlight">\({\mathcal{T}_h}^*\)</span> of the full domain, and build the partition <span class="math notranslate nohighlight">\(\pi\)</span> function constant equal to <span class="math notranslate nohighlight">\(i\)</span> on each sub domain <span class="math notranslate nohighlight">\(\mathcal{O}_i, i =1 ,.., N_p\)</span>, of the grid with the <code class="code freefem docutils literal highlight highlight-freefem"><span></span>metis</code> graph partitioner [KARYPIS1995] and on each process <span class="math notranslate nohighlight">\(i\)</span> in <span class="math notranslate nohighlight">\(1..,N_p\)</span> do</p>
<ol class="arabic">
<li><p class="first">Broadcast from process <span class="math notranslate nohighlight">\(1\)</span>, the mesh <span class="math notranslate nohighlight">\({\mathcal{T}_h}^*\)</span> (call <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Thii</code> in FreeFem++ script), and <span class="math notranslate nohighlight">\(\pi\)</span> function,</p>
</li>
<li><p class="first">remark that the characteristic function <span class="math notranslate nohighlight">\(\mathrm{1\!\!I}_{\mathcal{O}_i}\)</span> of domain <span class="math notranslate nohighlight">\(\mathcal{O}_i\)</span>, is defined by <span class="math notranslate nohighlight">\((\pi=i)?1:0\)</span>,</p>
</li>
<li><p class="first">Let us call <span class="math notranslate nohighlight">\(\Pi^2_P\)</span> (resp. <span class="math notranslate nohighlight">\(\Pi^2_V\)</span>) the <span class="math notranslate nohighlight">\(L^2\)</span> on <span class="math notranslate nohighlight">\(P_h^*\)</span> the space of the constant finite element function per element on <span class="math notranslate nohighlight">\({\mathcal{T}_h}^*\)</span> (resp. <span class="math notranslate nohighlight">\(V_h^*\)</span> the space of the affine continuous finite element per element on <span class="math notranslate nohighlight">\({\mathcal{T}_h}^*\)</span>) and build in parallel the <span class="math notranslate nohighlight">\(\pi_i\)</span> and <span class="math notranslate nohighlight">\(\Omega_i\)</span>, such that <span class="math notranslate nohighlight">\(\mathcal{O}_i\ \subset \Omega_i\)</span> where <span class="math notranslate nohighlight">\(\mathcal{O}_i= supp ((\Pi^2_V \Pi^2_C)^m \mathrm{1\!\!I}_{O_i})\)</span>, and <span class="math notranslate nohighlight">\(m\)</span> is a the overlaps size on the coarse mesh (generally one), (this is done in function <code class="code freefem docutils literal highlight highlight-freefem"><span></span>AddLayers(Thii,suppii[],nlayer,phii[]);</code> We choose a function <span class="math notranslate nohighlight">\(\pi^*_i = (\Pi^2_1 \Pi^2_0)^m \mathrm{1\!\!I}_{\mathcal{O}_i}\)</span> so the partition of the unity is simply defined by</p>
<div class="math notranslate nohighlight">
\[\pi_i = \frac{\pi_i^*}{\sum_{j=1}^{N_p} \pi_j^*}\]</div>
<p>The set <span class="math notranslate nohighlight">\(J_i\)</span> of neighborhood of the domain <span class="math notranslate nohighlight">\(\Omega_i\)</span>, and the local version on <span class="math notranslate nohighlight">\(V_{hi}\)</span> can be defined the array <code class="code freefem docutils literal highlight highlight-freefem"><span></span>jpart</code> and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>njpart</code> with:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>Vhi pii = piistar;
Vhi[int] pij(npij); //local partition of 1 = pii + sum_j pij[j]
int[int] jpart(npart);
int njpart = 0;
Vhi sumphi = piistar;
for (int i = 0; i &lt; npart; ++i)
    if (i != ipart){
        if (int3d(Thi)(pijstar,j) &gt; 0){
            pij[njpart] = pijstar;
            sumphi[] += pij[njpart][];
            jpart[njpart++] = i;
        }
    }
pii[] = pii[] ./ sumphi[];
for (int j = 0; j &lt; njpart; ++j)
    pij[j][] = pij[j][] ./ sumphi[];
jpart.resize(njpart);
</pre></div>
</div>
</li>
<li><p class="first">We call <span class="math notranslate nohighlight">\({\mathcal{T}_h}^*_{ij}\)</span> the sub mesh part of <span class="math notranslate nohighlight">\({\mathcal{T}_h}_i\)</span> where <span class="math notranslate nohighlight">\(\pi_j\)</span> are none zero.
And thanks to the function <code class="code freefem docutils literal highlight highlight-freefem"><span></span>trunc</code> to build this array,</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>for(int jp = 0; jp &lt; njpart; ++jp)
    aThij[jp] = trunc(Thi, pij[jp] &gt; 1e-10, label=10);
</pre></div>
</div>
</li>
<li><p class="first">At this step we have all on the coarse mesh, so we can build the fine final mesh by splitting all meshes: <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Thi, Thij[j], Thij[j]</code> with FreeFem++ <code class="code freefem docutils literal highlight highlight-freefem"><span></span>trunc</code> mesh function which do restriction and slipping.</p>
</li>
<li><p class="first">The construction of the send/recv matrices <code class="code freefem docutils literal highlight highlight-freefem"><span></span>sMj</code> and <cite>freefem:`rMj</cite>: can done with this code:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh3 Thij = Thi;
fespace Whij(Thij, Pk);
matrix Pii; Whi wpii = pii; Pii = wpii[]; //Diagonal matrix corresponding X pi_i
matrix[int] sMj(njpart), rMj(njpart); //M send/recive case
 for (int jp = 0; jp &lt; njpart; ++jp){
     int j = jpart[jp];
    Thij = aThij[jp]; //change mesh to change Whij, Whij
    matrix I = interpolate(Whij, Whi); //Whij &lt;- Whi
    sMj[jp] = I*Pii; //Whi -&gt; s Whij
    rMj[jp] = interpolate(Whij, Whi, t=1); //Whij -&gt; Whi
}
</pre></div>
</div>
</li>
</ol>
<p>To buil a not too bad application, all variables come from parameters value with the following code</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>include &quot;getARGV.idp&quot;
verbosity = getARGV(&quot;-vv&quot;, 0);
int vdebug = getARGV(&quot;-d&quot;, 1);
int ksplit = getARGV(&quot;-k&quot;, 10);
int nloc = getARGV(&quot;-n&quot;, 25);
string sff = getARGV(&quot;-p, &quot;, &quot;&quot;);
int gmres = getARGV(&quot;-gmres&quot;, 3);
bool dplot = getARGV(&quot;-dp&quot;, 0);
int nC = getARGV(&quot;-N&quot;, max(nloc/10, 4));
</pre></div>
</div>
<p>And small include to make graphic in parallel of distribute solution of vector <span class="math notranslate nohighlight">\(u\)</span> on mesh <span class="math notranslate nohighlight">\(T_h\)</span> with the following interface:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>include &quot;MPIplot.idp&quot;
func bool plotMPIall(mesh &amp;Th, real[int] &amp;u, string cm){
    PLOTMPIALL(mesh, Pk, Th, u, {cmm=cm, nbiso=20, fill=1, dim=3, value=1});
    return 1;
}
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="code freefem docutils literal highlight highlight-freefem"><span></span>cmm=cm, ...</code> in the macro argument is a way to quote macro argument so the argument is <code class="code freefem docutils literal highlight highlight-freefem"><span></span>cmm=cm, ...</code>.</p>
</div>
</div>
</div>
</div>
<div class="section" id="parallel-sparse-solvers">
<h2>Parallel sparse solvers<a class="headerlink" href="#parallel-sparse-solvers" title="Permalink to this headline">¶</a></h2>
<p>Parallel sparse solvers use several processors to solve linear systems of equation. Like sequential, parallel linear solvers can be direct or iterative. In <strong>FreeFem++</strong> both are available.</p>
<div class="section" id="using-parallel-sparse-solvers-in-freefem">
<h3>Using parallel sparse solvers in <strong>FreeFem++</strong><a class="headerlink" href="#using-parallel-sparse-solvers-in-freefem" title="Permalink to this headline">¶</a></h3>
<p>We recall that the <code class="code freefem docutils literal highlight highlight-freefem"><span></span>solver</code> parameters are defined in the following commands: <code class="code freefem docutils literal highlight highlight-freefem"><span></span>solve</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>problem</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>set</code> (setting parameter of a matrix) and in the construction of the matrix corresponding to a bilinear form.
In these commands, the parameter <code class="code freefem docutils literal highlight highlight-freefem"><span></span>solver</code> must be set to <code class="code freefem docutils literal highlight highlight-freefem"><span></span>sparsesolver</code> for parallel sparse solver.
We have added specify parameters to these command lines for parallel sparse solvers.
These are:</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>lparams</code> : vector of integer parameters (<code class="docutils literal highlight highlight-freefem"><span></span>l</code> is for the <code class="docutils literal highlight highlight-freefem"><span></span>C++</code> type <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="kt">long</span></code>)</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparams</code> : vector of real parameters</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>sparams</code> : string parameters</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>datafilename</code> : name of the file which contains solver parameters</li>
</ul>
<p>The following four parameters are only for direct solvers and are vectors.
These parameters allow the user to preprocess the matrix (see the section on <a class="reference external" href="#sparse-direct-solver">sparse direct solver</a> for more information).</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>permr</code> : row permutation (integer vector)</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>permc</code> : column permutation or inverse row permutation (integer vector)</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>scaler</code> : row scaling (real vector)</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>scalec</code> : column scaling (real vector)</li>
</ul>
<p>There are two possibilities to control solver parameters.
The first method defines parameters with <code class="code freefem docutils literal highlight highlight-freefem"><span></span>lparams</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparams</code> and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>sparams</code> in <code class="docutils literal highlight highlight-freefem"><span></span>.edp</code> file.</p>
<p>The second one reads the solver parameters from a data file. The name of this file is specified by <code class="code freefem docutils literal highlight highlight-freefem"><span></span>datafilename</code>.
If <code class="code freefem docutils literal highlight highlight-freefem"><span></span>lparams</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparams</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>sparams</code> or <code class="code freefem docutils literal highlight highlight-freefem"><span></span>datafilename</code> is not provided by the user, the solver’s default values are used.</p>
<p>To use parallel solver in <strong>FreeFem++</strong>, we need to load the dynamic library corresponding to this solver.
For example to use <a class="reference external" href="http://mumps.enseeiht.fr/">MUMPS</a> solver as parallel solver in <strong>FreeFem++</strong>, write in the <code class="docutils literal highlight highlight-freefem"><span></span>.edp</code> file <code class="code freefem docutils literal highlight highlight-freefem"><span></span>load &quot;MUMPS_FreeFem&quot;</code>.</p>
<p>If the libraries are not loaded, the default sparse solver will be loaded (default sparse solver is <code class="code freefem docutils literal highlight highlight-freefem"><span></span>UMFPACK</code>). The <a class="reference external" href="#Tab1">table 1</a> gives this new value for the different libraries.</p>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">review table</p>
</div>
<table><thead><tr><th colspan="3"><p>Table 1: Default sparse solver for real and complex arithmetics when we
load a parallel sparse solver library</p>
</th></tr></thead><tbody><tr><td rowspan="2" style="vertical-align: middle !important; font-weight: bold"><p>Libraries</p>
</td><td colspan="2" align="center" style="font-weight: bold"><p>Default sparse solver</p>
</td></tr><tr><td align="center" style="font-weight: bold"><p>real</p>
</td><td align="center" style="font-weight: bold"><p>complex</p>
</td></tr><tr><td><p>MUMPS_FreeFem</p>
</td><td align="center"><p>mumps</p>
</td><td align="center"><p>mumps</p>
</td></tr><tr><td><p>real_SuperLU_DIST_FreeFem</p>
</td><td align="center"><p>SuperLU_DIST</p>
</td><td align="center"><p>previous solver</p>
</td></tr><tr><td><p>complex_SuperLU_DIST_FreeFem</p>
</td><td align="center"><p>previous solver</p>
</td><td align="center"><p>SuperLU_DIST</p>
</td></tr><tr><td><p>real_pastix_FreeFem</p>
</td><td align="center"><p>PaStiX</p>
</td><td align="center"><p>previous solver</p>
</td></tr><tr><td><p>complex_pastix_FreeFem</p>
</td><td align="center"><p>previous solver</p>
</td><td align="center"><p>PaStiX</p>
</td></tr><tr><td><p>hips_FreeFem</p>
</td><td align="center"><p>hips</p>
</td><td align="center"><p>previous solver</p>
</td></tr><tr><td><p>hypre_FreeFem</p>
</td><td align="center"><p>hypre</p>
</td><td align="center"><p>previous solver</p>
</td></tr><tr><td><p>parms_FreeFem</p>
</td><td align="center"><p>parms</p>
</td><td align="center"><p>previous solver</p>
</td></tr></tbody></table><p>We also add functions (see <a class="reference external" href="#Tab2">Table 2</a>) with no parameter to change the default sparse solver in the <code class="docutils literal highlight highlight-freefem"><span></span>.edp</code> file.
To use these functions, we need to load the library corresponding to the solver.
An example of using different parallel sparse solvers for the same problem is given in <a class="reference external" href="/examples/#direct-solvers">Direct solvers example</a>.</p>
<table><thead><tr><th colspan="3"><p>Table 2: Functions that allow to change the default sparse solver for real and complex arithmetics and the result of these functions</p>
</th></tr></thead><tbody><tr><td rowspan="2" style="vertical-align: bottom !important; font-weight: bold"><p>Function</p>
</td><td colspan="2" align="center" style="font-weight: bold"><p>default sparse solver</p>
</td></tr><tr><td align="center" style="font-weight: bold"><p>real</p>
</td><td align="center" style="font-weight: bold"><p>complex</p>
</td></tr><tr><td><p>defaulttoMUMPS()</p>
</td><td align="center"><p>mumps</p>
</td><td align="center"><p>mumps</p>
</td></tr><tr><td><p>realdefaulttoSuperLUdist()</p>
</td><td align="center"><p>SuperLU_DIST</p>
</td><td align="center"><p>previous solver</p>
</td></tr><tr><td><p>complexdefaulttoSuperLUdist()</p>
</td><td align="center"><p>previous solver</p>
</td><td align="center"><p>SuperLU_DIST</p>
</td></tr><tr><td><p>realdefaultopastix()</p>
</td><td align="center"><p>pastix</p>
</td><td align="center"><p>previous solver</p>
</td></tr><tr><td><p>complexdefaulttopastix()</p>
</td><td align="center"><p>previous solver</p>
</td><td align="center"><p>pastix</p>
</td></tr><tr><td><p>defaulttohips()</p>
</td><td align="center"><p>hips</p>
</td><td align="center"><p>previous solver</p>
</td></tr><tr><td><p>defaulttohypre()</p>
</td><td align="center"><p>hypre</p>
</td><td align="center"><p>previous solver</p>
</td></tr><tr><td><p>defaulttoparms()</p>
</td><td align="center"><p>parms</p>
</td><td align="center"><p>previous solver</p>
</td></tr></tbody></table><div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Test direct solvers
```freefem load “MUMPS_FreeFem”</p>
</div>
<p>//default solver: real-&gt; MUMPS, complex -&gt; MUMPS load
“real_SuperLU_DIST_FreeFem” //default solver: real-&gt; SuperLU_DIST,
complex -&gt; MUMPS load “real_pastix_FreeFem” //default solver: real-&gt;
pastix, complex -&gt; MUMPS</p>
<p>// Solving with pastix { matrix A = [[1, 2, 2, 1, 1], [ 2, 12, 0, 10 ,
10], [ 2, 0, 1, 0, 2], [ 1, 10, 0, 22, 0.], [ 1, 10, 2, 0., 22]];</p>
<p>real[int] xx = [1, 32, 45, 7, 2], x(5), b(5), di(5); b = A*xx; cout &lt;&lt;
“b =” &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; “xx =” &lt;&lt; xx &lt;&lt; endl;</p>
<p>set(A, solver=sparsesolver, datafilename=“ffpastix_iparm_dparm.txt”);
cout &lt;&lt; “solve” &lt;&lt; endl; x = A^-1*b; cout &lt;&lt; “b =” &lt;&lt; b &lt;&lt; endl; cout &lt;&lt;
“x =” &lt;&lt; endl; cout &lt;&lt; x &lt;&lt; endl; di = xx - x; if (mpirank == 0){ cout
&lt;&lt; “x-xx =” &lt;&lt; endl; cout &lt;&lt; “Linf =” &lt;&lt; di.linfty &lt;&lt; “, L2 =” &lt;&lt; di.l2
&lt;&lt; endl; } }</p>
<p>// Solving with SuperLU_DIST realdefaulttoSuperLUdist(); //default
solver: real-&gt; SuperLU_DIST, complex -&gt; MUMPS { matrix A = [[1, 2, 2, 1,
1], [ 2, 12, 0, 10 , 10], [ 2, 0, 1, 0, 2], [ 1, 10, 0, 22, 0.], [ 1,
10, 2, 0., 22]];</p>
<p>real[int] xx = [1, 32, 45, 7, 2], x(5), b(5), di(5); b = A*xx; cout &lt;&lt;
“b =” &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; “xx =” &lt;&lt; xx &lt;&lt; endl;</p>
<p>set(A, solver=sparsesolver,
datafilename=“ffsuperlu_dist_fileparam.txt”); cout &lt;&lt; “solve” &lt;&lt; endl; x
= A^-1*b; cout &lt;&lt; “b =” &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; “x =” &lt;&lt; endl; cout &lt;&lt; x
&lt;&lt; endl; di = xx - x; if (mpirank == 0){ cout &lt;&lt; “x-xx =” &lt;&lt; endl; cout
&lt;&lt; “Linf =” &lt;&lt; di.linfty &lt;&lt; “, L2 =” &lt;&lt; di.l2 &lt;&lt; endl; } }</p>
<p>// Solving with MUMPS defaulttoMUMPS(); //default solver: real-&gt; MUMPS,
complex -&gt; MUMPS { matrix A = [[1, 2, 2, 1, 1], [ 2, 12, 0, 10 , 10], [
2, 0, 1, 0, 2], [ 1, 10, 0, 22, 0.], [ 1, 10, 2, 0., 22]];</p>
<p>real[int] xx = [1, 32, 45, 7, 2], x(5), b(5), di(5); b = A*xx; cout &lt;&lt;
“b =” &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; “xx =” &lt;&lt; xx &lt;&lt; endl;</p>
<p>set(A, solver=sparsesolver, datafilename=“ffmumps_fileparam.txt”); cout
&lt;&lt; “solving solution” &lt;&lt; endl; x = A^-1*b; cout &lt;&lt; “b =” &lt;&lt; b &lt;&lt; endl;
cout &lt;&lt; “x =” &lt;&lt; endl; cout &lt;&lt; x &lt;&lt; endl; di = xx - x; if (mpirank ==
0){ cout &lt;&lt; “x-xx =” &lt;&lt; endl; cout &lt;&lt; “Linf =” &lt;&lt; di.linfty &lt;&lt; “, L2” &lt;&lt;
di.l2 &lt;&lt; endl; } } ```</p>
</div>
<div class="section" id="sparse-direct-solver">
<h3>Sparse direct solver<a class="headerlink" href="#sparse-direct-solver" title="Permalink to this headline">¶</a></h3>
<p>In this section, we present the sparse direct solvers interfaced with
<strong>``FreeFem++``</strong>.</p>
<div class="section" id="mumps-solver">
<h4>MUMPS solver<a class="headerlink" href="#mumps-solver" title="Permalink to this headline">¶</a></h4>
<p>MUltifrontal Massively Parallel Solver
(<a class="reference external" href="http://mumps.enseeiht.fr/">MUMPS</a>) is an open-source library.</p>
<p>This package solves linear system of the form <span class="math notranslate nohighlight">\(A \: x = b\)</span> where
<span class="math notranslate nohighlight">\(A\)</span> is a square sparse matrix with a direct method. The square
matrix considered in MUMPS can be either unsymmetric, symmetric positive
definite or general symmetric.</p>
<p>The method implemented in MUMPS is a direct method based on a
multifrontal approach. It constructs a direct factorization
<span class="math notranslate nohighlight">\(A \:= \: L\:U\)</span>, <span class="math notranslate nohighlight">\(A\: = \: L^t \: D \: L\)</span> depending of the
symmetry of the matrix <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>MUMPS uses the following libraries :
<a class="reference external" href="http://www.netlib.org/blas/">BLAS</a>,
<a class="reference external" href="http://www.netlib.org/blacs/">BLACS</a> and
<a class="reference external" href="http://www.netlib.org/scalapack/">ScaLAPACK</a>.</p>
<p>!!!warning MUMPS does not solve linear system with a rectangular matrix.</p>
<p><strong>MUMPS parameters:</strong></p>
<p>There are four input parameters in
<a class="reference external" href="http://mumps.enseeiht.fr/index.php?page=doc">MUMPS</a>. Two integers
<code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">SYM</span></code> and <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">PAR</span></code>, a vector of integer of size 40
<code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">INCTL</span></code> and a vector of real of size 15 <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">CNTL</span></code>.</p>
<p>The first parameter gives the type of the matrix: 0 for unsymmetric
matrix, 1 for symmetric positive matrix and 2 for general symmetric.</p>
<p>The second parameter defined if the host processor work during the
factorization and solves steps : <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">PAR</span><span class="o">=</span><span class="mi">1</span></code> host processor working
and <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">PAR</span><span class="o">=</span><span class="mi">0</span></code> host processor not working.</p>
<p>The parameter <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">INCTL</span></code> and <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">CNTL</span></code> is the control
parameter of MUMPS. The vectors <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">ICNTL</span></code> and <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">CNTL</span></code> in
MUMPS becomes with index 1 like vector in <code class="docutils literal highlight highlight-freefem"><span></span>Fortran</code>. For more details
see the <a class="reference external" href="http://mumps.enseeiht.fr/index.php?page=doc">MUMPS user’s
guide</a>.</p>
<p>We describe now some elements of the main parameters of <code class="code cpp docutils literal highlight highlight-cpp"><span></span><span class="n">ICNTL</span></code>
for MUMPS.</p>
<ul>
<li><p class="first"><strong>Input matrix parameter</strong> The input matrix is controlled by
parameters <code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(5)</code> and <code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(18)</code>. The matrix format (resp.
matrix pattern and matrix entries) are controlled by <code class="docutils literal highlight highlight-freefem"><span></span>INCTL(5)</code>
(resp. <code class="docutils literal highlight highlight-freefem"><span></span>INCTL(18)</code>).</p>
<p>The different values of <code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(5)</code> are 0 for assembled format and 1
for element format. In the current release of <strong>``FreeFem++``</strong>, we
consider that FE matrix or matrix is storage in assembled format.
Therefore, <code class="docutils literal highlight highlight-freefem"><span></span>INCTL(5)</code> is treated as 0 value.</p>
<p>The main option for <code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(18)</code>: <code class="docutils literal highlight highlight-freefem"><span></span>INCLTL(18)=0</code> centrally on the
host processor, <code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(18)=3</code> distributed the input matrix pattern
and the entries (recommended option for distributed matrix by
developer of MUMPS). For other values of <code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(18)</code> see the <a class="reference external" href="http://mumps.enseeiht.fr/index.php?page=doc">MUMPS
user’s guide</a>. These
values can be used also in <strong>``FreeFem++``</strong>.</p>
<p>The default option implemented in <strong>``FreeFem++``</strong> are
<code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(5)=0</code> and <code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(18)=0</code>.</p>
</li>
<li><p class="first"><strong>Preprocessing parameter</strong> The preprocessed matrix <span class="math notranslate nohighlight">\(A_{p}\)</span>
that will be effectively factored is defined by</p>
<div class="math notranslate nohighlight">
\[A_{p} = P \: D_r \: A \: Q_c \ D_c P^t\]</div>
<p>where <span class="math notranslate nohighlight">\(P\)</span> is the permutation matrix, <span class="math notranslate nohighlight">\(Q_c\)</span> is the column
permutation, <span class="math notranslate nohighlight">\(D_r\)</span> and <span class="math notranslate nohighlight">\(D_c\)</span> are diagonal matrix for
respectively row and column scaling.</p>
<p>The ordering strategy to obtain <span class="math notranslate nohighlight">\(P\)</span> is controlled by parameter
<code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(7)</code>. The permutation of zero free diagonal <span class="math notranslate nohighlight">\(Q_c\)</span> is
controlled by parameter <code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(6)</code>. The row and column scaling is
controlled by parameter <code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(18)</code>. These option are connected and
also strongly related with <code class="docutils literal highlight highlight-freefem"><span></span>ICNTL(12)</code> (see the <a class="reference external" href="http://mumps.enseeiht.fr/index.php?page=doc">MUMPS user’s
guide</a> for more
details).</p>
<p>The parameters <code class="code freefem docutils literal highlight highlight-freefem"><span></span>permr</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>scaler</code>, and
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>scalec</code> in <strong>``FreeFem++``</strong> allow to give permutation
matrix(<span class="math notranslate nohighlight">\(P\)</span>), row scaling (<span class="math notranslate nohighlight">\(D_r\)</span>) and column scaling
(<span class="math notranslate nohighlight">\(D_c\)</span>) of the user respectively.</p>
</li>
</ul>
<p><strong>Calling MUMPS in ``FreeFem++``</strong></p>
<p>To call MUMPS in <strong>``FreeFem++``</strong>, we need to load the dynamic library
<code class="docutils literal highlight highlight-freefem"><span></span>MUMPS_freefem.dylib</code> (MacOSX), <code class="docutils literal highlight highlight-freefem"><span></span>MUMPS_freefem.so</code> (Unix) or
<code class="docutils literal highlight highlight-freefem"><span></span>MUMPS_freefem.dll</code> (Windows).</p>
<p>This is done in typing <code class="code freefem docutils literal highlight highlight-freefem"><span></span>load &quot;MUMPS_FreeFem&quot;</code> in the
<code class="docutils literal highlight highlight-freefem"><span></span>.edp</code> file. We give now the two methods to give the option of MUMPS
solver in <strong>``FreeFem++``</strong>.</p>
<ul>
<li><p class="first"><strong>Solver parameters is defined in .edp file:</strong> In this method, we
need to give the parameters <code class="code freefem docutils literal highlight highlight-freefem"><span></span>lparams</code> and
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparams</code>. These parameters are defined for MUMPS by :</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>lparams[0] = SYM</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>lparams[1] = PAR</code>,
<span class="math notranslate nohighlight">\(\forall i\)</span> = 1,…,40, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>lparams[i+1] = ICNTL(i)</code><span class="math notranslate nohighlight">\(\forall i\)</span> = 1,…,15, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparams[i-1] = CNTL(i)</code></p>
</li>
<li><p class="first"><strong>Reading solver parameters on a file:</strong></p>
<p>The structure of data file for MUMPS in <strong>``FreeFem++``</strong> is : first
line parameter <code class="docutils literal highlight highlight-freefem"><span></span>SYM</code> and second line parameter <code class="docutils literal highlight highlight-freefem"><span></span>PAR</code> and in the
following line the different value of vectors <code class="docutils literal highlight highlight-freefem"><span></span>ICNTL</code> and <code class="docutils literal highlight highlight-freefem"><span></span>CNTL</code>.
An example of this parameter file is given in
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>ffmumpsfileparam.txt</code>.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>0 /* SYM :: 0 for non symmetric matrix, 1 for symmetric definite positive matrix and 2 general symmetric matrix*/
1 /* PAR :: 0 host not working during factorization and solves steps, 1 host working during factorization and solves steps*/
-1 /* ICNTL(1) :: output stream for error message */
-1 /* ICNTL(2) :: output for diagnostic printing, statics and warning message */
-1 /* ICNTL(3) :: for global information */
0 /* ICNTL(4) :: Level of printing for error, warning and diagnostic message */
0 /* ICNTL(5) :: matrix format : 0 assembled format, 1 elemental format. */
7 /* ICNTL(6) :: control option for permuting and/or scaling the matrix in analysis phase */
3 /* ICNTL(7) :: pivot order strategy : AMD, AMF, metis, pord scotch*/
77 /* ICNTL(8) :: Row and Column scaling strategy */
1 /* ICNTL(9) :: 0 solve Ax = b, 1 solve the transposed system A^t x = b : parameter is not considered in the current release of freefem++*/
0 /* ICNTL(10) :: number of steps of iterative refinement */
0 /* ICNTL(11) :: statics related to linear system depending on ICNTL(9) */
1 /* ICNTL(12) :: constrained ordering strategy for general symmetric matrix */
0 /* ICNTL(13) :: method to control splitting of the root frontal matrix */
20 /* ICNTL(14) :: percentage increase in the estimated working space (default 20\%)*/
0 /* ICNTL(15) :: not used in this release of MUMPS */
0 /* ICNTL(16) :: not used in this release of MUMPS */
0 /* ICNTL(17) :: not used in this release of MUMPS */
3 /* ICNTL(18) :: method for given : matrix pattern and matrix entries : */
0 /* ICNTL(19) :: method to return the Schur complement matrix */
0 /* ICNTL(20) :: right hand side form ( 0 dense form, 1 sparse form) : parameter will be set to 0 for FreeFem++ */
0 /* ICNTL(21) :: 0, 1 kept distributed solution : parameter is not considered in the current release of FreeFem++ */
0 /* ICNTL(22) :: controls the in-core/out-of-core (OOC) facility */
0 /* ICNTL(23) :: maximum size of the working memory in Megabyte than MUMPS can allocate per working processor */
0 /* ICNTL(24) :: control the detection of null pivot */
0 /* ICNTL(25) :: control the computation of a null space basis */
0 /* ICNTL(26) :: This parameter is only significant with Schur option (ICNTL(19) not zero). : parameter is not considered in the current release of FreeFem++ */
-8 /* ICNTL(27) (Experimental parameter subject to change in next release of MUMPS) :: control the blocking factor for multiple righthand side during the solution phase : parameter is not considered in the current release of FreeFem++ */
0 /* ICNTL(28) :: not used in this release of MUMPS*/
0 /* ICNTL(29) :: not used in this release of MUMPS*/
0 /* ICNTL(30) :: not used in this release of MUMPS*/
0 /* ICNTL(31) :: not used in this release of MUMPS*/
0 /* ICNTL(32) :: not used in this release of MUMPS*/
0 /* ICNTL(33) :: not used in this release of MUMPS*/
0 /* ICNTL(34) :: not used in this release of MUMPS*/
0 /* ICNTL(35) :: not used in this release of MUMPS*/
0 /* ICNTL(36) :: not used in this release of MUMPS*/
0 /* ICNTL(37) :: not used in this release of MUMPS*/
0 /* ICNTL(38) :: not used in this release of MUMPS*/
1 /* ICNTL(39) :: not used in this release of MUMPS*/
0 /* ICNTL(40) :: not used in this release of MUMPS*/
0.01 /* CNTL(1) :: relative threshold for numerical pivoting */
1e-8 /* CNTL(2) :: stopping criteria for iterative refinement */
-1 /* CNTL(3) :: threshold for null pivot detection */
-1 /* CNTL(4) :: determine the threshold for partial pivoting */
0.0 /* CNTL(5) :: fixation for null pivots */
0 /* CNTL(6) :: not used in this release of MUMPS */
0 /* CNTL(7) :: not used in this release of MUMPS */
0 /* CNTL(8) :: not used in this release of MUMPS */
0 /* CNTL(9) :: not used in this release of MUMPS */
0 /* CNTL(10) :: not used in this release of MUMPS */
0 /* CNTL(11) :: not used in this release of MUMPS */
0 /* CNTL(12) :: not used in this release of MUMPS */
0 /* CNTL(13) :: not used in this release of MUMPS */
0 /* CNTL(14) :: not used in this release of MUMPS */
0 /* CNTL(15) :: not used in this release of MUMPS */
</pre></div>
</div>
</li>
</ul>
<p>If no solver parameter is given, we used default option of MUMPS solver.</p>
<p>!!!example “MUMPS example” A simple example of calling MUMPS in
<strong>``FreeFem++``</strong> with this two methods is given in the <a class="reference external" href="/examples/#solver-mumps">Test solver
MUMPS example</a>.</p>
</div>
<div class="section" id="superlu-distributed-solver">
<h4>SuperLU distributed solver<a class="headerlink" href="#superlu-distributed-solver" title="Permalink to this headline">¶</a></h4>
<p>The package
<a class="reference external" href="http://crd-legacy.lbl.gov/~xiaoye/SuperLU/">SuperLU_DIST</a> solves
linear systems using LU factorization. It is a free scientific library
under BSD license.</p>
<p>This library provides functions to handle square or rectangular matrix
in real and complex arithmetics. The method implemented in SuperLU_DIST
is a supernodal method. New release of this package includes a parallel
symbolic factorization. This scientific library is written in C and MPI
for communications.</p>
<p><strong>SuperLU_DIST parameters:</strong></p>
<p>We describe now some parameters of SuperLU_DIST. The SuperLU_DIST
library use a 2D-logical process group. This process grid is specified
by <span class="math notranslate nohighlight">\(nprow\)</span> (process row) and <span class="math notranslate nohighlight">\(npcol\)</span> (process column) such
that <span class="math notranslate nohighlight">\(N_{p} = nprow \: npcol\)</span> where <span class="math notranslate nohighlight">\(N_{p}\)</span> is the number of
all process allocated for SuperLU_DIST.</p>
<p>The input matrix parameters is controlled by “matrix=” in
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>sparams</code> for internal parameter or in the third line of
parameters file. The different value are</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>matrix=assembled</code> global matrix are available on all
process</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>matrix=distributedglobal</code> The global matrix is
distributed among all the process</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>matrix=distributed</code> The input matrix is distributed
(not yet implemented)</li>
</ul>
<p>The option arguments of SuperLU_DIST are described in the section
Users-callable routine of the <a class="reference external" href="http://crd-legacy.lbl.gov/~xiaoye/SuperLU/ug.pdf">SuperLU users’
guide</a>.</p>
<p>The parameter <code class="docutils literal highlight highlight-freefem"><span></span>Fact</code> and <code class="docutils literal highlight highlight-freefem"><span></span>TRANS</code> are specified in <strong>``FreeFem++``</strong>
interfaces to SuperLU_DIST during the different steps. For this reason,
the value given by the user for this option is not considered.</p>
<p>The factorization LU is calculated in SuperLU_DIST on the matrix
<span class="math notranslate nohighlight">\(A_p\)</span>.</p>
<div class="math notranslate nohighlight">
\[A_{p} = P_{c} \: P_r \: D_r \: A \: D_{c} \: P_{c}^{t}\]</div>
<p>where <span class="math notranslate nohighlight">\(P_c\)</span> and <span class="math notranslate nohighlight">\(P_r\)</span> is the row and column permutation
matrix respectively, <span class="math notranslate nohighlight">\(D_r\)</span> and <span class="math notranslate nohighlight">\(D_c\)</span> are diagonal matrix for
respectively row and column scaling.</p>
<p>The option argument <code class="docutils literal highlight highlight-freefem"><span></span>RowPerm</code> (resp. <code class="docutils literal highlight highlight-freefem"><span></span>ColPerm</code>) control the row
(resp. column) permutation matrix. <span class="math notranslate nohighlight">\(D_r\)</span> and <span class="math notranslate nohighlight">\(D_c\)</span> is
controlled by the parameter <code class="docutils literal highlight highlight-freefem"><span></span>DiagScale</code>.</p>
<p>The parameter <code class="code freefem docutils literal highlight highlight-freefem"><span></span>permr</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>permc</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>scaler</code>, and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>scalec</code> in <strong>``FreeFem++``</strong> is
provided to give row permutation, column permutation, row scaling and
column scaling of the user respectively.</p>
<p>The other parameters for LU factorization are <code class="docutils literal highlight highlight-freefem"><span></span>ParSymFact</code> and
<code class="docutils literal highlight highlight-freefem"><span></span>ReplaceTinyPivot</code>. The parallel symbolic factorization works only on
a power of two processes and need the <code class="docutils literal highlight highlight-freefem"><span></span>ParMetis</code> ordering. The default
option argument of SuperLU_DIST are given in the file
<code class="docutils literal highlight highlight-freefem"><span></span>ffsuperlu_dist_fileparam.txt</code>.</p>
<p><strong>Calling SuperLU_DIST in</strong><code class="docutils literal highlight highlight-freefem"><span></span>FreeFem++</code>____</p>
<p>To call SuperLU_DIST in <strong>``FreeFem++``</strong>, we need to load the library
dynamic correspond to interface. This done by the following line
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>load &quot;real_superlu _DIST_FreeFem&quot;</code> (resp.
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>load &quot;complex_superlu_DIST_FreeFem&quot;</code>) for real (resp.
complex) arithmetics in the file <code class="docutils literal highlight highlight-freefem"><span></span>.edp</code>.</p>
<p><strong>Solver parameters is defined in ``.edp`` file:</strong></p>
<p>To call SuperLU_DIST with internal parameter, we used the parameters
<code class="docutils literal highlight highlight-freefem"><span></span>sparams</code>. The value of parameters of SuperLU_DIST in <code class="docutils literal highlight highlight-freefem"><span></span>sparams</code> are
defined by :</p>
<ul class="simple">
<li><code class="docutils literal highlight highlight-freefem"><span></span>nprow=1</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>npcol=1</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>matrix= distributedgloba</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>Fact= DOFACT</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>Equil=NO</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>ParSymbFact=NO</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>ColPerm= MMD_AT_PLUS_A</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>RowPerm= LargeDiag</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>DiagPivotThresh=1.0</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>IterRefine=DOUBLE</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>Trans=NOTRANS</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>ReplaceTinyPivot=NO</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>SolveInitialized=NO</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>PrintStat=NO</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>DiagScale=NOEQUIL</code></li>
</ul>
<p>This value correspond to the parameter in the file
<code class="docutils literal highlight highlight-freefem"><span></span>ffsuperlu_dist_fileparam.txt</code>. If one parameter is not specified by
the user, we take the default value of SuperLU_DIST.</p>
<p><strong>Reading solver parameters on a file:</strong> The structure of data file for
SuperLU_DIST in <strong>``FreeFem++``</strong> is given in the file
<code class="docutils literal highlight highlight-freefem"><span></span>ffsuperlu_dist_fileparam.txt</code> (default value of the <strong>``FreeFem++``</strong>
interface).</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>1 /* nprow : integer value */
1 /* npcol : integer value */
distributedglobal /* matrix input : assembled, distributedglobal, distributed */
DOFACT /* Fact : DOFACT, SamePattern, SamePattern_SameRowPerm, FACTORED */
NO /* Equil : NO, YES */
NO /* ParSymbFact : NO, YES */
MMD_AT_PLUS_A /* ColPerm : NATURAL, MMD_AT_PLUS_A, MMD_ATA, METIS_AT_PLUS_A, PARMETIS, MY_PERMC */
LargeDiag /* RowPerm : NOROWPERM, LargeDiag, MY_PERMR */
1.0 /* DiagPivotThresh : real value */
DOUBLE /* IterRefine : NOREFINE, SINGLE, DOUBLE, EXTRA */
NOTRANS /* Trans : NOTRANS, TRANS, CONJ*/
NO /* ReplaceTinyPivot : NO, YES*/
NO /* SolveInitialized : NO, YES*/
NO /* RefineInitialized : NO, YES*/
NO /* PrintStat : NO, YES*/
NOEQUIL /* DiagScale : NOEQUIL, ROW, COL, BOTH*/
</pre></div>
</div>
<p>If no solver parameter is given, we used default option of SuperLU_DIST
solver.</p>
<p>!!!example A simple example of calling SuperLU_DIST in <strong>``FreeFem++``</strong>
with this two methods is given in the <a class="reference external" href="/examples/#solver-superlu_dist">Solver superLU_DIST
example</a>.</p>
</div>
<div class="section" id="pastix-solver">
<h4>PaStiX solver<a class="headerlink" href="#pastix-solver" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://pastix.gforge.inria.fr/files/README-txt.html">PaStiX</a>
(Parallel Sparse matrix package) is a free scientific library under
CECILL-C license. This package solves sparse linear system with a direct
and block ILU(k) iterative methods. This solver can be applied to a real
or complex matrix with a symmetric pattern.</p>
<p><strong>PaStiX parameters:</strong></p>
<p>The input <code class="code freefem docutils literal highlight highlight-freefem"><span></span>matrix</code> parameter of <strong>``FreeFem++``</strong> depend on
PaStiX interface. <code class="code freefem docutils literal highlight highlight-freefem"><span></span>matrix = assembled</code> for non distributed
matrix. It is the same parameter for SuperLU_DIST.</p>
<p>There are four parameters in PaStiX : <code class="docutils literal highlight highlight-freefem"><span></span>iparm</code>, <code class="docutils literal highlight highlight-freefem"><span></span>dparm</code>, <code class="docutils literal highlight highlight-freefem"><span></span>perm</code> and
<code class="docutils literal highlight highlight-freefem"><span></span>invp</code>. These parameters are respectively the integer parameters
(vector of size 64), real parameters (vector of size 64), permutation
matrix and inverse permutation matrix respectively. <code class="docutils literal highlight highlight-freefem"><span></span>iparm</code> and
<code class="docutils literal highlight highlight-freefem"><span></span>dparm</code> vectors are described in <a class="reference external" href="https://gforge.inria.fr/docman/?group_id=186&amp;view=listfile&amp;dirid=246">PaStiX
RefCard</a>.</p>
<p>The parameters <code class="code freefem docutils literal highlight highlight-freefem"><span></span>permr</code> and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>permc</code> in
<strong>``FreeFem++``</strong> are provided to give permutation matrix and inverse
permutation matrix of the user respectively.</p>
<p><strong>Solver parameters defined in ``.edp`` file:</strong></p>
<p>To call PaStiX in <strong>``FreeFem++``</strong> in this case, we need to specify the
parameters <code class="code freefem docutils literal highlight highlight-freefem"><span></span>lparams</code> and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparams</code>. These
parameters are defined by :</p>
<p><span class="math notranslate nohighlight">\(\forall i\)</span> = 0,… ,63, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>lparams[i] = iparm[i]</code>.</p>
<p><span class="math notranslate nohighlight">\(\forall i\)</span> = 0,… ,63, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparams[i] = dparm[i]</code>.</p>
<p><strong>Reading solver parameters on a file:</strong></p>
<p>The structure of data file for PaStiX parameters in <strong>``FreeFem++``</strong> is
: first line structure parameters of the matrix and in the following
line the value of vectors <code class="docutils literal highlight highlight-freefem"><span></span>iparm</code> and <code class="docutils literal highlight highlight-freefem"><span></span>dparm</code> in this order.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>assembled /* matrix input :: assembled, distributed global and distributed */
iparm[0]
iparm[1]
...
...
iparm[63]
dparm[0]
dparm[1]
...
...
dparm[63]
</pre></div>
</div>
<p>An example of this file parameter is given in
<code class="docutils literal highlight highlight-freefem"><span></span>ffpastix_iparm_dparm.txt</code> with a description of these parameters.
This file is obtained with the example file <code class="docutils literal highlight highlight-freefem"><span></span>iparm.txt</code> and
<code class="docutils literal highlight highlight-freefem"><span></span>dparm.txt</code> including in the PaStiX package.</p>
<p>If no solver parameter is given, we use the default option of PaStiX
solver.</p>
<p>!!!example A simple example of calling PaStiX in <strong>``FreeFem++``</strong> with
this two methods is given in the <a class="reference external" href="/examples/#solver-pastix">Solver PaStiX
example</a>.</p>
<p>In <a class="reference external" href="#Tab3">Table 3</a>, we recall the different matrix considering in
the different direct solvers.</p>
<table><thead><tr><th colspan="7"><p>Table 3: Type of matrix used by the different direct sparse solver</p>
</th></tr></thead><tbody><tr><td rowspan="2" style="vertical-align: bottom !important; font-weight: bold"><p>direct solver</p>
</td><td colspan="3" align="center" style="font-weight: bold"><p>square matrix</p>
</td><td colspan="3" align="center" style="font-weight: bold"><p>rectangular matrix</p>
</td></tr><tr><td style="font-weight: bold"><p>sym</p>
</td><td align="center" style="font-weight: bold"><p>sym pattern</p>
</td><td align="center" style="font-weight: bold"><p>unsym</p>
</td><td align="center" style="font-weight: bold"><p>sym</p>
</td><td align="center" style="font-weight: bold"><p>sym pattern</p>
</td><td align="center" style="font-weight: bold"><p>unsym</p>
</td></tr><tr><td><p>SuperLU_DIST</p>
</td><td align="center"><p>yes</p>
</td><td align="center"><p>yes</p>
</td><td align="center"><p>yes</p>
</td><td align="center"><p>yes</p>
</td><td align="center"><p>yes</p>
</td><td align="center"><p>yes</p>
</td></tr><tr><td><p>MUMPS</p>
</td><td align="center"><p>yes</p>
</td><td align="center"><p>yes</p>
</td><td align="center"><p>yes</p>
</td><td align="center"><p>no</p>
</td><td align="center"><p>no</p>
</td><td align="center"><p>no</p>
</td></tr><tr><td><p>pastix</p>
</td><td align="center"><p>yes</p>
</td><td align="center"><p>yes</p>
</td><td align="center"><p>no</p>
</td><td align="center"><p>no</p>
</td><td align="center"><p>no</p>
</td><td align="center"><p>no</p>
</td></tr></tbody></table></div>
</div>
<div class="section" id="parallel-sparse-iterative-solver">
<h3>Parallel sparse iterative solver<a class="headerlink" href="#parallel-sparse-iterative-solver" title="Permalink to this headline">¶</a></h3>
<p>Concerning iterative solvers, we have chosen
<a class="reference external" href="http://www-users.cs.umn.edu/~saad/software/pARMS/">pARMS</a>,
<a class="reference external" href="http://hips.gforge.inria.fr/">HIPS</a> and
<a class="reference external" href="https://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods">Hypre</a>.</p>
<p>Each software implements a different type of parallel preconditioner.</p>
<p>So, pARMS implements algebraic domain decomposition preconditioner type
such as additive Schwartz <a class="reference external" href="#CAI1989">CAI1989</a> and interface method;
while HIPS implement hierarchical incomplete factorization and finally
HYPRE implements multilevel preconditioner are AMG(Algebraic MultiGrid)
and parallel approximated inverse.</p>
<p>To use one of these programs in <strong>``FreeFem++``</strong>, you have to install
it independently of <strong>``FreeFem++``</strong>. It is also necessary to install
the MPI communication library which is essential for communication
between the processors and, in some cases, software partitioning graphs
like <a class="reference external" href="http://glaros.dtc.umn.edu/gkhome/metis/metis/overview">METIS</a>
or <a class="reference external" href="http://www.labri.fr/perso/pelegrin/scotch/">Scotch</a>.</p>
<p>All this preconditioners are used with Krylov subspace methods
accelerators.</p>
<p>Krylov subspace methods are iterative methods which consist in finding a
solution <span class="math notranslate nohighlight">\(x\)</span> of linear system <span class="math notranslate nohighlight">\(Ax=b\)</span> inside the affine space
<span class="math notranslate nohighlight">\(x_0+K_m\)</span> by imposing that <span class="math notranslate nohighlight">\(b-Ax \bot \mathcal{L}_m\)</span>, where
<span class="math notranslate nohighlight">\(K_m\)</span> is Krylov subspace of dimension <span class="math notranslate nohighlight">\(m\)</span> defined by
<span class="math notranslate nohighlight">\(K_m=\{r_0, Ar_0, A^2r_0,...,A^{m-1}r_0\}\)</span> and
<span class="math notranslate nohighlight">\(\mathcal{L}_m\)</span> is another subspace of dimension <span class="math notranslate nohighlight">\(m\)</span> which
depends on type of Krylov subspace. For example in GMRES,
<span class="math notranslate nohighlight">\(\mathcal{L}_m=AK_m\)</span>.</p>
<p>We realized an interface which is easy to use, so that the call of these
different softwares in <strong>``FreeFem++``</strong> is done in the same way. You
just have to load the solver and then specify the parameters to apply to
the specific solvers. In the rest of this chapter, when we talk about
Krylov subspace methods we mean one among GMRES, CG and BICGSTAB.</p>
<div class="section" id="parms-solver">
<h4>pARMS solver<a class="headerlink" href="#parms-solver" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://www-users.cs.umn.edu/~saad/software/pARMS/">pARMS</a> (parallel
Algebraic Multilevel Solver) is a software developed by Youssef Saad and
al at University of Minnesota.</p>
<p>This software is specialized in the resolution of large sparse non
symmetric linear systems of equation. Solvers developed in pARMS are of
type “Krylov’s subspace”.</p>
<p>It consists of variants of GMRES like FGMRES (Flexible GMRES), DGMRES
(Deflated GMRES) <a class="reference external" href="#SAAD2003">SAAD2003</a> and BICGSTAB. pARMS also
implements parallel preconditioner like RAS (Restricted Additive
Schwarz) <a class="reference external" href="#CAI1989">CAI1989</a> and Schur Complement type
preconditioner.</p>
<p>All these parallel preconditioners are based on the principle of domain
decomposition. Thus, the matrix <span class="math notranslate nohighlight">\(A\)</span> is partitioned into sub
matrices <span class="math notranslate nohighlight">\(A_i\)</span>(<span class="math notranslate nohighlight">\(i=1,...,p\)</span>) where p represents the number
of partitions one needs. The union of <span class="math notranslate nohighlight">\(A_i\)</span> forms the original
matrix. The solution of the overall system is obtained by solving the
local systems on <span class="math notranslate nohighlight">\(A_i\)</span> (see <a class="reference external" href="#SMITH1996">SMITH1996</a>).
Therefore, a distinction is made between iterations on <span class="math notranslate nohighlight">\(A\)</span> and the
local iterations on <span class="math notranslate nohighlight">\(A_i\)</span>.</p>
<p>To solve the local problem on <span class="math notranslate nohighlight">\(A_i\)</span> there are several
preconditioners as <strong>ilut</strong> (Incomplete LU with threshold), <strong>iluk</strong>
(Incomplete LU with level of fill in) and <strong>ARMS</strong> (Algebraic Recursive
Multilevel Solver).</p>
<p>!!!example “Default parameters” ```freefem load “parms_FreeFem” //Tell
FreeFem that you will use pARMS</p>
<p>// Mesh border C(t=0, 2*pi){x=cos(t); y=sin(t); label=1;} mesh Th =
buildmesh (C(50));</p>
<p>// Fespace fespace Vh(Th, P2); Vh u, v;</p>
<p>// Function func f= x*y;</p>
<p>// Problem problem Poisson (u, v, solver=sparsesolver) = int2d(Th)(
dx(u)<em>dx(v) + dy(u)</em>dy(v) ) + int2d(Th)( - f*v ) + on(1, u=0) ;</p>
<p>// Solve real cpu = clock(); Poisson; cout &lt;&lt; ” CPU time = ” &lt;&lt;
clock()-cpu &lt;&lt; endl;</p>
<p>// Plot plot(u); ```</p>
<p>In line 1, the pARMS dynamic library is loaded with interface
<strong>``FreeFem++``</strong>. After this, in line 15 we specify that the bilinear
form will be solved by the last sparse linear solver load in memory
which, in this case, is pARMS.</p>
<p>The parameters used in pARMS in this case are the default one since the
user does not have to provide any parameter.</p>
<p>!!!note In order to see the plot of a parallel script, run the command
<code class="docutils literal highlight highlight-freefem"><span></span>FreeFem++-mpi -glut ffglut script.edp</code></p>
<p>Here are some default parameters:</p>
<ul class="simple">
<li><code class="docutils literal highlight highlight-freefem"><span></span>solver=FGMRES</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>Krylov dimension=30</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>Maximum of Krylov=1000</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>Tolerance for convergence=$1e-08$</code>(see book
<a class="reference external" href="#SAAD2003">SAAD2003</a> to understand all this parameters),</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>preconditionner=Restricted Additif Schwarz</code>
<a class="reference external" href="#CAI1989">CAI1989</a>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>Inner Krylov dimension=5</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>Maximum of inner Krylov dimension=5</code>,</li>
<li><code class="docutils literal highlight highlight-freefem"><span></span>Inner preconditionner=ILUK</code>.</li>
</ul>
<p>To specify the parameters to apply to the solver, the user can either
give an integer vector for <strong>integer parameters</strong> and real vectors for
<strong>real parameters</strong> or provide a <strong>file</strong> which contains those
parameters.</p>
<p>!!!example “User specifies parameters inside two vectors” Lets us
consider Navier-Stokes example. In this example we solve linear systems
coming from discretization of Navier-Stokes equations with pARMS.
Parameters of solver is specified by user.</p>
<p>```freefem load “parms_FreeFem”</p>
<p>// Parameters real nu = 1.; int[int] iparm(16); real[int] dparm(6); for
(int ii = 0; ii &lt; 16; ii++) iparm[ii] = -1; for (int ii = 0; ii &lt; 6;
ii++) dparm[ii] = -1.0; iparm[0]=0;</p>
<p>// Mesh mesh Th = square(10, 10); int[int] wall = [1, 3]; int inlet = 4;</p>
<p>// Fespace fespace Vh(Th, [P2, P2, P1]);</p>
<p>// Function func uc = 1.;</p>
<p>varf Stokes ([u, v, p], [ush, vsh, psh], solver=sparsesolver) =
int2d(Th)( nu<em>( dx(u)</em>dx(ush) + dy(u)<em>dy(ush) + dx(v)</em>dx(vsh) +
dy(v)<em>dy(vsh) ) - p</em>psh<em>(1.e-6) - p</em>(dx(ush) + dy(vsh)) - (dx(u)
+ dy(v))*psh ) + on(wall, wall, u=0., v=0.) + on(inlet, u=uc, v=0) ;</p>
<p>matrix AA = Stokes(Vh, Vh); set(AA, solver=sparsesolver, lparams=iparm,
dparams=dparm); //set pARMS as linear solver real[int] bb = Stokes(0,
Vh); real[int] sol(AA.n); sol = AA^-1 * bb; ```</p>
<p>We need two vectors to specify the parameters of the linear solver. In
line 5-6 of the example, we have declared these
vectors(<code class="code freefem docutils literal highlight highlight-freefem"><span></span>int[int] iparm(16); real[int] dparm(6);</code>). In
line 7-10 we have initialized these vectors by negative values.</p>
<p>We do this because all parameters values in pARMS are positive and if
you do not change the negative values of one entry of this vector, the
default value will be set.</p>
<p>In <a class="reference external" href="#Tab4">table 4</a> and <a class="reference external" href="#Tab5">table 5</a>, we have the meaning of
different entries of these vectors.</p>
<table><thead><tr><th colspan="2"><p>Table 4: Meaning of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>lparams</code> corresponding variables</p>
</th></tr></thead><tbody><tr><td style="font-weight: bold"><p>Entries of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>iparm</code></p>
</td><td style="font-weight: bold"><p>Significations of each entries</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[0]</code></p>
</td><td><p>Krylov subspace methods.Different values for this parameters are specify
on <a class="reference external" href="#Tab6">table 7</a></p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[1]</code></p>
</td><td><p>Preconditionner.Different preconditionners for this parameters are
specify on <a class="reference external" href="#Tab7">table 7</a></p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[2]</code></p>
</td><td><p>Krylov subspace dimension in outer iteration: default value 30</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[3]</code></p>
</td><td><p>Maximum of iterations in outer iteration: default value 1000</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[4]</code></p>
</td><td><p>Number of level in arms when used.</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[5]</code></p>
</td><td><p>Krylov subspace dimension in inner iteration: default value 3</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[6]</code></p>
</td><td><p>Maximum of iterations in inner iteration: default value 3</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[7]</code></p>
</td><td><p>Symmetric(=1 for symmetric) or unsymmetric matrix:default value
0(unsymmetric matrix)</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[8]</code></p>
</td><td><p>Overlap size between different subdomain: default value 0(no overlap)</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[9]</code></p>
</td><td><p>Scale the input matrix or not: Default value 1 (Matrix should be scaled)</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[10]</code></p>
</td><td><p>Block size in arms when used: default value 20</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[11]</code></p>
</td><td><p>lfil0 (ilut, iluk, and arms) : default value 20</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[12]</code></p>
</td><td><p>lfil for Schur complement const : default value 20</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[13]</code></p>
</td><td><p>lfil for Schur complement const : default value 20</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[14]</code></p>
</td><td><p>Multicoloring or not in ILU when used : default value 1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[15]</code></p>
</td><td><p>Inner iteration : default value 0</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[16]</code></p>
</td><td><p>Print message when solving:default 0 (no message print).0: no message is
print,1: Convergence informations like number of iteration and residual
,2: Timing for a different step like preconditioner3 : Print all
informations.</p>
</td></tr></tbody></table><table><thead><tr><th colspan="2"><p>Table 5: Significations of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparams</code> corresponding
variables</p>
</th></tr></thead><tbody><tr><td style="font-weight: bold"><p>Entries of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparm</code></p>
</td><td style="font-weight: bold"><p>Significations of each entries</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[0]</code></p>
</td><td><p>precision for outer iteration : default value 1e-08</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[1]</code></p>
</td><td><p>precision for inner iteration: default value 1e-2</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[2]</code></p>
</td><td><p>tolerance used for diagonal domain: : default value 0.1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[3]</code></p>
</td><td><p>drop tolerance droptol0 (ilut, iluk, and arms) : default value 1e-2</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[4]</code></p>
</td><td><p>droptol for Schur complement const: default value 1e-2</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[5]</code></p>
</td><td><p>droptol for Schur complement const: default value 1e-2</p>
</td></tr></tbody></table><table><thead><tr><th colspan="2"><p>Table 6: Krylov Solvers in pARMS</p>
</th></tr></thead><tbody><tr><td style="font-weight: bold"><p>Values of <code class="docutils literal highlight highlight-freefem"><span></span>iparm[0]</code></p>
</td><td style="font-weight: bold"><p>Krylov subspace methods</p>
</td></tr><tr><td><p>0</p>
</td><td><p>FGMRES (Flexible GMRES)</p>
</td></tr><tr><td><p>1</p>
</td><td><p>DGMRES (Deflated GMRES)</p>
</td></tr><tr><td><p>2</p>
</td><td><p>BICGSTAB</p>
</td></tr></tbody></table><table><thead><tr><th colspan="2"><p>Table 7: Preconditionners in pARMS</p>
</th></tr></thead><tbody><tr><td style="font-weight: bold"><p>Values of <code class="docutils literal highlight highlight-freefem"><span></span>iparm[1]</code></p>
</td><td style="font-weight: bold"><p>Preconditionners type</p>
</td></tr><tr><td><p>0</p>
</td><td><p>additive Schwartz preconditioner with ilu0 as local preconditioner</p>
</td></tr><tr><td><p>1</p>
</td><td><p>additive Schwartz preconditioner with iluk as local preconditioner</p>
</td></tr><tr><td><p>2</p>
</td><td><p>additive Schwartz preconditioner with ilut as local preconditioner</p>
</td></tr><tr><td><p>3</p>
</td><td><p>additive Schwartz preconditioner with arms as local preconditioner</p>
</td></tr><tr><td><p>4</p>
</td><td><p>Left Schur complement preconditioner with ilu0 as local preconditioner</p>
</td></tr><tr><td><p>5</p>
</td><td><p>Left Schur complement preconditioner with ilut as local preconditioner</p>
</td></tr><tr><td><p>6</p>
</td><td><p>Left Schur complement preconditioner with iluk as local preconditioner</p>
</td></tr><tr><td><p>7</p>
</td><td><p>Left Schur complement preconditioner with arms as local preconditioner</p>
</td></tr><tr><td><p>8</p>
</td><td><p>Right Schur complement preconditioner with ilu0 as local preconditioner</p>
</td></tr><tr><td><p>9</p>
</td><td><p>Right Schur complement preconditioner with ilut as local preconditioner</p>
</td></tr><tr><td><p>10</p>
</td><td><p>Right Schur complement preconditioner with iluk as local preconditioner</p>
</td></tr><tr><td><p>11</p>
</td><td><p>Right Schur complement preconditioner with arms as local preconditioner</p>
</td></tr><tr><td><p>12</p>
</td><td><p>sch_gilu0, Schur complement preconditioner with global ilu0</p>
</td></tr><tr><td><p>13</p>
</td><td><p>SchurSymmetric GS preconditioner</p>
</td></tr></tbody></table><p>We run this example on a cluster paradent of Grid5000 and report results
in <a class="reference external" href="#Tab8">table 8</a>.</p>
<table><thead><tr><th colspan="5"><p>Table 8: Convergence and time for solving linear system</p>
</th></tr></thead><tbody><tr><td colspan="2" align="center" style="font-weight: bold"><p>n=471281</p>
</td><td colspan="2" align="center" style="font-weight: bold"><p>nnz=<span class="math notranslate nohighlight">\(13\times10^6\)</span></p>
</td><td colspan="2" align="center" style="font-weight: bold"><p>Te=571,29</p>
</td></tr><tr><td rowspan="2" align="center" style="vertical-align: bottom !important"><p>np</p>
</td><td colspan="2" align="center"><p>add(iluk)</p>
</td><td colspan="2" align="center"><p>schur(iluk)</p>
</td></tr><tr><td align="center"><p><code class="docutils literal highlight highlight-freefem"><span></span>nit</code></p>
</td><td align="center"><p><code class="docutils literal highlight highlight-freefem"><span></span>time</code></p>
</td><td align="center"><p><code class="docutils literal highlight highlight-freefem"><span></span>nit</code></p>
</td><td align="center"><p><code class="docutils literal highlight highlight-freefem"><span></span>time</code></p>
</td></tr><tr><td align="center"><p>4</p>
</td><td align="center"><p>230</p>
</td><td align="center"><p>637.57</p>
</td><td align="center"><p>21</p>
</td><td align="center"><p>557.8</p>
</td></tr><tr><td align="center"><p>8</p>
</td><td align="center"><p>240</p>
</td><td align="center"><p>364.12</p>
</td><td align="center"><p>22</p>
</td><td align="center"><p>302.25</p>
</td></tr><tr><td align="center"><p>16</p>
</td><td align="center"><p>247</p>
</td><td align="center"><p>212.07</p>
</td><td align="center"><p>24</p>
</td><td align="center"><p>167.5</p>
</td></tr><tr><td align="center"><p>32</p>
</td><td align="center"><p>261</p>
</td><td align="center"><p>111.16</p>
</td><td align="center"><p>25</p>
</td><td align="center"><p>81.5</p>
</td></tr></tbody></table><table><thead><tr><th colspan="2"><p>Table 9: Legend of <a class="reference external" href="#Tab8">table 8</a></p>
</th></tr></thead><tbody><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>n</code></p>
</td><td><p>matrix size</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>nnz</code></p>
</td><td><p>number of non null entries inside matrix</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>nit</code></p>
</td><td><p>number of iteration for convergence</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>time</code></p>
</td><td><p>Time for convergence</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>Te</code></p>
</td><td><p>Time for constructing finite element matrix</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>np</code></p>
</td><td><p>number of processor</p>
</td></tr></table><p>In this example, we fix the matrix size (in term of finite element, we
fix the mesh) and increase the number of processors used to solve the
linear system. We saw that, when the number of processors increases, the
time for solving the linear equation decreases, even if the number of
iteration increases. This proves that, using pARMS as solver of linear
systems coming from discretization of partial differential equation in
<strong>``FreeFem++``</strong> can decrease drastically the total time of simulation.</p>
</div>
<div class="section" id="interfacing-with-hips">
<h4>Interfacing with HIPS<a class="headerlink" href="#interfacing-with-hips" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://hips.gforge.inria.fr/">HIPS</a> (<em>Hierarchical Iterative
Parallel Solver</em>) is a scientific library that provides an efficient
parallel iterative solver for very large sparse linear systems. HIPS is
available as free software under the CeCILL-C licence.</p>
<p>HIPS implements two solver classes which are the iteratives class
(GMRES, PCG) and the Direct class. Concerning preconditionners, HIPS
implements a type of multilevel ILU. For further informations on those
preconditionners see the <a class="reference external" href="http://hips.gforge.inria.fr/doc/hips_user.pdf">HIPS
documentation</a>.</p>
<p>!!!example “Laplacian 3D solved with HIPS” Let us consider the 3D
Laplacian example inside <strong>``FreeFem++``</strong> package where after
discretization we want to solve the linear equation with HIPS.</p>
<p>The following example is a Laplacian 3D using Hips as linear solver. We
first load Hips solver at line 2. From line 7 to 18 we specify the
parameters for the Hips solver and in line 82 we set these parameters in
the linear solver.</p>
<p>In <a class="reference external" href="#Tab10">Table 10</a> results of running on Cluster Paradent of
Grid5000 are reported. We can see in this running example the efficiency
of parallelism.</p>
<p>```freefem load “msh3” load “hips_FreeFem” //load Hips library</p>
<p>// Parameters int nn = 10; real zmin = 0, zmax = 1; int[int] iparm(14);
real[int] dparm(6); for (int iii = 0; iii &lt; 14; iii++) iparm[iii] = -1;
for (int iii = 0; iii &lt; 6; iii++) dparm[iii] = -1; iparm[0] = 0; //use
iterative solver iparm[1] = 1; //PCG as Krylov method iparm[4] = 0;
//Matrix are symmetric iparm[5] = 1; //Pattern are also symmetric
iparm[9] = 1; //Scale matrix dparm[0] = 1e-13; //Tolerance to
convergence dparm[1] = 5e-4; //Threshold in ILUT dparm[2] = 5e-4;
//Threshold for Schur preconditionner</p>
<p>// Functions func ue = 2<em>x</em>x + 3<em>y</em>y + 4<em>z</em>z + 5<em>x</em>y +
6<em>x</em>z + 1; func uex = 4<em>x + 5</em>y + 6<em>z; func uey = 6</em>y +
5<em>x; func uez = 8</em>z + 6*x; func f = -18.;</p>
<p>// Mesh mesh Th2 = square(nn, nn);</p>
<p>int[int] rup = [0,2], rdown=[0, 1]; int[int] rmid=[1, 1, 2, 1, 3, 1, 4,
1];</p>
<p>mesh3 Th=buildlayers(Th2, nn, zbound=[zmin, zmax], reffacemid=rmid,
reffaceup = rup, reffacelow = rdown);</p>
<p>// Fespace fespace Vh2(Th2, P2); Vh2 ux, uz, p2;</p>
<p>fespace Vh(Th, P2); Vh uhe = ue; cout &lt;&lt; “uhe min =” &lt;&lt; uhe[].min &lt;&lt; “,
max =” &lt;&lt; uhe[].max &lt;&lt; endl; Vh u, v; Vh F;</p>
<p>// Macro macro Grad3(u) [dx(u), dy(u), dz(u)] //</p>
<p>// Problem varf va (u, v) = int3d(Th)( Grad3(v)’ * Grad3(u) ) +
int2d(Th, 2)( u<em>v ) - int3d(Th)( f</em>v ) - int2d(Th, 2)( ue<em>v +
(uex</em>N.x + uey<em>N.y + uez</em>N.z)*v ) + on(1, u=ue);</p>
<p>varf l (unused, v) = int3d(Th)(f*v);</p>
<p>real cpu=clock(); matrix Aa = va(Vh, Vh);</p>
<p>F[] = va(0, Vh);</p>
<p>if (mpirank == 0){ cout &lt;&lt; “Size of A =” &lt;&lt; Aa.n &lt;&lt; endl; cout &lt;&lt; “Non
zero coefficients =” &lt;&lt; Aa.nbcoef &lt;&lt; endl; cout &lt;&lt; “CPU TIME FOR FORMING
MATRIX =” &lt;&lt; clock()-cpu &lt;&lt; endl; }</p>
<p>set(Aa, solver=sparsesolver, dparams=dparm, lparams=iparm); //Set hips
as linear solver</p>
<p>// Solve u[] = Aa^-1*F[];</p>
<p>// Plot plot(u); ```</p>
<table><thead><tr><th colspan="3"><p>Table 10: Legend of this table are give in <a class="reference external" href="#Tab9">table 9</a></p>
</th></tr></thead><tbody><tr><td align="center"><p><span class="math notranslate nohighlight">\(n=4 \times 10^6\)</span></p>
</td><td align="center"><p><span class="math notranslate nohighlight">\(nnz=118 \times 10^6\)</span></p>
</td><td align="center"><p><span class="math notranslate nohighlight">\(Te=221.34\)</span></p>
</td></tr><tr><td align="center"><p><code class="docutils literal highlight highlight-freefem"><span></span>np</code></p>
</td><td align="center"><p><code class="docutils literal highlight highlight-freefem"><span></span>nit</code></p>
</td><td align="center"><p><code class="docutils literal highlight highlight-freefem"><span></span>time</code></p>
</td></tr><tr><td align="center"><p>8</p>
</td><td align="center"><p>190</p>
</td><td align="center"><p>120.34</p>
</td></tr><tr><td align="center"><p>16</p>
</td><td align="center"><p>189</p>
</td><td align="center"><p>61.08</p>
</td></tr><tr><td align="center"><p>32</p>
</td><td align="center"><p>186</p>
</td><td align="center"><p>31.70</p>
</td></tr><tr><td align="center"><p>64</p>
</td><td align="center"><p>183</p>
</td><td align="center"><p>23.44</p>
</td></tr></tbody></table><p>!!!tips</p>
<table><thead><tr><th colspan="2"><p>Table 11: Significations of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>lparams</code> corresponding to HIPS
interface</p>
</th></tr></thead><tbody><tr><td style="font-weight: bold"><p>Entries of <code class="docutils literal highlight highlight-freefem"><span></span>iparm</code></p>
</td><td style="font-weight: bold"><p>Significations of each entries</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[0]</code></p>
</td><td><p>Strategy use for solving (Iterative=0 or Hybrid=1 or Direct=2). Defaults
values are : Iterative</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[1]</code></p>
</td><td><p>Krylov methods. If iparm[0]=0, give type of Krylov methods: 0 for GMRES,
1 for PCG</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[2]</code></p>
</td><td><p>Maximum of iterations in outer iteration: default value 1000</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[3]</code></p>
</td><td><p>Krylov subspace dimension in outer iteration: default value 40</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[4]</code></p>
</td><td><p>Symmetric(=0 for symmetric) and 1 for unsymmetricmatrix: default value 1
(unsymmetric matrix)</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[5]</code></p>
</td><td><p>Pattern of matrix are symmetric or not: default value 0</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[6]</code></p>
</td><td><p>Partition type of input matrix: default value 0</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[7]</code></p>
</td><td><p>Number of level that use the HIPS locally consistentfill-in: Default
value 2</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[8]</code></p>
</td><td><p>Numbering in indices array will start at 0 or 1: Default value 0</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[9]</code></p>
</td><td><p>Scale matrix. Default value 1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[10]</code></p>
</td><td><p>Reordering use inside subdomains for reducingfill-in: Only use for
iterative. Default value 1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[11]</code></p>
</td><td><p>Number of unknowns per node in the matrix non-zeropattern graph: Default
value 1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[12]</code></p>
</td><td><p>This value is used to set the number of time the normalization is
applied to the matrix: Default 2.</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[13]</code></p>
</td><td><p>Level of informations printed during solving: Default 5.</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparm[14]</code></p>
</td><td><p>HIPS_DOMSIZE Subdomain size</p>
</td></tr></tbody></table><table><thead><tr><th colspan="2"><p>Table 12: Significations of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparams</code> corresponding to HIPS
interface</p>
</th></tr></thead><tbody><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[0]</code></p>
</td><td><p>HIPS_PREC: Relative residual norm: Default=1e-9</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[1]</code></p>
</td><td><p>HIPS_DROPTOL0: Numerical threshold in ILUT for interior domain
(important : set 0.0 in HYBRID: Default=0.005)</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[2]</code></p>
</td><td><p>HIPS_DROPTOL1 : Numerical threshold in ILUT for Schur preconditioner:
Default=0.005</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[3]</code></p>
</td><td><p>HIPS_DROPTOLE : Numerical threshold for coupling between the interior
level and Schur: Default 0.005</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[4]</code></p>
</td><td><p>HIPS_AMALG : Numerical threshold for coupling between the interior level
and Schur: Default=0.005</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparm[5]</code></p>
</td><td><p>HIPS_DROPSCHUR : Numerical threshold for coupling between the interior
level and Schur: Default=0.005</p>
</td></tr></tbody></table></div>
<div class="section" id="interfacing-with-hypre">
<h4>Interfacing with HYPRE<a class="headerlink" href="#interfacing-with-hypre" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods">Hypre</a>
(High Level Preconditioner) is a suite of parallel preconditioner
developed at Lawrence Livermore National Lab.</p>
<p>There are two main classes of preconditioners developed in HYPRE: AMG
(Algebraic MultiGrid) and Parasails (Parallel Sparse Approximate
Inverse).</p>
<p>Now, suppose we want to solve <span class="math notranslate nohighlight">\(Ax=b\)</span>.</p>
<p>At the heart of AMG there is a series of progressively coarser (smaller)
representations of the matrix <span class="math notranslate nohighlight">\(A\)</span>. Given an approximation
<span class="math notranslate nohighlight">\(\hat{x}\)</span> to the solution <span class="math notranslate nohighlight">\(x\)</span>, consider solving the residual
equation <span class="math notranslate nohighlight">\(Ae=r\)</span> to find the error <span class="math notranslate nohighlight">\(e\)</span>, where
<span class="math notranslate nohighlight">\(r=b-A\hat{x}\)</span>. A fundamental principle of AMG is that it is an
algebraically smooth error. To reduce the algebraically smooth errors
further, they need to be represented by a smaller defect equation
(coarse grid residual equation) <span class="math notranslate nohighlight">\(A_ce_c=r_c\)</span>, which is cheaper to
solve. After solving this coarse equation, the solution is then
interpolated in fine grid represented here by matrix <span class="math notranslate nohighlight">\(A\)</span>. The
quality of AMG depends on the choice of coarsening and interpolating
operators.</p>
<p>The <em>sparse approximate inverse</em> approximates the inverse of a matrix
<span class="math notranslate nohighlight">\(A\)</span> by a sparse matrix <span class="math notranslate nohighlight">\(M\)</span>. A technical idea to construct
matrix <span class="math notranslate nohighlight">\(M\)</span> is to minimize the Frobenuis norm of the residual
matrix <span class="math notranslate nohighlight">\(I-MA\)</span>. For more details on this preconditioner technics
see <a class="reference external" href="#CHOW1997">CHOW1997</a>.</p>
<p>HYPRE implement three Krylov subspace solvers: GMRES, PCG and BiCGStab.</p>
<p>!!!example “Laplacian 3D solved with HYPRE” Let us consider again the 3D
Laplacian example inside FreeFem++ package where after discretization we
want to solve the linear equation with Hypre. The following example is a
Laplacian 3D using Hypre as linear solver. This is the same example as
Hips one, so we just show here the lines where we set some Hypre
parameters.</p>
<p>We first load the Hypre solver at line 2. From line 6 to 18 we specifies
the parameters to set to Hypre solver and in line 22 we set parameters
to Hypre solver.</p>
<p>It should be noted that the meaning of the entries of these vectors is
different from those of Hips. In the case of HYPRE, the meaning of
differents entries of vectors <code class="code freefem docutils literal highlight highlight-freefem"><span></span>iparm</code> and
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparm</code> are given in <a class="reference external" href="#Tab13">tables 13</a> to
<a class="reference external" href="#Tab17">17</a>.</p>
<p>In <a class="reference external" href="#Tab18">Table 18</a> the results of running on Cluster Paradent of
Grid5000 are reported. We can see in this running example the efficiency
of parallelism, in particular when AMG are use as preconditioner.</p>
<p>```freefem load “msh3” load “hipre_FreeFem” //Load Hipre librairy</p>
<p>// Parameters int nn = 10; int[int] iparm(20); real[int] dparm(6); for
(int iii = 0; iii &lt; 20; iii++) iparm[iii] = -1; for (int iii = 0; iii &lt;
6; iii++) dparm[iii] = -1; iparm[0] = 2; //PCG as krylov method iparm[1]
= 0; //AMG as preconditionner 2: if ParaSails iparm[7] = 7;
//Interpolation iparm[9] = 6; //AMG Coarsen type iparm[10] = 1;
//Measure type iparm[16] = 2; //Additive schwarz as smoother dparm[0] =
1e-13; //Tolerance to convergence dparm[1] = 5e-4; //Threshold dparm[2]
= 5e-4; //Truncation factor</p>
<p>…</p>
<p>set(Aa, solver=sparsesolver, dparams=dparm, lparams=iparm); ```</p>
<table><thead><tr><th colspan="2"><p>Table 13: Definitions of common entries of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>iparms</code> and
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparms</code> vectors for every preconditioner in HYPRE</p>
</th></tr></thead><tbody><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[0]</code></p>
</td><td><p>Solver identification: 0: BiCGStab, 1: GMRES, 2: PCG. Default=1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[1]</code></p>
</td><td><p>Preconditioner identification: 0: BOOMER AMG, 1: PILUT, 2: Parasails, 3:
Schwartz Default=0</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[2]</code></p>
</td><td><p>Maximum of iteration: Default=1000</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[3]</code></p>
</td><td><p>Krylov subspace dim: Default= 40</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[4]</code></p>
</td><td><p>Solver print info level: Default=2</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[5]</code></p>
</td><td><p>Solver log: Default=1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[6]</code></p>
</td><td><p>Solver stopping criteria only for BiCGStab : Default=1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>dparms[0]</code></p>
</td><td><p>Tolerance for convergence: Default=<span class="math notranslate nohighlight">\(1.0e-11\)</span></p>
</td></tr></tbody></table><table><thead><tr><th colspan="2"><p>Table 14: Definitions of other entries of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>iparms</code> and
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>dparms</code> if preconditioner is BOOMER AMG</p>
</th></tr></thead><tbody><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[7]</code></p>
</td><td><p>AMG interpolation type: Default=6</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[8]</code></p>
</td><td><p>Specifies the use of GSMG - geometrically smooth coarsening and
interpolation: Default=1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[9]</code></p>
</td><td><p>AMG coarsen type: Default=6</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[10]</code></p>
</td><td><p>Defines whether local or global measures are used: Default=1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[11]</code></p>
</td><td><p>AMG cycle type: Default=1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[12]</code></p>
</td><td><p>AMG Smoother type: Default=1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[13]</code></p>
</td><td><p>AMG number of levels for smoothers: Default=3</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[14]</code></p>
</td><td><p>AMG number of sweeps for smoothers: Default=2</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[15]</code></p>
</td><td><p>Maximum number of multigrid levels: Default=25</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[16]</code></p>
</td><td><p>Defines which variant of the Schwartz method isused: 0: hybrid
multiplicative Schwartz method (no overlap across processor boundaries)
1: hybrid additive Schwartz method (no overlap across processor
boundaries) 2: additive Schwartz method 3: hybrid multiplicative
Schwartz method (with overlap across processor boundaries) Default=1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[17]</code></p>
</td><td><p>Size of the system of PDEs: Default=1</p>
</td></tr><tr><td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[18]</code></p>
</td><td><p>Overlap for the Schwarz method: Default=1</p>
</td></tr><tr><td><p>Type of domain used for the Schwarz method</p>
<td><p><code class="docutils literal highlight highlight-freefem"><span></span>iparms[19]</code></p>
</td><div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>            0: each point is a domain&lt;br&gt;
            1: each node is a domain (only of interest in &quot;systems&quot; AMG)&lt;br&gt;
            2: each domain is generated by agglomeration (default)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;`dparms[1]`&lt;/td&gt;
            &lt;td&gt;AMG strength threshold: Default=0.25&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;`dparms[2]`&lt;/td&gt;
            &lt;td&gt;Truncation factor for the interpolation: Default=1e-2&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;`dparms[3]`&lt;/td&gt;
            &lt;td&gt;Sets a parameter to modify the definition of strength for diagonal dominant portions of the matrix: Default=0.9&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;`dparms[3]`&lt;/td&gt;
            &lt;td&gt;Defines a smoothing parameter for the additive Schwartz method. Default=1&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;&lt;a name=&quot;Tab15&quot;&gt;Table 15&lt;/a&gt;: Definitions of other entries of `:::freefem iparms` and `:::freefem dparms` if preconditioner is PILUT&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;`iparms[7]`&lt;/td&gt;
            &lt;td&gt;Row size in Parallel ILUT: Default=1000&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;`iparms[8]`&lt;/td&gt;
            &lt;td&gt;Set maximum number of iterations: Default=30&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;`dparms[1]`&lt;/td&gt;
            &lt;td&gt;Drop tolerance in Parallel ILUT: Default=$1e-5$&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;&lt;a name=&quot;Tab16&quot;&gt;Table 16&lt;/a&gt;: Definitions of other entries of `:::freefem iparms` and `:::freefem dparms` if preconditioner is ParaSails&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;`iparms[7]`&lt;/td&gt;
            &lt;td&gt;Number of levels in Parallel Sparse Approximate inverse: Default=1&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;`iparms[8]`&lt;/td&gt;
            &lt;td&gt;Symmetric parameter for the ParaSails preconditioner:&lt;br&gt;
            0: nonsymmetric and/or indefinite problem, and nonsymmetric preconditioner&lt;br&gt;
            1: SPD problem, and SPD (factored) preconditioner&lt;br&gt;
            2: nonsymmetric, definite problem, and SPD (factored) preconditioner&lt;br&gt;
            Default=0&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;`dparms[1]`&lt;/td&gt;
            &lt;td&gt;Filters parameters. The filter parameter is used to drop small nonzeros in the preconditioner, to reduce the cost of applying the preconditioner: Default=0.1&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;`dparms[2]`&lt;/td&gt;
            &lt;td&gt;Threshold parameter: Default=0.1&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;&lt;a name=&quot;Tab17&quot;&gt;Table 17&lt;/a&gt;: Definitions of other entries of `:::freefem iparms` and `:::freefem dparms` if preconditionner is Schwartz&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;`iparms[7]`&lt;/td&gt;
            &lt;td&gt;Defines which variant of the Schwartz method isused:&lt;br&gt;
            0: hybrid multiplicative Schwartz method (no overlap across processor boundaries)&lt;br&gt;
            1: hybrid additive Schwartz method (no overlap across processor boundaries)&lt;br&gt;
            2: additive Schwartz method&lt;br&gt;
            3: hybrid multiplicative Schwartz method (with overlap across processor boundaries)&lt;br&gt;
            Default=1&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;`iparms[8]`&lt;/td&gt;
            &lt;td&gt;Overlap for the Schwartz method: Default=1&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;`iparms[9]`&lt;/td&gt;
            &lt;td&gt;Type of domain used for the Schwartz method&lt;br&gt;
            0: each point is a domain&lt;br&gt;
            1: each node is a domain (only of interest in &quot;systems&quot; AMG)&lt;br&gt;
            2: each domain is generated by agglomeration (default)&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;3&quot;&gt;&lt;a name=&quot;Tab18&quot;&gt;Table 18&lt;/a&gt;: Convergence and time for solving linear system&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td align=&#39;center&#39;&gt;n = $4\times10^6$&lt;/td&gt;
            &lt;td align=&#39;center&#39;&gt;nnz = $13\times10^6$&lt;/td&gt;
            &lt;td align=&#39;center&#39;&gt;$Te = 571,29$&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td rowspan=&quot;2&quot; align=&#39;center&#39;&gt;np&lt;/td&gt;
            &lt;td colspan=&quot;2&quot; align=&#39;center&#39;&gt;AMG&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td align=&#39;center&#39;&gt;`nit`&lt;/td&gt;
            &lt;td align=&#39;center&#39;&gt;`time`&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td align=&#39;center&#39;&gt;8&lt;/td&gt;
            &lt;td align=&#39;center&#39;&gt;6&lt;/td&gt;
            &lt;td align=&#39;center&#39;&gt;1491.83&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td align=&#39;center&#39;&gt;16&lt;/td&gt;
            &lt;td align=&#39;center&#39;&gt;5&lt;/td&gt;
            &lt;td align=&#39;center&#39;&gt;708.49&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td align=&#39;center&#39;&gt;32&lt;/td&gt;
            &lt;td align=&#39;center&#39;&gt;4&lt;/td&gt;
            &lt;td align=&#39;center&#39;&gt;296.22&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td align=&#39;center&#39;&gt;64&lt;/td&gt;
            &lt;td align=&#39;center&#39;&gt;4&lt;/td&gt;
            &lt;td align=&#39;center&#39;&gt;145.64&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</pre></div>
</div>
</div>
<div class="section" id="conclusion">
<h4>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h4>
<p>With the different runs presented here, we wanted to illustrate the gain
in time when we increase the number of processors used for the
simulations. We saw that in every case the time for the construction of
the finite element matrix is constant. This is normal because until now
this phase is sequential in FreeFem++. In contrast, phases for solving
the linear system are parallel. We saw on several examples presented
here that when we increase the number of processors, in general we
decrease the time used for solving the linear systems. But this is not
true in every case. In several case, when we increase the number of
processors the time to convergence also increases. There are two main
reasons for this. First, the increase of processors can lead to the
increase of volume of exchanged data across processors consequently
increasing the time for solving the linear systems.</p>
<p>Furthermore, in decomposition domain type preconditioners, the number of
processors generally corresponds to the number of sub domains. In
subdomain methods, generally when we increase the number of subdomains
we decrease convergence quality of the preconditioner. This can increase
the time used for solving linear equations.</p>
<p>To end this, we should note that good use of the preconditioners
interfaced in <strong>``FreeFem++``</strong> is empiric, because it is difficult to
know what is a good preconditioner for some type of problems. Although,
the efficiency of preconditioners sometimes depends on how its
parameters are set. For this reason we advise the user to pay attention
to the meaning of the parameters in the user guide of the iterative
solvers interfaced in <strong>``FreeFem++``</strong>.</p>
</div>
</div>
<div class="section" id="domain-decomposition">
<h3>Domain decomposition<a class="headerlink" href="#domain-decomposition" title="Permalink to this headline">¶</a></h3>
<p>In the previous section, we saw that the phases to construct a matrix
are sequential. One strategy to construct the matrix in parallel is to
divide geometrically the domain into subdomains. In every subdomain we
construct a local submatrix and after that we assemble every submatrix
to form the global matrix.</p>
<p>We can use this technique to solve PDE directly in domain
<span class="math notranslate nohighlight">\(\Omega\)</span>. In this case, in every subdomains you have to define
artificial boundary conditions to form consistent equations in every
subdomains. After this, you solve equation in every subdomains and
define a strategy to obtain the global solution.</p>
<p>In terms of parallel programming for <strong>``FreeFem++``</strong>, with MPI, this
means that the user must be able to divide processors avaible for
computation into subgroups of processors and also must be able to
realize different type of communications in <strong>``FreeFem++``</strong> script.
Here is a wrapper of some MPI functions.</p>
<div class="section" id="communicators-and-groups">
<h4>Communicators and groups<a class="headerlink" href="#communicators-and-groups" title="Permalink to this headline">¶</a></h4>
<p><strong>Groups</strong></p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiGroup grpe(mpiGroup gp, KN_&lt;long&gt;)</code>: Create MPI_Group
from existing group <code class="code freefem docutils literal highlight highlight-freefem"><span></span>gp</code> by given vector.</p>
<p><strong>Communicators</strong></p>
<p>Communicators is an abstract MPI object which allows MPI user to
communicate across group of processors. Communicators can be
Intra-communicators(involves a single group) or Inter-communicators
(involves two groups). When we not specify type of communicator it will
be Intra-communicators</p>
<p><strong>mpiComm cc(mpiComm comm, mpiGroup gp):</strong> Creates a new communicator.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>comm</code> communicator(handle), <code class="code freefem docutils literal highlight highlight-freefem"><span></span>gp</code> group which
is a subset of the group of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>comm</code> (handle). Return new
communicator</p>
<p><strong>mpiComm cc(mpiGroup gp)</strong>: Same as previous constructor but default
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>comm</code> here is <code class="docutils literal highlight highlight-freefem"><span></span>MPI_COMM_WORLD</code>.</p>
<p><strong>mpiComm cc(mpiComm comm, int color, int key):</strong> Creates new
communicators based on <code class="code freefem docutils literal highlight highlight-freefem"><span></span>colors</code> and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>key</code>.
This constructor is based on MPI_Comm_split routine of MPI.</p>
<p><strong>mpiComm cc(MPIrank p, int key):</strong> Same constructor than the last one.</p>
<p>Here <code class="code freefem docutils literal highlight highlight-freefem"><span></span>colors</code> and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>comm</code> is defined in
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>MPIrank</code>. This constructor is based on <code class="docutils literal highlight highlight-freefem"><span></span>MPI_Comm_split</code>
routine of MPI.</p>
<p>!!!example “Split communicator”
<code class="docutils literal highlight highlight-freefem"><span></span>freefem     mpiComm comm(mpiCommWorld, 0, 0);     int color = mpiRank(comm)%2;     mpiComm ccc(processor(color, comm), 0);     mpiComm qpp(comm, 0, 0);     mpiComm cp(ccc, color, 0);</code></p>
<p><strong>mpiComm cc(mpiComm comm, int high):</strong> Creates an intracommunicator
from an intercommunicator. <code class="code freefem docutils literal highlight highlight-freefem"><span></span>comm</code> intercommunicator,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>high</code>.</p>
<p>Used to order the groups within <code class="code freefem docutils literal highlight highlight-freefem"><span></span>comm</code> (logical) when
creating the new communicator. This constructor is based on
<code class="docutils literal highlight highlight-freefem"><span></span>MPI_Intercomm_merge</code> routine of MPI.</p>
<p><strong>mpiComm cc(MPIrank p1, MPIrank p2, int tag):</strong> This constructor
creates an intercommuncator from two intracommunicators.
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>p1</code> defined local (intra)communicator and rank in
<code class="docutils literal highlight highlight-freefem"><span></span>local_comm</code> of leader (often 0) while <code class="code freefem docutils literal highlight highlight-freefem"><span></span>p2</code> defined
remote communicator and rank in <code class="docutils literal highlight highlight-freefem"><span></span>peer_comm</code> of remote leader (often
0). <code class="code freefem docutils literal highlight highlight-freefem"><span></span>tag</code> Message tag to use in constructing
intercommunicator. This constructor is based on
<code class="docutils literal highlight highlight-freefem"><span></span>MPI_Intercomm_create</code>.</p>
<p>!!!example “Merge”
<code class="docutils literal highlight highlight-freefem"><span></span>freefem     mpiComm comm, cc;     int color = mpiRank(comm)%2;     int rk = mpiRank(comm);     int size = mpiSize(comm);     cout &lt;&lt; &quot;Color values: &quot; &lt;&lt; color &lt;&lt; endl;     mpiComm ccc(processor((rk&lt;size/2), comm), rk);     mpiComm cp(cc, color, 0);     int rleader;     if (rk == 0){ rleader = size/2; }     else if (rk == size/2){ rleader = 0; }     else{ rleader = 3; }     mpiComm qqp(processor(0, ccc), processor(rleader, comm), 12345);     int aaa = mpiSize(ccc);     cout &lt;&lt; &quot;Number of processor: &quot; &lt;&lt; aaa &lt;&lt; endl;</code></p>
</div>
<div class="section" id="process">
<h4>Process<a class="headerlink" href="#process" title="Permalink to this headline">¶</a></h4>
<p>In <strong>``FreeFem++``</strong> we wrap MPI process by function call
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>processor</code> which create internal <strong>``FreeFem++``</strong> object
call <code class="code freefem docutils literal highlight highlight-freefem"><span></span>MPIrank</code>. This mean that do not use
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>MPIrank</code> in <strong>``FreeFem++``</strong> script.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>processor(int rk)</code>: Keep process rank inside object
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>MPIrank</code>. Rank is inside <code class="docutils literal highlight highlight-freefem"><span></span>MPI_COMM_WORLD</code>.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>processor(int rk, mpiComm cc)</code> and
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>processor(mpiComm cc, int rk)</code> process rank inside
communicator cc.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>processor(int rk, mpiComm cc)</code> and
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>processor(mpiComm cc, int rk)</code> process rank inside
communicator cc.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>processorblock(int rk)</code>: This function is exactlly the
same than <code class="code freefem docutils literal highlight highlight-freefem"><span></span>processor(int rk)</code> but is use in case of
blocking communication.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>processorblock(int rk, mpiComm cc)</code>: This function is
exactly the same as <code class="code freefem docutils literal highlight highlight-freefem"><span></span>processor(int rk, mpiComm cc)</code> but
uses a synchronization point.</p>
</div>
<div class="section" id="points-to-points-communicators">
<h4>Points to Points communicators<a class="headerlink" href="#points-to-points-communicators" title="Permalink to this headline">¶</a></h4>
<p>In <strong>``FreeFem++``</strong> you can call MPI points to points communications
functions.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>Send(processor(int rk, mpiComm cc), Data D)</code> : Blocking
send of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data D</code> to processor of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>rank rk</code>
inside communicator <code class="code freefem docutils literal highlight highlight-freefem"><span></span>cc</code>. Note that <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data D</code>
can be: <code class="code freefem docutils literal highlight highlight-freefem"><span></span>int</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>real</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>int[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>real[int]</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Mesh</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Mesh3</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Matrix</code>.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>Recv(processor(int rk, mpiComm cc), Data D)</code>: Receive
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data D</code> from process of rank <code class="code freefem docutils literal highlight highlight-freefem"><span></span>rk</code> in
communicator <code class="code freefem docutils literal highlight highlight-freefem"><span></span>cc</code>. Note that <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data D</code> can be:
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>int</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>real</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>int[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>real[int]</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Mesh</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Mesh3</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Matrix</code> and should be the same type than corresponding
send.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>Isend(processor(int rk, mpiComm cc), Data D)</code> : Non
blocking send of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data D</code> to processor of
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>rank rk</code> inside communicator <code class="code freefem docutils literal highlight highlight-freefem"><span></span>cc</code>. Note that
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data D</code> can be: <code class="code freefem docutils literal highlight highlight-freefem"><span></span>int</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>real</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>int[int]</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>real[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex[int]</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>mesh</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mesh3</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>matrix</code>.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>Recv(processor(int rk, mpiComm cc), Data D)</code>: Receive
corresponding to send.</p>
</div>
<div class="section" id="global-operations">
<h4>Global operations<a class="headerlink" href="#global-operations" title="Permalink to this headline">¶</a></h4>
<p>In <strong>``FreeFem++``</strong> you can call MPI global communication functions.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>broadcast(processor(int rk, mpiComm cc), Data D)</code>: Process
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>rk</code> Broadcast <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data D</code> to all process inside
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>communicator cc</code>. Note that <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data D</code> can be:
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>int</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>real</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>int[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>real[int]</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Mesh</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Mesh3</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Matrix</code>.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>broadcast(processor(int rk), Data D)</code>: Process
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>rk</code> Broadcast <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data D</code> to all process inside
<code class="docutils literal highlight highlight-freefem"><span></span>MPI_COMM_WORLD</code>. Note that <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data D</code> can be:
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>int</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>real</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>int[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>real[int]</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>complex[int]</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Mesh</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Mesh3</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Matrix</code>.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiAlltoall(Data a, Data b)</code>: Sends <code class="code freefem docutils literal highlight highlight-freefem"><span></span>data a</code>
from all to all processes. Receive buffer is <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data b</code>. This
is done inside communicator <code class="docutils literal highlight highlight-freefem"><span></span>MPI_COMM_WORLD</code>.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiAlltoall(Data a, Data b, mpiComm cc)</code>: Sends
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>data a</code> from all to all processes. Receive buffer is
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data b</code>. This is done inside communicator <code class="docutils literal highlight highlight-freefem"><span></span>cc</code>.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiGather(Data a, Data b, processor(mpiComm, int rk)</code>:
Gathers together values <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data a</code> from a group of processes.
Process of rank <code class="code freefem docutils literal highlight highlight-freefem"><span></span>rk</code> get data on communicator
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>rk</code>. This function is like <code class="docutils literal highlight highlight-freefem"><span></span>MPI_Gather</code>.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiAllgather(Data a, Data b)</code>: Gathers
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data a</code> from all processes and distribute it to all in
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data b</code>. This is done inside communicator
<code class="docutils literal highlight highlight-freefem"><span></span>MPI_COMM_WORLD</code>. This function is like <code class="docutils literal highlight highlight-freefem"><span></span>MPI_Allgather</code>.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiAllgather(Data a, Data b, mpiComm cc)</code>: Gathers
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data a</code> from all processes and distribute it to all in
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data b</code>. This is done inside
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>communicator cc</code>. This function is like <code class="docutils literal highlight highlight-freefem"><span></span>MPI_Allgather</code>.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiScatter(Data a,Data b,processor(int rk, mpiComm cc))</code>:
Sends <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data a</code> from one process whith rank
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>rk</code> to all other processes in group represented by
communicator <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiComm cc</code>.</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiReduce(Data a, Data b, processor(int rk, mpiComm cc), MPI_Op op)</code>
Reduces values <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data a</code> on all processes to a single value
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Data b</code> on process of rank <code class="code freefem docutils literal highlight highlight-freefem"><span></span>rk</code> and
communicator <code class="code freefem docutils literal highlight highlight-freefem"><span></span>cc</code>.</p>
<p>Operation use in reduce is: <code class="code freefem docutils literal highlight highlight-freefem"><span></span>MPI_Op op</code> which can be:
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiMAX</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiMIN</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiSUM</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiPROD</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiLAND</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiLOR</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiLXOR</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiBAND</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiBXOR</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiMAXLOC</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpiMINLOC</code>.</p>
<p>Note that, for all global operations, only <code class="code freefem docutils literal highlight highlight-freefem"><span></span>int[int]</code> and
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>real[int]</code> are data type take in account in
<strong>``FreeFem++``</strong>.</p>
</div>
</div>
<div class="section" id="hpddm-solvers">
<h3>HPDDM solvers<a class="headerlink" href="#hpddm-solvers" title="Permalink to this headline">¶</a></h3>
<p>Real valued problems (diffusion, heat, elasticity and Stokes) and
complex valued problems (Maxwell and Helmholtz) are given in both 2D and
3D. We detail here the 3D elasticity problem and the 3D time-dependent
heat problem.</p>
<p>!!!example “Elasticity 3D” A three dimensional elasticity problem is
defined. The solver is a domain decomposition method. Domain
decomposition methods are a natural framework for parallel computers.
The scripts run on multicores computers (from 2 to tens of thousands of
cores). Recall that like in any MPI code the number of MPI processes,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>mpisize</code>, is given in the command line via the option
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>-np</code>. We focus on the script
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Elasticity3D.edp</code> but the other scripts have the same
structure. The command line to run the example on four processes with
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>ffglut</code> visualization is:
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>ff-mpirun -np 4 Elasticity3D.edp -glut ffglut</code></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>```freefem
load &quot;hpddm&quot; //load HPDDM plugin
macro partitioner()metis//metis, scotch, or parmetis
macro dimension()3//2D or 3D
macro vectorialfe()P1//
include &quot;macro_ddm.idp&quot; //additional DDM functions

// Macro
macro def(i)[i, i#B, i#C] //vector field definition
macro init(i)[i, i, i] //vector field initialization

real Sqrt = sqrt(2.0);
macro epsilon(u) [dx(u), dy(u#B), dz(u#C),
    (dz(u#B) + dy(u#C)) / Sqrt,
    (dz(u) + dx(u#C)) / Sqrt,
    (dy(u) + dx(u#B)) / Sqrt] //
macro div(u) (dx(u) + dy(u#B) + dz(u#C)) //

// Parameters
real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11; // steel
real poisson = 0.35;

func Pk = [vectorialfe, vectorialfe, vectorialfe];

string deflation = getARGV(&quot;-deflation&quot;, &quot;geneo&quot;); //coarse space construction
int overlap = getARGV(&quot;-overlap&quot;, 1); //geometric overlap between subdomains
int fakeInterface = getARGV(&quot;-interface&quot;, 10); //interface between subdomains
int s = getARGV(&quot;-split&quot;, 1); //refinement factor
int p = getARGV(&quot;-hpddm_master_p&quot;, 1);

mpiComm comm;
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV(&quot;-hpddm_master_topology&quot;, 0), exclude = (usedARGV(&quot;-hpddm_master_exclude&quot;) != -1));

// Display
if (verbosity &gt; 0 &amp;&amp; mpirank == 0){
    cout &lt;&lt; &quot; --- &quot; &lt;&lt; mpirank &lt;&lt; &quot;/&quot; &lt;&lt; mpisize;
    cout &lt;&lt; &quot; - Elasticity3D.edp - input parameters: refinement factor = &quot; &lt;&lt; s &lt;&lt; &quot; - overlap = &quot; &lt;&lt; overlap &lt;&lt; endl;
}

// Mesh
int[int] LL = [2, 3, 2, 1, 2, 2];
meshN ThBorder, Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk); //local finite element space

int[int] arrayIntersection; //ranks of neighboring subdomains
int[int][int] restrictionIntersection(0); //local-to-neighbors renumbering
real[int] D; //partition of unity
{
    meshN ThGlobal = cube(10*getARGV(&quot;-global&quot;, 5), getARGV(&quot;-global&quot;, 5), getARGV(&quot;-global&quot;, 5), [10*x, y, z], label=LL); //global mesh
    build(Th, ThBorder, ThGlobal, fakeInterface, s, overlap, D, arrayIntersection, restrictionIntersection, Wh, Pk, comm, excluded, 3)
}

// Problem
real tmp = 1.0 + poisson;
real mu = Young / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
real[int] rhs; //local right-hand side
matrix&lt;real&gt; Mat; //local operator
{ //local weak form
    meshN ThAugmented = Th + ThBorder;
    varf vPb (def(u), def(v))
        = intN(ThAugmented)(
              lambda * div(u) * div(v)
            + 2.0 * mu * (epsilon(u)&#39; * epsilon(v))
        )
        + intN(ThAugmented)(
              f * vC
        )
        + on(1, u=0.0, uB=0.0, uC=0.0)
        ;

    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv=-1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv=-1);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = cube(1, 1, 1, [x, y, z]);

dschwarz A(Mat, arrayIntersection, restrictionIntersection, scaling = D);

set(A, sparams = &quot;-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction balanced -hpddm_variant right -hpddm_verbosity 1 -hpddm_geneo_nu 10&quot;);

matrix&lt;real&gt; Opt; //local operator with optimized boundary conditions
dpair ret;
{
    int solver = getOption(&quot;schwarz_method&quot;);
    if (solver == 1 || solver == 2 || solver == 4){ //optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV(&quot;-kZero&quot;, 10.0);
        Ph transmission = 2 * kZero * mu * (2 * mu + lambda) / (lambda + 3 * mu);
        varf vOptimized (def(u), def(v))
            = intN(Th)(
                  lambda * div(u) * div(v)
                + 2.0 * mu * (epsilon(u)&#39; * epsilon(v))
            )
            + intN1(Th, fakeInterface)(
                  transmission * (def(u)&#39; * def(v))
            )
            + on(1, u=0.0, uB=0.0, uC=0.0)
            ;
        Opt = vOptimized(Wh, Wh, tgv=-1);
    }
    if (mpisize &gt; 1 &amp;&amp; isSetOption(&quot;schwarz_coarse_correction&quot;)){ //two-level Schwarz methods
        if(excluded)
            attachCoarseOperator(mpiCommWorld, A);
        else {
            varf vPbNoPen (def(u), def(v))
                = intN(Th)(
                      lambda * div(u) * div(v)
                    + 2.0 * mu * (epsilon(u)&#39; * epsilon(v))
                )
                + on(1, u=0.0, uB=0.0, uC=0.0)
                ;
            matrix&lt;real&gt; noPen = vPbNoPen(Wh, Wh, solver=CG);
            if(deflation == &quot;geneo&quot;) //standard GenEO, no need for RHS -&gt; deduced from LHS (Neumann matrix)
                attachCoarseOperator(mpiCommWorld, A, A=noPen, ret=ret);
            else if(deflation == &quot;dtn&quot;){
                varf vMass (def(u), def(v)) = intN1(Th, fakeInterface)(u * v);
                matrix&lt;real&gt; massMatrix = vMass(Wh, Wh, solver=CG);
                attachCoarseOperator(mpiCommWorld, A, A=noPen, B=massMatrix, pattern=Opt, ret=ret);
            }
            else if(deflation == &quot;geneo-2&quot;) //GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                attachCoarseOperator(mpiCommWorld, A, A=noPen, B=Opt, pattern=Opt, ret=ret);
        }
    }
}

// Solve
Wh&lt;real&gt; def(u); //local solution

if(Opt.n &gt; 0) //optimized Schwarz methods
    DDM(A, u[], rhs, excluded=excluded, ret=ret, O=Opt);
else
    u[] = A^-1 * rhs;

// Error
real[int] err(u[].n);
err = A * u[]; //global matrix-vector product
err -= rhs;

// Plot
plotMPI(Th, u[], &quot;Global solution&quot;, Pk, def, real, 3, 1)
plotMPI(Th, err, &quot;Global residual&quot;, Pk, def, real, 3, 1)
real alpha = 2000.0;
meshN ThMoved = movemesh3(Th, transfo = [x + alpha*u, y + alpha*uB, z + alpha*uC]);
u[] = mpirank;
plotMPI(ThMoved, u[], &quot;Global moved solution&quot;, Pk, def, real, 3, 1)
```

The macro `:::freefem build` is of particular interest since it handles the data distribution among the `:::freefem mpisize` MPI processes with the following steps:

* The initial mesh `:::freefem ThGlobal` is partitioned by process 0 into `:::freefem mpisize` submeshes

* The partition is broadcasted to every process $i$ for 0 &lt; $i$ &lt; `:::freefem mpisize`. From then on, all tasks are parallel.

* Each process creates the local submesh `:::freefem Th` (if the refinement factor `:::freefem s` defined via the option `:::freefem -split` is larger than 1, each local edge is splitted into $s$ subedges, resulting in each element being split into $s^2$ element in 2D and $s^3$ elements in 3D) so that the collection of these submeshes is an overlapping domain decomposition of a refined mesh. The number of extra layers added to the initial partition is monitored by the option `:::freefem -overlap`.

* Connectivity structures are created
    * `:::freefem D` is the diagonal of the local partition of unity (see [Distributed vectors in HPDDM](#distributed-vectors-in-hpddm for more details)
    * `:::freefem arrayIntersection` is the list of neighbors of the current subdomain
    * For `:::freefem j` in `:::freefem arrayIntersection`, `:::freefem restrictionIntersection[j]` is the list of the degrees of freedom that belong to the intersection of the current subdomain with its neighbor `:::freefem j`.

Then, the variational formulation `:::freefem vPb` of a three dimensional elasticity problem is used to assemble a local matrix `:::freefem Mat`. This matrix along with `:::freefem D`, `:::freefem arrayIntersection` and `:::freefem restrictionIntersection` are arguments for the constructor of the distributed matrix `:::freefem A`. This is enough to solve the problem with a one-level additive Schwarz method which can be either ASM or RAS.

For some problems it is interesting to use optimized interface conditions. When there are many subdomains, it is usually profitable to add a second level to the solver. Options are set in the sequel of the script:

```freefem
set(A, sparams=&quot;-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction balanced -hpddm_variant right -hpddm_verbosity 1 -hpddm_geneo_nu 10&quot;);
```

In the above line, the first option selects the one-level preconditioner `:::freefem ras` (possible choices are `:::freefem ras`, `:::freefem oras`, `:::freefem soras`, `:::freefem asm`, `:::freefem osm` or `:::freefem none`), the second option selects the correction formula for the second level here `:::freefem balanced` (possible options are `:::freefem deflated`, `:::freefem additive` or `:::freefem balanced`), the third option selects right preconditioning, the fourth one is verbosity level of HPDDM (different from the one of __`FreeFem++`__), the fifth one prints all possible options of HPPDM and the last one specifies the number of coarse degrees of freedom per subdomain of the GENEO coarse space. All other options of [HPDDM library](https://github.com/hpddm/hpddm/blob/master/doc/cheatsheet.pdf) can be selected via the __`FreeFem++`__ function `:::freefem set`.

In the last part of the script, the global linear system is solved by the domain decomposition method defined above.

```freefem
// Solve
Wh&lt;real&gt; def(u); //local solution

if(Opt.n &gt; 0) //optimized Schwarz methods
    DDM(A, u[], rhs, excluded=excluded, ret=ret, O=Opt);
else
    u[] = A^-1 * rhs;
```
</pre></div>
</div>
</div>
<div class="section" id="time-dependent-problem">
<h3>Time dependent problem<a class="headerlink" href="#time-dependent-problem" title="Permalink to this headline">¶</a></h3>
<p>!!!example “Heat 3D” A three dimensional heat problem</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>\[
\frac{\partial u}{\partial t} - \Delta u = 1,\ \ \ u(0,\cdot) := 0 \text{ in }\Omega\,.
\]

is discretized by an implicit Euler scheme. At each time step $n$, we shall seek $u^n(x,y,z)$ satisfying for all $w\in H^1(\Omega)$:

\[
\int_\Omega \frac{u^n-u^{n-1}}{\delta t}\,w + \nabla u^n \nabla w = \int_\Omega w ,\ \ \ u^0 := 0 \text{ in }\Omega\,.
\]

so that at each time step a linear system

\[
(M+dt*K) u^n[] = M*u^{n-1}[] + \delta t*F
\]

is solved by a domain decomposition method where $M$ is the mass matrix and $K$ is the rigidity matrix. In order to save computational efforts, the domain decomposition method preconditioner is built only once and then reused for all subsequent solves with matrix $A:=M+dt*K$. The distributed matrix vector product with matrix $M$ is made through the call to the function `:::freefem dmv` using the partition of unity associated to matrix $A$.

```freefem
load &quot;hpddm&quot; //load HPDDM plugin
macro partitioner()metis//metis, scotch, or parmetis
macro dimension()3//2D or 3D
include &quot;macro_ddm.idp&quot; //additional DDM functions

// Macro
macro def(i)i //scalar field definition
macro init(i)i //scalar field initialization
macro grad(u) [dx(u), dy(u), dz(u)] //three-dimensional gradient

// Parameters
func Pk = P2; //finite element space

string deflation = getARGV(&quot;-deflation&quot;, &quot;geneo&quot;); //coarse space construction
int overlap = getARGV(&quot;-overlap&quot;, 1); //geometric overlap between subdomains
int fakeInterface = getARGV(&quot;-interface&quot;, 10); //interface between subdomains
int s = getARGV(&quot;-split&quot;, 1); //refinement factor
real dt = getARGV(&quot;-dt&quot;, 0.01); //time step
int iMax = getARGV(&quot;-iMax&quot;, 10); //number of iterations

mpiComm comm;
int p = getARGV(&quot;-hpddm_master_p&quot;, 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV(&quot;-hpddm_master_topology&quot;, 0), exclude = (usedARGV(&quot;-hpddm_master_exclude&quot;) != -1));

// Display
if (verbosity &gt; 0 &amp;&amp; mpirank == 0){
    cout &lt;&lt; &quot; --- &quot; &lt;&lt; mpirank &lt;&lt; &quot;/&quot; &lt;&lt; mpisize;
    cout &lt;&lt; &quot; - Heat3D.edp - input parameters: refinement factor = &quot; &lt;&lt; s &lt;&lt; &quot; - overlap = &quot; &lt;&lt; overlap &lt;&lt; endl;
}

// Mesh
int[int] LL = [1, 2, 1, 1, 1, 1];
meshN ThBorder, Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk); //local finite element space
int[int] arrayIntersection; //ranks of neighboring subdomains
int[int][int] restrictionIntersection(0); //local-to-neighbors renumbering
real[int] D; //partition of unity
{
    meshN ThGlobal = cube(getARGV(&quot;-global&quot;, 10), getARGV(&quot;-global&quot;, 10), getARGV(&quot;-global&quot;, 10), [x, y, z], label=LL); //global mesh
    build(Th, ThBorder, ThGlobal, fakeInterface, s, overlap, D, arrayIntersection, restrictionIntersection, Wh, Pk, comm, excluded)
}

// Problem
real[int] rhs; // local right-hand side
matrix&lt;real&gt; Mat; //local operator
matrix&lt;real&gt; M; //local mass matrix
{ //local weak form
    meshN ThAugmented = Th + ThBorder;
    varf vPb (u, v)
        = intN(ThAugmented)(
              u * v
            + dt * (grad(u)&#39; * grad(v))
        )
        + intN(ThAugmented)(
              dt * v
        )
        + on(1, u=0.0)
        ;
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv=-1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv=-1);
    matrix R = interpolate(Wh, WhAugmented);
    varf vPbM (u, v) = intN(ThAugmented)(u * v);
    M = vPbM(WhAugmented, WhAugmented);
    renumbering(M, R, rhsFull, rhs);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = cube(1, 1, 1, [x, y, z]);

dschwarz A(Mat, arrayIntersection, restrictionIntersection, scaling=D);

matrix&lt;real&gt; Opt; //local operator with optimized boundary conditions
dpair ret;
{
    int solver = getOption(&quot;schwarz_method&quot;);
    if (solver == 1 || solver == 2 || solver == 4){ //optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV(&quot;-kZero&quot;, 10.0);
        Ph transmission = kZero;
        varf vOptimized (u, v)
            = intN(Th)(
                  u * v
                + dt * (grad(u)&#39; * grad(v))
            )
            + intN1(Th, fakeInterface)(
                  transmission * (u * v)
            )
            + on(1, u=0.0)
            ;
        Opt = vOptimized(Wh, Wh, tgv=-1);
    }
    if (mpisize &gt; 1 &amp;&amp; isSetOption(&quot;schwarz_coarse_correction&quot;)){ //two-level Schwarz methods
        if(excluded)
            attachCoarseOperator(mpiCommWorld, A);
        else {
            varf vPbNoPen (u, v)
                = intN(Th)(
                      u * v
                    + dt * (grad(u)&#39; * grad(v))
                )
                + on(1, u=0.0)
                ;
            matrix&lt;real&gt; noPen = vPbNoPen(Wh, Wh, solver=CG);
            if(deflation == &quot;geneo&quot;) //standard GenEO, no need for RHS -&gt; deduced from LHS (Neumann matrix)
                attachCoarseOperator(mpiCommWorld, A, A=noPen, ret = ret);
            else if(deflation == &quot;dtn&quot;) {
                varf vMass (def(u), def(v)) = intN1(Th, fakeInterface)(u * v);
                matrix&lt;real&gt; massMatrix = vMass(Wh, Wh, solver=CG);
                attachCoarseOperator(mpiCommWorld, A, A=noPen, B=massMatrix, pattern=Opt, ret=ret);
            }
            else if(deflation == &quot;geneo-2&quot;) //GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                attachCoarseOperator(mpiCommWorld, A, A=noPen, B=Opt, pattern=Opt, ret=ret);
        }
    }
}

// Solve
set(A, sparams=&quot;-hpddm_reuse_preconditioner=1&quot;);
Wh&lt;real&gt; def(u) = init(0.0); //local solution
for (int i = 0; i &lt; iMax; ++i){
    real[int] newRhs(rhs.n);
    dmv(A, M, u[], newRhs); //newRhs = M * u[]
    newRhs += rhs;

    if (Opt.n &gt; 0) //optimized Schwarz methods
        DDM(A, u[], newRhs, excluded=excluded, ret=ret, O=Opt);
    else
        u[] = A^-1 * newRhs;

    plotMPI(Th, u[], &quot;Global solution&quot;, Pk, def, real, 3, 0)
}
```
</pre></div>
</div>
</div>
<div class="section" id="distributed-vectors-in-hpddm">
<h3>Distributed vectors in HPDDM<a class="headerlink" href="#distributed-vectors-in-hpddm" title="Permalink to this headline">¶</a></h3>
<p>We give here some hints on the way vectors are distributed among
<span class="math notranslate nohighlight">\(np\)</span> processes when using <strong>``FreeFem++``</strong> interfaced with HPDDM.
The set of degrees of freedom <span class="math notranslate nohighlight">\({\mathcal N}\)</span> is decomposed into
<span class="math notranslate nohighlight">\(np\)</span> overlapping sets <span class="math notranslate nohighlight">\(({\mathcal N}_i)_{1\le i\le np}\)</span>.</p>
<p>A MPI-process is in charge of each subset. Let <span class="math notranslate nohighlight">\(n:=\#{\mathcal N}\)</span>
be the number of degrees of freedom of the global finite element space.
Let <span class="math notranslate nohighlight">\(R_i\)</span> denote the restriction operator from <span class="math notranslate nohighlight">\(\R^n\)</span> onto
<span class="math notranslate nohighlight">\(\R^{\#{\mathcal N}_i}\)</span>. We have also defined local diagonal
matrices
<span class="math notranslate nohighlight">\(D_i\in \R^{\#{\mathcal N}_i}\times \R^{\#{\mathcal N}_i}\)</span> so that
we have a partition of unity at the algebraic level:</p>
<div class="math notranslate nohighlight" id="equation-eq-hpddm-14">
<span class="eqno">(31)<a class="headerlink" href="#equation-eq-hpddm-14" title="Permalink to this equation">¶</a></span>\[{\mathbf U} = \sum_{i=1}^{np} R_i^T\,D_i\,R_i\,{\mathbf U}\ \ \ \ \forall\ {\mathbf U}\in\R^n\,.\]</div>
<p>A global vector <span class="math notranslate nohighlight">\({\mathbf U}\in\R^n\)</span> is actually not stored.
Rather, it is stored in a distributed way. Each process <span class="math notranslate nohighlight">\(i\)</span>,
<span class="math notranslate nohighlight">\(1\le i\le N\)</span>, stores the local vector
<span class="math notranslate nohighlight">\({\mathbf U}_i:=R_i {\mathbf U}\in \R^{\#{\mathcal N}_i}\)</span>.</p>
<p>It is important to ensure that the result of all linear algebra
operators applied to this representation are coherent.</p>
<p>As an example, consider the scalar product of two distributed vectors
<span class="math notranslate nohighlight">\({\mathbf U}, {\mathbf V} \in \mathbb{R}^{n}\)</span>. Using the partition
of unity <a href="#id1"><span class="problematic" id="id2">:raw-latex:`\eqref{eq:hpddm:14}`</span></a>, we have:</p>
<p><a href="#id3"><span class="problematic" id="id4">:raw-latex:`\begin{align*}({\mathbf U}, {\mathbf V}) = \left({\mathbf U}, \sum_{i=1}^{np} R_i^T D_i R_i {\mathbf V}\right) &amp;= \sum_{i=1}^{np} (R_i {\mathbf U}, D_i R_i {\mathbf V})\\
&amp;=\sum_{i=1}^{np} \left({\mathbf U}_i, D_i {\mathbf V}_i\right)\,.
\end{align*}`</span></a></p>
<p>Thus, the formula for the scalar product is:</p>
<p><a href="#id5"><span class="problematic" id="id6">:raw-latex:`\begin{equation*}
({\mathbf U}, {\mathbf V}) = \sum_{i = 1}^{np} (R_i {\mathbf U}, D_i R_i {\mathbf V})\,.
\end{equation*}`</span></a></p>
<p>Local scalar products are performed concurrently. Thus, the
implementation is parallel except for the sum which corresponds to a
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>MPI_Reduce</code> call across the <span class="math notranslate nohighlight">\(np\)</span> MPI processes. Note
also that the implementation relies on the knowledge of a partition of
unity so that the FreeFem++ syntax is <code class="code freefem docutils literal highlight highlight-freefem"><span></span>dscalprod(D, u, v)</code>.</p>
<p>A <code class="code freefem docutils literal highlight highlight-freefem"><span></span>axpy</code> procedure <span class="math notranslate nohighlight">\(y \leftarrow \alpha\,x+y\)</span> for
<span class="math notranslate nohighlight">\(x,y\in \mathbb{R}^{n}\)</span> and <span class="math notranslate nohighlight">\(\alpha\in\R\)</span> is easily
implemented concurrently for distributed vectors in the form:</p>
<div class="math notranslate nohighlight">
\[y_i \leftarrow \alpha\,x_i+y_i\,, \forall\ 1\le i \le np\,.\]</div>
<p>The matrix vector product is more involved and details are given in the
SIAM book <a class="reference external" href="https://www.ljll.math.upmc.fr/nataf/OT144DoleanJolivetNataf_full.pdf">An Introduction to Domain Decomposition Methods: algorithms,
theory and parallel
implementation</a>
and even more details are given in <a class="reference external" href="http://jolivet.perso.enseeiht.fr/thesis.pdf">P. Jolivet’s PhD
manuscrit</a>.</p>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>[KARYPIS1995] KARYPIS, George et KUMAR, Vipin. METIS–unstructured graph
partitioning and sparse matrix ordering system, version 2.0. 1995.</p>
<p>[CAI1989] CAI, Xiao-Chuan. Some domain decomposition algorithms for
nonselfadjoint elliptic and parabolic partial differential equations.
1989.</p>
<p>[SAAD2003] SAAD, Yousef. Iterative methods for sparse linear systems.
siam, 2003.</p>
<p>[SMITH1996] SMITH, B. P. Bj rstad and W. Gropp, Domain Decomposition.
1996.</p>
</div>
</div>


        </div>
        <div class="side-doc-outline">
            <div class="side-doc-outline--content"> 
<div class="localtoc">
    <p class="caption">
      <span class="caption-text">Table Of Contents</span>
    </p>
    <ul>
<li><a class="reference internal" href="#">Parallelization</a><ul>
<li><a class="reference internal" href="#mpi">MPI</a><ul>
<li><a class="reference internal" href="#mpi-keywords">MPI Keywords</a></li>
<li><a class="reference internal" href="#mpi-constants">MPI Constants</a></li>
<li><a class="reference internal" href="#mpi-constructor">MPI Constructor</a></li>
<li><a class="reference internal" href="#mpi-functions">MPI Functions</a></li>
<li><a class="reference internal" href="#mpi-communicator-operator">MPI Communicator operator</a></li>
<li><a class="reference internal" href="#schwarz-example-in-parallel">Schwarz example in parallel</a><ul>
<li><a class="reference internal" href="#true-parallel-schwarz-example">True parallel Schwarz example</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#parallel-sparse-solvers">Parallel sparse solvers</a><ul>
<li><a class="reference internal" href="#using-parallel-sparse-solvers-in-freefem">Using parallel sparse solvers in <strong>FreeFem++</strong></a></li>
<li><a class="reference internal" href="#sparse-direct-solver">Sparse direct solver</a><ul>
<li><a class="reference internal" href="#mumps-solver">MUMPS solver</a></li>
<li><a class="reference internal" href="#superlu-distributed-solver">SuperLU distributed solver</a></li>
<li><a class="reference internal" href="#pastix-solver">PaStiX solver</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parallel-sparse-iterative-solver">Parallel sparse iterative solver</a><ul>
<li><a class="reference internal" href="#parms-solver">pARMS solver</a></li>
<li><a class="reference internal" href="#interfacing-with-hips">Interfacing with HIPS</a></li>
<li><a class="reference internal" href="#interfacing-with-hypre">Interfacing with HYPRE</a></li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#domain-decomposition">Domain decomposition</a><ul>
<li><a class="reference internal" href="#communicators-and-groups">Communicators and groups</a></li>
<li><a class="reference internal" href="#process">Process</a></li>
<li><a class="reference internal" href="#points-to-points-communicators">Points to Points communicators</a></li>
<li><a class="reference internal" href="#global-operations">Global operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hpddm-solvers">HPDDM solvers</a></li>
<li><a class="reference internal" href="#time-dependent-problem">Time dependent problem</a></li>
<li><a class="reference internal" href="#distributed-vectors-in-hpddm">Distributed vectors in HPDDM</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

</div>
            </div>
        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
     <a id="button-prev" href="algorithmsOptimization.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="P">
         <i class="pagenation-arrow-L material-icons">arrow_back</i>
         <div class="pagenation-text">
            <span class="pagenation-direction">Previous</span>
            <div>Algorithms & Optimization</div>
         </div>
     </a>
     <a id="button-next" href="plugins.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="N">
        <i class="pagenation-arrow-R material-icons">arrow_forward</i>
        <div class="pagenation-text">
            <span class="pagenation-direction">Next</span>
            <div>Plugins</div>
        </div>
     </a>
  </div>
        <footer class="mdl-mini-footer">
    <div class="mdl-mini-footer__left-section">
      <div class="mdl-logo">FreeFem++</div>
      <div>
        
        <p class="caption"><span class="caption-text">Table of contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Language references</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model/index.html">Mathematical Models</a></li>
</ul>

      </div>
    </div>

    <div class="mdl-mini-footer__right-section">
        <div>&copy; Copyright 2018, FreeFem++.</div>
      <div>Generated by <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.3 using <a href="https://github.com/myyasuda/sphinx_materialdesign_theme">sphinx_materialdesign_theme</a>.</div>
    </div>
</footer>
        </main>
    </div>
  </body>
</html>