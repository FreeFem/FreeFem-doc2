<!DOCTYPE html>

<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>ffddm documentation</title>
		<link rel="icon" href="../../_static/img/favicon.png">

		<!--Let browser know website is optimized for mobile-->
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>

		<!-- Google font -->
		<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">

		<!-- FreeFem++ theme specific -->
		<link rel="stylesheet" type="text/css" href="../../_static/css/freefemtheme.css" />

		<!-- css -->
		<link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

		<!-- js -->
		<script src="../../_static/nav.json"></script>
		<script src="../../_static/js/nav.js"></script>
		<script src="../../_static/js/common.js"></script>

		<!-- MathJax -->
		<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>

		<!-- Font Awesome -->
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
	</head>
	<body>
		<header>
			<div class="header-logo">
    <div>
        <a href="../../introduction/introduction.html">
            <img alt="logo" title="FreeFem++ documentation" src="../../_static/img/Logo.png" />
        </a>
    </div>
</div>
<div class="header-title">
    <div>
        <a href="../../introduction/introduction.html">
            <h2>FreeFem++ documentation</h2>
        </a>
    </div>
</div>
<div class="header-github">
    <a href="https://github.com/FreeFem/FreeFem-sources">
        <div class="header-github-img">
            <img alt="GitHub" title="FreeFem++ on GitHub" src="../../_static/img/GitHub-Mark-120px-plus.png" />
        </div>
        <div class="header-github-title">
            <div class="header-github-title-text">
                FreeFem++ on GitHub
            </div>
            <div class="header-github-title-stars">
                <span id="headerGithubStars"></span> stars - <span id="headerGithubForks"></span> forks
            </div>
        </div>
    </a>
</div>
<script src="../../_static/js/github.js"></script>
		</header>
		
		<nav>
			<script>nav("../../")</script>
			<div class="search">
				<script async src="../../_static/js/lunr.js"></script>
<script async src="../../_static/lunr_index.js"></script>

<script src="../../_static/js/search.js"></script>

<div class="search">
    <input type="search" id="searchInput" placeholder="Search..." oninput="search(this.value);" />
    <div class="searchResults">
        <div id="resultCount">
        </div>
        <div id="searchResults">
        </div>
    </div>
</div>
			</div>
		</nav>
		

		
		<div class="container">
			<div class="toc" id="toc">
				<div>
					<ul>
<li><a class="reference internal" href="#">ffddm documentation</a><ul>
<li><a class="reference internal" href="#minimal-example">Minimal example</a></li>
<li><a class="reference internal" href="#overlapping-mesh-decomposition">Overlapping mesh decomposition</a></li>
<li><a class="reference internal" href="#local-finite-element-spaces">Local finite element spaces</a></li>
<li><a class="reference internal" href="#define-the-problem-to-solve">Define the problem to solve</a></li>
<li><a class="reference internal" href="#one-level-preconditioners">One level preconditioners</a></li>
<li><a class="reference internal" href="#two-level-preconditioners">Two level preconditioners</a><ul>
<li><a class="reference internal" href="#building-the-geneo-coarse-space">Building the GenEO coarse space</a></li>
<li><a class="reference internal" href="#building-the-coarse-space-from-a-coarse-mesh">Building the coarse space from a coarse mesh</a></li>
</ul>
</li>
<li><a class="reference internal" href="#solving-the-linear-system">Solving the linear system</a></li>
<li><a class="reference internal" href="#using-hpddm-within-ffddm">Using <em>HPDDM</em> within <em>ffddm</em></a></li>
</ul>
</li>
</ul>

				</div>
			</div>
			<div class="content">
				<div>
					
    <div class="section" id="ffddm-documentation">
<span id="ffddmdocumentation"></span><h1>ffddm documentation<a class="headerlink" href="#ffddm-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="minimal-example">
<h2>Minimal example<a class="headerlink" href="#minimal-example" title="Permalink to this headline">¶</a></h2>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="kt">macro</span> <span class="n">dimension</span> <span class="mi">3</span><span class="c1">// EOM            // 2D or 3D</span>

<span class="cp">include</span> <span class="s">&quot;ffddm.idp&quot;</span>

<span class="kt">int</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="n">LL</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">mesh3</span> <span class="n">ThGlobal</span> <span class="o">=</span> <span class="nf">cube</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="kr">x</span><span class="p">,</span> <span class="kr">y</span><span class="p">,</span> <span class="kr">z</span><span class="p">],</span> <span class="kr">label</span> <span class="o">=</span> <span class="n">LL</span><span class="p">);</span>      <span class="c1">// global mesh</span>

<span class="kt">macro</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="p">[</span><span class="nf">dx</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="nf">dy</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="nf">dz</span><span class="p">(</span><span class="n">u</span><span class="p">)]</span><span class="c1">// EOM    // three-dimensional gradient</span>

<span class="kt">macro</span> <span class="n">Varf</span><span class="p">(</span><span class="n">varfName</span><span class="p">,</span> <span class="n">meshName</span><span class="p">,</span> <span class="n">VhName</span><span class="p">)</span>
    <span class="kt">varf</span> <span class="n">varfName</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nf">int3d</span><span class="p">(</span><span class="n">meshName</span><span class="p">)(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">&#39;&#39;*</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">+</span> <span class="nf">int3d</span><span class="p">(</span><span class="n">meshName</span><span class="p">)(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="nf">on</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="c1">// EOM</span>

<span class="c1">// Domain decomposition</span>
<span class="n">ffddmbuildDmesh</span><span class="p">(</span> <span class="n">Lap</span> <span class="p">,</span> <span class="n">ThGlobal</span> <span class="p">,</span> <span class="kr">mpiCommWorld</span> <span class="p">)</span>

<span class="kt">macro</span> <span class="n">def</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="n">i</span><span class="c1">// EOM                         // scalar field definition</span>
<span class="kt">macro</span> <span class="kp">init</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="n">i</span><span class="c1">// EOM                        // scalar field initialization</span>
<span class="n">ffddmbuildDfespace</span><span class="p">(</span> <span class="n">Lap</span> <span class="p">,</span> <span class="n">Lap</span> <span class="p">,</span> <span class="kt">real</span> <span class="p">,</span> <span class="n">def</span> <span class="p">,</span> <span class="kp">init</span> <span class="p">,</span> <span class="nc">P1</span> <span class="p">)</span>

<span class="n">ffddmsetupOperator</span><span class="p">(</span> <span class="n">Lap</span> <span class="p">,</span><span class="n">Lap</span> <span class="p">,</span> <span class="n">Varf</span> <span class="p">)</span>

<span class="kt">real</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="n">rhsi</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">ffddmbuildrhs</span><span class="p">(</span> <span class="n">Lap</span> <span class="p">,</span> <span class="n">Varf</span> <span class="p">,</span> <span class="n">rhsi</span> <span class="p">)</span>

<span class="n">LapVhi</span> <span class="n">def</span><span class="p">(</span><span class="n">ui</span><span class="p">);</span>

<span class="c1">//Direct solve</span>
<span class="n">ui</span><span class="p">[]</span> <span class="o">=</span> <span class="n">Lapdirectsolve</span><span class="p">(</span><span class="n">rhsi</span><span class="p">);</span>

<span class="n">Lapwritesummary</span>

<span class="nf">ffddmplot</span><span class="p">(</span><span class="n">Lap</span><span class="p">,</span><span class="n">ui</span><span class="p">,</span><span class="s">&quot;u&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="overlapping-mesh-decomposition">
<span id="ffddmdocumentationoverlappingmeshdecomposition"></span><h2>Overlapping mesh decomposition<a class="headerlink" href="#overlapping-mesh-decomposition" title="Permalink to this headline">¶</a></h2>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="n">ffddmbuildDmesh</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span><span class="n">Th</span><span class="p">,</span><span class="n">comm</span><span class="p">)</span>
</pre></div>
</div>
<p>decomposes the mesh <strong>Th</strong> into overlapping submeshes.
The mesh will be distributed over the mpi ranks of communicator <strong>comm</strong>.
This will create and expose variables whose names will be prefixed by <strong>pr</strong>, see below (# is the concatenation operator).
The way the initial mesh <strong>Th</strong> is partitioned depends on the value of <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmpartitioner</span></a>.</p>
<p>The size of the overlap between subdomains (its width in terms of number of mesh elements) is given by <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmoverlap</span></a>.</p>
<p>The level of refinement of the resulting submeshes with respect to the input mesh <strong>Th</strong> is given by <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmsplit</span></a>.</p>
<p>If <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmexclude</span></a> <span class="math notranslate nohighlight">\(\neq 0\)</span>, the first <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmpCS</span></a> mpi ranks of <strong>comm</strong> will be excluded from the spatial domain decomposition, in order to dedicate them later to the coarse problem (for two-level preconditioners).</p>
<p>The label of the new border of the submeshes (the interface between the subdomains) is given by <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddminterfacelabel</span></a>.</p>
<p><strong>defines</strong>:</p>
<ul class="simple">
<li><code class="docutils literal highlight highlight-default"><span></span><span class="nb">int</span> <span class="n">pr</span><span class="c1">#npart</span></code> number of subdomains for this decomposition; should be equal to mpiSize(<strong>comm</strong>) - <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmexclude</span></a> * <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmpCS</span></a></li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">meshN</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="n">pr</span><span class="c1">#aTh</span></code> array (size <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#npart</span></code>) of local meshes of the subdomains.
In the standard parallel case, only the local mesh for this mpi rank <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aTh[mpiRank(pr#commddm)]</span></code> is defined (unless this mpi rank is excluded from the spatial domain decomposition, i.e. <code class="docutils literal highlight highlight-default"><span></span><span class="n">prmesh</span><span class="c1">#excluded</span></code> = 1, see below).
In the sequential case, all local meshes are defined.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">meshN</span> <span class="n">pr</span><span class="c1">#Thi</span></code> the local mesh of the subdomain for this mpi rank, i. e. <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aTh[mpiRank(pr#commddm)]</span></code> in the parallel case -  <code class="docutils literal highlight highlight-default"><span></span><span class="nb">int</span> <span class="n">pr</span><span class="c1">#numberIntersection</span></code> the number of neighbors for this mpi rank</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="nb">int</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="n">pr</span><span class="c1">#arrayIntersection</span></code> the list of neighbor ranks in <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#commddm</span></code> for this mpi rank</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="nb">int</span> <span class="n">pr</span><span class="c1">#pCS</span></code> equal to <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmpCS</span></a></li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="nb">int</span> <span class="n">pr</span><span class="c1">#exclude</span></code> equal to <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmexclude</span></a></li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="nb">int</span> <span class="n">pr</span><span class="c1">#excluded</span></code> <em>true</em> if <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmexclude</span></a> is <em>true</em> (<span class="math notranslate nohighlight">\(\neq 0\)</span>) and mpiRank(<strong>comm</strong>) &lt; <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#pCS</span></code>.
In this case, this mpi rank will be excluded from the spatial domain decomposition and will only work on the coarse problem.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">mpiComm</span> <span class="n">pr</span><span class="c1">#commddm</span></code> mpi communicator for ranks participating in the spatial domain decomposition (ranks 0 to <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#npart</span></code>-1 in <strong>comm</strong> if <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#exclude</span></code> is <em>false</em>, ranks <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#pCS</span></code> to <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#pCS</span></code>+<code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#npart</span></code>-1 otherwise)</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">mpiComm</span> <span class="n">pr</span><span class="c1">#commCS</span></code> mpi communicator for ranks participating in the assembly and resolution of the coarse problem for two-level preconditioners (ranks 0 to <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#pCS</span></code> - 1 in <strong>comm</strong>)</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">mpiComm</span> <span class="n">pr</span><span class="c1">#commself</span></code> self mpi communicator (this mpi rank only), used for factorizing local matrices</li>
</ul>
<!--
***For advanced users***:

- `int pr#binexactCS`
- `int pr#inexactCSsplit`
- `int pr#isincomm`
- `meshN[int] pr#aThborder`
--><dl class="docutils">
<dt><strong>Remark for sequential use</strong> (see <a class="reference internal" href="parameters.html#ffddmparameterscommandline"><span class="std std-ref">-seqddm</span></a>):</dt><dd><ul class="simple">
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">meshN</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="n">pr</span><span class="c1">#aTh</span></code> array (size <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#npart</span></code>) of local meshes of the subdomains</li>
</ul>
</dd>
</dl>
<!--
 int pr#binexactgeneoCS

fespace pr#VhiP1(pr#Thi,P1);

pr#VhiP1[int] pr#partitionIntersectionbasei(0);

meshN pr#Thglob = minimalMesh;

matrix[int] pr#RihP1(pr#npart);
pr#VhiP1[int] pr#DP1(pr#npart);

NewMacro pr#mpicomm()comm EndMacro

***depends on***:
- [ffddmpartitioner](parameters.md#global-parameters)
- [ffddmpCS](parameters.md#global-parameters)
- [ffddmexclude](parameters.md#global-parameters)
- [ffddmoverlap](parameters.md#global-parameters)
- [ffddmsplit](parameters.md#global-parameters)
- [ffddminterfacelabel](parameters.md#global-parameters)

***see also***:
--></div>
<div class="section" id="local-finite-element-spaces">
<span id="ffddmdocumentationlocalfiniteelementspaces"></span><h2>Local finite element spaces<a class="headerlink" href="#local-finite-element-spaces" title="Permalink to this headline">¶</a></h2>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="n">ffddmbuildDfespace</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span><span class="n">prmesh</span><span class="p">,</span><span class="n">scalar</span><span class="p">,</span><span class="n">def</span><span class="p">,</span><span class="kp">init</span><span class="p">,</span><span class="n">Pk</span><span class="p">)</span>
</pre></div>
</div>
<p>builds the local finite element spaces and associated distributed operators on top of the mesh decomposition <strong>prmesh</strong>.
This will create and expose variables whose names will be prefixed by <strong>pr</strong>, see below.
It is assumed that <a class="reference internal" href="#ffddmdocumentationoverlappingmeshdecomposition"><span class="std std-ref">ffddmbuildDmesh</span></a> has already been called with prefix <strong>prmesh</strong> in order to build the mesh decomposition.</p>
<p>The local finite element spaces of type <strong>Pk</strong> (where <strong>Pk</strong> is the type of finite element: P1, [P2,P2,P1], …) are defined on the local meshes of the subdomains based on the mesh decomposition previously created with prefix <strong>prmesh</strong>.</p>
<p><strong>scalar</strong> determines the type of data for this finite element: <em>real</em> or <em>complex</em>.</p>
<p>Two macros, <strong>def</strong> and <strong>init</strong>, are needed: <strong>def</strong> specifies how to define a finite element function in the finite element space <strong>Pk</strong>, and <strong>init</strong> specifies how to interpolate a scalar function onto the (possibly multiple) components of <strong>Pk</strong>. Two examples are given below:</p>
<p>For scalar P2 finite elements and complex-valued problems:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="kt">macro</span> <span class="n">def</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="n">u</span><span class="c1">// EOM</span>
<span class="kt">macro</span> <span class="kp">init</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="n">u</span><span class="c1">// EOM</span>
<span class="n">ffddmbuildDfespace</span><span class="p">(</span><span class="n">myFEprefix</span><span class="p">,</span><span class="n">mymeshprefix</span><span class="p">,</span><span class="kt">complex</span><span class="p">,</span><span class="n">def</span><span class="p">,</span><span class="kp">init</span><span class="p">,</span><span class="nc">P2</span><span class="p">)</span>
</pre></div>
</div>
<p>For vectorial [P2,P2,P1] finite elements and real-valued problems:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="kt">macro</span> <span class="n">def</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="o">#</span><span class="kp">B</span><span class="p">,</span> <span class="n">u</span><span class="o">#</span><span class="n">C</span><span class="p">]</span><span class="c1">// EOM</span>
<span class="kt">macro</span> <span class="kp">init</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span><span class="c1">// EOM</span>
<span class="n">ffddmbuildDfespace</span><span class="p">(</span><span class="n">myFEprefix</span><span class="p">,</span><span class="n">mymeshprefix</span><span class="p">,</span><span class="kt">real</span><span class="p">,</span><span class="n">def</span><span class="p">,</span><span class="kp">init</span><span class="p">,[</span><span class="nc">P2</span><span class="p">,</span><span class="nc">P2</span><span class="p">,</span><span class="nc">P1</span><span class="p">])</span>
</pre></div>
</div>
<p>In practice, this builds the necessary distributed operators associated to the finite element space: the local partition of unity functions <span class="math notranslate nohighlight">\((D_i)_{i=1,...,N}\)</span> (see <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Dk</span></code> and <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Dih</span></code> below) as well as the function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#update</span></code> (see below) which synchronizes local vectors <span class="math notranslate nohighlight">\((u_i)_{i=1,...,N}\)</span> between neighboring subdomains, performing the equivalent of <span class="math notranslate nohighlight">\(u_i = R_i (\sum_{j=1}^N R_j^T u_j)\)</span> or <span class="math notranslate nohighlight">\(u_i = R_i (\sum_{j=1}^N R_j^T D_j u_j)\)</span> in a distributed parallel environment.</p>
<p><code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#scalprod</span></code> (see below) performs the parallel scalar product for vectors defined on this finite element.</p>
<p><strong>defines</strong>:</p>
<ul class="simple">
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prmesh</span></code> macro, saves the parent prefix <strong>prmesh</strong> of the mesh decomposition</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#K</span></code> macro, saves the type of data <strong>scalar</strong> for this finite element space (<em>real</em> or <em>complex</em>)</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">func</span> <span class="n">pr</span><span class="c1">#fPk</span></code> saves the type of finite element <strong>Pk</strong>, e.g.&nbsp;<em>P1, [P2,P2,P1], …</em></li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">fespace</span> <span class="n">pr</span><span class="c1">#Vhi</span></code> the local finite element space for this mpi rank, defined on the local mesh <code class="docutils literal highlight highlight-default"><span></span><span class="n">prmesh</span><span class="c1">#Thi</span></code></li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="nb">int</span> <span class="n">pr</span><span class="c1">#Ndofglobal</span></code> the total number of degrees of freedom <span class="math notranslate nohighlight">\(n\)</span> for this finite element discretization</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#mdef</span></code> macro, saves the macro <strong>def</strong> giving the definition of a finite element function in the finite element space <strong>Pk</strong></li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#minit</span></code> macro, saves the macro <strong>init</strong> specifying how to interpolate a scalar function onto the (possibly multiple) components of a finite element function of <strong>Pk</strong>.
This is used to create the local partition of unity function in <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Vhi</span></code>, by interpolating the local P1 partition of unity function onto the components of <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Vhi</span></code>.
For non Lagrange finite element spaces (e.g.&nbsp;<em>RT0</em>, <em>Edge03d</em>, …), see <a class="reference internal" href="#ffddmdocumentationlocalfiniteelementspaces"><span class="std std-ref">ffddmbuildDfespaceEdge</span></a>.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#K[int][int] pr#Dk</span></code> array (size <code class="docutils literal highlight highlight-default"><span></span><span class="n">prmesh</span><span class="c1">#npart</span></code>) of local partition of unity vectors in the subdomains, equivalent to <span class="math notranslate nohighlight">\((D_i)_{i=1,...,N}\)</span>.
In the standard parallel case, only the local partition of unity vector for this mpi rank <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Dk[mpiRank(prmesh#commddm)]</span></code> is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. <code class="docutils literal highlight highlight-default"><span></span><span class="n">prmesh</span><span class="c1">#excluded</span></code> = 1).
In the sequential case, all local partition of unity vectors are defined.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">pr</span><span class="c1">#K&gt;[int] pr#Dih</span></code> array (size <code class="docutils literal highlight highlight-default"><span></span><span class="n">prmesh</span><span class="c1">#npart</span></code>) similar to <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Dk</span></code> but in <em>matrix</em> form, allowing for easier <em>matrix</em>-<em>matrix</em> multiplications.
<code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Dih[i]</span></code> is a diagonal matrix, with the diagonal equal to <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Dk[i]</span></code>.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">fespace</span> <span class="n">pr</span><span class="c1">#Vhglob</span></code> the global finite element space defined on the global mesh <code class="docutils literal highlight highlight-default"><span></span><span class="n">prmesh</span><span class="c1">#Thglob</span></code>.
Defined only if <a class="reference internal" href="parameters.html#ffddmparameterscommandline"><span class="std std-ref">-noGlob</span></a> is not used.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">pr</span><span class="c1">#K&gt;[int] pr#Rih</span></code> array (size <code class="docutils literal highlight highlight-default"><span></span><span class="n">prmesh</span><span class="c1">#npart</span></code>) of restriction matrices from the global finite element space to the local finite element spaces on the local submeshes of the subdomains.
In the standard parallel case, only the restriction matrix for this mpi rank <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Rih[mpiRank(prmesh#commddm)]</span></code> is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. <code class="docutils literal highlight highlight-default"><span></span><span class="n">prmesh</span><span class="c1">#excluded</span></code> = 1).
In the sequential case, all restriction matrices are defined. The restriction matrices <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Rih</span></code> are defined only if <a class="reference internal" href="parameters.html#ffddmparameterscommandline"><span class="std std-ref">-noGlob</span></a> is not used.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">func</span> <span class="nb">int</span> <span class="n">pr</span><span class="c1">#update(scalar[int] ui, bool scale)</span></code> The function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#update</span></code> synchronizes the local vector <em>ui</em> between subdomains by exchanging the values of <em>ui</em> shared with neighboring subdomains (in the overlap region) using point-to-point MPI communications.
If <em>scale</em> is <em>true</em>, <em>ui</em> is multiplied by the local partition of unity beforehand.
This is equivalent to <span class="math notranslate nohighlight">\(u_i = R_i (\sum_{j=1}^N R_j^T u_j)\)</span> when <em>scale</em> is <em>false</em> and <span class="math notranslate nohighlight">\(u_i = R_i (\sum_{j=1}^N R_j^T D_j u_j)\)</span> when <em>scale</em> is <em>true</em>.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">func</span> <span class="n">scalar</span> <span class="n">pr</span><span class="c1">#scalprod(scalar[int] ai, scalar[int] bi)</span></code> The function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#scalprod</span></code> computes the global scalar product of two vectors whose local restriction to the subdomain of this mpi rank are <em>ai</em> and <em>bi</em>.
The result is computed as <span class="math notranslate nohighlight">\(\sum_{j=1}^N (D_j a_j, b_j)\)</span>.</li>
</ul>
<!--
***Remark:***


***For advanced users***:

matrix<pr#K>[int] pr#restrictionIntersection(0);

NewMacro pr#mdefpart udefpart EndMacro

NewMacro pr#minitpart uinitpart EndMacro

func pr#fPkP0 = mPkP0;

pr#K[int][int] pr#rcv(0);
pr#K[int][int] pr#snd(0);

***depends on***:

***see also***:

- **[`ffddmbuildDfespaceEdge`](#local-finite-element-spaces)**
--></div>
<div class="section" id="define-the-problem-to-solve">
<span id="ffddmdocumentationdefineproblemtosolve"></span><h2>Define the problem to solve<a class="headerlink" href="#define-the-problem-to-solve" title="Permalink to this headline">¶</a></h2>
<div class="code freefem highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ffddmsetupOperator</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span><span class="n">prfe</span><span class="p">,</span><span class="n">Varf</span><span class="p">)</span>
</pre></div>
</div>
<p>builds the distributed operator associated to the variational problem given by <strong>Varf</strong>, on top of the distributed finite element space <strong>prfe</strong>.
This will create and expose variables whose names will be prefixed by <strong>pr</strong>, see below.
It is assumed that <a class="reference internal" href="#ffddmdocumentationlocalfiniteelementspaces"><span class="std std-ref">ffddmbuildDfespace</span></a> has already been called with prefix <strong>prfe</strong> in order to define the distributed finite element space.</p>
<p>In practice, this builds the so-called local ‘Dirichlet’ matrices <span class="math notranslate nohighlight">\(A_i = R_i A R_i^T\)</span>, the restrictions of the global operator <span class="math notranslate nohighlight">\(A\)</span> to the subdomains (see <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aRd</span></code>below).
The matrices correspond to the discretization of the bilinear form given by the macro <strong>Varf</strong>, which represents the abstract variational form of the problem.
These matrices are then used to implement the action of the global operator <span class="math notranslate nohighlight">\(A\)</span> on a local vector (the parallel matrix-vector product with <span class="math notranslate nohighlight">\(A\)</span>), see <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#A</span></code> below.</p>
<p>At this point, we already have the necessary data to be able to solve the problem with a parallel direct solver (<em>MUMPS</em>), which is the purpose of the function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#directsolve</span></code> (see below).
See <a class="reference internal" href="#ffddmdocumentationdefineproblemtosolve"><span class="std std-ref">ffddmbuildrhs</span></a> for building the right-hand side.</p>
<p>The macro <strong>Varf</strong> is required to have three parameters: the name of the variational form, the mesh, and the finite element space.
The variational form given in this ‘abstract’ format will then be used by <em>ffddm</em> to assemble the discrete operators by setting the appropriate mesh and finite element space as parameters.
An example is given below:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="kt">macro</span> <span class="nf">myVarf</span><span class="p">(</span><span class="n">varfName</span><span class="p">,</span> <span class="n">meshName</span><span class="p">,</span> <span class="n">VhName</span><span class="p">)</span>
    <span class="kt">varf</span> <span class="n">varfName</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nf">int3d</span><span class="p">(</span><span class="n">meshName</span><span class="p">)(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">&#39;&#39;*</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">+</span> <span class="nf">on</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="c1">// EOM</span>

<span class="n">ffddmsetupOperator</span><span class="p">(</span><span class="n">myprefix</span><span class="p">,</span><span class="n">myFEprefix</span><span class="p">,</span><span class="n">myVarf</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Remark</strong> In this simple example, the third parameter <em>VhName</em> is not used.
However, for more complex cases such as non-linear or time dependent problems where the problem depends on a solution computed at a previous step, it is useful to know for which discrete finite element space the variational form is being used.
See for example TODO</p>
<p><strong>defines</strong>:</p>
<ul class="simple">
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prfe</span></code> macro, saves the parent prefix <strong>prfe</strong> of the finite element space</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="nb">int</span> <span class="n">pr</span><span class="c1">#verbosity</span></code> the level of verbosity for this problem, initialized with the value of <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmverbosity</span></a></li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#writesummary</span></code> macro, prints a summary of timings for this problem, such as the time spent to assemble local matrices or solve the linear system.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">prfe</span><span class="c1">#K&gt; pr#Aglobal</span></code> the global matrix <span class="math notranslate nohighlight">\(A\)</span> corresponding to the discretization of the variational form given by the macro <strong>Varf</strong> on the global finite element space <code class="docutils literal highlight highlight-default"><span></span><span class="n">prfe</span><span class="c1">#Vhglob</span></code>.
Defined only in the sequential case.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">prfe</span><span class="c1">#K&gt;[int] pr#aRd</span></code> array (size <code class="docutils literal highlight highlight-default"><span></span><span class="n">prfe</span><span class="c1">#prmesh#npart</span></code>) of so-called local ‘Dirichlet’ matrices in the subdomains; these are the restrictions of the global operator to the subdomains, equivalent to <span class="math notranslate nohighlight">\(A_i = R_i A R_i^T\)</span> with <span class="math notranslate nohighlight">\(A\)</span> the global matrix corresponding to the discretization of the variational form given by the macro <strong>Varf</strong> on the global finite element space.
In the standard parallel case, only the local matrix for this mpi rank <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aRd[mpiRank(prmesh#commddm)]</span></code> is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. <code class="docutils literal highlight highlight-default"><span></span><span class="n">prmesh</span><span class="c1">#excluded</span></code> = 1).
In the sequential case, all local matrices are defined.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">func</span> <span class="n">prfe</span><span class="c1">#K[int] pr#A(prfe#K[int] &amp;ui)</span></code> The function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#A</span></code> computes the parallel matrix-vector product, i.e.&nbsp;the action of the global operator <span class="math notranslate nohighlight">\(A\)</span> on the local vector <span class="math notranslate nohighlight">\(u_i\)</span>.
The computation is equivalent to <span class="math notranslate nohighlight">\(R_i (\sum_{j=1}^N R_j^T D_j A_j u_j)\)</span> and is performed in parallel using local matrices <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aRd</span></code> and the function <code class="docutils literal highlight highlight-default"><span></span><span class="n">prfe</span><span class="c1">#update</span></code>.
In the sequential case, the global matrix <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Aglobal</span></code> is used instead.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">func</span> <span class="n">prfe</span><span class="c1">#K[int] pr#directsolve(prfe#K[int]&amp; rhsi)</span></code> The function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#directsolve</span></code> allows to solve the linear system <span class="math notranslate nohighlight">\(A x = b\)</span> in parallel using the parallel direct solver <em>MUMPS</em>.
The matrix is given to <em>MUMPS</em> in distributed form through the local matrices <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aRd</span></code>.
The input <em>rhsi</em> is given as a distributed vector (<em>rhsi</em> is the restriction of the global right-hand side <span class="math notranslate nohighlight">\(b\)</span> to the subdomain of this mpi rank, see <a class="reference internal" href="#ffddmdocumentationdefineproblemtosolve"><span class="std std-ref">ffddmbuildrhs</span></a>) and the returned vector is local as well.</li>
</ul>
<!--
NewMacro pr#plot(u,s)

***For advanced users***:

NewMacro pr#fromVhi(ui,VhName,res)

***depends on***:

- [ffddmverbosity](parameters.md#global-parameters)
--><hr class="docutils" />
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="n">ffddmbuildrhs</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span><span class="n">Varfrhs</span><span class="p">,</span><span class="n">rhs</span><span class="p">)</span>
</pre></div>
</div>
<p>builds the right-hand side associated to the variational form given by <strong>Varfrhs</strong> for the problem corresponding to prefix <strong>pr</strong>.
The resulting right-hand side vector <strong>rhs</strong> corresponds to the discretization of the abstract linear form given by the macro <strong>Varfrhs</strong> (see <a class="reference internal" href="#ffddmdocumentationdefineproblemtosolve"><span class="std std-ref">ffddmsetupOperator</span></a> for more details on how to define the abstract variational form as a macro).</p>
<p>The input vector <strong>rhs</strong> is resized and contains the resulting local right-hand side <span class="math notranslate nohighlight">\(R_i b\)</span>, the restriction of the global right-hand side <span class="math notranslate nohighlight">\(b\)</span> to the subdomain of this mpi rank.
In the sequential case, the global right-hand side vector <span class="math notranslate nohighlight">\(b\)</span> is assembled instead.</p>
<p>An example is given below:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="kt">macro</span> <span class="nf">myVarfrhs</span><span class="p">(</span><span class="n">varfName</span><span class="p">,</span> <span class="n">meshName</span><span class="p">,</span> <span class="n">VhName</span><span class="p">)</span>
    <span class="kt">varf</span> <span class="n">varfName</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">intN</span><span class="p">(</span><span class="n">meshName</span><span class="p">)(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="nf">on</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="c1">// EOM</span>

<span class="kt">real</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="n">rhsi</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">ffddmbuildrhs</span><span class="p">(</span><span class="n">myprefix</span><span class="p">,</span><span class="n">myVarfrhs</span><span class="p">,</span><span class="n">rhsi</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="one-level-preconditioners">
<span id="ffddmdocumentationonelevelpreconditioners"></span><h2>One level preconditioners<a class="headerlink" href="#one-level-preconditioners" title="Permalink to this headline">¶</a></h2>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="n">ffddmsetupPrecond</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span><span class="n">VarfPrec</span><span class="p">)</span>
</pre></div>
</div>
<p>builds the one level preconditioner for problem <strong>pr</strong>.
This will create and expose variables whose names will be prefixed by <strong>pr</strong>, see below.
It is assumed that <a class="reference internal" href="#ffddmdocumentationdefineproblemtosolve"><span class="std std-ref">ffddmsetupOperator</span></a> has already been called with prefix <strong>pr</strong> in order to define the problem to solve.</p>
<p>In practice, this builds and performs the factorization of the local matrices used in the one level preconditioner.
The local matrices depend on the choice of <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmprecond</span></a> and <strong>VarfPrec</strong>, see <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aR</span></code>below.</p>
<p><strong>defines</strong>:</p>
<ul class="simple">
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">string</span> <span class="n">pr</span><span class="c1">#prec</span></code> equal to <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmprecond</span></a>.
Sets the type of one level preconditioner <span class="math notranslate nohighlight">\(M^{-1}_1\)</span> to be used: “asm” (<em>Additive Schwarz</em>), “ras” (<em>Restricted Additive Schwarz</em>), “oras” (<em>Optimized Restricted Additive Schwarz</em>), “soras” (<em>Symmetric Optimized Restricted Additive Schwarz</em>) or “none” (no preconditioner).</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">pr</span><span class="c1">#prfe#K&gt;[int] pr#aR</span></code> array (size <code class="docutils literal highlight highlight-default"><span></span><span class="n">prfe</span><span class="c1">#prmesh#npart</span></code>) of local matrices used for the one level preconditioner.
Each mpi rank of the spatial domain decomposition performs the <span class="math notranslate nohighlight">\(LU\)</span> (or <span class="math notranslate nohighlight">\(LDL^T\)</span>) factorization of the local matrix corresponding to its subdomain using the direct solver <em>MUMPS</em>.<ul>
<li>If <strong>VarfPrec</strong> is not a previously defined macro (just put <em>null</em> for example), the matrices <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aR</span></code> are set to be equal to the so-called local ‘Dirichlet’ matrices <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aRd</span></code> (see <a class="reference internal" href="#ffddmdocumentationdefineproblemtosolve"><span class="std std-ref">ffddmsetupOperator</span></a>).
This is for the classical ASM preconditioner <span class="math notranslate nohighlight">\(M^{-1}_1 = M^{-1}_{\text{ASM}} = \sum_{i=1}^N R_i^T A_i^{-1} R_i\)</span> or classical RAS preconditioner <span class="math notranslate nohighlight">\(M^{-1}_1 = M^{-1}_{\text{RAS}} = \sum_{i=1}^N R_i^T D_i A_i^{-1} R_i\)</span> (it is assumed that <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmprecond</span></a> is equal to “asm” or “ras”).</li>
<li>If <strong>VarfPrec</strong> is a macro, it is assumed that <strong>VarfPrec</strong> defines an abstract bilinear form (see <a class="reference internal" href="#ffddmdocumentationdefineproblemtosolve"><span class="std std-ref">ffddmsetupOperator</span></a> for more details on how to define the abstract variational form as a macro).<ul>
<li>If <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmprecond</span></a> is equal to “asm” or “ras”, the matrices <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aR</span></code> will be assembled as local ‘Dirichlet’ matrices in the same manner as <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aRd</span></code>, but using the bilinear form defined by <strong>VarfPrec</strong> instead.
This defines the ASM preconditioner as <span class="math notranslate nohighlight">\(M^{-1}_1 = M^{-1}_{\text{ASM}} = \sum_{i=1}^N R_i^T {(A_i^{\text{Prec}})}^{-1} R_i\)</span> and the RAS preconditioner as <span class="math notranslate nohighlight">\(M^{-1}_1 = M^{-1}_{\text{RAS}} = \sum_{i=1}^N R_i^T D_i {(A_i^{\text{Prec}})}^{-1} R_i\)</span>, where <span class="math notranslate nohighlight">\(A_i^{\text{Prec}} = R_i A^{\text{Prec}} R_i^T\)</span>.</li>
<li>If <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmprecond</span></a> is equal to “oras” or “soras”, the matrices <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aR</span></code> will correspond to the discretization of the variational form <strong>VarfPrec</strong> in the subdomains <span class="math notranslate nohighlight">\(\Omega_i\)</span>.
In particular, various boundary conditions can be imposed at the interface between subdomains (corresponding to mesh boundary of label <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddminterfacelabel</span></a> set by the parent call to <a class="reference internal" href="#ffddmdocumentationoverlappingmeshdecomposition"><span class="std std-ref">ffddmbuildDmesh</span></a>), such as Optimized Robin boundary conditions.
We note the ORAS preconditioner as <span class="math notranslate nohighlight">\(M^{-1}_1 = M^{-1}_{\text{ORAS}} = \sum_{i=1}^N R_i^T D_i {(B_i^{\text{Prec}})}^{-1} R_i\)</span> and the SORAS preconditioner as <span class="math notranslate nohighlight">\(M^{-1}_1 = M^{-1}_{\text{SORAS}} = \sum_{i=1}^N R_i^T D_i {(B_i^{\text{Prec}})}^{-1} D_i R_i\)</span>.</li>
</ul>
</li>
</ul>
</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">func</span> <span class="n">pr</span><span class="c1">#prfe#K[int] pr#PREC1(pr#prfe#K[int] &amp;ui)</span></code> The function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#PREC1</span></code> computes the parallel application of the one level preconditioner <span class="math notranslate nohighlight">\(M^{-1}_1\)</span>, i.e.&nbsp;the action of <span class="math notranslate nohighlight">\(M^{-1}_1\)</span> on the local vector <span class="math notranslate nohighlight">\(u_i\)</span>.
In the sequential case, it computes the action of <span class="math notranslate nohighlight">\(M^{-1}_1\)</span> on a global vector.
The action of the inverse of local matrices <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aRd</span></code> is computed by forward-backward substitution using their <span class="math notranslate nohighlight">\(LU\)</span> (or <span class="math notranslate nohighlight">\(LDL^T\)</span>) decomposition.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">func</span> <span class="n">pr</span><span class="c1">#prfe#K[int] pr#PREC(pr#prfe#K[int] &amp;ui)</span></code> The function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#PREC</span></code> corresponds to the action of the preconditioner <span class="math notranslate nohighlight">\(M^{-1}\)</span> for problem <strong>pr</strong>.
It coincides with the one level preconditioner <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#PREC1</span></code> after the call to <a class="reference internal" href="#ffddmdocumentationonelevelpreconditioners"><span class="std std-ref">ffddmsetupPrecond</span></a>.
If a second level is subsequently added (see the next section about <a class="reference internal" href="#ffddmdocumentationtwolevelpreconditioners"><span class="std std-ref">Two level preconditioners</span></a>), it will then coincide with the two level preconditioner <span class="math notranslate nohighlight">\(M^{-1}_2\)</span> (see <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#PREC2level</span></code>).</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">func</span> <span class="n">pr</span><span class="c1">#prfe#K[int] pr#fGMRES(pr#prfe#K[int]&amp; x0i, pr#prfe#K[int]&amp; bi, real eps, int nbiter, string sprec)</span></code> The function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#fGMRES</span></code> allows to solve the linear system <span class="math notranslate nohighlight">\(A x = b\)</span> in parallel using the flexible GMRES method preconditioned by <span class="math notranslate nohighlight">\(M^{-1}\)</span>.
The action of the global operator <span class="math notranslate nohighlight">\(A\)</span> is given by <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#A</span></code>, the action of the preconditioner <span class="math notranslate nohighlight">\(M^{-1}\)</span> is given by <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#PREC</span></code> and the scalar products are computed by <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#scalprod</span></code>.
More details are given in the section <a class="reference internal" href="#ffddmdocumentationsolvinglinearsystem"><span class="std std-ref">Solving the linear system</span></a>.</li>
</ul>
<!--
***For advanced users***:

NewMacro pr#localmacroaug pr#prfe#prmesh#buildAug EndMacro
IFMACRO(pr#localmacroaug,1)
matrix<pr#prfe#K> pr#CSinterp;
ENDIFMACRO
--></div>
<div class="section" id="two-level-preconditioners">
<span id="ffddmdocumentationtwolevelpreconditioners"></span><h2>Two level preconditioners<a class="headerlink" href="#two-level-preconditioners" title="Permalink to this headline">¶</a></h2>
<p>The main ingredient of a two level preconditioner is the so-called ‘coarse space’ matrix <span class="math notranslate nohighlight">\(Z\)</span>.</p>
<p><span class="math notranslate nohighlight">\(Z\)</span> is a rectangular matrix of size <span class="math notranslate nohighlight">\(n \times n_c\)</span>, where usually <span class="math notranslate nohighlight">\(n_c \ll n\)</span>.</p>
<p><span class="math notranslate nohighlight">\(Z\)</span> is used to build the ‘coarse space operator’ <span class="math notranslate nohighlight">\(E = Z^T A Z\)</span>, a square matrix of size <span class="math notranslate nohighlight">\(n_c \times n_c\)</span>.
We can then define the ‘coarse space correction operator’ <span class="math notranslate nohighlight">\(Q = Z E^{-1} Z^T = Z (Z^T A Z)^{-1} Z^T\)</span>, which can then be used to enrich the one level preconditioner through a correction formula.
The simplest one is the <em>additive</em> coarse correction: <span class="math notranslate nohighlight">\(M^{-1}_2 = M^{-1}_1 + Q\)</span>.
See <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#corr</span></code> below for all other available correction formulas.</p>
<p>There are multiple ways to define a relevant coarse space <span class="math notranslate nohighlight">\(Z\)</span> for different classes of problems.
<a class="reference internal" href="#ffddmdocumentationbuildinggeneocoarsespace"><span class="std std-ref">ffddmgeneosetup</span></a> defines a coarse space correction operator by building the GenEO coarse space, while <a class="reference internal" href="#ffddmdocumentationbuildingcoarsespacefromcoarsemesh"><span class="std std-ref">ffddmcoarsemeshsetup</span></a> builds the coarse space using a coarse mesh.</p>
<p>After a call to either <a class="reference internal" href="#ffddmdocumentationbuildinggeneocoarsespace"><span class="std std-ref">ffddmgeneosetup</span></a> or <a class="reference internal" href="#ffddmdocumentationbuildingcoarsespacefromcoarsemesh"><span class="std std-ref">ffddmcoarsemeshsetup</span></a>, the following variables and functions are set up:</p>
<ul class="simple">
<li><code class="docutils literal highlight highlight-default"><span></span><span class="nb">int</span> <span class="n">pr</span><span class="c1">#ncoarsespace</span></code> the size of the coarse space <span class="math notranslate nohighlight">\(n_c\)</span>.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">string</span> <span class="n">pr</span><span class="c1">#corr</span></code> initialized with the value of <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmcorrection</span></a>.
Specifies the type of coarse correction formula to use for the two level preconditioner.
The possible values are:</li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{llllll}
\nonumber
    &amp;&amp;\text{&quot;AD&quot;}:&amp;&amp;\textit{Additive}, \quad &amp;M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1\phantom{ (I - A Q)} + Q\\
    &amp;&amp;\text{&quot;BNN&quot;}:&amp;&amp;\textit{Balancing Neumann-Neumann}, \quad &amp;M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1 (I - A Q) + Q\\
    &amp;&amp;\text{&quot;ADEF1&quot;}:&amp;&amp;\textit{Adapted Deflation Variant 1}, \quad &amp;M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1 (I - A Q) + Q\\
    &amp;&amp;\text{&quot;ADEF2&quot;}:&amp;&amp;\textit{Adapted Deflation Variant 2}, \quad &amp;M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1\phantom{ (I - A Q)} + Q\\
    &amp;&amp;\text{&quot;RBNN1&quot;}:&amp;&amp;\textit{Reduced Balancing Variant 1}, \quad &amp;M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1 (I - A Q)\\
    &amp;&amp;\text{&quot;RBNN2&quot;}:&amp;&amp;\textit{Reduced Balancing Variant 2}, \quad &amp;M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1\phantom{ (I - A Q)}\\
    &amp;&amp;\text{&quot;none&quot;}:&amp;&amp;\textit{no coarse correction}, \quad &amp;M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1\phantom{ (I - A Q)}\\
\end{array}\end{split}\]</div>
<ul class="simple">
<li>Note that <em>AD</em>, <em>ADEF1</em> and <em>RBNN2</em> only require one application of <span class="math notranslate nohighlight">\(Q\)</span>, while <em>BNN</em>, <em>ADEF2</em> and <em>RBNN1</em> require two.
The default coarse correction is <em>ADEF1</em>, which is cheaper and generally as robust as <em>BNN</em> or <em>ADEF2</em>.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">func</span> <span class="n">pr</span><span class="c1">#prfe#K[int] pr#Q(pr#prfe#K[int] &amp;ui)</span></code> The function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Q</span></code> computes the parallel application of the coarse correction operator <span class="math notranslate nohighlight">\(Q\)</span>, i.e.&nbsp;the action of <span class="math notranslate nohighlight">\(Q = Z E^{-1} Z^T\)</span> on the local vector <span class="math notranslate nohighlight">\(u_i\)</span>.
In the sequential case, it computes the action of <span class="math notranslate nohighlight">\(Q\)</span> on a global vector.
The implementation differs depending on the method used to build the coarse space (with GenEO or using a coarse mesh), but the idea is the same: the action of the transpose of the distributed operator <span class="math notranslate nohighlight">\(Z\)</span> on the distributed vector <span class="math notranslate nohighlight">\(u_i\)</span> is computed in parallel, with the contribution of all subdomains being gathered in a vector of size <span class="math notranslate nohighlight">\(n_c\)</span> in the mpi process of rank 0.
The action of the inverse of the coarse space operator <span class="math notranslate nohighlight">\(E\)</span> is then computed by forward-backward substitution using its <span class="math notranslate nohighlight">\(LU\)</span> (or <span class="math notranslate nohighlight">\(LDL^T\)</span>) decomposition previously computed by the first <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prfe#prmesh#pCS</span></code> ranks of the mpi communicator.
The result is then sent back to all subdomains to perform the last application of <span class="math notranslate nohighlight">\(Z\)</span> and obtain the resulting local vector in each subdomain.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">func</span> <span class="n">pr</span><span class="c1">#prfe#K[int] pr#PREC2level(pr#prfe#K[int] &amp;ui)</span></code> The function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#PREC2level</span></code> computes the parallel application of the two level preconditioner <span class="math notranslate nohighlight">\(M^{-1}_2\)</span>, i.e.&nbsp;the action of <span class="math notranslate nohighlight">\(M^{-1}_2\)</span> on the local vector <span class="math notranslate nohighlight">\(u_i\)</span>.
In the sequential case, it computes the action of <span class="math notranslate nohighlight">\(M^{-1}_2\)</span> on a global vector.
The two level preconditioner depends on the choice of the coarse correction formula which is determined by <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#corr</span></code>, see above.</li>
</ul>
<!--
***For advanced users***:

int pr#bCM = 0;
--><div class="section" id="building-the-geneo-coarse-space">
<span id="ffddmdocumentationbuildinggeneocoarsespace"></span><h3>Building the GenEO coarse space<a class="headerlink" href="#building-the-geneo-coarse-space" title="Permalink to this headline">¶</a></h3>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="n">ffddmgeneosetup</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span><span class="n">Varf</span><span class="p">)</span>
</pre></div>
</div>
<p>This builds the GenEO coarse space for problem <strong>pr</strong>.
This will create and expose variables whose names will be prefixed by <strong>pr</strong>, see below.
It is assumed that <a class="reference internal" href="#ffddmdocumentationonelevelpreconditioners"><span class="std std-ref">ffddmsetupPrecond</span></a> has already been called for prefix <strong>pr</strong> in order to define the one level preconditioner for problem <strong>pr</strong>.
The GenEO coarse space is <span class="math notranslate nohighlight">\(Z = (R_i^T D_i V_{i,k})^{i=1,...,N}_{\lambda_{i,k} \ge \tau}\)</span>, where <span class="math notranslate nohighlight">\(V_{i,k}\)</span> are eigenvectors corresponding to eigenvalues <span class="math notranslate nohighlight">\(\lambda_{i,k}\)</span> of the following local generalized eigenvalue problem in subdomain <span class="math notranslate nohighlight">\(i\)</span>:</p>
<p><span class="math notranslate nohighlight">\(D_i A_i D_i V_{i,k} = \lambda_{i,k} A_i^{\text{Neu}} V_{i,k}\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(A_i^{\text{Neu}}\)</span> is the local Neumann matrix of subdomain <span class="math notranslate nohighlight">\(i\)</span> (with Neumann boundary conditions at the subdomain interface).</p>
<p>In practice, this builds and factorizes the local Neumann matrices <span class="math notranslate nohighlight">\(A_i^{\text{Neu}}\)</span> corresponding to the abstract bilinear form given by the macro <strong>Varf</strong> (see <a class="reference internal" href="#ffddmdocumentationdefineproblemtosolve"><span class="std std-ref">ffddmsetupOperator</span></a> for more details on how to define the abstract variational form as a macro).
In the GenEO method, the abstract bilinear form <strong>Varf</strong> is assumed to be the same as the one used to define the problem <strong>pr</strong> through the previous call to <a class="reference internal" href="#ffddmdocumentationdefineproblemtosolve"><span class="std std-ref">ffddmsetupOperator</span></a>.
The local generalized eigenvalue problem is then solved in each subdomain to find the eigenvectors <span class="math notranslate nohighlight">\(V_{i,k}\)</span> corresponding to the largest eigenvalues <span class="math notranslate nohighlight">\(\lambda_{i,k}\)</span> (see <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Z</span></code> below).
The number of computed eigenvectors <span class="math notranslate nohighlight">\(\nu\)</span> is given by <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmnu</span></a>.
The eigenvectors selected to enter <span class="math notranslate nohighlight">\(Z\)</span> correspond to eigenvalues <span class="math notranslate nohighlight">\(\lambda_{i,k}\)</span> larger than <span class="math notranslate nohighlight">\(\tau\)</span>, where the threshold parameter <span class="math notranslate nohighlight">\(\tau\)</span> is given by <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmtau</span></a>.
If <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmtau</span></a> <span class="math notranslate nohighlight">\(= 0\)</span>, all <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmnu</span></a> eigenvectors are selected.
Finally, the coarse space operator <span class="math notranslate nohighlight">\(E = Z^T A Z\)</span> is assembled and factorized (see <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#E</span></code> below).</p>
<p><strong>defines</strong>:</p>
<ul class="simple">
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prfe#K[int][int] pr#Z</span></code> array of local eigenvectors <span class="math notranslate nohighlight">\(Z_{i,k} = D_i V_{i,k}\)</span> obtained by solving the local generalized eigenvalue problem above in the subdomain of this mpi rank using <em>Arpack</em>.
The number of computed eigenvectors <span class="math notranslate nohighlight">\(\nu\)</span> is given by <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmnu</span></a>.
The eigenvectors selected to enter <span class="math notranslate nohighlight">\(Z\)</span> correspond to eigenvalues <span class="math notranslate nohighlight">\(\lambda_{i,k}\)</span> larger than <span class="math notranslate nohighlight">\(\tau\)</span>, where the threshold parameter <span class="math notranslate nohighlight">\(\tau\)</span> is given by <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmtau</span></a>.
If <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmtau</span></a> <span class="math notranslate nohighlight">\(= 0\)</span>, all <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmnu</span></a> eigenvectors are selected.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">pr</span><span class="c1">#prfe#K&gt; pr#E</span></code> the coarse space operator <span class="math notranslate nohighlight">\(E = Z^T A Z\)</span>.
The matrix <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#E</span></code> is assembled in parallel and is factorized by the parallel direct solver <em>MUMPS</em> using the first <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prfe#prmesh#pCS</span></code> ranks of the mpi communicator, with mpi rank 0 as the master process.
The number of mpi processes dedicated to the coarse problem is set by the underlying mesh decomposition of problem <strong>pr</strong>, which also specifies if these mpi ranks are excluded from the spatial decomposition or not.
These parameters are set by <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmpCS</span></a> and <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmexclude</span></a> when calling <a class="reference internal" href="#ffddmdocumentationoverlappingmeshdecomposition"><span class="std std-ref">ffddmbuildDmesh</span></a> (see <a class="reference internal" href="#ffddmdocumentationoverlappingmeshdecomposition"><span class="std std-ref">ffddmbuildDmesh</span></a> for more details).</li>
</ul>
<!--
***For advanced users***:

int pr#si;

pr#sizelg(pr#prfe#prmesh#npart), pr#offseti(pr#prfe#prmesh#npart);

int[int] pr#sizelgworld(mpiSize(pr#prfe#prmesh#mpicomm)), pr#offsetiworld(mpiSize(pr#prfe#prmesh#mpicomm));

matrix<pr#prfe#K> pr#matN;
--></div>
<div class="section" id="building-the-coarse-space-from-a-coarse-mesh">
<span id="ffddmdocumentationbuildingcoarsespacefromcoarsemesh"></span><h3>Building the coarse space from a coarse mesh<a class="headerlink" href="#building-the-coarse-space-from-a-coarse-mesh" title="Permalink to this headline">¶</a></h3>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="n">ffddmcoarsemeshsetup</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span><span class="n">Thc</span><span class="p">,</span><span class="n">VarfEprec</span><span class="p">,</span><span class="n">VarfAprec</span><span class="p">)</span>
</pre></div>
</div>
<p>builds the coarse space for problem <strong>pr</strong> from a coarse problem which corresponds to the discretization of a variational form on a coarser mesh <strong>Thc</strong> of <span class="math notranslate nohighlight">\(\Omega\)</span>.
This will create and expose variables whose names will be prefixed by <strong>pr</strong>, see below.
It is assumed that <a class="reference internal" href="#ffddmdocumentationonelevelpreconditioners"><span class="std std-ref">ffddmsetupPrecond</span></a> has already been called for prefix <strong>pr</strong> in order to define the one level preconditioner for problem <strong>pr</strong>.
The abstract variational form for the coarse problem can differ from the original problem <strong>pr</strong> and is given by macro <strong>VarfEprec</strong> (see <a class="reference internal" href="#ffddmdocumentationdefineproblemtosolve"><span class="std std-ref">ffddmsetupOperator</span></a> for more details on how to define the abstract variational form as a macro).
For example, absorption can be added in the preconditioner for wave propagation problems, see examples for Helmholtz and Maxwell equations in the <a class="reference internal" href="examples.html#ffddmexamples"><span class="std std-ref">Examples</span></a> section.</p>
<p>The coarse space <span class="math notranslate nohighlight">\(Z\)</span> corresponds to the interpolation operator from the coarse finite element space to the original finite element space of the problem.
Thus, the coarse space operator <span class="math notranslate nohighlight">\(E = Z^T A^{\text{Eprec}} Z\)</span> corresponds to the matrix of the problem given by <strong>VarfEprec</strong> discretized on the coarse mesh <strong>Thc</strong> and is assembled as such.</p>
<p>Similarly, <strong>VarfAprec</strong> specifies the global operator involved in multiplicative coarse correction formulas.
For example, <span class="math notranslate nohighlight">\(M^{-1}_{2,\text{ADEF1}} = M^{-1}_1 (I - A^{\text{Aprec}} Q) + Q\)</span> (where <span class="math notranslate nohighlight">\(Q = Z E^{-1} Z^T\)</span>).
<span class="math notranslate nohighlight">\(A^{\text{Aprec}}\)</span> defaults to <span class="math notranslate nohighlight">\(A\)</span> if <strong>VarfAprec</strong> is not a valid macro (you can put <em>null</em> for example).</p>
<p><strong>defines</strong>:</p>
<ul class="simple">
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">meshN</span> <span class="n">pr</span><span class="c1">#ThCoarse</span></code> the coarse mesh <strong>Thc</strong></li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">fespace</span> <span class="n">pr</span><span class="c1">#VhCoarse</span></code> the coarse finite element space of type <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prfe#fPk</span></code> defined on the coarse mesh <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#ThCoarse</span></code></li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">pr</span><span class="c1">#prfe#K&gt; pr#AglobEprec</span></code> the global matrix <span class="math notranslate nohighlight">\(A^{\text{Aprec}}\)</span> corresponding to the discretization of the variational form given by the macro <strong>VarfAprec</strong> on the global finite element space <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prfe#Vhglob</span></code>.
Defined only in the sequential case.
<code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#AglobEprec</span></code> is equal to <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#Aglobal</span></code> if <strong>VarfAprec</strong> is not a valid macro.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">pr</span><span class="c1">#prfe#K&gt; pr#aRdEprec</span></code> the local ‘Dirichlet’ matrix corresponding to <strong>VarfAprec</strong>; it is the local restriction of the global operator <span class="math notranslate nohighlight">\(A^{\text{Aprec}}\)</span> to the subdomain, equivalent to <span class="math notranslate nohighlight">\(A^{\text{Aprec}}_i = R_i A^{\text{Aprec}} R_i^T\)</span> with <span class="math notranslate nohighlight">\(A^{\text{Aprec}}\)</span> the global matrix corresponding to the discretization of the variational form given by the macro <strong>VarfAprec</strong> on the global finite element space.
Defined only if this mpi rank is not excluded from the spatial domain decomposition, i. e. <code class="docutils literal highlight highlight-default"><span></span><span class="n">prmesh</span><span class="c1">#excluded</span></code> = 0.
<code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aRdEprec</span></code> is equal to <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aRd[mpiRank(prmesh#commddm)]</span></code> if <strong>VarfAprec</strong> is not a valid macro.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">func</span> <span class="n">pr</span><span class="c1">#prfe#K[int] pr#AEprec(pr#prfe#K[int] &amp;ui)</span></code> The function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#AEprec</span></code> computes the parallel matrix-vector product, i.e.&nbsp;the action of the global operator <span class="math notranslate nohighlight">\(A^{\text{Aprec}}\)</span> on the local vector <span class="math notranslate nohighlight">\(u_i\)</span>.
The computation is equivalent to <span class="math notranslate nohighlight">\(R_i (\sum_{j=1}^N R_j^T D_j A^{\text{Aprec}}_j u_j)\)</span> and is performed in parallel using local matrices <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#aRdEprec</span></code> and the function <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prfe#update</span></code>.
In the sequential case, the global matrix <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#AglobEprec</span></code> is used instead.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">pr</span><span class="c1">#prfe#K&gt; pr#ZCM</span></code> the interpolation operator <span class="math notranslate nohighlight">\(Z\)</span> from the coarse finite element space <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#VhCoarse</span></code> to the global finite element space <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prfe#Vhglob</span></code>.
Defined only in the sequential case.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">pr</span><span class="c1">#prfe#K&gt; pr#ZCMi</span></code> the local interpolation operator <span class="math notranslate nohighlight">\(Z_i\)</span> from the coarse finite element space <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#VhCoarse</span></code> to the local finite element space <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prfe#Vhi</span></code>.
Defined only if this mpi rank is not excluded from the spatial domain decomposition, i. e. <code class="docutils literal highlight highlight-default"><span></span><span class="n">prmesh</span><span class="c1">#excluded</span></code> = 0.
<code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#ZCMi</span></code> is used for the parallel application of <span class="math notranslate nohighlight">\(Z\)</span> and <span class="math notranslate nohighlight">\(Z^T\)</span>.</li>
<li><code class="docutils literal highlight highlight-default"><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">pr</span><span class="c1">#prfe#K&gt; pr#ECM</span></code> the coarse space operator <span class="math notranslate nohighlight">\(E = Z^T A^{\text{Eprec}} Z\)</span>.
The matrix <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#ECM</span></code> is assembled by discretizing the variational form given by <strong>VarfEprec</strong> on the coarse mesh and factorized by the parallel direct solver <em>MUMPS</em> using the first <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prfe#prmesh#pCS</span></code> ranks of the mpi communicator, with mpi rank 0 as the master process.
The number of mpi processes dedicated to the coarse problem is set by the underlying mesh decomposition of problem <strong>pr</strong>, which also specifies if these mpi ranks are excluded from the spatial decomposition or not.
These parameters are set by <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmpCS</span></a> and <a class="reference internal" href="parameters.html#ffddmparametersglobal"><span class="std std-ref">ffddmexclude</span></a> when calling <a class="reference internal" href="#ffddmdocumentationoverlappingmeshdecomposition"><span class="std std-ref">ffddmbuildDmesh</span></a> (see <a class="reference internal" href="#ffddmdocumentationoverlappingmeshdecomposition"><span class="std std-ref">ffddmbuildDmesh</span></a> for more details).</li>
</ul>
</div>
</div>
<div class="section" id="solving-the-linear-system">
<span id="ffddmdocumentationsolvinglinearsystem"></span><h2>Solving the linear system<a class="headerlink" href="#solving-the-linear-system" title="Permalink to this headline">¶</a></h2>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="kt">func</span> <span class="n">pr</span><span class="o">#</span><span class="n">prfe</span><span class="o">#</span><span class="n">K</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="n">pr</span><span class="o">#</span><span class="n">fGMRES</span><span class="p">(</span><span class="n">pr</span><span class="o">#</span><span class="n">prfe</span><span class="o">#</span><span class="n">K</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">&amp;</span> <span class="n">x0i</span><span class="p">,</span> <span class="n">pr</span><span class="o">#</span><span class="n">prfe</span><span class="o">#</span><span class="n">K</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">&amp;</span> <span class="n">bi</span><span class="p">,</span> <span class="kt">real</span> <span class="kp">eps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">itmax</span><span class="p">,</span> <span class="kt">string</span> <span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
<p>solves the linear system for problem <strong>pr</strong> using the flexible GMRES algorithm with preconditioner <span class="math notranslate nohighlight">\(M^{-1}\)</span> (corresponding to <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#PREC</span></code>).
Returns the local vector corresponding to the restriction of the solution to <code class="docutils literal highlight highlight-default"><span></span><span class="n">pr</span><span class="c1">#prfe#Vhi</span></code>.
<strong>x0i</strong> and <strong>bi</strong> are local distributed vectors corresponding respectively to the initial guess and the right-hand side (see <a class="reference internal" href="#ffddmdocumentationdefineproblemtosolve"><span class="std std-ref">ffddmbuildrhs</span></a>).
<strong>eps</strong> is the stopping criterion in terms of the relative decrease in residual norm.
If <strong>eps</strong> <span class="math notranslate nohighlight">\(&lt; 0\)</span>, the residual norm itself is used instead.
<strong>itmax</strong> sets the maximum number of iterations.
<strong>sp</strong> selects between the <code class="docutils literal highlight highlight-default"><span></span><span class="s2">&quot;left&quot;</span></code> or <code class="docutils literal highlight highlight-default"><span></span><span class="s2">&quot;right&quot;</span></code> preconditioning variants: <em>left</em> preconditioned GMRES solves <span class="math notranslate nohighlight">\(M^{-1} A x = M^{-1} b\)</span>, while <em>right</em> preconditioned GMRES solves <span class="math notranslate nohighlight">\(A M^{-1} y = b\)</span> for <span class="math notranslate nohighlight">\(y\)</span>, with <span class="math notranslate nohighlight">\(x = M^{-1} y\)</span>.</p>
</div>
<div class="section" id="using-hpddm-within-ffddm">
<span id="ffddmdocumentationhpddmffddm"></span><h2>Using <em>HPDDM</em> within <em>ffddm</em><a class="headerlink" href="#using-hpddm-within-ffddm" title="Permalink to this headline">¶</a></h2>
</div>
</div>


				</div>
			</div>
		</div>
		
		<footer>
			<script>
    let date = new Date()
    let currentYear = date.getFullYear()
</script>
<div class="footer-text">
    <a href="https://freefem.org/">FreeFem++</a> 1987-<script>document.write(currentYear)</script>
</div>
<div class="footer-img">
    <p>
        Made with <i class="fas fa-heart"></i> on
    </p>
    <span class="separator"></span>
    <a href="https://github.com/FreeFem">
        <img alt="Github" title="Github" src="../../_static/img/GitHub_Logo_White.png" />
    </a>
</div>
		</footer>
		

		<script src="../../_static/js/toc.js"></script>
	</body>
</html>