<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
    <title>Mesh Generation &#8212; FreeFem++ 3.61.2 documentation</title>

    <link rel="stylesheet" href="../_static/material-icons.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/extra.css" />
    <link rel="stylesheet" type="text/css" href="../_static/notosanscjkjp.css" />
    <link rel="stylesheet" type="text/css" href="../_static/roboto.css" />
    <link rel="stylesheet" type="text/css" href="../_static/material-design-lite-1.3.0/material.indigo-pink.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_materialdesign_theme.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/sphinx_materialdesign_theme.js"></script>
    <link rel="canonical" href="doc.freefem.org/dev/documentation/meshGeneration.html" />
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Finite element" href="finiteElement.html" />
    <link rel="prev" title="Notations" href="notations.html" /> 
  </head>
<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header mdl-layout--fixed-drawer"><header class="mdl-layout__header mdl-layout__header--waterfall ">
    <div class="mdl-layout__header-row">
        
        <nav class="mdl-navigation breadcrumb">
            <a class="mdl-navigation__link" href="index.html">Documentation</a><i class="material-icons">navigate_next</i>
            <a class="mdl-navigation__link is-active">Mesh Generation</a>
        </nav>
        <div class="mdl-layout-spacer"></div>
        <nav class="mdl-navigation">
        
<form class="form-inline pull-sm-right" action="../search.html" method="get">
      <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right">
        <label id="quick-search-icon" class="mdl-button mdl-js-button mdl-button--icon"  for="waterfall-exp">
            <i class="material-icons">search</i>
        </label>
        <div class="mdl-textfield__expandable-holder">
          <input class="mdl-textfield__input" type="text" name="q"  id="waterfall-exp" placeholder="Search" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </div>
      </div>
      <div class="mdl-tooltip" data-mdl-for="quick-search-icon">
      Quick search
      </div>
</form>
        
<a id="button-show-source"
    class="mdl-button mdl-js-button mdl-button--icon"
    href="../_sources/documentation/meshGeneration.rst.txt" rel="nofollow">
<i class="material-icons">code</i>
</a>
<div class="mdl-tooltip" data-mdl-for="button-show-source">
Show Source
</div>
        </nav>
    </div>
    <div class="mdl-layout__header-row header-links">
      <div class="mdl-layout-spacer"></div>
      <nav class="mdl-navigation">
      </nav>
    </div>
</header><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <span class="title-text">
                  FreeFem++
              </span>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <p class="caption"><span class="caption-text">Table of contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../introduction/introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/download.html">Download FreeFem++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/installation.html">Installation guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/contributing.html">Contributing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/citation.html">Citation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/authors.html">Authors</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="documentation.html">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="notations.html">Notations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Mesh Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="finiteElement.html">Finite element</a></li>
<li class="toctree-l2"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithmsOptimization.html">Algorithms &amp; Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallelization.html">Parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="plugins.html">Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="developers.html">Developers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Language references</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/reference.html">Language reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/globalVariables.html">Global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/quadratureFormulae.html">Quadrature formulae</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/operators.html">Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/loops.html">Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/IO.html">I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/externalLibraries.html">External libraries</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/tutorial.html">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/poisson.html">Solving Poisson’s equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/equationsClassification.html">Classification of partial differential equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/membrane.html">Membrane</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/heatExchanger.html">Heat Exchanger</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/acoustics.html">Acoustics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/thermalConduction.html">Thermal Conduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/fanBlade.html">Irrotational Fan Blade Flow and Thermal effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/rotatingHill.html">Pure Convection : The Rotating Hill</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/elasticity.html">The System of elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/stokes.html">The System of Stokes for Fluids</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/navierStokesProjection.html">A projection algorithm for the Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/navierStokesNewton.html">Newton Method for the Steady Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/aLargeFluidProblem.html">A Large Fluid Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/complexNumbers.html">An Example with Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/optimalControl.html">Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/flowWithShocks.html">A Flow with Shocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/heatEquationOptimization.html">Time dependent schema optimization for heat equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/timeDependentStokes.html">Tutorial to write a transient Stokes solver in matrix form</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/wifiPropagation.html">Wifi Propagation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/matlabOctavePlot.html">Plotting in Matlab and Octave</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../example/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model/index.html">Mathematical Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../model/model.html">Mathematical Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/staticProblems.html">Static problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/elasticity.html">Elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/nonLinearStaticProblems.html">Non-linear static problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/eigenValueProblems.html">Eigen value problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/evolutionProblems.html">Evolution problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/navierStokesEquations.html">Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/variationalInequality.html">Variational Inequality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/domainDecomposition.html">Domain decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/fluidStructureCoupledProblem.html">Fluid-structure coupled problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/transmissionProblem.html">Transmission problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/freeBoundaryProblem.html">Free boundary problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/nonLinearElasticity.html">Non-linear elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/compressibleNeoHookeanMaterials.html">Compressible Neo-Hookean materials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/whisperingGalleryModes.html">Whispering gallery modes</a></li>
</ul>
</li>
</ul>

            </nav>
        
        </div>
    
</header>
        <main class="mdl-layout__content" tabIndex="0">
<header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <span class="title-text">
                  FreeFem++
              </span>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <p class="caption"><span class="caption-text">Table of contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../introduction/introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/download.html">Download FreeFem++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/installation.html">Installation guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/contributing.html">Contributing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/citation.html">Citation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/authors.html">Authors</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="documentation.html">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="notations.html">Notations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Mesh Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="finiteElement.html">Finite element</a></li>
<li class="toctree-l2"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithmsOptimization.html">Algorithms &amp; Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallelization.html">Parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="plugins.html">Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="developers.html">Developers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Language references</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/reference.html">Language reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/globalVariables.html">Global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/quadratureFormulae.html">Quadrature formulae</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/operators.html">Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/loops.html">Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/IO.html">I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/externalLibraries.html">External libraries</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/tutorial.html">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/poisson.html">Solving Poisson’s equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/equationsClassification.html">Classification of partial differential equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/membrane.html">Membrane</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/heatExchanger.html">Heat Exchanger</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/acoustics.html">Acoustics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/thermalConduction.html">Thermal Conduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/fanBlade.html">Irrotational Fan Blade Flow and Thermal effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/rotatingHill.html">Pure Convection : The Rotating Hill</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/elasticity.html">The System of elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/stokes.html">The System of Stokes for Fluids</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/navierStokesProjection.html">A projection algorithm for the Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/navierStokesNewton.html">Newton Method for the Steady Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/aLargeFluidProblem.html">A Large Fluid Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/complexNumbers.html">An Example with Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/optimalControl.html">Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/flowWithShocks.html">A Flow with Shocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/heatEquationOptimization.html">Time dependent schema optimization for heat equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/timeDependentStokes.html">Tutorial to write a transient Stokes solver in matrix form</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/wifiPropagation.html">Wifi Propagation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/matlabOctavePlot.html">Plotting in Matlab and Octave</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../example/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model/index.html">Mathematical Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../model/model.html">Mathematical Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/staticProblems.html">Static problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/elasticity.html">Elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/nonLinearStaticProblems.html">Non-linear static problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/eigenValueProblems.html">Eigen value problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/evolutionProblems.html">Evolution problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/navierStokesEquations.html">Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/variationalInequality.html">Variational Inequality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/domainDecomposition.html">Domain decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/fluidStructureCoupledProblem.html">Fluid-structure coupled problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/transmissionProblem.html">Transmission problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/freeBoundaryProblem.html">Free boundary problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/nonLinearElasticity.html">Non-linear elasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/compressibleNeoHookeanMaterials.html">Compressible Neo-Hookean materials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../model/whisperingGalleryModes.html">Whispering gallery modes</a></li>
</ul>
</li>
</ul>

            </nav>
        
        </div>
    
</header>

    <div class="document">
        <div class="page-content">
        
  <div class="section" id="mesh-generation">
<span id="meshgeneration"></span><h1>Mesh Generation<a class="headerlink" href="#mesh-generation" title="Permalink to this headline">¶</a></h1>
<p>Let us begin with the two important keywords: <code class="code freefem docutils literal highlight highlight-freefem"><span></span>border</code> and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>buildmesh</code>.</p>
<div class="section" id="square">
<h2>Square<a class="headerlink" href="#square" title="Permalink to this headline">¶</a></h2>
<p>The command <code class="code freefem docutils literal highlight highlight-freefem"><span></span>square</code> triangulates the unit square.</p>
<p>The following generates a <span class="math notranslate nohighlight">\(4&nbsp;\times 5\)</span> grid in the unit square <span class="math notranslate nohighlight">\([0,1]^2\)</span>. The labels of the boundaries are shown in <a class="reference internal" href="#figboundarylabels"><span class="std std-numref">Fig. 1</span></a>.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh Th = square(4, 5);
</pre></div>
</div>
<div class="figure" id="figboundarylabels">
<img alt="../_images/MeshGeneration_Square.png" src="../_images/MeshGeneration_Square.png" />
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Boundary labels of the mesh by <code class="code freefem docutils literal highlight highlight-freefem"><span></span>square(10,10)</code></span></p>
</div>
<p>To construct a <span class="math notranslate nohighlight">\(n\times m\)</span> grid in the rectangle <span class="math notranslate nohighlight">\([x_0,x_1]\times [y_0,y_1]\)</span>, proceed as follows:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>real x0 = 1.2;
real x1 = 1.8;
real y0 = 0;
real y1 = 1;
int n = 5;
real m = 20;
mesh Th = square(n, m, [x0+(x1-x0)*x, y0+(y1-y0)*y]);
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Adding the named parameter <code class="code freefem docutils literal highlight highlight-freefem"><span></span>flags=icase</code> with icase:</p>
<ol class="arabic simple" start="0">
<li>will produce a mesh where all quads are split with diagonal <span class="math notranslate nohighlight">\(x-y=constant\)</span></li>
<li>will produce <em>Union Jack flag</em> type of mesh</li>
<li>will produce a mesh where all quads are split with diagonal <span class="math notranslate nohighlight">\(x+y=constant\)</span></li>
<li>same as in case 0, except two corners where the triangles are the same as case 2 to avoid having 3 vertices on the boundary</li>
<li>same as in case 2, except two corners where the triangles are the same as case 0 to avoid having 3 vertices on the boundary</li>
</ol>
<div class="last highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh Th = square(n, m, [x0+(x1-x0)*x, y0+(y1-y0)*y], flags=icase);
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Adding the named parameter <code class="code freefem docutils literal highlight highlight-freefem"><span></span>label=labs</code> will
change the 4 default label numbers to <code class="code freefem docutils literal highlight highlight-freefem"><span></span>labs[i-1]</code>, for
example <code class="code freefem docutils literal highlight highlight-freefem"><span></span>int[int] labs=[11, 12, 13, 14]</code>, and adding the
named parameter <code class="code freefem docutils literal highlight highlight-freefem"><span></span>region=10</code> will change the region number
to <span class="math notranslate nohighlight">\(10\)</span>, for instance (v 3.8).</p>
<p>To see all of these flags at work, check [SquareMesh.edp](./scripts/MeshGeneration/SquareMesh.edp):</p>
<div class="last highlight-freefem notranslate"><div class="highlight"><pre><span></span>for (int i = 0; i &lt; 5; ++i){
  int[int] labs = [11, 12, 13, 14];
  mesh Th = square(3, 3, flags=i, label=labs, region=10);
  plot(Th, wait=1, cmm=&quot;square flags = &quot;+i );
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="border">
<span id="meshborder"></span><h2>Border<a class="headerlink" href="#border" title="Permalink to this headline">¶</a></h2>
<p>Boundaries are defined piecewise by parametrized curves. The pieces can only intersect at their endpoints, but it is possible to join more than two endpoints. This can be used to structure the mesh if an area touches a border and create new regions by dividing larger ones:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>int upper = 1;
int others = 2;
int inner = 3;

border C01(t=0, 1){x=0; y=-1+t; label=upper;}
border C02(t=0, 1){x=1.5-1.5*t; y=-1; label=upper;}
border C03(t=0, 1){x=1.5; y=-t; label=upper;}
border C04(t=0, 1){x=1+0.5*t; y=0; label=others;}
border C05(t=0, 1){x=0.5+0.5*t; y=0; label=others;}
border C06(t=0, 1){x=0.5*t; y=0; label=others;}
border C11(t=0, 1){x=0.5; y=-0.5*t; label=inner;}
border C12(t=0, 1){x=0.5+0.5*t; y=-0.5; label=inner;}
border C13(t=0, 1){x=1; y=-0.5+0.5*t; label=inner;}

int n = 10;
plot(C01(-n) + C02(-n) + C03(-n) + C04(-n) + C05(-n)
  + C06(-n) + C11(n) + C12(n) + C13(n), wait=true);

mesh Th = buildmesh(C01(-n) + C02(-n) + C03(-n) + C04(-n) + C05(-n)
  + C06(-n) + C11(n) + C12(n) + C13(n));

plot(Th, wait=true);

cout &lt;&lt; &quot;Part 1 has region number &quot; &lt;&lt; Th(0.75, -0.25).region &lt;&lt; endl;
cout &lt;&lt; &quot;Part 2 has redion number &quot; &lt;&lt; Th(0.25, -0.25).region &lt;&lt; endl;
</pre></div>
</div>
<p>Borders and mesh are respectively shown in <a class="reference internal" href="#figmultipleborder"><span class="std std-numref">Fig. 2</span></a> and Fig. <a class="reference internal" href="#figgeneratedmesh"><span class="std std-numref">Fig. 3</span></a>.</p>
<div class="figure" id="figmultipleborder">
<img alt="../_images/MeshGeneration_Border1.png" src="../_images/MeshGeneration_Border1.png" />
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Multiple border ends intersect</span></p>
</div>
<div class="figure" id="figgeneratedmesh">
<img alt="../_images/MeshGeneration_Border2.png" src="../_images/MeshGeneration_Border2.png" />
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Generated mesh</span></p>
</div>
<p>Triangulation keywords assume that the domain is defined as being on the <em>left</em> (resp <em>right</em>) of its oriented parameterized boundary</p>
<div class="math notranslate nohighlight">
\[\Gamma_j = \{(x,y)\left|\; x=\varphi_x(t),\, y=\varphi_y(t),\, a_j\le t\le b_j\right.\}\]</div>
<p>To check the orientation plot <span class="math notranslate nohighlight">\(t\mapsto (\varphi_x(t),\varphi_y(t)),\, t_0\le t\le t_1\)</span>. If it is as in <a class="reference internal" href="#figborder"><span class="std std-numref">Fig. 4</span></a>, then the domain lies on the shaded area, otherwise it lies on the opposite side.</p>
<div class="figure" id="figborder">
<img alt="../_images/MeshGeneration_Border3.png" src="../_images/MeshGeneration_Border3.png" />
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Orientation of the boundary defined by <span class="math notranslate nohighlight">\((\phi_x(t),\phi_y(t))\)</span></span></p>
</div>
<p>The general expression to define a triangulation with <code class="code freefem docutils literal highlight highlight-freefem"><span></span>buildmesh</code> is</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh Mesh_Name = buildmesh(Gamma1(m1)+...+GammaJ(mj), OptionalParameter);
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(m_j\)</span> are positive or negative numbers to indicate how many vertices should be on <span class="math notranslate nohighlight">\(\Gamma_j,\, \Gamma=\cup_{j=1}^J \Gamma_J\)</span>, and the optional parameter (see also <a class="reference external" href="/reference/Functions/#buildmesh">References</a>), separated with a comma, can be:</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>nbvx= int</code>, to set the maximum number of vertices in the mesh.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>fixedborder= bool</code>, to say if the mesh generator can change the boundary mesh or not (by default the boundary mesh can change; beware that with periodic boundary conditions (see. <a class="reference external" href="../FiniteElement">Finite Element</a>), it can be dangerous.</li>
</ul>
<p>The orientation of boundaries can be changed by changing the sign of <span class="math notranslate nohighlight">\(m_j\)</span>.</p>
<p>The following example shows how to change the orientation. The example generates the unit disk with a small circular hole, and assigns “1” to the unit disk (“2” to the circle inside). The boundary label <strong>must be non-zero</strong>, but it can also be omitted.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
border b(t=0, 2*pi){x=0.3+0.3*cos(t); y=0.3*sin(t); label=2;}
plot(a(50) + b(30)); //to see a plot of the border mesh
mesh Thwithouthole = buildmesh(a(50) + b(30));
mesh Thwithhole = buildmesh(a(50) + b(-30));
plot(Thwithouthole, ps=&quot;Thwithouthole.eps&quot;);
plot(Thwithhole, ps=&quot;Thwithhole.eps&quot;);
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Notice that the orientation is changed by <code class="code freefem docutils literal highlight highlight-freefem"><span></span>b(-30)</code> in the 5th line. In the 7th line, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>ps=&quot;fileName&quot;</code> is used to generate a postscript file with identification shown on the figure.</p>
</div>
<div class="figure" id="figmeswithouthhole">
<img alt="../_images/MeshGeneration_Border4.png" src="../_images/MeshGeneration_Border4.png" />
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">Mesh without hole</span></p>
</div>
<div class="figure" id="figmeshwithhole">
<img alt="../_images/MeshGeneration_Border5.png" src="../_images/MeshGeneration_Border5.png" />
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Mesh with hole</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Borders are evaluated only at the time <code class="code freefem docutils literal highlight highlight-freefem"><span></span>plot</code> or <code class="code freefem docutils literal highlight highlight-freefem"><span></span>buildmesh</code> is called so the global variables are defined at this time. In this case, since <span class="math notranslate nohighlight">\(r\)</span> is changed between the two border calls, the following code will not work because the first border will be computed with r=0.3:</p>
<div class="last highlight-freefem notranslate"><div class="highlight"><pre><span></span>real r=1;
border a(t=0, 2*pi){x=r*cos(t); y=r*sin(t); label=1;}
r=0.3;
border b(t=0, 2*pi){x=r*cos(t); y=r*sin(t); label=1;}
mesh Thwithhole = buildmesh(a(50) + b(-30)); // bug (a trap) because
    // the two circles have the same radius = :math:`0.3`
</pre></div>
</div>
</div>
</div>
<div class="section" id="multi-border">
<h2>Multi-Border<a class="headerlink" href="#multi-border" title="Permalink to this headline">¶</a></h2>
<p>Sometimes it can be useful to make an array of the border, but unfortunately it is incompatible with the FreeFem++ syntax. To bypass this problem, if the number of segments of the discretization <span class="math notranslate nohighlight">\(n\)</span> is an array, we make an implicit loop on all of the values of the array, and the index variable <span class="math notranslate nohighlight">\(i\)</span> of the loop is defined after the parameter definition, like in :freefem`border a(t=0, 2*pi; i)` …</p>
<p>A first very small example:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>border a(t=0, 2*pi; i){x=(i+1)*cos(t); y=(i+1)*sin(t); label=1;}
int[int] nn = [10, 20, 30];
plot(a(nn)); //plot 3 circles with 10, 20, 30 points
</pre></div>
</div>
<p>And a more complex example to define a square with small circles:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>real[int] xx = [0, 1, 1, 0],
          yy = [0, 0, 1, 1];
//radius, center of the 4 circles
real[int] RC = [0.1, 0.05, 0.05, 0.1],
          XC = [0.2, 0.8, 0.2, 0.8],
          YC = [0.2, 0.8, 0.8, 0.2];
int[int] NC = [-10,-11,-12,13]; //list number of :math:`\pm` segments of the 4 circles borders

border bb(t=0, 1; i)
{
    // i is the index variable of the multi border loop
    int ii = (i+1)%4;
    real t1 = 1-t;
    x = xx[i]*t1 + xx[ii]*t;
    y = yy[i]*t1 + yy[ii]*t;
    label = 0;
}

border cc(t=0, 2*pi; i)
{
    x = RC[i]*cos(t) + XC[i];
    y = RC[i]*sin(t) + YC[i];
    label = i + 1;
}
int[int] nn = [4, 4, 5, 7]; //4 border, with 4, 4, 5, 7 segment respectively
plot(bb(nn), cc(NC), wait=1);
mesh th = buildmesh(bb(nn) + cc(NC));
plot(th, wait=1);
</pre></div>
</div>
</div>
<div class="section" id="data-structures-and-read-write-statements-for-a-mesh">
<h2>Data Structures and Read/Write Statements for a Mesh<a class="headerlink" href="#data-structures-and-read-write-statements-for-a-mesh" title="Permalink to this headline">¶</a></h2>
<p>Users who want to read a triangulation made elsewhere should see the structure of the file generated below:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>border C(t=0, 2*pi){x=cos(t); y=sin(t);}
mesh Th = buildmesh(C(10));
savemesh(Th, &quot;mesh.msh&quot;);
</pre></div>
</div>
<p>The mesh is shown on <a class="reference internal" href="#figbuildmesh"><span class="std std-numref">Fig. 7</span></a>.</p>
<p>The information about :freefem`Th` are saved in the file <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mesh.msh</code> whose structure is shown on Tab. 1.</p>
<p>There, <span class="math notranslate nohighlight">\(n_v\)</span> denotes the number of vertices, <span class="math notranslate nohighlight">\(n_t\)</span> the number of triangles and <span class="math notranslate nohighlight">\(n_s\)</span> the number of edges on boundary.</p>
<p>For each vertex <span class="math notranslate nohighlight">\(q^i,\, i=1,\cdots,n_v\)</span>, denoted by <span class="math notranslate nohighlight">\((q^i_x,q^i_y)\)</span> the <span class="math notranslate nohighlight">\(x\)</span>-coordinate and <span class="math notranslate nohighlight">\(y\)</span>-coordinate.</p>
<p>Each triangle <span class="math notranslate nohighlight">\(T_k, k=1,\cdots,n_t\)</span> has three vertices <span class="math notranslate nohighlight">\(q^{k_1},\, q^{k_2},\,q^{k_3}\)</span> that are oriented counter-clockwise.</p>
<p>The boundary consists of 10 lines <span class="math notranslate nohighlight">\(L_i,\, i=1,\cdots,10\)</span> whose end points are <span class="math notranslate nohighlight">\(q^{i_1},\, q^{i_2}\)</span>.</p>
<div class="figure" id="figbuildmesh">
<img alt="../_images/MeshGeneration_Data.png" src="../_images/MeshGeneration_Data.png" />
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">Mesh by :freefem`buildmesh(C(10))`</span></p>
</div>
<p>In the <a class="reference internal" href="#figbuildmesh"><span class="std std-numref">Fig. 7</span></a>, we have the following.
<span class="math notranslate nohighlight">\(n_v=14, n_t=16, n_s=10\)</span>
<span class="math notranslate nohighlight">\(q^1=(-0.309016994375, 0.951056516295)\)</span>
<span class="math notranslate nohighlight">\(\vdots\quad \vdots\quad \vdots\)</span>
<span class="math notranslate nohighlight">\(q^{14}=(-0.309016994375, -0.951056516295)\)</span>
The vertices of <span class="math notranslate nohighlight">\(T_1\)</span> are <span class="math notranslate nohighlight">\(q^9, q^{12},\, q^{10}\)</span>.
<span class="math notranslate nohighlight">\(\vdots\quad \vdots\quad \vdots\)</span>
The vertices of <span class="math notranslate nohighlight">\(T_{16}\)</span> are <span class="math notranslate nohighlight">\(q^9, q^{10}, q^{6}\)</span>.
The edge of the 1st side <span class="math notranslate nohighlight">\(L_1\)</span> are <span class="math notranslate nohighlight">\(q^6, q^5\)</span>.<span class="math notranslate nohighlight">\(\vdots\quad \vdots\quad \vdots\)</span>
The edge of the 10th side <span class="math notranslate nohighlight">\(L_{10}\)</span> are <span class="math notranslate nohighlight">\(q^{10}, q^6\)</span>.</p>
<p>In FreeFem++ there are many mesh file formats available for communication with other tools such as <code class="docutils literal highlight highlight-freefem"><span></span>emc2</code>, <code class="docutils literal highlight highlight-freefem"><span></span>modulef</code>, … (see <a class="reference external" href="../Developers/#mesh-format">Mesh format chapter</a> ).</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">todo</p>
</div>
<p>The extension of a file implies its format.
More details can be found on the file format .msh in the article by F. Hecht “bamg : a bidimensional anisotropic mesh generator” <a class="reference external" href="#refHecht19982">Hecht1998</a>.</p>
<p>A mesh file can be read into FreeFem++ except that the names of the borders are lost and only their reference numbers are kept.
So these borders have to be referenced by the number which corresponds to their order of appearance in the program, unless this number is overwritten by the keyword <code class="code freefem docutils literal highlight highlight-freefem"><span></span>label</code>. Here are some examples:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>border floor(t=0, 1){x=t; y=0; label=1;}
border right(t=0, 1){x=1; y=t; label=5;}
border ceiling(t=1, 0){x=t; y=1; label=5;}
border left(t=1, 0){x=0; y=t; label=5;}

int n = 10;
mesh th = buildmesh(floor(n) + right(n) + ceiling(n) + left(n));
savemesh(th, &quot;toto.am_fmt&quot;); //&quot;formatted Marrocco&quot; format
savemesh(th, &quot;toto.Th&quot;); //&quot;bamg&quot;-type mesh
savemesh(th, &quot;toto.msh&quot;); //freefem format
savemesh(th, &quot;toto.nopo&quot;); //modulef format
mesh th2 = readmesh(&quot;toto.msh&quot;); //read the mesh
</pre></div>
</div>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
int n = 10;

// Mesh
border floor(t=0, 1){x=t; y=0; label=1;};
border right(t=0, 1){x=1; y=t; label=5;};
border ceiling(t=1, 0){x=t; y=1; label=5;};
border left(t=1, 0){x=0; y=t; label=5;};

mesh th = buildmesh(floor(n) + right(n) + ceiling(n) + left(n));

//save mesh in different formats
savemesh(th, &quot;toto.am_fmt&quot;); // format &quot;formated Marrocco&quot;
savemesh(th, &quot;toto.Th&quot;); // format database db mesh &quot;bamg&quot;
savemesh(th, &quot;toto.msh&quot;); // format freefem
savemesh(th, &quot;toto.nopo&quot;); // modulef format

// Fespace
fespace femp1(th, P1);
femp1 f = sin(x)*cos(y);
femp1 g;

//save the fespace function in a file
{
  ofstream file(&quot;f.txt&quot;);
  file &lt;&lt; f[] &lt;&lt; endl;
} //the file is automatically closed at the end of the block
//read a file and put it in a fespace function
{
  ifstream file(&quot;f.txt&quot;);
  file &gt;&gt; g[] ;
}//the file is equally automatically closed

// Plot
plot(g);

// Mesh 2
//read the mesh for freefem format saved mesh
mesh th2 = readmesh(&quot;toto.msh&quot;);

// Fespace 2
fespace Vh2(th2, P1);
Vh2 u, v;

// Problem
//solve:
//  $u + \Delta u = g$ in $\Omega $
//  $u=0$ on $\Gamma_1$
//  $\frac{\partial u }{\partial n} = g$ on $\Gamma_2$
solve Problem(u, v)
  = int2d(th2)(
      u*v
    - dx(u)*dx(v)
    - dy(u)*dy(v)
  )
  + int2d(th2)(
    - g*v
  )
  + int1d(th2, 5)(
      g*v
  )
  + on(1, u=0)
  ;

// Plot
plot(th2, u);
</pre></div>
</div>
</div>
<div class="section" id="mesh-connectivity-and-data">
<h2>Mesh Connectivity and data<a class="headerlink" href="#mesh-connectivity-and-data" title="Permalink to this headline">¶</a></h2>
<p>The following example explains methods to obtain mesh information.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Mesh
mesh Th = square(2, 2);

cout &lt;&lt; &quot;// Get data of the mesh&quot; &lt;&lt; endl;
{
    int NbTriangles = Th.nt;
    real MeshArea = Th.measure;
    real BorderLenght = Th.bordermeasure;

    cout &lt;&lt; &quot;Number of triangle(s) = &quot; &lt;&lt; NbTriangles &lt;&lt; endl;
    cout &lt;&lt; &quot;Mesh area = &quot; &lt;&lt; MeshArea &lt;&lt; endl;
    cout &lt;&lt; &quot;Border length = &quot; &lt;&lt; BorderLenght &lt;&lt; endl;

    // Th(i) return the vextex i of Th
    // Th[k] return the triangle k of Th
    // Th[k][i] return the vertex i of the triangle k of Th
    for (int i = 0; i &lt; NbTriangles; i++)
        for (int j = 0; j &lt; 3; j++)
            cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; - Th[i][j] = &quot; &lt;&lt; Th[i][j]
                 &lt;&lt; &quot;, x = &quot; &lt;&lt; Th[i][j].x
                 &lt;&lt; &quot;, y= &quot; &lt;&lt; Th[i][j].y
                 &lt;&lt; &quot;, label=&quot; &lt;&lt; Th[i][j].label &lt;&lt; endl;
}

cout &lt;&lt; &quot;// Hack to get vertex coordinates&quot; &lt;&lt; endl;
{
    fespace femp1(Th, P1);
    femp1 Thx=x,Thy=y;

    int NbVertices = Th.nv;
    cout &lt;&lt; &quot;Number of vertices = &quot; &lt;&lt; NbVertices &lt;&lt; endl;

    for (int i = 0; i &lt; NbVertices; i++)
        cout &lt;&lt; &quot;Th(&quot; &lt;&lt; i &lt;&lt; &quot;) : &quot; &lt;&lt; Th(i).x &lt;&lt; &quot; &quot; &lt;&lt; Th(i).y &lt;&lt; &quot; &quot; &lt;&lt; Th(i).label
             &lt;&lt; endl &lt;&lt; &quot;\told method: &quot; &lt;&lt; Thx[][i] &lt;&lt; &quot; &quot; &lt;&lt; Thy[][i] &lt;&lt; endl;
}

cout &lt;&lt; &quot;// Method to find information of point (0.55,0.6)&quot; &lt;&lt; endl;
{
    int TNumber = Th(0.55, 0.6).nuTriangle; //the triangle number
    int RLabel = Th(0.55, 0.6).region; //the region label

    cout &lt;&lt; &quot;Triangle number in point (0.55, 0.6): &quot; &lt;&lt; TNumber &lt;&lt; endl;
    cout &lt;&lt; &quot;Region label in point (0.55, 0.6): &quot; &lt;&lt; RLabel &lt;&lt; endl;
}

cout &lt;&lt; &quot;// Information of triangle&quot; &lt;&lt; endl;
{
    int TNumber = Th(0.55, 0.6).nuTriangle;
    real TArea = Th[TNumber].area; //triangle area
    real TRegion = Th[TNumber].region; //triangle region
    real TLabel = Th[TNumber].label; //triangle label, same as region for triangles

    cout &lt;&lt; &quot;Area of triangle &quot; &lt;&lt; TNumber &lt;&lt; &quot;: &quot; &lt;&lt; TArea &lt;&lt; endl;
    cout &lt;&lt; &quot;Region of triangle &quot; &lt;&lt; TNumber &lt;&lt; &quot;: &quot; &lt;&lt; TRegion &lt;&lt; endl;
    cout &lt;&lt; &quot;Label of triangle &quot; &lt;&lt; TNumber &lt;&lt; &quot;: &quot; &lt;&lt; TLabel &lt;&lt; endl;
}

cout &lt;&lt; &quot;// Hack to get a triangle containing point x, y or region number (old method)&quot; &lt;&lt; endl;
{
    fespace femp0(Th, P0);
    femp0 TNumbers; //a P0 function to get triangle numbering
    for (int i = 0; i &lt; Th.nt; i++)
        TNumbers[][i] = i;
    femp0 RNumbers = region; //a P0 function to get the region number

    int TNumber = TNumbers(0.55, 0.6); // Number of the triangle containing (0.55, 0,6)
    int RNumber = RNumbers(0.55, 0.6); // Number of the region containing (0.55, 0,6)

    cout &lt;&lt; &quot;Point (0.55,0,6) :&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\tTriangle number = &quot; &lt;&lt; TNumber &lt;&lt; endl;
    cout &lt;&lt; &quot;\tRegion number = &quot; &lt;&lt; RNumber &lt;&lt; endl;
}

cout &lt;&lt; &quot;// New method to get boundary information and mesh adjacent&quot; &lt;&lt; endl;
{
    int k = 0;
    int l=1;
    int e=1;

    // Number of boundary elements
    int NbBoundaryElements = Th.nbe;
    cout &lt;&lt; &quot;Number of boundary element = &quot; &lt;&lt; NbBoundaryElements &lt;&lt; endl;
    // Boundary element k in {0, ..., Th.nbe}
    int BoundaryElement = Th.be(k);
    cout &lt;&lt; &quot;Boundary element &quot; &lt;&lt; k &lt;&lt; &quot; = &quot; &lt;&lt; BoundaryElement &lt;&lt; endl;
    // Vertice l in {0, 1} of boundary element k
    int Vertex = Th.be(k)[l];
    cout &lt;&lt; &quot;Vertex &quot; &lt;&lt; l &lt;&lt; &quot; of boundary element &quot; &lt;&lt; k &lt;&lt; &quot; = &quot; &lt;&lt; Vertex &lt;&lt; endl;
    // Triangle containg the boundary element k
    int Triangle = Th.be(k).Element;
    cout &lt;&lt; &quot;Triangle containing the boundary element &quot; &lt;&lt; k &lt;&lt; &quot; = &quot; &lt;&lt; Triangle &lt;&lt; endl;
    // Triangle egde nubmer containing the boundary element k
    int Edge = Th.be(k).whoinElement;
    cout &lt;&lt; &quot;Triangle edge number containing the boundary element &quot; &lt;&lt; k &lt;&lt; &quot; = &quot; &lt;&lt; Edge &lt;&lt; endl;
    // Adjacent triangle of the triangle k by edge e
    int Adjacent = Th[k].adj(e); //The value of e is changed to the corresponding edge in the adjacent triangle
    cout &lt;&lt; &quot;Adjacent triangle of the triangle &quot; &lt;&lt; k &lt;&lt; &quot; by edge &quot; &lt;&lt; e &lt;&lt; &quot; = &quot; &lt;&lt; Adjacent &lt;&lt; endl;
    cout &lt;&lt; &quot;\tCorresponding edge = &quot; &lt;&lt; e &lt;&lt; endl;
    // If there is no adjacent triangle by edge e, the same triangle is returned
    //Th[k] == Th[k].adj(e)
    // Else a different triangle is returned
    //Th[k] != Th[k].adj(e)
}

cout &lt;&lt; &quot;// Print mesh connectivity &quot; &lt;&lt; endl;
{
    int NbTriangles = Th.nt;
    for (int k = 0; k &lt; NbTriangles; k++)
        cout &lt;&lt; k &lt;&lt; &quot; : &quot; &lt;&lt; int(Th[k][0]) &lt;&lt; &quot; &quot; &lt;&lt; int(Th[k][1])
             &lt;&lt; &quot; &quot; &lt;&lt; int(Th[k][2])
             &lt;&lt; &quot;, label &quot; &lt;&lt; Th[k].label &lt;&lt; endl;

    for (int k = 0; k &lt; NbTriangles; k++)
        for (int e = 0, ee; e &lt; 3; e++)
            //set ee to e, and ee is change by method adj,
            cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; e &lt;&lt; &quot; &lt;=&gt; &quot; &lt;&lt; int(Th[k].adj((ee=e))) &lt;&lt; &quot; &quot; &lt;&lt; ee
                 &lt;&lt; &quot;, adj: &quot; &lt;&lt; (Th[k].adj((ee=e)) != Th[k]) &lt;&lt; endl;

    int NbBoundaryElements = Th.nbe;
    for (int k = 0; k &lt; NbBoundaryElements; k++)
        cout &lt;&lt; k &lt;&lt; &quot; : &quot; &lt;&lt; Th.be(k)[0] &lt;&lt; &quot; &quot; &lt;&lt; Th.be(k)[1]
             &lt;&lt; &quot; , label &quot; &lt;&lt; Th.be(k).label
             &lt;&lt; &quot;, triangle &quot; &lt;&lt; int(Th.be(k).Element)
             &lt;&lt; &quot; &quot; &lt;&lt; Th.be(k).whoinElement &lt;&lt; endl;

    real[int] bb(4);
    boundingbox(Th, bb);
    // bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax
    cout &lt;&lt; &quot;boundingbox:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;xmin = &quot; &lt;&lt; bb[0]
         &lt;&lt; &quot;, xmax = &quot; &lt;&lt; bb[1]
         &lt;&lt; &quot;, ymin = &quot; &lt;&lt; bb[2]
         &lt;&lt; &quot;, ymax = &quot; &lt;&lt; bb[3] &lt;&lt; endl;
}
</pre></div>
</div>
<p>The output is:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>// Get data of the mesh
Number of <span class="nv">triangle</span> <span class="o">=</span> <span class="m">8</span>
Mesh <span class="nv">area</span> <span class="o">=</span> <span class="m">1</span>
Border <span class="nv">length</span> <span class="o">=</span> <span class="m">4</span>
<span class="m">0</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">0</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">1</span>
<span class="m">0</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">1</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">1</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">1</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">3</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">2</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">1</span>
<span class="m">2</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">2</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">2</span>
<span class="m">2</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">5</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">2</span>
<span class="m">3</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">1</span>
<span class="m">3</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">5</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">2</span>
<span class="m">3</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">4</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">3</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">4</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">4</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">7</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">3</span>
<span class="m">5</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">3</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">5</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">7</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">3</span>
<span class="m">5</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">6</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">6</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">6</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">5</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">2</span>
<span class="m">6</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">8</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">3</span>
<span class="m">7</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">7</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">8</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">3</span>
<span class="m">7</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">7</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">3</span>
// Hack to get vertex coordinates
Number of <span class="nv">vertices</span> <span class="o">=</span> <span class="m">9</span>
Th<span class="o">(</span><span class="m">0</span><span class="o">)</span> : <span class="m">0</span> <span class="m">0</span> <span class="m">4</span>
   old method: <span class="m">0</span> <span class="m">0</span>
Th<span class="o">(</span><span class="m">1</span><span class="o">)</span> : <span class="m">0</span>.5 <span class="m">0</span> <span class="m">1</span>
   old method: <span class="m">0</span>.5 <span class="m">0</span>
Th<span class="o">(</span><span class="m">2</span><span class="o">)</span> : <span class="m">1</span> <span class="m">0</span> <span class="m">2</span>
   old method: <span class="m">1</span> <span class="m">0</span>
Th<span class="o">(</span><span class="m">3</span><span class="o">)</span> : <span class="m">0</span> <span class="m">0</span>.5 <span class="m">4</span>
   old method: <span class="m">0</span> <span class="m">0</span>.5
Th<span class="o">(</span><span class="m">4</span><span class="o">)</span> : <span class="m">0</span>.5 <span class="m">0</span>.5 <span class="m">0</span>
   old method: <span class="m">0</span>.5 <span class="m">0</span>.5
Th<span class="o">(</span><span class="m">5</span><span class="o">)</span> : <span class="m">1</span> <span class="m">0</span>.5 <span class="m">2</span>
   old method: <span class="m">1</span> <span class="m">0</span>.5
Th<span class="o">(</span><span class="m">6</span><span class="o">)</span> : <span class="m">0</span> <span class="m">1</span> <span class="m">4</span>
   old method: <span class="m">0</span> <span class="m">1</span>
Th<span class="o">(</span><span class="m">7</span><span class="o">)</span> : <span class="m">0</span>.5 <span class="m">1</span> <span class="m">3</span>
   old method: <span class="m">0</span>.5 <span class="m">1</span>
Th<span class="o">(</span><span class="m">8</span><span class="o">)</span> : <span class="m">1</span> <span class="m">1</span> <span class="m">3</span>
   old method: <span class="m">1</span> <span class="m">1</span>
// Method to find the information of point <span class="o">(</span><span class="m">0</span>.55,0.6<span class="o">)</span>
Triangle number in point <span class="o">(</span><span class="m">0</span>.55, <span class="m">0</span>.6<span class="o">)</span>: <span class="m">7</span>
Region label in point <span class="o">(</span><span class="m">0</span>.55, <span class="m">0</span>.6<span class="o">)</span>: <span class="m">0</span>
// Information of a triangle
Area of triangle <span class="m">7</span>: <span class="m">0</span>.125
Region of triangle <span class="m">7</span>: <span class="m">0</span>
Label of triangle <span class="m">7</span>: <span class="m">0</span>
// Hack to get a triangle containing point x, y or region number <span class="o">(</span>old method<span class="o">)</span>
Point <span class="o">(</span><span class="m">0</span>.55,0,6<span class="o">)</span> :
   Triangle <span class="nv">number</span> <span class="o">=</span> <span class="m">7</span>
   Region <span class="nv">number</span> <span class="o">=</span> <span class="m">0</span>
// New method to get boundary information and mesh adjacent
Number of boundary <span class="nv">element</span> <span class="o">=</span> <span class="m">8</span>
Boundary element <span class="nv">0</span> <span class="o">=</span> <span class="m">0</span>
Vertex <span class="m">1</span> of boundary element <span class="nv">0</span> <span class="o">=</span> <span class="m">1</span>
Triangle containing the boundary element <span class="nv">0</span> <span class="o">=</span> <span class="m">0</span>
Triangle edge number containing the boundary element <span class="nv">0</span> <span class="o">=</span> <span class="m">2</span>
Adjacent triangle of the triangle <span class="m">0</span> by edge <span class="nv">1</span> <span class="o">=</span> <span class="m">1</span>
   Corresponding <span class="nv">edge</span> <span class="o">=</span> <span class="m">2</span>
// Print mesh connectivity
<span class="m">0</span> : <span class="m">0</span> <span class="m">1</span> <span class="m">4</span>, label <span class="m">0</span>
<span class="m">1</span> : <span class="m">0</span> <span class="m">4</span> <span class="m">3</span>, label <span class="m">0</span>
<span class="m">2</span> : <span class="m">1</span> <span class="m">2</span> <span class="m">5</span>, label <span class="m">0</span>
<span class="m">3</span> : <span class="m">1</span> <span class="m">5</span> <span class="m">4</span>, label <span class="m">0</span>
<span class="m">4</span> : <span class="m">3</span> <span class="m">4</span> <span class="m">7</span>, label <span class="m">0</span>
<span class="m">5</span> : <span class="m">3</span> <span class="m">7</span> <span class="m">6</span>, label <span class="m">0</span>
<span class="m">6</span> : <span class="m">4</span> <span class="m">5</span> <span class="m">8</span>, label <span class="m">0</span>
<span class="m">7</span> : <span class="m">4</span> <span class="m">8</span> <span class="m">7</span>, label <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">3</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">0</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">1</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">0</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">0</span> <span class="m">2</span>, adj: <span class="m">0</span>
<span class="m">1</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">4</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">1</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">1</span> <span class="m">1</span>, adj: <span class="m">0</span>
<span class="m">1</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">0</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">2</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">2</span> <span class="m">0</span>, adj: <span class="m">0</span>
<span class="m">2</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">3</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">2</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">2</span> <span class="m">2</span>, adj: <span class="m">0</span>
<span class="m">3</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">6</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">3</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">0</span> <span class="m">0</span>, adj: <span class="m">1</span>
<span class="m">3</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">2</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">4</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">7</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">4</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">5</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">4</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">1</span> <span class="m">0</span>, adj: <span class="m">1</span>
<span class="m">5</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">5</span> <span class="m">0</span>, adj: <span class="m">0</span>
<span class="m">5</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">5</span> <span class="m">1</span>, adj: <span class="m">0</span>
<span class="m">5</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">4</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">6</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">6</span> <span class="m">0</span>, adj: <span class="m">0</span>
<span class="m">6</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">7</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">6</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">3</span> <span class="m">0</span>, adj: <span class="m">1</span>
<span class="m">7</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">7</span> <span class="m">0</span>, adj: <span class="m">0</span>
<span class="m">7</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">4</span> <span class="m">0</span>, adj: <span class="m">1</span>
<span class="m">7</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">6</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">0</span> : <span class="m">0</span> <span class="m">1</span> , label <span class="m">1</span>, triangle <span class="m">0</span> <span class="m">2</span>
<span class="m">1</span> : <span class="m">1</span> <span class="m">2</span> , label <span class="m">1</span>, triangle <span class="m">2</span> <span class="m">2</span>
<span class="m">2</span> : <span class="m">2</span> <span class="m">5</span> , label <span class="m">2</span>, triangle <span class="m">2</span> <span class="m">0</span>
<span class="m">3</span> : <span class="m">5</span> <span class="m">8</span> , label <span class="m">2</span>, triangle <span class="m">6</span> <span class="m">0</span>
<span class="m">4</span> : <span class="m">6</span> <span class="m">7</span> , label <span class="m">3</span>, triangle <span class="m">5</span> <span class="m">0</span>
<span class="m">5</span> : <span class="m">7</span> <span class="m">8</span> , label <span class="m">3</span>, triangle <span class="m">7</span> <span class="m">0</span>
<span class="m">6</span> : <span class="m">0</span> <span class="m">3</span> , label <span class="m">4</span>, triangle <span class="m">1</span> <span class="m">1</span>
<span class="m">7</span> : <span class="m">3</span> <span class="m">6</span> , label <span class="m">4</span>, triangle <span class="m">5</span> <span class="m">1</span>
boundingbox:
<span class="nv">xmin</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">xmax</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">ymin</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">ymax</span> <span class="o">=</span> <span class="m">1</span>
</pre></div>
</div>
<p>The real characteristic function of a mesh <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th</code> is <code class="code freefem docutils literal highlight highlight-freefem"><span></span>chi(Th)</code> in 2D and 3D where:</p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>chi(Th)(P)=1</code> if <span class="math notranslate nohighlight">\(P\in Th\)</span></p>
<p><code class="code freefem docutils literal highlight highlight-freefem"><span></span>chi(Th)(P)=0</code> if <span class="math notranslate nohighlight">\(P\not\in Th\)</span></p>
</div>
<div class="section" id="the-keyword-triangulate">
<h2>The keyword “triangulate”<a class="headerlink" href="#the-keyword-triangulate" title="Permalink to this headline">¶</a></h2>
<p>FreeFem++ is able to build a triangulation from a set of points. This
triangulation is a Delaunay mesh of the convex hull of the set of
points. It can be useful to build a mesh from a table function.</p>
<p>The coordinates of the points and the value of the table function are
defined separately with rows of the form: <code class="code freefem docutils literal highlight highlight-freefem"><span></span>x y f(x,y)</code> in a
file such as:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>0.51387 0.175741 0.636237
0.308652 0.534534 0.746765
0.947628 0.171736 0.899823
0.702231 0.226431 0.800819
0.494773 0.12472 0.580623
0.0838988 0.389647 0.456045
...............
</pre></div>
</div>
<div class="figure" id="figdelaunaymesh">
<img alt="../_images/MeshGeneration_Triangulate1.png" src="../_images/MeshGeneration_Triangulate1.png" />
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">Delaunay mesh of the convex hull of point set in file xy</span></p>
</div>
<div class="figure" id="figisovalue">
<img alt="../_images/MeshGeneration_Triangulate2.png" src="../_images/MeshGeneration_Triangulate2.png" />
<p class="caption"><span class="caption-number">Fig. 9 </span><span class="caption-text">Isolvalue of table function</span></p>
</div>
<p>The third column of each line is left untouched by the <code class="code freefem docutils literal highlight highlight-freefem"><span></span>triangulate</code> command. But you can use this third value to define a table function with rows of the form: :freefem`x y f(x,y)`.</p>
<p>The following example shows how to make a mesh from the file <code class="docutils literal highlight highlight-freefem"><span></span>xyf</code> with the format stated just above. The command :freefem`triangulate` only uses the 1st and 2nd columns.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Build the Delaunay mesh of the convex hull
mesh Thxy=triangulate(&quot;xyf&quot;); //points are defined by the first 2 columns of file `xyf`

// Plot the created mesh
plot(Thxy);

// Fespace
fespace Vhxy(Thxy, P1);
Vhxy fxy;

// Reading the 3rd column to define the function fxy
{
    ifstream file(&quot;xyf&quot;);
    real xx, yy;
    for(int i = 0; i &lt; fxy.n; i++)
        file &gt;&gt; xx &gt;&gt; yy &gt;&gt; fxy[][i]; //to read third row only.
                                      //xx and yy are just skipped
}

// Plot
plot(fxy);
</pre></div>
</div>
<p>One new way to build a mesh is to have two arrays: one for the <span class="math notranslate nohighlight">\(x\)</span>
values and the other for the <span class="math notranslate nohighlight">\(y\)</span> values.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>//set two arrays for the x&#39;s and y&#39;s
Vhxy xx=x, yy=y;
//build the mesh
mesh Th = triangulate(xx[], yy[]);
</pre></div>
</div>
<div class="section" id="boundary-fem-spaces-built-as-empty-meshes">
<h3>Boundary FEM Spaces Built as Empty Meshes<a class="headerlink" href="#boundary-fem-spaces-built-as-empty-meshes" title="Permalink to this headline">¶</a></h3>
<p>To define a Finite Element space on a boundary, we came up with the idea
of a mesh with no internal points (called empty mesh). It can be useful
to handle Lagrange multipliers in mixed and mortar methods.</p>
<p>So the function <code class="code freefem docutils literal highlight highlight-freefem"><span></span>emptymesh</code> removes all the internal points
of a mesh except points on internal boundaries.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>{
    border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
    mesh Th = buildmesh(a(20));
    Th = emptymesh(Th);
    plot(Th);
}
</pre></div>
</div>
<p>It is also possible to build an empty mesh of a pseudo subregion with
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>emptymesh(Th, ssd)</code> using the set of edges from the mesh
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th</code>; an edge <span class="math notranslate nohighlight">\(e\)</span> is in this set when, with the two
adjacent triangles <span class="math notranslate nohighlight">\(e =t1\cap t2\)</span> and <span class="math notranslate nohighlight">\(ssd[T1] \neq ssd[T2]\)</span>
where <span class="math notranslate nohighlight">\(ssd\)</span> refers to the pseudo region numbering of triangles,
they are stored in the <code class="code freefem docutils literal highlight highlight-freefem"><span></span>int[int]</code> array of size “the number
of triangles”.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>{
    mesh Th = square(10, 10);
    int[int] ssd(Th.nt);
    //build the pseudo region numbering
    for(int i = 0; i &lt; ssd.n; i++){
        int iq = i/2; //because 2 triangles per quad
        int ix = iq%10;
        int iy = iq/10;
        ssd[i] = 1 + (ix&gt;=5) + (iy&gt;=5)*2;
    }
    //build emtpy with all edges $e=T1 \cap T2$ and $ssd[T1] \neq ssd[T2]$
    Th = emptymesh(Th, ssd);
    //plot
    plot(Th);
    savemesh(Th, &quot;emptymesh.msh&quot;);
}
</pre></div>
</div>
<div class="figure" id="figemptymesh1">
<img alt="../_images/MeshGeneration_EmptyMesh1.png" src="../_images/MeshGeneration_EmptyMesh1.png" />
<p class="caption"><span class="caption-number">Fig. 10 </span><span class="caption-text">The empty mesh with boundary</span></p>
</div>
<div class="figure" id="figemptymesh2">
<img alt="../_images/MeshGeneration_EmptyMesh2.png" src="../_images/MeshGeneration_EmptyMesh2.png" />
<p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text">An empty mesh defined from a pseudo region numbering of triangle</span></p>
</div>
</div>
<div class="section" id="remeshing">
<h3>Remeshing<a class="headerlink" href="#remeshing" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="movemesh">
<h2>Movemesh<a class="headerlink" href="#movemesh" title="Permalink to this headline">¶</a></h2>
<p>Meshes can be translated, rotated, and deformed by
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>movemesh</code>; this is useful for elasticity to watch the
deformation due to the displacement
<span class="math notranslate nohighlight">\(\mathbf{\Phi}(x,y)=(\Phi_1(x,y),\Phi_2(x,y))\)</span> of shape.</p>
<p>It is also useful to handle free boundary problems or optimal shape
problems.</p>
<p>If <span class="math notranslate nohighlight">\(\Omega\)</span> is triangulated as <span class="math notranslate nohighlight">\(T_h(\Omega)\)</span>, and
<span class="math notranslate nohighlight">\(\mathbf{\Phi}\)</span> is a displacement vector then
<span class="math notranslate nohighlight">\(\mathbf{\Phi}(T_h)\)</span> is obtained by</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh Th = movemesh(Th,[Phi1, Phi2]);
</pre></div>
</div>
<p>Sometimes the transformed mesh is invalid because some triangles have
flipped over (meaning it now has a negative area). To spot such
problems, one may check the minimum triangle area in the transformed
mesh with <code class="code freefem docutils literal highlight highlight-freefem"><span></span>checkmovemesh</code> before any real transformation.</p>
<p>For example:
.. math:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>\Phi_1(x,y) &amp;=&amp; x+k*\sin(y*\pi)/10)\\
\Phi_2(x,y) &amp;=&amp; y+k*\cos(y\pi)/10)
</pre></div>
</div>
<p>for a big number <span class="math notranslate nohighlight">\(k&gt;1\)</span>.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>verbosity = 4;

// Parameters
real coef = 1;

// Mesh
border a(t=0, 1){x=t; y=0; label=1;};
border b(t=0, 0.5){x=1; y=t; label=1;};
border c(t=0, 0.5){x=1-t; y=0.5; label=1;};
border d(t=0.5, 1){x=0.5; y=t; label=1;};
border e(t=0.5, 1){x=1-t; y=1; label=1;};
border f(t=0, 1){x=0; y=1-t; label=1;};
mesh Th = buildmesh(a(6) + b(4) + c(4) + d(4) + e(4) + f(6));
plot(Th, wait=true, fill=true, ps=&quot;Lshape.eps&quot;);

// Function
func uu = sin(y*pi)/10;
func vv = cos(x*pi)/10;

// Checkmovemesh
real minT0 = checkmovemesh(Th, [x, y]); //return the min triangle area
while(1){ // find a correct move mesh
    real minT = checkmovemesh(Th, [x+coef*uu, y+coef*vv]);
    if (minT &gt; minT0/5) break; //if big enough
    coef /= 1.5;
}

// Movemesh
Th = movemesh(Th, [x+coef*uu, y+coef*vv]);
plot(Th, wait=true, fill=true, ps=&quot;MovedMesh.eps&quot;);
</pre></div>
</div>
<div class="figure" id="figlshape">
<img alt="../_images/MeshGeneration_MoveMesh1.png" src="../_images/MeshGeneration_MoveMesh1.png" />
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">L-shape</span></p>
</div>
<div class="figure" id="figmovedlshape">
<img alt="../_images/MeshGeneration_MoveMesh2.png" src="../_images/MeshGeneration_MoveMesh2.png" />
<p class="caption"><span class="caption-number">Fig. 13 </span><span class="caption-text">Moved L-shape</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Consider a function <span class="math notranslate nohighlight">\(u\)</span> defined on a mesh
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th</code>. A statement like <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th=movemesh(Th...)</code>
does not change <span class="math notranslate nohighlight">\(u\)</span> and so the old mesh still exists. It will be
destroyed when no function uses it. A statement like <span class="math notranslate nohighlight">\(u=u\)</span>
redefines <span class="math notranslate nohighlight">\(u\)</span> on the new mesh <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th</code> with interpolation
and therefore destroys the old <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th</code>, if <span class="math notranslate nohighlight">\(u\)</span> was the
only function using it.</p>
</div>
<p>Now, we give an example of moving a mesh with a Lagrangian function
<span class="math notranslate nohighlight">\(u\)</span> defined on the moving mesh.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
int nn = 10;
real dt = 0.1;

// Mesh
mesh Th = square(nn, nn);

// Fespace
fespace Vh(Th, P1);
Vh u=y;

// Loop
real t=0;
for (int i = 0; i &lt; 4; i++){
    t = i*dt;
    Vh f=x*t;
    real minarea = checkmovemesh(Th, [x, y+f]);
    if (minarea &gt; 0) //movemesh will be ok
    Th = movemesh(Th, [x, y+f]);

    cout &lt;&lt; &quot; Min area = &quot; &lt;&lt; minarea &lt;&lt; endl;

    real[int] tmp(u[].n);
    tmp = u[]; //save the value
    u = 0;//to change the FEspace and mesh associated with u
    u[] = tmp;//set the value of u without any mesh update
    plot(Th, u, wait=true);
}
// In this program, since u is only defined on the last mesh, all the
// previous meshes are deleted from memory.
</pre></div>
</div>
<div class="section" id="regular-triangulation-htriangle">
<h3>Regular Triangulation: hTriangle<a class="headerlink" href="#regular-triangulation-htriangle" title="Permalink to this headline">¶</a></h3>
<p>For a set <span class="math notranslate nohighlight">\(S\)</span>, we define the diameter of <span class="math notranslate nohighlight">\(S\)</span> by</p>
<div class="math notranslate nohighlight">
\[\textrm{diam}(S)=\sup\{|\mathbf{x}-\mathbf{y}|; \; \mathbf{x},\, \mathbf{y}\in S\}\]</div>
<p>The sequence <span class="math notranslate nohighlight">\(\{\mathcal{T}_h\}_{h\rightarrow 0}\)</span> of
<span class="math notranslate nohighlight">\(\Omega\)</span> is called <em>regular</em> if they satisfy the following:</p>
<ol class="arabic simple">
<li><span class="math notranslate nohighlight">\(\lim_{h\rightarrow 0}\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}=0\)</span></li>
<li>There is a number <span class="math notranslate nohighlight">\(\sigma&gt;0\)</span> independent of <span class="math notranslate nohighlight">\(h\)</span> such that
<span class="math notranslate nohighlight">\(\frac{\rho(T_k)}{\textrm{diam}(T_k)}\ge \sigma\quad \textrm{for all }T_k\in \mathcal{T}_h\)</span>
where <span class="math notranslate nohighlight">\(\rho(T_k)\)</span> are the diameter of the inscribed circle of
<span class="math notranslate nohighlight">\(T_k\)</span>.</li>
</ol>
<p>We put
<span class="math notranslate nohighlight">\(h(\mathcal{T}_h)=\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}\)</span>,
which is obtained by</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh Th = ......;
fespace Ph(Th, P0);
Ph h = hTriangle;
cout &lt;&lt; &quot;size of mesh = &quot; &lt;&lt; h[].max &lt;&lt; endl;
</pre></div>
</div>
</div>
<div class="section" id="adaptmesh">
<h3>Adaptmesh<a class="headerlink" href="#adaptmesh" title="Permalink to this headline">¶</a></h3>
<p>The function</p>
<div class="math notranslate nohighlight">
\[f(x,y) = 10.0x^3+y^3+\tan^{-1}[\varepsilon/(\sin(5.0y)-2.0x)],\ \varepsilon = 0.0001\]</div>
<p>sharply varies in value and the initial mesh given by one of the
commands in the <a class="reference external" href="##commands-for-mesh-generation">Mesh Generation
section</a> cannot reflect its sharp
variations.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
real eps = 0.0001;
real h = 1;
real hmin = 0.05;
func f = 10.0*x^3 + y^3 + h*atan2(eps, sin(5.0*y)-2.0*x);

// Mesh
mesh Th = square(5, 5, [-1+2*x, -1+2*y]);

// Fespace
fespace Vh(Th,P1);
Vh fh = f;
plot(fh);

// Adaptmesh
for (int i = 0; i &lt; 2; i++){
    Th = adaptmesh(Th, fh);
    fh = f; //old mesh is deleted
    plot(Th, fh, wait=true);
}
</pre></div>
</div>
<div class="figure" id="figmeshadaptation">
<img alt="../_images/MeshGeneration_AdaptMesh1.png" src="../_images/MeshGeneration_AdaptMesh1.png" />
<p class="caption"><span class="caption-number">Fig. 14 </span><span class="caption-text">3D graphs for the initial mesh and 1st and 2nd mesh adaptations</span></p>
</div>
<p>FreeFem++ uses a variable metric/Delaunay automatic meshing algorithm.</p>
<p>The command:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh ATh = adaptmesh(Th, f);
</pre></div>
</div>
<p>create the new mesh <code class="code freefem docutils literal highlight highlight-freefem"><span></span>ATh</code> adapted to the Hessian</p>
<div class="math notranslate nohighlight">
\[D^2f=(\partial^2 f/\partial x^2,\, \partial^2 f/\partial x\partial y, \partial^2 f/\partial y^2)\]</div>
<p>of a function (formula or FE-function).</p>
<p>Mesh adaptation is a very powerful tool when the solution of a problem
varies locally and sharply.</p>
<p>Here we solve the <a class="reference external" href="/tutorials/">Poisson’s problem</a>, when <span class="math notranslate nohighlight">\(f=1\)</span>
and <span class="math notranslate nohighlight">\(\Omega\)</span> is a L-shape domain.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Fig. 15: L-shape domain and its
boundary name</th>
<th class="head">Fig. 16: Final solution after
4-times adaptation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><img alt="L-shape2" src="../_images/MeshGeneration_AdaptMesh2.png" /></td>
<td><img alt="L Shape solution" src="../_images/MeshGeneration_AdaptMesh3.png" /></td>
</tr>
</tbody>
</table>
<p>!!!example “Example” The solution has the singularity
<span class="math notranslate nohighlight">\(r^{3/2},\, r=|x-\gamma|\)</span> at the point <span class="math notranslate nohighlight">\(\gamma\)</span> of the
intersection of two lines <span class="math notranslate nohighlight">\(bc\)</span> and <span class="math notranslate nohighlight">\(bd\)</span> (see Fig. 15).</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
real error = 0.1;

// Mesh
border ba(t=0, 1){x=t; y=0; label=1;}
border bb(t=0, 0.5){x=1; y=t; label=1;}
border bc(t=0, 0.5){x=1-t; y=0.5; label=1;}
border bd(t=0.5, 1){x=0.5; y=t; label=1;}
border be(t=0.5, 1){x=1-t; y=1; label=1;}
border bf(t=0, 1){x=0; y=1-t; label=1;}
mesh Th = buildmesh(ba(6) + bb(4) + bc(4) + bd(4) + be(4) + bf(6));

// Fespace
fespace Vh(Th, P1);
Vh u, v;

// Function
func f = 1;

// Problem
problem Poisson(u, v, solver=CG, eps=1.e-6)
    = int2d(Th)(
          dx(u)*dx(v)
        + dy(u)*dy(v)
    )
    - int2d(Th)(
          f*v
    )
    + on(1, u=0);

// Adaptmesh loop
for (int i = 0; i &lt; 4; i++){
    Poisson;
    Th = adaptmesh(Th, u, err=error);
    error = error/2;
}

// Plot
plot(u);
</pre></div>
</div>
<p>To speed up the adaptation, the default parameter <code class="code freefem docutils literal highlight highlight-freefem"><span></span>err</code> of
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>adaptmesh</code> is changed by hand; it specifies the required
precision, so as to make the new mesh finer or coarser.</p>
<p>The problem is coercive and symmetric, so the linear system can be
solved with the conjugate gradient method (parameter
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>solver=CG</code>) with the stopping criteria on the residual,
here <code class="code freefem docutils literal highlight highlight-freefem"><span></span>eps=1.e-6</code>).</p>
<p>By <code class="code freefem docutils literal highlight highlight-freefem"><span></span>adaptmesh</code>, the slope of the final solution is
correctly computed near the point of intersection of <span class="math notranslate nohighlight">\(bc\)</span> and
<span class="math notranslate nohighlight">\(bd\)</span> as in Fig. 16.</p>
<p>This method is described in detail in <a class="reference external" href="#refHecht1998">Hecht1998</a>. It
has a number of default parameters which can be modified.</p>
<p>If <code class="code freefem docutils literal highlight highlight-freefem"><span></span>f1,f2</code> are functions and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>thold, Thnew</code>
are meshes:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>Thnew = adaptmesh(Thold, f1 ... );
Thnew = adaptmesh(Thold, f1,f2 ... ]);
Thnew = adaptmesh(Thold, [f1,f2] ... );
</pre></div>
</div>
<p>The additional parameters of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>adaptmesh</code> are:</p>
<p>See <a class="reference external" href="/reference/Functions/#adaptmesh">Reference part</a> for more inforamtions</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>hmin=</code> Minimum edge size. Its default is related to the size of the domain to be meshed and the precision of the mesh generator.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>hmax=</code> Maximum edge size. It defaults to the diameter of the domain to be meshed.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>err=</code> <span class="math notranslate nohighlight">\(P_1\)</span> interpolation error level (0.01 is the default).</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>errg=</code> Relative geometrical error. By default this error is 0.01, and in any case it must be lower than <span class="math notranslate nohighlight">\(1/\sqrt{2}\)</span>.</li>
</ul>
<blockquote>
<div>Meshes created with this option may have some edges smaller than the <code class="code freefem docutils literal highlight highlight-freefem"><span></span>-hmin</code> due to geometrical constraints.</div></blockquote>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>nbvx=</code> Maximum number of vertices generated by the mesh generator (9000 is the default).</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>nbsmooth=</code> number of iterations of the smoothing procedure (5 is the default).</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>nbjacoby=</code> number of iterations in a smoothing procedure during the metric construction, 0 means no smoothing, 6 is the default.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>ratio=</code> ratio for a prescribed smoothing on the metric.</li>
</ul>
<blockquote>
<div>If the value is 0 or less than 1.1 no smoothing is done on the metric. 1.8 is the default.
If <code class="code freefem docutils literal highlight highlight-freefem"><span></span>ratio &gt; 1.1</code>, the speed of mesh size variations is bounded by <span class="math notranslate nohighlight">\(log(\mathtt{ratio})\)</span>.
.. note:: As <code class="code freefem docutils literal highlight highlight-freefem"><span></span>ratio</code> gets closer to 1, the number of generated vertices increases. This may be useful to control the thickness of refined regions near shocks or boundary layers.</div></blockquote>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>omega=</code> relaxation parameter for the smoothing procedure. 1.0 is the default.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>iso=</code> If true, forces the metric to be isotropic. <code class="code freefem docutils literal highlight highlight-freefem"><span></span>false</code> is the default.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>abserror=</code> If false, the metric is evaluated using the</li>
</ul>
<blockquote>
<div><p>criteria of equi-repartion of relative error. <code class="code freefem docutils literal highlight highlight-freefem"><span></span>false</code> is
the default. In this case the metric is defined by
.. math:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>\mathcal{M} = \left({1\over\mathtt{err}\,\, \mathtt{coef}^2} \quad {
|\mathcal{H}| \over max(\mathtt{CutOff},|\eta|)}\right)^p
</pre></div>
</div>
<p>Otherwise, the metric is evaluated using the
criteria of equi-distribution of errors. In this case the metric is
defined by
.. math:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>\mathcal{M} = \left({1\over \mathtt{err}\,\,\mathtt{coef}^2} \quad
{|{\mathcal{H}|} \over
{\sup(\eta)-\inf(\eta)}}\right)^p.\label{eq err abs}
</pre></div>
</div>
</div></blockquote>
<ul>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>cutoff=</code> lower limit for the relative error evaluation.
1.0e-6 is the default.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>verbosity=</code> informational messages level (can be chosen
between 0 and <span class="math notranslate nohighlight">\(\infty\)</span>). Also changes the value of the global
variable verbosity (obsolete).</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>inquire=</code> To inquire graphically about the mesh.
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>false</code> is the default.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>splitpbedge=</code> If true, splits all internal edges in
half with two boundary vertices. <code class="code freefem docutils literal highlight highlight-freefem"><span></span>true</code> is the default.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>maxsubdiv=</code> Changes the metric such that the maximum
subdivision of a background edge is bound by <code class="code freefem docutils literal highlight highlight-freefem"><span></span>val</code>.
Always limited by 10, and 10 is also the default.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>rescaling=</code> if true, the function, with respect to
which the mesh is adapted, is rescaled to be between 0 and 1.
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>true</code> is the default.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>keepbackvertices=</code> if true, tries to keep as many
vertices from the original mesh as possible. <code class="code freefem docutils literal highlight highlight-freefem"><span></span>true</code> is
the default.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>IsMetric=</code> if true, the metric is defined explicitly.
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>false</code> is the default. If the 3 functions
<span class="math notranslate nohighlight">\(m_{11}, m_{12}, m_{22}\)</span> are given, they directly define a
symmetric matrix field whose Hessian is computed to define a metric.
If only one function is given, then it represents the isotropic mesh
size at every point.</p>
<p>For example, if the partial derivatives <code class="code freefem docutils literal highlight highlight-freefem"><span></span>fxx</code>
(<span class="math notranslate nohighlight">\(=\partial^2 f/\partial x^2\)</span>), <code class="code freefem docutils literal highlight highlight-freefem"><span></span>fxy</code>
(<span class="math notranslate nohighlight">\(=\partial^2 f/\partial x\partial y\)</span>), <code class="code freefem docutils literal highlight highlight-freefem"><span></span>fyy</code>
(<span class="math notranslate nohighlight">\(=\partial^2 f/\partial y^2\)</span>) are given, we can set
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th = adaptmesh(Th, fxx, fxy, fyy, IsMetric=1, nbvx=10000, hmin=hmin);</code></p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>power=</code> exponent power of the Hessian used to compute
the metric. 1 is the default.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>thetamax=</code> minimum corner angle in degrees. Default is
<span class="math notranslate nohighlight">\(10^\circ\)</span> where the corner is <span class="math notranslate nohighlight">\(ABC\)</span> and the angle is the
angle of the two vectors <span class="math notranslate nohighlight">\({AB}, {BC}\)</span>, (<span class="math notranslate nohighlight">\(0\)</span> imply no
corner, <span class="math notranslate nohighlight">\(90\)</span> imply perpendicular corner, …).</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>splitin2=</code> boolean value. If true, splits all triangles
of the final mesh into 4 sub-triangles.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>metric=</code> an array of 3 real arrays to set or get metric
data information. The size of these three arrays must be the number
of vertices. So if <code class="code freefem docutils literal highlight highlight-freefem"><span></span>m11,m12,m22</code> are three P1 finite
elements related to the mesh to adapt, you can write:
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>metric=[m11[],m12[],m22[]]</code> (see file
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>convect-apt.edp</code> for a full example)</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>nomeshgeneration=</code> If true, no adapted mesh is
generated (useful to compute only a metric).</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>periodic=</code> Writing
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>periodic=[[4,y],[2,y],[1,x],[3,x]];</code> builds an adapted
periodic mesh. The sample builds a biperiodic mesh of a square. (see
<a class="reference external" href="../FiniteElement">periodic finite element spaces</a>, and see <a class="reference external" href="/examples/#sphere">the
Sphere example</a> for a full example)</p>
</li>
</ul>
<p>We can use the command <code class="code freefem docutils literal highlight highlight-freefem"><span></span>adaptmesh</code> to build a uniform mesh
with a constant mesh size. To build a mesh with a constant mesh size
equal to <span class="math notranslate nohighlight">\(\frac{1}{30}\)</span> try:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh Th=square(2, 2); //the initial mesh
plot(Th, wait=true, ps=&quot;square-0.eps&quot;);

Th = adaptmesh(Th, 1./30., IsMetric=1, nbvx=10000);
plot(Th, wait=true, ps=&quot;square-1.eps&quot;);

Th = adaptmesh(Th, 1./30., IsMetric=1, nbvx=10000); //More the one time du to
Th = adaptmesh(Th, 1./30., IsMetric=1, nbvx=10000); //Adaptation bound `maxsubdiv=`
plot(Th, wait=true, ps=&quot;square-2.eps&quot;);
</pre></div>
</div>
<p>Fig. 17: Initial mesh Fig. 18: First iteration Fig. 19: Last iteration</p>
<p><img alt="Initial mesh" src="../_images/MeshGeneration_AdaptMesh4.png" />        <img alt="First iteration" src="../_images/MeshGeneration_AdaptMesh5.png" />        <img alt="Last iteration" src="../_images/MeshGeneration_AdaptMesh6.png" /></p>
</div>
<div class="section" id="trunc">
<h3>Trunc<a class="headerlink" href="#trunc" title="Permalink to this headline">¶</a></h3>
<p>Two operators have been introduced to remove triangles from a mesh or to
divide them. Operator <code class="code freefem docutils literal highlight highlight-freefem"><span></span>trunc</code> has two parameters:</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>label=</code> sets the label number of new boundary item, one
by default.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>split=</code> sets the level <span class="math notranslate nohighlight">\(n\)</span> of triangle splitting.
Each triangle is split in <span class="math notranslate nohighlight">\(n\times n\)</span>, one by default.</li>
</ul>
<p>To create the mesh <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th3</code> where all triangles of a mesh
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th</code> are split in <span class="math notranslate nohighlight">\(3{\times}3\)</span>, just write:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh Th3 = trunc(Th, 1, split=3);
</pre></div>
</div>
<p>The following example construct all “trunced” meshes to the support of
the basic function of the space <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Vh</code>
(cf.&nbsp;<code class="code freefem docutils literal highlight highlight-freefem"><span></span>abs(u)&gt;0</code>), split all the triangles in
<span class="math notranslate nohighlight">\(5{\times} 5\)</span>, and put a label number to <span class="math notranslate nohighlight">\(2\)</span> on a new
boundary.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Mesh
mesh Th = square(3, 3);

// Fespace
fespace Vh(Th, P1);
Vh u=0;

// Loop on all degrees of freedom
int n=u.n;
for (int i = 0; i &lt; n; i++){
    u[][i] = 1; // The basis function i
    plot(u, wait=true);
    mesh Sh1 = trunc(Th, abs(u)&gt;1.e-10, split=5, label=2);
    plot(Th, Sh1, wait=true, ps=&quot;trunc&quot;+i+&quot;.eps&quot;);
    u[][i] = 0; // reset
}
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Fig. 20: mesh of support the
function P1 number 0, split in
<span class="math notranslate nohighlight">\(5{\times}5\)</span></th>
<th class="head">Fig. 21: Mesh of support the
function P1 number 6, split in
<span class="math notranslate nohighlight">\(5{\times}5\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><img alt="Trunc0" src="../_images/MeshGeneration_Trunc1.png" /></td>
<td><img alt="Trunc6" src="../_images/MeshGeneration_Trunc2.png" /></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="splitmesh">
<h3>Splitmesh<a class="headerlink" href="#splitmesh" title="Permalink to this headline">¶</a></h3>
<p>Another way to split mesh triangles is to use <code class="code freefem docutils literal highlight highlight-freefem"><span></span>splitmesh</code>,
for example:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Mesh
border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
mesh Th = buildmesh(a(20));
plot(Th, wait=true, ps=&quot;NotSplittedMesh.eps&quot;);

// Splitmesh
Th = splitmesh(Th, 1 + 5*(square(x-0.5) + y*y));
plot(Th, wait=true, ps=&quot;SplittedMesh.eps&quot;);
</pre></div>
</div>
</div>
<div class="section" id="meshing-examples">
<h3>Meshing Examples<a class="headerlink" href="#meshing-examples" title="Permalink to this headline">¶</a></h3>
<p>!!!example “Two rectangles touching by a side”
<code class="docutils literal highlight highlight-freefem"><span></span>freefem     border a(t=0, 1){x=t; y=0;};     border b(t=0, 1){x=1; y=t;};     border c(t=1, 0){x=t; y=1;};     border d(t=1, 0){x=0; y=t;};     border c1(t=0, 1){x=t; y=1;};     border e(t=0, 0.2){x=1; y=1+t;};     border f(t=1, 0){x=t; y=1.2;};     border g(t=0.2, 0){x=0; y=1+t;};     int n=1;     mesh th = buildmesh(a(10*n) + b(10*n) + c(10*n) + d(10*n));     mesh TH = buildmesh(c1(10*n) + e(5*n) + f(10*n) + g(5*n));     plot(th, TH, ps=&quot;TouchSide.esp&quot;);</code></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>&lt;center&gt;
&lt;!-- Review --&gt;
|&lt;a name=&quot;Fig24&quot;&gt;Fig. 24&lt;/a&gt;: Two rectangles touching by a side|
|:----:|
|![Rectangles touching by a side](images/MeshGeneration_Example_NACA0012_1.png)|

&lt;/center&gt;
</pre></div>
</div>
<p>!!!example “NACA0012 Airfoil”
<code class="docutils literal highlight highlight-freefem"><span></span>freefem     border upper(t=0, 1){         x=t;         y=0.17735*sqrt(t) - 0.075597*t - 0.212836*(t^2) + 0.17363*(t^3) - 0.06254*(t^4);     }     border lower(t=1, 0){         x = t;         y=-(0.17735*sqrt(t) -0.075597*t - 0.212836*(t^2) + 0.17363*(t^3) - 0.06254*(t^4));     }     border c(t=0, 2*pi){x=0.8*cos(t) + 0.5; y=0.8*sin(t);}     mesh Th = buildmesh(c(30) + upper(35) + lower(35));     plot(Th, ps=&quot;NACA0012.eps&quot;, bw=true);</code></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>&lt;center&gt;
</pre></div>
</div>
<p>&lt;table border=”1” class=”docutils”&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=”center”&gt;&lt;a name=”Fig25”&gt;Fig. 25&lt;/a&gt;: NACA0012 Airfoil&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=”center”&gt;&lt;img alt=”NACA0012 Airfoil” src=”images/MeshGeneration_Example_NACA0012_2.png” /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<blockquote>
<div>&lt;/center&gt;</div></blockquote>
<p>&lt;table border=”1” class=”docutils”&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=”center”&gt;&lt;a name=”Fig26”&gt;Fig. 26&lt;/a&gt;: Domain with Cardioid curve boundary&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=”center”&gt;&lt;img alt=”Cardiod” src=”images/MeshGeneration_Example_Cardioid1.png” /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<p>!!!example “Cassini Egg”
<code class="docutils literal highlight highlight-freefem"><span></span>freefem     border C(t=0, 2*pi) {x=(2*cos(2*t)+3)*cos(t); y=(2*cos(2*t)+3)*sin(t);}     mesh Th = buildmesh(C(50));     plot(Th, ps=&quot;Cassini.eps&quot;, bw=true);</code></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>&lt;center&gt;
</pre></div>
</div>
<p>&lt;table border=”1” class=”docutils”&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=”center”&gt;&lt;a name=”Fig27”&gt;Fig. 27&lt;/a&gt;: Domain with Cassini Egg curve boundary&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=”center”&gt;&lt;img alt=”Cassini” src=”images/MeshGeneration_Example_Cardioid2.png” /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<blockquote>
<div>&lt;/center&gt;</div></blockquote>
<p>!!!example “By cubic Bezier curve” ```freefem // A cubic Bezier curve
connecting two points with two control points func real bzi(real p0,
real p1, real q1, real q2, real t){ return p0<em>(1-t)^3 +
q1</em>3<em>(1-t)2t + q23(1-t)t2 + p1</em>t^3; }</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>real[int] p00 = [0, 1], p01 = [0, -1], q00 = [-2, 0.1], q01 = [-2, -0.5];
real[int] p11 = [1,-0.9], q10 = [0.1, -0.95], q11=[0.5, -1];
real[int] p21 = [2, 0.7], q20 = [3, -0.4], q21 = [4, 0.5];
real[int] q30 = [0.5, 1.1], q31 = [1.5, 1.2];
border G1(t=0, 1){
    x=bzi(p00[0], p01[0], q00[0], q01[0], t);
    y=bzi(p00[1], p01[1], q00[1], q01[1], t);
}
border G2(t=0, 1){
    x=bzi(p01[0], p11[0], q10[0], q11[0], t);
    y=bzi(p01[1], p11[1], q10[1], q11[1], t);
}
border G3(t=0, 1){
    x=bzi(p11[0], p21[0], q20[0], q21[0], t);
    y=bzi(p11[1], p21[1], q20[1], q21[1], t);
}
border G4(t=0, 1){
    x=bzi(p21[0], p00[0], q30[0], q31[0], t);
    y=bzi(p21[1], p00[1], q30[1], q31[1], t);
}
int m = 5;
mesh Th = buildmesh(G1(2*m) + G2(m) + G3(3*m) + G4(m));
plot(Th, ps=&quot;Bezier.eps&quot;, bw=true);
```

&lt;center&gt;
</pre></div>
</div>
<p>&lt;table border=”1” class=”docutils”&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=”center”&gt;&lt;a name=”Fig28”&gt;Fig. 28&lt;/a&gt;: Boundary drawn by Bezier curves&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=”center”&gt;&lt;img alt=”Bezier” src=”images/MeshGeneration_Example_Bezier.png” /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<blockquote>
<div>&lt;/center&gt;</div></blockquote>
<p>!!!example “Section of Engine” ```freefem real a = 6., b = 1., c = 0.5;</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>border L1(t=0, 1){x=-a; y=1+b-2*(1+b)*t;}
border L2(t=0, 1){x=-a+2*a*t; y=-1-b*(x/a)*(x/a)*(3-2*abs(x)/a );}
border L3(t=0, 1){x=a; y=-1-b+(1+b)*t; }
border L4(t=0, 1){x=a-a*t; y=0;}
border L5(t=0, pi){x=-c*sin(t)/2; y=c/2-c*cos(t)/2;}
border L6(t=0, 1){x=a*t; y=c;}
border L7(t=0, 1){x=a; y=c+(1+b-c)*t;}
border L8(t=0, 1){x=a-2*a*t; y=1+b*(x/a)*(x/a)*(3-2*abs(x)/a);}
mesh Th = buildmesh(L1(8) + L2(26) + L3(8) + L4(20) + L5(8) + L6(30) + L7(8) + L8(30));
plot(Th, ps=&quot;Engine.eps&quot;, bw=true);
```

&lt;center&gt;
</pre></div>
</div>
<p>&lt;table border=”1” class=”docutils”&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=”left”&gt;&lt;a name=”Fig29”&gt;Fig. 29&lt;/a&gt;: Section of Engine&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=”left”&gt;&lt;img alt=”Engine” src=”images/MeshGeneration_Example_Engine.png” /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<blockquote>
<div>&lt;/center&gt;</div></blockquote>
<p>!!!example “Domain with U-shape channel”
<code class="docutils literal highlight highlight-freefem"><span></span>freefem     real d = 0.1; //width of U-shape     border L1(t=0, 1-d){x=-1; y=-d-t;}     border L2(t=0, 1-d){x=-1; y=1-t;}     border B(t=0, 2){x=-1+t; y=-1;}     border C1(t=0, 1){x=t-1; y=d;}     border C2(t=0, 2*d){x=0; y=d-t;}     border C3(t=0, 1){x=-t; y=-d;}     border R(t=0, 2){x=1; y=-1+t;}     border T(t=0, 2){x=1-t; y=1;}     int n = 5;     mesh Th = buildmesh(L1(n/2) + L2(n/2) + B(n) + C1(n) + C2(3) + C3(n) + R(n) + T(n));     plot(Th, ps=&quot;U-shape.eps&quot;, bw=true);</code></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>&lt;center&gt;
</pre></div>
</div>
<p>&lt;table border=”1” class=”docutils”&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=”left”&gt;&lt;a name=”Fig30”&gt;Fig. 30&lt;/a&gt;: Domain with U-shape channel changed by :freefem&lt;code&gt;d&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=”left”&gt;&lt;img alt=”U-Shape” src=”images/MeshGeneration_Example_UShape.png” /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<blockquote>
<div>&lt;/center&gt;</div></blockquote>
<p>!!!example “Domain with V-shape cut”
<code class="docutils literal highlight highlight-freefem"><span></span>freefem     real dAg = 0.02; //angle of V-shape     border C(t=dAg, 2*pi-dAg){x=cos(t); y=sin(t);};     real[int] pa(2), pb(2), pc(2);     pa[0] = cos(dAg);     pa[1] = sin(dAg);     pb[0] = cos(2*pi-dAg);     pb[1] = sin(2*pi-dAg);     pc[0] = 0;     pc[1] = 0;     border seg1(t=0, 1){x=(1-t)*pb[0]+t*pc[0]; y=(1-t)*pb[1]+t*pc[1];};     border seg2(t=0, 1){x=(1-t)*pc[0]+t*pa[0]; y=(1-t)*pc[1]+t*pa[1];};     mesh Th = buildmesh(seg1(20) + C(40) + seg2(20));     plot(Th, ps=&quot;V-shape.eps&quot;, bw=true);</code></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>&lt;center&gt;
</pre></div>
</div>
<p>&lt;table border=”1” class=”docutils”&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=”left”&gt;&lt;a name=”Fig31”&gt;Fig. 31&lt;/a&gt;: Domain with V-shape cut changed by :freefem:&lt;code&gt;dAg&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=”left”&gt;&lt;img alt=”V-Shape” src=”images/MeshGeneration_Example_VShape.png” /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<blockquote>
<div>&lt;/center&gt;</div></blockquote>
<p>!!!example “Smiling face” ```freefem real d=0.1; int m = 5; real a =
1.5, b = 2, c = 0.7, e = 0.01;</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>border F(t=0, 2*pi){x=a*cos(t); y=b*sin(t);}
border E1(t=0, 2*pi){x=0.2*cos(t)-0.5; y=0.2*sin(t)+0.5;}
border E2(t=0, 2*pi){x=0.2*cos(t)+0.5; y=0.2*sin(t)+0.5;}
func real st(real t){
    return sin(pi*t) - pi/2;
}
border C1(t=-0.5, 0.5){x=(1-d)*c*cos(st(t)); y=(1-d)*c*sin(st(t));}
border C2(t=0, 1){x=((1-d)+d*t)*c*cos(st(0.5)); y=((1-d)+d*t)*c*sin(st(0.5));}
border C3(t=0.5, -0.5){x=c*cos(st(t)); y=c*sin(st(t));}
border C4(t=0, 1){x=(1-d*t)*c*cos(st(-0.5)); y=(1-d*t)*c*sin(st(-0.5));}
border C0(t=0, 2*pi){x=0.1*cos(t); y=0.1*sin(t);}

mesh Th=buildmesh(F(10*m) + C1(2*m) + C2(3) + C3(2*m) + C4(3)
    + C0(m) + E1(-2*m) + E2(-2*m));
plot(Th, ps=&quot;SmileFace.eps&quot;, bw=true);
```

&lt;center&gt;
</pre></div>
</div>
<p>&lt;table border=”1” class=”docutils”&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=”center”&gt;&lt;a name=”Fig32”&gt;Fig. 32&lt;/a&gt;: Smiling face (Mouth is changeable)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=”center”&gt;&lt;img alt=”Smiling Face” src=”images/MeshGeneration_Example_SmilingFace.png” /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<blockquote>
<div>&lt;/center&gt;</div></blockquote>
<p>!!!example “3 points bending” ```freefem // Square for Three-Point Bend
Specimens fixed on Fix1, Fix2 // It will be loaded on Load. real a = 1,
b = 5, c = 0.1; int n = 5, m = b<em>n; border Left(t=0, 2</em>a){x=-b;
y=a-t;} border Bot1(t=0, b/2-c){x=-b+t; y=-a;} border Fix1(t=0,
2<em>c){x=-b/2-c+t; y=-a;} border Bot2(t=0, b-2</em>c){x=-b/2+c+t; y=-a;}
border Fix2(t=0, 2<em>c){x=b/2-c+t; y=-a;} border Bot3(t=0,
b/2-c){x=b/2+c+t; y=-a;} border Right(t=0, 2</em>a){x=b; y=-a+t;} border
Top1(t=0, b-c){x=b-t; y=a;} border Load(t=0, 2*c){x=c-t; y=a;} border
Top2(t=0, b-c){x=-c-t; y=a;}</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh Th = buildmesh(Left(n) + Bot1(m/4) + Fix1(5) + Bot2(m/2)
    + Fix2(5) + Bot3(m/4) + Right(n) + Top1(m/2) + Load(10) + Top2(m/2));
plot(Th, ps=&quot;ThreePoint.eps&quot;, bw=true);
```

&lt;center&gt;
</pre></div>
</div>
<p>&lt;table border=”1” class=”docutils”&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=”left”&gt;&lt;a name=”Fig33”&gt;Fig. 33&lt;/a&gt;: Domain for three-point bending test&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=”left”&gt;&lt;img alt=”Three-point bending test” src=”images/MeshGeneration_Example_ThreePoints.png” /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<blockquote>
<div>&lt;/center&gt;</div></blockquote>
</div>
<div class="section" id="how-to-change-the-label-of-elements-and-border-elements-of-a-mesh">
<h3>How to change the label of elements and border elements of a mesh<a class="headerlink" href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh" title="Permalink to this headline">¶</a></h3>
<p>Changing the label of elements and border elements will be done using
the keyword <code class="code freefem docutils literal highlight highlight-freefem"><span></span>change</code>. The parameters for this command line
are for two dimensional and three dimensional cases:</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>label =</code> is a vector of integer that contains
successive pairs of the old label number to the new label number.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>region =</code> is a vector of integer that contains
successive pairs of the old region number to new region number.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>flabel =</code> is an integer function given the new value of
the label.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>fregion=</code> is an integer function given the new value of
the region.</li>
</ul>
<p>These vectors are composed of <span class="math notranslate nohighlight">\(n_{l}\)</span> successive pairs of numbers
<span class="math notranslate nohighlight">\(O,N\)</span> where <span class="math notranslate nohighlight">\(n_{l}\)</span> is the number (label or region) that we
want to change. For example, we have :</p>
<div class="math notranslate nohighlight" id="equation-eq-org-vector-change-label">
<span class="eqno">(1)<a class="headerlink" href="#equation-eq-org-vector-change-label" title="Permalink to this equation">¶</a></span>\[\begin{split}\mathtt{label} &amp;= &amp;[ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ] \\
\mathtt{region} &amp; =&amp; [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ]\end{split}\]</div>
<p>An example of using this function is given here:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>verbosity=3;

// Mesh
mesh Th1 = square(10, 10);
mesh Th2 = square(20, 10, [x+1, y]);

int[int] r1=[2,0];
plot(Th1, wait=true);

Th1 = change(Th1, label=r1); //change the label of Edges 2 in 0.
plot(Th1, wait=true);

int[int] r2=[4,0];
Th2 = change(Th2, label=r2); //change the label of Edges 4 in 0.
plot(Th2, wait=true);

mesh Th = Th1 + Th2; //&#39;gluing together&#39; of meshes Th1 and Th2
cout &lt;&lt; &quot;nb lab = &quot; &lt;&lt; int1d(Th1,1,3,4)(1./lenEdge)+int1d(Th2,1,2,3)(1./lenEdge)
     &lt;&lt; &quot; == &quot; &lt;&lt; int1d(Th,1,2,3,4)(1./lenEdge) &lt;&lt; &quot; == &quot; &lt;&lt; ((10+20)+10)*2 &lt;&lt; endl;
plot(Th, wait=true);

fespace Vh(Th, P1);
Vh u, v;

macro Grad(u) [dx(u),dy(u)] // Definition of a macro

solve P(u, v)
    = int2d(Th)(
          Grad(u)&#39;*Grad(v)
    )
    -int2d(Th)(
          v
    )
    + on(1, 3, u=0)
    ;

plot(u, wait=1);
</pre></div>
</div>
<p><strong>“gluing” different mesh</strong> In line 17 of the previous file, the method
to “gluing” different meshes of the same dimension in FreeFem++ is
using. This function is the operator “+” between meshes. The method
implemented needs the point in adjacent meshes to be the same.</p>
</div>
<div class="section" id="mesh-in-three-dimensions">
<h3>Mesh in three dimensions<a class="headerlink" href="#mesh-in-three-dimensions" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="cube">
<h2>Cube<a class="headerlink" href="#cube" title="Permalink to this headline">¶</a></h2>
<p>A new function <code class="code freefem docutils literal highlight highlight-freefem"><span></span>cube</code> like the function
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>square</code> in 2d is the simple way to a build cubic object,
in plugin <code class="code freefem docutils literal highlight highlight-freefem"><span></span>msh3</code> (need <code class="code freefem docutils literal highlight highlight-freefem"><span></span>load &quot;msh3&quot;</code>).</p>
<p>The following code generates a <span class="math notranslate nohighlight">\(3\times 4 \times 5\)</span> grid in the
unit cube <span class="math notranslate nohighlight">\([0, 1]^3\)</span>.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh3 Th = cube(3, 4, 5);
</pre></div>
</div>
<p>By default the labels are :</p>
<ol class="arabic simple">
<li>face <span class="math notranslate nohighlight">\(y=0\)</span>,</li>
<li>face <span class="math notranslate nohighlight">\(x=1\)</span>,</li>
<li>face <span class="math notranslate nohighlight">\(y=1\)</span>,</li>
<li>face <span class="math notranslate nohighlight">\(x=0\)</span>,</li>
<li>face <span class="math notranslate nohighlight">\(z=0\)</span>,</li>
<li>face <span class="math notranslate nohighlight">\(z=1\)</span></li>
</ol>
<p>and the region number is <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>A full example of this function to build a mesh of cube <span class="math notranslate nohighlight">\(]-1,1[^3\)</span>
with face label given by <span class="math notranslate nohighlight">\((ix + 4*(iy+1) + 16*(iz+1))\)</span> where
<span class="math notranslate nohighlight">\((ix, iy, iz)\)</span> are the coordinates of the barycenter of the
current face, is given below.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>load &quot;msh3&quot;

int[int] l6 = [37, 42, 45, 40, 25, 57];
int r11 = 11;
mesh3 Th = cube(4, 5, 6, [x*2-1, y*2-1, z*2-1], label=l6, flags =3, region=r11);

cout &lt;&lt; &quot;Volume = &quot; &lt;&lt; Th.measure &lt;&lt; &quot;, border area = &quot; &lt;&lt; Th.bordermeasure &lt;&lt; endl;

int err = 0;
for(int i = 0; i &lt; 100; ++i){
    real s = int2d(Th,i)(1.);
    real sx = int2d(Th,i)(x);
    real sy = int2d(Th,i)(y);
    real sz = int2d(Th,i)(z);

    if(s){
        int ix = (sx/s+1.5);
        int iy = (sy/s+1.5);
        int iz = (sz/s+1.5);
        int ii = (ix + 4*(iy+1) + 16*(iz+1) );
        //value of ix,iy,iz =&gt; face min 0, face max 2, no face 1
        cout &lt;&lt; &quot;Label = &quot; &lt;&lt; i &lt;&lt; &quot;, s = &quot; &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; ix &lt;&lt; iy &lt;&lt; iz &lt;&lt; &quot; : &quot; &lt;&lt; ii &lt;&lt; endl;
        if( i != ii ) err++;
    }
}
real volr11 = int3d(Th,r11)(1.);
cout &lt;&lt; &quot;Volume region = &quot; &lt;&lt; 11 &lt;&lt; &quot;: &quot; &lt;&lt; volr11 &lt;&lt; endl;
if((volr11 - Th.measure )&gt;1e-8) err++;
plot(Th, fill=false);
cout &lt;&lt; &quot;Nb err = &quot; &lt;&lt; err &lt;&lt; endl;
assert(err==0);
</pre></div>
</div>
<p>The output of this script is:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>Enter: BuildCube: 3
  kind = 3 n tet Cube = 6 / n slip 6 19
Cube  nv=210 nt=720 nbe=296
Out:  BuildCube
Volume = 8, border area = 24
Label = 25, s = 4 110 : 25
Label = 37, s = 4 101 : 37
Label = 40, s = 4 011 : 40
Label = 42, s = 4 211 : 42
Label = 45, s = 4 121 : 45
Label = 57, s = 4 112 : 57
Volume region = 11: 8
Nb err = 0
</pre></div>
</div>
<center><p>Fig. 34: The mesh 3d of function <code class="code freefem docutils literal highlight highlight-freefem"><span></span>cube(4, 5, 6, flags=3)</code></p>
<p><img alt="Function cube mesh" src="../_images/MeshGeneration_Cube.jpg" /></p>
</center></div>
<div class="section" id="read-write-statements-for-a-mesh-in-3d">
<h2>Read/Write Statements for a Mesh in 3D<a class="headerlink" href="#read-write-statements-for-a-mesh-in-3d" title="Permalink to this headline">¶</a></h2>
<p>In three dimensions, the file mesh format supported for input and output
files by FreeFem++ are the extension .msh and .mesh. These formats are
described in the <a class="reference external" href="../Developers/#mesh-format">Mesh Format section</a>
.</p>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">todo</p>
</div>
<p><strong>Extension file .msh</strong> The structure of the files with extension .msh
in 3D is given in Table 2..</p>
<p>In this structure, <span class="math notranslate nohighlight">\(n_v\)</span> denotes the number of vertices,
<span class="math notranslate nohighlight">\(n_{tet}\)</span> the number of tetrahedra and <span class="math notranslate nohighlight">\(n_{tri}\)</span> the number
of triangles.</p>
<p>For each vertex <span class="math notranslate nohighlight">\(q^i,\, i=1,\cdots,n_v\)</span>, we denote by
<span class="math notranslate nohighlight">\((q^i_x,q^i_y,q^i_z)\)</span> the <span class="math notranslate nohighlight">\(x\)</span>-coordinate, the
<span class="math notranslate nohighlight">\(y\)</span>-coordinate and the <span class="math notranslate nohighlight">\(z\)</span>-coordinate.</p>
<p>Each tetrahedra <span class="math notranslate nohighlight">\(T_k, k=1,\cdots,n_{tet}\)</span> has four vertices
<span class="math notranslate nohighlight">\(q^{k_1},\, q^{k_2},\,q^{k_3}, \,q^{k_4}\)</span>.</p>
<p>The boundary consists of a union of triangles. Each triangle
<span class="math notranslate nohighlight">\(be_j, j=1,\cdots,n_{tri}\)</span> has three vertices
<span class="math notranslate nohighlight">\(q^{j_1},\, q^{j_2},\,q^{j_3}\)</span>.</p>
<center></center><p><strong>extension file .mesh</strong> The data structure for a three dimensional mesh
is composed of the data structure presented in <a class="reference external" href="../Developers/#mesh-format">Mesh Format
section</a> and a data
structure for the tetrahedra. The tetrahedra of a three dimensional mesh
are referred using the following field:</p>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">todo</p>
</div>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>Tetrahedra
NbTetrahedra
Vertex1 Vertex2 Vertex3 Vertex4 Label
...
Vertex1 Vertex2 Vertex3 Vertex4 Label
</pre></div>
</div>
<p>This field is express with the notation of <a class="reference external" href="../Developers/#mesh-format">Mesh Format
section</a> .</p>
<div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Todo</p>
<p class="last">todo</p>
</div>
</div>
<div class="section" id="tetgen-a-tetrahedral-mesh-generator">
<h2>TetGen: A tetrahedral mesh generator<a class="headerlink" href="#tetgen-a-tetrahedral-mesh-generator" title="Permalink to this headline">¶</a></h2>
<p><strong>TetGen</strong></p>
<p>TetGen is a software developed by Dr.&nbsp;Hang Si of Weierstrass Institute
for Applied Analysis and Stochastics in Berlin, Germany
<a class="reference external" href="#refHang2006">Hang2006</a>. TetGen is free for research and
non-commercial use. For any commercial license utilization, a commercial
license is available upon request to Hang Si.</p>
<p>This software is a tetrahedral mesh generator of a three dimensional
domain defined by its boundary. The input domain takes into account a
polyhedral or a piecewise linear complex. This tetrahedralization is a
constrained Delaunay tetrahedralization.</p>
<p>The method used in TetGen to control the quality of the mesh is a
Delaunay refinement due to Shewchuk <a class="reference external" href="#refShewchuk1998">Shewchuk1998</a>.
The quality measure of this algorithm is the Radius-Edge Ratio (see
Section 1.3.1 <a class="reference external" href="#refHang2006">Hang2006</a> for more details). A
theoretical bound of this ratio of the Shewchuk algorithm is obtained
for a given complex of vertices, constrained segments and facets of
surface mesh, with no input angle less than 90 degrees. This theoretical
bound is 2.0.</p>
<p>The launch of TetGen is done with the keyword <code class="code freefem docutils literal highlight highlight-freefem"><span></span>tetg</code>. The
parameters of this command line is:</p>
<ul>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>reftet=</code> sets the label of tetrahedra.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>label=</code> is a vector of integers that contains the old
labels number at index <span class="math notranslate nohighlight">\(2i\)</span> and the new labels number at index
<span class="math notranslate nohighlight">\(2i+1\)</span> of Triangles. This parameter is initialized as a label
for the keyword
<a class="reference external" href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh">change</a>.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>switch=</code> A string expression. This string corresponds
to the command line switch of TetGen see Section 3.2 of
<a class="reference external" href="#refHang2006">Hang2006</a>.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>nbofholes=</code> Number of holes (default value: “size of
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>holelist</code> / 3”).</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>holelist=</code> This array corresponds to
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>holelist</code> of TetGenio data structure
<a class="reference external" href="#refHang2006">Hang2006</a>. A real vector of size
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>3 * nbofholes</code>. In TetGen, each hole is associated with
a point inside this domain. This vector is
<span class="math notranslate nohighlight">\(x_{1}^{h}, y_{1}^{h}, z_{1}^{h}, x_{2}^{h}, y_{2}^{h}, z_{2}^{h}, \cdots,\)</span>
where <span class="math notranslate nohighlight">\(x_{i}^{h},y_{i}^{h},z_{i}^{h}\)</span> is the associated point
with the <span class="math notranslate nohighlight">\(i^{\mathrm{th}}\)</span> hole.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>nbofregions=</code> Number of regions (default value: “size
of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>regionlist</code> / 5”).</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>regionlist=</code> This array corresponds to
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>regionlist</code> of TetGenio data structure
<a class="reference external" href="#refHang2006">Hang2006</a>.</p>
<p>The attribute and the volume constraint of region are given in this
real vector of size <code class="code freefem docutils literal highlight highlight-freefem"><span></span>5 * nbofregions</code>. The
<span class="math notranslate nohighlight">\(i^{\mathrm{th}}\)</span> region is described by five elements:
<span class="math notranslate nohighlight">\(x-\)</span>coordinate, <span class="math notranslate nohighlight">\(y-\)</span>coordinate and
<span class="math notranslate nohighlight">\(z-\)</span>coordinate of a point inside this domain
(<span class="math notranslate nohighlight">\(x_{i},y_{i},z_{i}\)</span>); the attribute (<span class="math notranslate nohighlight">\(at_{i}\)</span>) and the
maximum volume for tetrahedra (<span class="math notranslate nohighlight">\(mvol_{i}\)</span>) for this region.</p>
<p>The <code class="code freefem docutils literal highlight highlight-freefem"><span></span>regionlist</code> vector is:
<span class="math notranslate nohighlight">\(x_{1}, y_{1}, z_{1}, at_{1}, mvol_{1}, x_{2}, y_{2}, z_{2}, at_{2}, mvol_{2}, \cdots\)</span>.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>nboffacetcl=</code> Number of facets constraints “size of
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>facetcl</code> / 2”).</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>facetcl=</code> This array corresponds to
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>facetconstraintlist</code> of TetGenio data structure
<a class="reference external" href="#refHang2006">Hang2006</a>.</p>
<p>The <span class="math notranslate nohighlight">\(i^{th}\)</span> facet constraint is defined by the facet marker
<span class="math notranslate nohighlight">\(Ref_{i}^{fc}\)</span> and the maximum area for faces
<span class="math notranslate nohighlight">\(marea_{i}^{fc}\)</span>. The <code class="code freefem docutils literal highlight highlight-freefem"><span></span>facetcl</code> array is:
<span class="math notranslate nohighlight">\(Ref_{1}^{fc}, marea_{1}^{fc}, Ref_{2}^{fc}, marea_{2}^{fc}, \cdots\)</span>.</p>
<p>This parameters has no effect if switch <code class="code freefem docutils literal highlight highlight-freefem"><span></span>q</code> is not
selected.</p>
</li>
</ul>
<p>Principal switch parameters in TetGen:</p>
<ul>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>p</code> Tetrahedralization of boundary.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>q</code> Quality mesh generation. The bound of Radius-Edge
Ratio will be given after the option <code class="code freefem docutils literal highlight highlight-freefem"><span></span>q</code>. By default,
this value is 2.0.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>a</code> Constructs with the volume constraints on
tetrahedra. These volumes constraints are defined with the bound of
the previous switch <code class="code freefem docutils literal highlight highlight-freefem"><span></span>q</code> or in the parameter
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>regionlist</code>.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>A</code> Attributes reference to region given in the
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>regionlist</code>. The other regions have label 0.</p>
<p>The option <code class="docutils literal highlight highlight-freefem"><span></span>AA</code> gives a different label at each region. This switch
works with the option <code class="code freefem docutils literal highlight highlight-freefem"><span></span>p</code>. If option :freefem`r` is
used, this switch has no effect.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>r</code> Reconstructs and Refines a previously generated
mesh. This character is only used with the command line
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>tetgreconstruction</code>.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>Y</code> This switch preserves the mesh on the exterior
boundary.</p>
<p>This switch must be used to ensure a conformal mesh between two
adjacent meshes.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>YY</code> This switch preserves the mesh on the exterior and
interior boundary.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>C</code> The consistency of the result’s mesh is testing by
TetGen.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>CC</code> The consistency of the result’s mesh is testing by
TetGen and also constrained checks of Delaunay mesh (if
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>p</code> switch is selected) or the consistency of Conformal
Delaunay (if <code class="code freefem docutils literal highlight highlight-freefem"><span></span>q</code> switch is selected).</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>V</code> Give information of the work of TetGen. More
information can be obtained in specified <code class="code freefem docutils literal highlight highlight-freefem"><span></span>VV</code> or
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>VVV</code>.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>Q</code> Quiet: No terminal output except errors</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>M</code> The coplanar facets are not merging.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>T</code> Sets a tolerance for coplanar test. The default
value is <span class="math notranslate nohighlight">\(1e-8\)</span>.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>d</code> Intersections of facets are detected.</p>
</li>
</ul>
<p>To obtain a tetrahedral mesh with TetGen, we need the surface mesh of a
three dimensional domain. We now give the command line in FreeFem++ to
construct these meshes.</p>
<p><strong>keyword: :freefem:`movemesh23`</strong></p>
<p>A simple method to construct a surface is to place a two dimensional
domain in a three dimensional space. This corresponds to moving the
domain by a displacement vector of this form
<span class="math notranslate nohighlight">\(\mathbf{\Phi(x,y)} = (\Phi1(x,y), \Phi2(x,y), \Phi3(x,y))\)</span>.</p>
<p>The result of moving a two dimensional mesh Th2 by this three
dimensional displacement is obtained using:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh3 Th3 = movemesh23(Th2, transfo=[Phi(1), Phi(2), Phi(3)]);
</pre></div>
</div>
<p>The parameters of this command line are:</p>
<ul>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>transfo=</code> [<span class="math notranslate nohighlight">\(\Phi 1\)</span>, <span class="math notranslate nohighlight">\(\Phi 2\)</span>,
<span class="math notranslate nohighlight">\(\Phi 3\)</span>] sets the displacement vector of transformation
<span class="math notranslate nohighlight">\(\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]\)</span>.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>label=</code> sets an integer label of triangles.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>orientation=</code> sets an integer orientation of mesh.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>ptmerge=</code> A real expression. When you transform a mesh,
some points can be merged. This parameter is the criteria to define
two merging points. By default, we use</p>
<div class="math notranslate nohighlight">
\[ptmerge \: = \: 1e-7 \: \:Vol( B ),\]</div>
<p>where <span class="math notranslate nohighlight">\(B\)</span> is the smallest axis, parallel boxes containing the
discretized domain of <span class="math notranslate nohighlight">\(\Omega\)</span> and <span class="math notranslate nohighlight">\(Vol(B)\)</span> is the volume
of this box.</p>
</li>
</ul>
<p>We can do a “gluing” of surface meshes using the process given in
<a class="reference external" href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh">Change
section</a>.
An example to obtain a three dimensional mesh using the command line
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>tetg</code> and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>movemesh23</code> is given below.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>load &quot;msh3&quot;
load &quot;tetgen&quot;

// Parameters
real x10 = 1.;
real x11 = 2.;
real y10 = 0.;
real y11 = 2.*pi;

func ZZ1min = 0;
func ZZ1max = 1.5;
func XX1 = x;
func YY1 = y;

real x20 = 1.;
real x21 = 2.;
real y20=0.;
real y21=1.5;

func ZZ2 = y;
func XX2 = x;
func YY2min = 0.;
func YY2max = 2*pi;

real x30=0.;
real x31=2*pi;
real y30=0.;
real y31=1.5;

func XX3min = 1.;
func XX3max = 2.;
func YY3 = x;
func ZZ3 = y;

// Mesh
mesh Thsq1 = square(5, 35, [x10+(x11-x10)*x, y10+(y11-y10)*y]);
mesh Thsq2 = square(5, 8, [x20+(x21-x20)*x, y20+(y21-y20)*y]);
mesh Thsq3 = square(35, 8, [x30+(x31-x30)*x, y30+(y31-y30)*y]);

// Mesh 2D to 3D surface
mesh3 Th31h = movemesh23(Thsq1, transfo=[XX1, YY1, ZZ1max]);
mesh3 Th31b = movemesh23(Thsq1, transfo=[XX1, YY1, ZZ1min]);

mesh3 Th32h = movemesh23(Thsq2, transfo=[XX2, YY2max, ZZ2]);
mesh3 Th32b = movemesh23(Thsq2, transfo=[XX2, YY2min, ZZ2]);

mesh3 Th33h = movemesh23(Thsq3, transfo=[XX3max, YY3, ZZ3]);
mesh3 Th33b = movemesh23(Thsq3, transfo=[XX3min, YY3, ZZ3]);

// Gluing surfaces
mesh3 Th33 = Th31h + Th31b + Th32h + Th32b + Th33h + Th33b;
plot(Th33, cmm=&quot;Th33&quot;);

// Tetrahelize the interior of the cube with TetGen
real[int] domain =[1.5, pi, 0.75, 145, 0.0025];
mesh3 Thfinal = tetg(Th33, switch=&quot;paAAQY&quot;, regionlist=domain);
plot(Thfinal, cmm=&quot;Thfinal&quot;);

// Build a mesh of a half cylindrical shell of interior radius 1, and exterior radius 2 and a height of 1.5
func mv2x = x*cos(y);
func mv2y = x*sin(y);
func mv2z = z;
mesh3 Thmv2 = movemesh3(Thfinal, transfo=[mv2x, mv2y, mv2z]);
plot(Thmv2, cmm=&quot;Thmv2&quot;);
</pre></div>
</div>
<p>The command <code class="code freefem docutils literal highlight highlight-freefem"><span></span>movemesh3</code> is described in the following
section.</p>
<p><strong>The keyword :freefem:`tetgtransfo`</strong></p>
<p>This keyword corresponds to a composition of command line
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>tetg</code> and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>movemesh23</code>.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>tetgtransfo(Th2, transfo=[Phi(1), Phi(2), Phi(3)]), ...) = tetg(Th3surf, ...),
</pre></div>
</div>
<p>where
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th3surf = movemesh23(Th2, transfo=[Phi(1), Phi(2), Phi(3)])</code>
and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th2</code> is the input two dimensional mesh of
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>tetgtransfo</code>.</p>
<p>The parameters of this command line are, on one hand, the parameters
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>label</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>switch</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>regionlist</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>nboffacetcl</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>facetcl</code> of keyword
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>tetg</code> and on the other hand, the parameter
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>ptmerge</code> of keyword <code class="code freefem docutils literal highlight highlight-freefem"><span></span>movemesh23</code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To use <code class="code freefem docutils literal highlight highlight-freefem"><span></span>tetgtransfo</code>, the result’s mesh of
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>movemesh23</code> must be a closed surface and define one region
only. Therefore, the parameter <code class="code freefem docutils literal highlight highlight-freefem"><span></span>regionlist</code> is defined for
one region.</p>
</div>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>An example of this keyword can be found in line 61 of the [Build layer mesh example](/examples/#build-layer-mesh).
</pre></div>
</div>
<p><strong>The keyword :freefem:`tetgconvexhull`</strong></p>
<p>FreeFem++, using TetGen, is able to build a tetrahedralization from a
set of points. This tetrahedralization is a Delaunay mesh of the convex
hull of the set of points.</p>
<p>The coordinates of the points can be initialized in two ways. The first
is a file that contains the coordinate of points
<span class="math notranslate nohighlight">\(X_{i}=(x_{i}, y_{i}, z_{i})\)</span>. This file is organized as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{ccc}
n_{v} &amp; &amp; \\
x_{1} &amp; y_{1} &amp; z_{1} \\
x_{2} &amp; y_{2} &amp; z_{2} \\
\vdots &amp;\vdots &amp; \vdots \\
x_{n_v} &amp; y_{n_v} &amp; z_{n_v}
\end{array}\end{split}\]</div>
<p>The second way is to give three arrays that correspond respectively to
the <span class="math notranslate nohighlight">\(x-\)</span>coordinates, <span class="math notranslate nohighlight">\(y-\)</span>coordinates and
<span class="math notranslate nohighlight">\(z-\)</span>coordinates.</p>
<p>The parameters of this command line are :</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>switch=</code> A string expression. This string corresponds
to the command line <code class="code freefem docutils literal highlight highlight-freefem"><span></span>switch</code> of TetGen see Section 3.2
of <a class="reference external" href="#refHang2006">Hang2006</a>.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>reftet=</code> An integer expression. Set the label of
tetrahedra.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>label=</code> An integer expression. Set the label of
triangles.</li>
</ul>
<p>In the string <code class="code freefem docutils literal highlight highlight-freefem"><span></span>switch</code>, we can’t used the option
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>p</code> and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>q</code> of TetGen.</p>
</div>
<div class="section" id="reconstruct-refine-a-three-dimensional-mesh-with-tetgen">
<h2>Reconstruct/Refine a three dimensional mesh with TetGen<a class="headerlink" href="#reconstruct-refine-a-three-dimensional-mesh-with-tetgen" title="Permalink to this headline">¶</a></h2>
<p>Meshes in three dimension can be refined using TetGen with the command
line <code class="code freefem docutils literal highlight highlight-freefem"><span></span>tetgreconstruction</code>.</p>
<p>The parameter of this keyword are</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>region=</code> an integer array that changes the region
number of tetrahedra. This array is defined as the parameter
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>reftet</code> in the keyword <code class="code freefem docutils literal highlight highlight-freefem"><span></span>change</code>.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>label=</code> an integer array that changes the label of
boundary triangles. This array is defined as the parameter
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>label</code> in the keyword <code class="code freefem docutils literal highlight highlight-freefem"><span></span>change</code>.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>sizeofvolume=</code> a reel function. This function
constraints the volume size of the tetrahedra in the domain. (see
<a class="reference external" href="#a-first-3d-isotrope-mesh-adaptation-process">Isotrope mesh adaption
section</a> to build a
3d adapted mesh).</li>
</ul>
<p>The parameters <code class="code freefem docutils literal highlight highlight-freefem"><span></span>switch</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>nbofregions</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>regionlist</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>nboffacetcl</code> and
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>facetcl</code> of the command line which call TetGen
(<code class="code freefem docutils literal highlight highlight-freefem"><span></span>tetg</code>) is used for <code class="code freefem docutils literal highlight highlight-freefem"><span></span>tetgrefine</code>.</p>
<p>In the parameter <code class="code freefem docutils literal highlight highlight-freefem"><span></span>switch=</code>, the character <code class="code freefem docutils literal highlight highlight-freefem"><span></span>r</code>
should be used without the character <code class="code freefem docutils literal highlight highlight-freefem"><span></span>p</code>.</p>
<p>For instance, see the manual of TetGen <a class="reference external" href="#refHang2006">Hang2006</a> for
effect of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>r</code> to other character.</p>
<p>The parameter <code class="code freefem docutils literal highlight highlight-freefem"><span></span>regionlist</code> defines a new volume constraint
in the region. The label in the <code class="code freefem docutils literal highlight highlight-freefem"><span></span>regionlist</code> will be the
previous label of region.</p>
<p>This parameter and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>nbofregions</code> can’t be used with the
parameter <code class="code freefem docutils literal highlight highlight-freefem"><span></span>sizeofvolume</code>.</p>
<p><strong>Example :freefem:`refinesphere.edp`</strong></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>load &quot;msh3&quot;
load &quot;TetGen&quot;
load &quot;medit&quot;

mesh Th = square(10, 20, [x*pi-pi/2, 2*y*pi]); // $]-pi/2, pi/2[X]0, 2pi[ $

// A parametrization of a sphere
func f1 = cos(x)*cos(y);
func f2 = cos(x)*sin(y);
func f3 = sin(x);
// Partial derivative of the parametrization DF
func f1x = sin(x)*cos(y);
func f1y = -cos(x)*sin(y);
func f2x = -sin(x)*sin(y);
func f2y = cos(x)*cos(y);
func f3x = cos(x);
func f3y = 0;
// M = DF^t DF
func m11 = f1x^2 + f2x^2 + f3x^2;
func m21 = f1x*f1y + f2x*f2y + f3x*f3y;
func m22 = f1y^2 + f2y^2 + f3y^2;

// Mesh adaptation
func perio = [[4, y], [2, y], [1, x], [3, x]];
real hh = 0.1;
real vv = 1/square(hh);
verbosity = 2;
Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
plot(Th, wait=true);

// Construction of the surface of spheres
real Rmin = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

mesh3 Th3 = movemesh23(Th, transfo=[f1min, f2min, f3min]);

// Contruct the volume
real[int] domain = [0., 0., 0., 145, 0.01];
mesh3 Th3sph = tetg(Th3, switch=&quot;paAAQYY&quot;, nbofregions=1, regionlist=domain);

// Refine
int[int] newlabel = [145, 18];
real[int] domainrefine = [0., 0., 0., 145, 0.0001];
mesh3 Th3sphrefine = tetgreconstruction(Th3sph, switch=&quot;raAQ&quot;, reftet=newlabel,
    nbofregions=1, regionlist=domain, sizeofvolume=0.0001);

// Re-Refine
int[int] newlabel2 = [145, 53];
func fsize = 0.01/((1 + 5*sqrt((x-0.5)^2+(y-0.5)^2+(z-0.5)^2))^3);
mesh3 Th3sphrefine2 = tetgreconstruction(Th3sph, switch=&quot;raAQ&quot;, reftet=newlabel2,
    sizeofvolume=fsize);

// Medit
medit(&quot;sphere&quot;, Th3sph);
medit(&quot;isotroperefine&quot;, Th3sphrefine);
medit(&quot;anisotroperefine&quot;, Th3sphrefine2);
</pre></div>
</div>
</div>
<div class="section" id="moving-mesh-in-three-dimensions">
<h2>Moving mesh in three dimensions<a class="headerlink" href="#moving-mesh-in-three-dimensions" title="Permalink to this headline">¶</a></h2>
<p>Meshes in three dimensions can be translated, rotated, and deformed
using the command line <code class="code freefem docutils literal highlight highlight-freefem"><span></span>movemesh</code> as in the 2D case (see
<cite>section :freefem:`movemesh</cite> &lt;#movemesh&gt;`__). If <span class="math notranslate nohighlight">\(\Omega\)</span> is
tetrahedrized as <span class="math notranslate nohighlight">\(T_{h}(\Omega)\)</span>, and
<span class="math notranslate nohighlight">\(\Phi(x,y)=(\Phi1(x,y,z), \Phi2(x,y,z), \Phi3(x,y,z))\)</span> is a
displacement vector then <span class="math notranslate nohighlight">\(\Phi(T_{h})\)</span> is obtained by</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>mesh3 Th = movemesh(Th, [$\Phi$1, $\Phi$2, $\Phi$3], ...);
</pre></div>
</div>
<p>The parameters of movemesh in three dimensions are:</p>
<ul>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>region=</code> sets the integer labels of the tetrahedra. 0
by default.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>label=</code> sets the labels of the border faces. This
parameter is initialized as the label for the keyword
<cite>:freefem:`change</cite> &lt;#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh&gt;`__.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>facemerge=</code> An integer expression. When you transform a
mesh, some faces can be merged. This parameter equals to one if the
merges’ faces is considered. Otherwise it equals to zero. By default,
this parameter is equal to 1.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>ptmerge =</code> A real expression. When you transform a
mesh, some points can be merged. This parameter is the criteria to
define two merging points. By default, we use</p>
<div class="math notranslate nohighlight">
\[ptmerge \: = \: 1e-7 \: \:Vol( B ),\]</div>
<p>where <span class="math notranslate nohighlight">\(B\)</span> is the smallest axis parallel boxes containing the
discretion domain of <span class="math notranslate nohighlight">\(\Omega\)</span> and <span class="math notranslate nohighlight">\(Vol(B)\)</span> is the volume
of this box.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>orientation =</code> An integer expression (1 by default), to
reverse or not to reverse the orientation of the tetrahedra if it is
not positive.</p>
</li>
</ul>
<p>An example of this command can be found in the <a class="reference external" href="/examples/#poissons-equation-3d">Poisson’s equation 3D
example</a>.</p>
</div>
<div class="section" id="layer-mesh">
<h2>Layer mesh<a class="headerlink" href="#layer-mesh" title="Permalink to this headline">¶</a></h2>
<p>In this section, we present the command line to obtain a Layer mesh:
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>buildlayers</code>. This mesh is obtained by extending a two
dimensional mesh in the <span class="math notranslate nohighlight">\(z\)</span>-axis.</p>
<p>The domain <span class="math notranslate nohighlight">\(\Omega_{3d}\)</span> defined by the layer mesh is equal to
<span class="math notranslate nohighlight">\(\Omega_{3d} = \Omega_{2d} \times [zmin, zmax]\)</span> where
<span class="math notranslate nohighlight">\(\Omega_{2d}\)</span> is the domain defined by the two dimensional meshes.
<span class="math notranslate nohighlight">\(zmin\)</span> and <span class="math notranslate nohighlight">\(zmax\)</span> are functions of <span class="math notranslate nohighlight">\(\Omega_{2d}\)</span> in
<span class="math notranslate nohighlight">\(\R\)</span> that defines respectively the lower surface and upper surface
of <span class="math notranslate nohighlight">\(\Omega_{3d}\)</span>.</p>
<center><p>Fig. 35: Example of Layer mesh in three dimensions.</p>
<p><img alt="Layer Mesh 3D" src="../_images/MeshGeneration_LayerMesh.png" /></p>
</center><p>For a vertex of a two dimensional mesh
<span class="math notranslate nohighlight">\(V_{i}^{2d} = (x_{i},y_{i})\)</span>, we introduce the number of
associated vertices in the <span class="math notranslate nohighlight">\(z-\)</span>axis <span class="math notranslate nohighlight">\(M_{i}+1\)</span>.</p>
<p>We denote by <span class="math notranslate nohighlight">\(M\)</span> the maximum of <span class="math notranslate nohighlight">\(M_{i}\)</span> over the vertices of
the two dimensional mesh. This value is called the number of layers (if
<span class="math notranslate nohighlight">\(\forall i, \; M_{i}=M\)</span> then there are <span class="math notranslate nohighlight">\(M\)</span> layers in the
mesh of <span class="math notranslate nohighlight">\(\Omega_{3d}\)</span>). <span class="math notranslate nohighlight">\(V_{i}^{2d}\)</span> generated <span class="math notranslate nohighlight">\(M+1\)</span>
vertices which are defined by :</p>
<div class="math notranslate nohighlight">
\[\forall j=0, \ldots, M, \quad V_{i,j}^{3d} = ( x_{i}, y_{i}, \theta_{i}(z_{i,j}) ),\]</div>
<p>where <span class="math notranslate nohighlight">\((z_{i,j})_{j=0,\ldots,M}\)</span> are the <span class="math notranslate nohighlight">\(M+1\)</span> equidistant
points on the interval <span class="math notranslate nohighlight">\([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d})]\)</span>:</p>
<p><a href="#id1"><span class="problematic" id="id2">:raw-latex:`\begin{eqnarray*}
z_{i,j} = j \: \delta \alpha + zmin(V_{i}^{2d}), \quad \delta \alpha= \frac{ zmax( V_{i}^{2d} ) - zmin( V_{i}^{2d}) }{M}.
\end{eqnarray*}`</span></a></p>
<p>The function <span class="math notranslate nohighlight">\(\theta_{i}\)</span>, defined on
<span class="math notranslate nohighlight">\([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]\)</span>, is given by :</p>
<div class="math notranslate nohighlight">
\[\begin{split}\theta_{i}(z) = \left \{
\begin{array}{cl}
\theta_{i,0} &amp; \mbox{if} \: z=zmin(V_{i}^{2d}), \\
\theta_{i,j} &amp; \mbox{if} \: z \in ] \theta_{i,j-1}, \theta_{i,j}],\\
\end{array}
\right.\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\((\theta_{i,j})_{j=0,\ldots,M_{i}}\)</span> are the <span class="math notranslate nohighlight">\(M_{i}+1\)</span>
equidistant points on the interval
<span class="math notranslate nohighlight">\([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]\)</span>.</p>
<p>Set a triangle <span class="math notranslate nohighlight">\(K=(V_{i1}^{2d}\)</span>, <span class="math notranslate nohighlight">\(V_{i2}^{2d}\)</span>,
<span class="math notranslate nohighlight">\(V_{i3}^{2d})\)</span> of the two dimensional mesh. <span class="math notranslate nohighlight">\(K\)</span> is
associated with a triangle on the upper surface (resp. on the lower
surface) of layer mesh:</p>
<p><span class="math notranslate nohighlight">\(( V_{i1,M}^{3d}, V_{i2,M}^{3d}, V_{i3,M}^{3d} )\)</span> (resp.
<span class="math notranslate nohighlight">\(( V_{i1,0}^{3d}, V_{i2,0}^{3d}, V_{i3,0}^{3d})\)</span>).</p>
<p>Also <span class="math notranslate nohighlight">\(K\)</span> is associated with <span class="math notranslate nohighlight">\(M\)</span> volume prismatic elements
which are defined by :</p>
<div class="math notranslate nohighlight">
\[\forall j=0,\ldots,M, \quad H_{j} = ( V_{i1,j}^{3d}, V_{i2,j}^{3d}, V_{i3,j}^{3d}, V_{i1,j+1}^{3d}, V_{i2,j+1}^{3d}, V_{i3,j+1}^{3d} ).\]</div>
<p>Theses volume elements can have some merged point:</p>
<ul class="simple">
<li>0 merged point : prism</li>
<li>1 merged points : pyramid</li>
<li>2 merged points : tetrahedra</li>
<li>3 merged points : no elements</li>
</ul>
<p>The elements with merged points are called degenerate elements. To
obtain a mesh with tetrahedra, we decompose the pyramid into two
tetrahedra and the prism into three tetrahedra. These tetrahedra are
obtained by cutting the quadrilateral face of pyramid and prism with the
diagonal which have the vertex with the maximum index (see
<a class="reference external" href="#refHecht1992">Hecht1992</a>} for the reason of this choice).</p>
<p>The triangles on the middle surface obtained with the decomposition of
the volume prismatic elements are the triangles generated by the edges
on the border of the two dimensional mesh. The label of triangles on the
border elements and tetrahedra are defined with the label of these
associated elements.</p>
<p>The arguments of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>buildlayers</code> is a two dimensional mesh
and the number of layers <span class="math notranslate nohighlight">\(M\)</span>.</p>
<p>The parameters of this command are:</p>
<ul>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>zbound=</code> <span class="math notranslate nohighlight">\([zmin,zmax]\)</span> where <span class="math notranslate nohighlight">\(zmin\)</span> and
<span class="math notranslate nohighlight">\(zmax\)</span> are functions expression. Theses functions define the
lower surface mesh and upper mesh of surface mesh.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>coef=</code> A function expression between [0,1]. This
parameter is used to introduce degenerate element in mesh.</p>
<p>The number of associated points or vertex <span class="math notranslate nohighlight">\(V_{i}^{2d}\)</span> is the
integer part of <span class="math notranslate nohighlight">\(coef(V_{i}^{2d}) M\)</span>.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>region=</code> This vector is used to initialize the region
of tetrahedra.</p>
<p>This vector contains successive pairs of the 2d region number at
index <span class="math notranslate nohighlight">\(2i\)</span> and the corresponding 3d region number at index
<span class="math notranslate nohighlight">\(2i+1\)</span>, like
<cite>:freefem:`change</cite> &lt;#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh&gt;`__.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>labelmid=</code> This vector is used to initialize the 3d
labels number of the vertical face or mid face from the 2d label
number.</p>
<p>This vector contains successive pairs of the 2d label number at index
<span class="math notranslate nohighlight">\(2i\)</span> and the corresponding 3d label number at index
<span class="math notranslate nohighlight">\(2i+1\)</span>, like
<cite>:freefem:`change</cite> &lt;#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh&gt;`__.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>labelup=</code> This vector is used to initialize the 3d
label numbers of the upper/top face from the 2d region number.</p>
<p>This vector contains successive pairs of the 2d region number at
index <span class="math notranslate nohighlight">\(2i\)</span> and the corresponding 3d label number at index
<span class="math notranslate nohighlight">\(2i+1\)</span>, like
<cite>:freefem:`change</cite> &lt;#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh&gt;`__.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>labeldown=</code> Same as the previous case but for the
lower/down face label.</p>
</li>
</ul>
<p>Moreover, we also add post processing parameters that allow to moving
the mesh. These parameters correspond to parameters
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>transfo</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>facemerge</code> and
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>ptmerge</code> of the command line <code class="code freefem docutils literal highlight highlight-freefem"><span></span>movemesh</code>.</p>
<p>The vector <code class="code freefem docutils literal highlight highlight-freefem"><span></span>region</code>, <code class="code freefem docutils literal highlight highlight-freefem"><span></span>labelmid</code>,
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>labelup</code> and <code class="code freefem docutils literal highlight highlight-freefem"><span></span>labeldown</code> These vectors are
composed of <span class="math notranslate nohighlight">\(n_{l}\)</span> successive pairs of number <span class="math notranslate nohighlight">\(O_i,N_l\)</span>
where <span class="math notranslate nohighlight">\(n_{l}\)</span> is the number (label or region) that we want to get.</p>
<p>An example of this command is given in the <a class="reference external" href="/examples/#build-layer-mesh">Build layer mesh
example</a>.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>func mesh3 Cube (int[int] &amp;NN, real[int, int] &amp;BB, int[int, int] &amp;L){
    real x0 = BB(0,0), x1 = BB(0,1);
    real y0 = BB(1,0), y1 = BB(1,1);
    real z0 = BB(2,0), z1 = BB(2,1);

    int nx = NN[0], ny = NN[1], nz = NN[2];

    // 2D mesh
    mesh Thx = square(nx, ny, [x0+(x1-x0)*x, y0+(y1-y0)*y]);

    // 3D mesh
    int[int] rup = [0, L(2,1)], rdown=[0, L(2,0)];
    int[int] rmid=[1, L(1,0), 2, L(0,1), 3, L(1,1), 4, L(0,0)];
    mesh3 Th = buildlayers(Thx, nz, zbound=[z0,z1],
        labelmid=rmid, labelup = rup, labeldown = rdown);

    return Th;
}
```
</pre></div>
</div>
<p>!!!example “Unit cube” ```freefem include “Cube.idp”</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>int[int] NN = [10,10,10]; //the number of step in each direction
real [int, int] BB = [[0,1],[0,1],[0,1]]; //the bounding box
int [int, int] L = [[1,2],[3,4],[5,6]]; //the label of the 6 face left,right, front, back, down, right
mesh3 Th = Cube(NN, BB, L);
medit(&quot;Th&quot;, Th);
```

&lt;center&gt;
</pre></div>
</div>
<p>&lt;table border=”1” class=”docutils”&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=”center”&gt;&lt;a name=”Fig36”&gt;Fig. 36&lt;/a&gt;: The mesh of a cube made with :freefem:&lt;code&gt;cube.edp&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=”center”&gt;&lt;img alt=”Cube” src=”images/MeshGeneration_LayerMesh_Example1.png” /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<blockquote>
<div>&lt;/center&gt;</div></blockquote>
<p>!!!example “Cone” An axisymtric mesh on a triangle with degenerateness
```freefem load “msh3” load “medit”</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
real RR = 1;
real HH = 1;

int nn=10;

// 2D mesh
border Taxe(t=0, HH){x=t; y=0; label=0;}
border Hypo(t=1, 0){x=HH*t; y=RR*t; label=1;}
border Vert(t=0, RR){x=HH; y=t; label=2;}
mesh Th2 = buildmesh(Taxe(HH*nn) + Hypo(sqrt(HH*HH+RR*RR)*nn) + Vert(RR*nn));
plot(Th2, wait=true);

// 3D mesh
real h = 1./nn;
int MaxLayersT = (int(2*pi*RR/h)/4)*4;//number of layers
real zminT = 0;
real zmaxT = 2*pi; //height 2*pi
func fx = y*cos(z);
func fy = y*sin(z);
func fz = x;
int[int] r1T = [0,0], r2T = [0,0,2,2], r4T = [0,2];
//trick function:
//The function defined the proportion
//of number layer close to axis with reference MaxLayersT
func deg = max(.01, y/max(x/HH, 0.4)/RR);
mesh3 Th3T = buildlayers(Th2, coef=deg, MaxLayersT,
    zbound=[zminT, zmaxT], transfo=[fx, fy, fz],
    facemerge=0, region=r1T, labelmid=r2T);
medit(&quot;cone&quot;, Th3T);
```

&lt;center&gt;
</pre></div>
</div>
<p>&lt;table border=”1” class=”docutils”&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=”center”&gt;&lt;a name=”Fig37”&gt;Fig. 37&lt;/a&gt;: the mesh of a cone made with :freefem:&lt;code&gt;cone.edp&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=”center”&gt;&lt;img alt=”Cone” src=”images/MeshGeneration_LayerMesh_Example2.png” /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<blockquote>
<div>&lt;/center&gt;</div></blockquote>
<p>!!!example “Buildlayer mesh” ```freefem load “msh3” load “TetGen” load
“medit”</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
int C1 = 99;
int C2 = 98;

// 2D mesh
border C01(t=0, pi){x=t; y=0; label=1;}
border C02(t=0, 2*pi){ x=pi; y=t; label=1;}
border C03(t=0, pi){ x=pi-t; y=2*pi; label=1;}
border C04(t=0, 2*pi){ x=0; y=2*pi-t; label=1;}

border C11(t=0, 0.7){x=0.5+t; y=2.5; label=C1;}
border C12(t=0, 2){x=1.2; y=2.5+t; label=C1;}
border C13(t=0, 0.7){x=1.2-t; y=4.5; label=C1;}
border C14(t=0, 2){x=0.5; y=4.5-t; label=C1;}

border C21(t=0, 0.7){x=2.3+t; y=2.5; label=C2;}
border C22(t=0, 2){x=3; y=2.5+t; label=C2;}
border C23(t=0, 0.7){x=3-t; y=4.5; label=C2;}
border C24(t=0, 2){x=2.3; y=4.5-t; label=C2;}

mesh Th = buildmesh(C01(10) + C02(10) + C03(10) + C04(10)
    + C11(5) + C12(5) + C13(5) + C14(5)
    + C21(-5) + C22(-5) + C23(-5) + C24(-5));

mesh Ths = buildmesh(C01(10) + C02(10) + C03(10) + C04(10)
    + C11(5) + C12(5) + C13(5) + C14(5));

// Construction of a box with one hole and two regions
func zmin = 0.;
func zmax = 1.;
int MaxLayer = 10;

func XX = x*cos(y);
func YY = x*sin(y);
func ZZ = z;

int[int] r1 = [0, 41], r2 = [98, 98, 99, 99, 1, 56];
int[int] r3 = [4, 12];//the triangles of uppper surface mesh
                      //generated by the triangle in the 2D region
                      //of mesh Th of label 4 as label 12
int[int] r4 = [4, 45];//the triangles of lower surface mesh
                      //generated by the triangle in the 2D region
                      //of mesh Th of label 4 as label 45.

mesh3 Th3 = buildlayers(Th, MaxLayer, zbound=[zmin, zmax], region=r1,
    labelmid=r2, labelup=r3, labeldown=r4);
medit(&quot;box 2 regions 1 hole&quot;, Th3);

// Construction of a sphere with TetGen
func XX1 = cos(y)*sin(x);
func YY1 = sin(y)*sin(x);
func ZZ1 = cos(x);

real[int] domain = [0., 0., 0., 0, 0.001];
string test = &quot;paACQ&quot;;
cout &lt;&lt; &quot;test = &quot; &lt;&lt; test &lt;&lt; endl;
mesh3 Th3sph = tetgtransfo(Ths, transfo=[XX1, YY1, ZZ1],
    switch=test, nbofregions=1, regionlist=domain);
medit(&quot;sphere 2 regions&quot;, Th3sph);
```
</pre></div>
</div>
<div class="section" id="meshing-examples-1">
<span id="id3"></span><h3>Meshing examples<a class="headerlink" href="#meshing-examples-1" title="Permalink to this headline">¶</a></h3>
<p>!!!example “lake” ```freefem load “msh3” load “medit”</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
int nn = 5;

// 2D mesh
border cc(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
mesh Th2 = buildmesh(cc(100));

// 3D mesh
int[int] rup = [0, 2], rlow = [0, 1];
int[int] rmid = [1, 1, 2, 1, 3, 1, 4, 1];
func zmin = 2-sqrt(4-(x*x+y*y));
func zmax = 2-sqrt(3.);

mesh3 Th = buildlayers(Th2, nn,
    coef=max((zmax-zmin)/zmax, 1./nn),
    zbound=[zmin,zmax],
    labelmid=rmid,
    labelup=rup,
    labeldown=rlow);

medit(&quot;Th&quot;, Th);
```
</pre></div>
</div>
<p>!!!example “Hole region” ```freefem load “msh3” load “TetGen” load
“medit”</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// 2D mesh
mesh Th = square(10, 20, [x*pi-pi/2, 2*y*pi]); // ]-pi/2, pi/2[X]0,2pi[

// 3D mesh
//parametrization of a sphere
func f1 = cos(x)*cos(y);
func f2 = cos(x)*sin(y);
func f3 = sin(x);
//partial derivative of the parametrization
func f1x = sin(x)*cos(y);
func f1y = -cos(x)*sin(y);
func f2x = -sin(x)*sin(y);
func f2y = cos(x)*cos(y);
func f3x = cos(x);
func f3y = 0;
//M = DF^t DF
func m11 = f1x^2 + f2x^2 + f3x^2;
func m21 = f1x*f1y + f2x*f2y + f3x*f3y;
func m22 = f1y^2 + f2y^2 + f3y^2;

func perio = [[4, y], [2, y], [1, x], [3, x]];
real hh = 0.1;
real vv = 1/square(hh);
verbosity = 2;
Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
plot(Th, wait=true);

//construction of the surface of spheres
real Rmin = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

mesh3 Th3sph = movemesh23(Th, transfo=[f1min, f2min, f3min]);

real Rmax = 2.;
func f1max = Rmax*f1;
func f2max = Rmax*f2;
func f3max = Rmax*f3;

mesh3 Th3sph2 = movemesh23(Th, transfo=[f1max, f2max, f3max]);

//gluing meshse
mesh3 Th3 = Th3sph + Th3sph2;

cout &lt;&lt; &quot; TetGen call without hole &quot; &lt;&lt; endl;
real[int] domain2 = [1.5, 0., 0., 145, 0.001, 0.5, 0., 0., 18, 0.001];
mesh3 Th3fin = tetg(Th3, switch=&quot;paAAQYY&quot;, nbofregions=2, regionlist=domain2);
medit(&quot;Sphere with two regions&quot;, Th3fin);

cout &lt;&lt; &quot; TetGen call with hole &quot; &lt;&lt; endl;
real[int] hole = [0.,0.,0.];
real[int] domain = [1.5, 0., 0., 53, 0.001];
mesh3 Th3finhole = tetg(Th3, switch=&quot;paAAQYY&quot;,
    nbofholes=1, holelist=hole, nbofregions=1, regionlist=domain);
medit(&quot;Sphere with a hole&quot;, Th3finhole);
```
</pre></div>
</div>
</div>
</div>
<div class="section" id="build-a-3d-mesh-of-a-cube-with-a-balloon">
<h2>Build a 3d mesh of a cube with a balloon<a class="headerlink" href="#build-a-3d-mesh-of-a-cube-with-a-balloon" title="Permalink to this headline">¶</a></h2>
<p>First the <code class="docutils literal highlight highlight-freefem"><span></span>MeshSurface.idp</code> file to build boundary mesh of a Hexaedra
and of a Sphere:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>func mesh3 SurfaceHex (int[int] &amp;N, real[int, int] &amp;B, int[int, int] &amp;L, int orientation){
    real x0 = B(0, 0), x1 = B(0, 1);
    real y0 = B(1, 0), y1 = B(1, 1);
    real z0 = B(2, 0), z1 = B(2, 1);

    int nx = N[0], ny = N[1], nz = N[2];

    mesh Thx = square(ny, nz, [y0+(y1-y0)*x, z0+(z1-z0)*y]);
    mesh Thy = square(nx, nz, [x0+(x1-x0)*x, z0+(z1-z0)*y]);
    mesh Thz = square(nx, ny, [x0+(x1-x0)*x, y0+(y1-y0)*y]);

    int[int] refx = [0, L(0,0)], refX = [0, L(0,1)]; //Xmin, Ymax faces labels renumbering
    int[int] refy = [0, L(1,0)], refY = [0, L(1,1)]; //Ymin, Ymax faces labesl renumbering
    int[int] refz = [0, L(2,0)], refZ = [0, L(2,1)]; //Zmin, Zmax faces labels renumbering

    mesh3 Thx0 = movemesh23(Thx, transfo=[x0, x, y], orientation=-orientation, label=refx);
    mesh3 Thx1 = movemesh23(Thx, transfo=[x1, x, y], orientation=+orientation, label=refX);
    mesh3 Thy0 = movemesh23(Thy, transfo=[x, y0, y], orientation=+orientation, label=refy);
    mesh3 Thy1 = movemesh23(Thy, transfo=[x, y1, y], orientation=-orientation, label=refY);
    mesh3 Thz0 = movemesh23(Thz, transfo=[x, y, z0], orientation=-orientation, label=refz);
    mesh3 Thz1 = movemesh23(Thz, transfo=[x, y, z1], orientation=+orientation, label=refZ);
    mesh3 Th = Thx0 + Thx1 + Thy0 + Thy1 + Thz0 + Thz1;

    return Th;
}

func mesh3 Sphere (real R, real h, int L, int orientation){
    mesh Th=square(10, 20, [x*pi-pi/2, 2*y*pi]); //]-pi/2, pi/2[X]0,2pi[

    func f1 = cos(x)*cos(y);
    func f2 = cos(x)*sin(y);
    func f3 = sin(x);

    func f1x = sin(x)*cos(y);
    func f1y = -cos(x)*sin(y);
    func f2x = -sin(x)*sin(y);
    func f2y = cos(x)*cos(y);
    func f3x = cos(x);
    func f3y = 0;

    func m11 = f1x^2 + f2x^2 + f3x^2;
    func m21 = f1x*f1y + f2x*f2y + f3x*f3y;
    func m22 = f1y^2 + f2y^2 + f3y^2;

    func perio = [[4, y], [2, y], [1, x], [3, x]]; //to store the periodic condition

    real hh = h/R; //hh mesh size on unite sphere
    real vv = 1/square(hh);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
    int[int] ref = [0, L];

    mesh3 ThS = movemesh23(Th, transfo=[f1*R, f2*R, f3*R], orientation=orientation, refface=ref);

    return ThS;
}
</pre></div>
</div>
<p>The test of the two functions and the call to <code class="code freefem docutils literal highlight highlight-freefem"><span></span>TetGen</code> mesh
generator:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>load &quot;msh3&quot;
load &quot;TetGen&quot;
load &quot;medit&quot;
include &quot;MeshSurface.idp&quot;

// Parameters
real hs = 0.1; //mesh size on sphere
int[int] N = [20, 20, 20];
real [int,int] B = [[-1, 1], [-1, 1], [-1, 1]];
int [int,int] L = [[1, 2], [3, 4], [5, 6]];

// Mesh
mesh3 ThH = SurfaceHex(N, B, L, 1);
mesh3 ThS = Sphere(0.5, hs, 7, 1);

mesh3 ThHS = ThH + ThS;
medit(&quot;Hex-Sphere&quot;, ThHS);

real voltet = (hs^3)/6.;
cout &lt;&lt; &quot;voltet = &quot; &lt;&lt; voltet &lt;&lt; endl;
real[int] domain = [0, 0, 0, 1, voltet, 0, 0, 0.7, 2, voltet];
mesh3 Th = tetg(ThHS, switch=&quot;pqaAAYYQ&quot;, nbofregions=2, regionlist=domain);
medit(&quot;Cube with ball&quot;, Th);
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Fig. 38: The surface mesh of the
Hex with internal Sphere</th>
<th class="head">Fig. 39: The tetrahedral mesh of
the cube with internal ball</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><img alt="Hex Sphere" src="../_images/MeshGeneration_CubeSphere1.png" /></td>
<td><img alt="Cube with ball" src="../_images/MeshGeneration_CubeSphere2.png" /></td>
</tr>
</tbody>
</table>
<div class="section" id="medit">
<h3>Medit<a class="headerlink" href="#medit" title="Permalink to this headline">¶</a></h3>
<p>The keyword <code class="code freefem docutils literal highlight highlight-freefem"><span></span>medit</code> allows to display a mesh alone or a
mesh and one or several functions defined on the mesh using the Pascal
Frey’s freeware <code class="docutils literal highlight highlight-freefem"><span></span>medit</code>. <code class="docutils literal highlight highlight-freefem"><span></span>medit</code> opens its own window and uses
OpenGL extensively. Naturally to use this command <code class="docutils literal highlight highlight-freefem"><span></span>medit</code> must be
installed.</p>
<p>A vizualisation with <code class="code freefem docutils literal highlight highlight-freefem"><span></span>medit</code> of scalar solutions <span class="math notranslate nohighlight">\(f1\)</span>
and <span class="math notranslate nohighlight">\(f2\)</span> continuous, piecewise linear and known at the vertices of
the mesh Th is obtained using :</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>medit(&quot;sol1 sol2&quot;, Th, f1, f2, order=1);
</pre></div>
</div>
<p>The first plot named <code class="code freefem docutils literal highlight highlight-freefem"><span></span>sol1</code> display f1. The second plot
names <code class="code freefem docutils literal highlight highlight-freefem"><span></span>sol2</code> display f2.</p>
<p>The arguments of the function <code class="code freefem docutils literal highlight highlight-freefem"><span></span>medit</code> are the name of the
differents scenes (separated by a space) of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>medit</code>, a mesh
and solutions.</p>
<p>Each solution is associated with one scene. The scalar, vector and
symmetric tensor solutions are specified in the format described in the
section dealing with the keyword <code class="code freefem docutils literal highlight highlight-freefem"><span></span>savesol</code>.</p>
<p>The parameters of this command line are :</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>order=</code> 0 if the solution is given at the center of
gravity of elements. 1 is the solution is given at the vertices of
elements.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>meditff=</code> set the name of execute command of medit. By
default, this string is medit.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>save=</code> set the name of a file <code class="code freefem docutils literal highlight highlight-freefem"><span></span>.sol</code> or
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>.solb</code> to save solutions.</li>
</ul>
<p>This command line allows also to represent two differents meshes and
solutions on them in the same windows. The nature of solutions must be
the same. Hence, we can vizualize in the same window the different
domains in a domain decomposition method for instance. A vizualisation
with medit of scalar solutions <span class="math notranslate nohighlight">\(h1\)</span> and <span class="math notranslate nohighlight">\(h2\)</span> at vertices of
the mesh Th1 and Th2 respectively are obtained using :</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>medit(&quot;sol2domain&quot;, Th1, h1, Th2, h2, order=1);
</pre></div>
</div>
<p>!!!example “<code class="code freefem docutils literal highlight highlight-freefem"><span></span>medit</code>” <code class="code freefem docutils literal highlight highlight-freefem"><span></span>load &quot;medit&quot;</code></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Initial Problem:
// Resolution of the following EDP:
// -Delta u_s = f on \Omega = { (x,y) | 1 &lt;= sqrt(x^2+y^2) &lt;= 2 }
// -Delta u_1 = f1 on \Omega_1 = { (x,y) | 0.5 &lt;= sqrt(x^2+y^2) &lt;= 1. }
// u = 1 on Gamma
// Null Neumman condition on Gamma_1 and on Gamma_2
// We find the solution u by solving two EDP defined on domain Omega and Omega_1
// This solution is visualize with medit

verbosity=3;

// Mesh
border Gamma(t=0, 2*pi){x=cos(t); y=sin(t); label=1;};
border Gamma1(t=0, 2*pi){x=2*cos(t); y=2*sin(t); label=2;};
border Gamma2(t=0, 2*pi){x=0.5*cos(t); y=0.5*sin(t); label=3;};

mesh Th = buildmesh(Gamma1(40) + Gamma(-40)); //Omega
mesh Th1 = buildmesh(Gamma(40) + Gamma2(-40)); //Omega_1

// Fespace
fespace Vh(Th, P2);
func f = sqrt(x*x + y*y);
Vh us, v;

fespace Vh1(Th1, P2);
func f1 = 10*sqrt(x*x+y*y);
Vh1 u1, v1;

// Macro
macro Grad2(us) [dx(us), dy(us)] // EOM

// Problem
problem Lap2dOmega (us, v, init=false)
    = int2d(Th)(
          Grad2(v)&#39; * Grad2(us)
    )
    - int2d(Th)(
          f*v
    )
    +on(1, us=1)
    ;

problem Lap2dOmega1 (u1, v1, init=false)
    = int2d(Th1)(
          Grad2(v1)&#39; * Grad2(u1)
    )
    - int2d(Th1)(
          f1*v1
    )
    + on(1, u1=1)
    ;

// Solve
Lap2dOmega;
Lap2dOmega1;

// Plot with medit
medit(&quot;solution&quot;, Th, us, Th1, u1, order=1, save=&quot;testsavemedit.solb&quot;);
```
</pre></div>
</div>
</div>
<div class="section" id="mshmet">
<h3>Mshmet<a class="headerlink" href="#mshmet" title="Permalink to this headline">¶</a></h3>
<p>Mshmet is a software developed by P. Frey that allows to compute an
anisotropic metric based on solutions (i.e.&nbsp;Hessian-based). This
software can return also an isotropic metric. Moreover, <code class="docutils literal highlight highlight-freefem"><span></span>mshmet</code> can
also construct a metric suitable for levelset interface capturing. The
solution can be defined on 2D or 3D structured/unstructured meshes. For
example, the solution can be an error estimate of a FE solution.</p>
<p>Solutions for <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mshmet</code> are given as an argument. The
solution can be a <code class="code freefem docutils literal highlight highlight-freefem"><span></span>func</code>, a vector <code class="code freefem docutils literal highlight highlight-freefem"><span></span>func</code>, a
symmetric tensor, a <code class="code freefem docutils literal highlight highlight-freefem"><span></span>fespace</code> function, a
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>fespace</code> vector function and a <code class="code freefem docutils literal highlight highlight-freefem"><span></span>fespace</code>
symmetric tensor. The symmetric tensor argument is defined as this type
of data for datasol argument. This software accepts more than one
solution.</p>
<p>For example, the metric <span class="math notranslate nohighlight">\(M\)</span> computed with <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mshmet</code>
for the solution <span class="math notranslate nohighlight">\(u\)</span> defined on the mesh <span class="math notranslate nohighlight">\(Th\)</span> is obtained by
writing :</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>fespace Vh(Th, P1);
Vh u; //a scalar fespace function
real[int] M = mshmet(Th, u);
</pre></div>
</div>
<p>The parameters of the keyword <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mshmet</code> are :</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>normalization =</code> (b) do a normalization of all solution
in <span class="math notranslate nohighlight">\([0,1]\)</span>.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>aniso =</code> (b) build anisotropic metric if 1 (default 0:
isotropic)</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>levelset =</code> (b) build metric for levelset method
(default: <code class="code freefem docutils literal highlight highlight-freefem"><span></span>false</code>)</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>verbosity =</code> (l) level of verbosity</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>nbregul =</code> (l) number of regularization’s iteration of
solutions given (default 0).</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>hmin =</code> (d)</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>hmax =</code> (d)</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>err =</code> (d) level of error.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>width =</code> (d) the width</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>metric =</code> a vector of double. This vector contains an
initial metric given to <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mshmet</code>. The structure of the
metric vector is described in the next paragraph.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>loptions =</code> a vector of integer of size 7. This vector
contains the integer parameters of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mshmet</code> (for expert
only).<ul>
<li>loptions(0): normalization (default 1).</li>
<li>loptions(1): isotropic parameters (default 0). 1 for isotropic
metric results otherwise 0.</li>
<li>loptions(2): level set parameters (default 0). 1 for building
level set metric otherwise 0.</li>
<li>loptions(3): debug parameters (default 0). 1 for turning on debug
mode otherwise 0.</li>
<li>loptions(4): level of verbosity (default 10).</li>
<li>loptions(5): number of regularization’s iteration of solutions
given (default 0).</li>
<li>loptions(6): previously metric parameter (default 0). 1 for using
previous metric otherwise 0.</li>
</ul>
</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>doptions=</code> a vector of double of size 4. This vector
contains the real parameters of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mshmet</code> (for expert
only).<ul>
<li>doptions(0): hmin : min size parameters (default 0.01).</li>
<li>doptions(1): hmax : max size parameters (default 1.0).</li>
<li>doptions(2): eps : tolerance parameters (default 0.01).</li>
<li>doptions(2): width : relative width for Level Set (<span class="math notranslate nohighlight">\(0&lt;w&lt;1\)</span>)
(default 0.05).</li>
</ul>
</li>
</ul>
<p>The result of the keyword <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mshmet</code> is a
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>real[int]</code> which contains the metric computed by
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>mshmet</code> at the different vertices <span class="math notranslate nohighlight">\(V_{i}\)</span> of the
mesh.</p>
<p>With <span class="math notranslate nohighlight">\(nv\)</span> is the number of vertices, the structure of this vector
is</p>
<div class="math notranslate nohighlight">
\[M_{iso}= (m(V_0), m(V_1), \ldots, m(V_{nv}))^t\]</div>
<p>for a isotropic metric <span class="math notranslate nohighlight">\(m\)</span>. For a symmetric tensor metric
<span class="math notranslate nohighlight">\(h=\left(\begin{array}{ccc} m_{1 1} &amp; m_{1 2} &amp; m_{1 3}\\ m_{2 1} &amp; m_{2 2} &amp; m_{2 3} \\ m_{3 1} &amp; m_{3 2} &amp; m_{3 3} \end{array}\right)\)</span>
, the parameters <code class="code freefem docutils literal highlight highlight-freefem"><span></span>metric</code> is :</p>
<div class="math notranslate nohighlight">
\[M_{aniso}= (H(V_{0}), \ldots, H(V_{nv}) )^t\]</div>
<p>where <span class="math notranslate nohighlight">\(H(V_{i})\)</span> is the vector of size 6 defined by
<span class="math notranslate nohighlight">\([m11,m21,m22,m31,m32,m33]\)</span></p>
<p>!!!example “<code class="code freefem docutils literal highlight highlight-freefem"><span></span>mshmet</code>” <code class="code freefem docutils literal highlight highlight-freefem"><span></span>load &quot;mshmet&quot; load &quot;medit&quot; load &quot;msh3&quot;</code></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
real error = 0.01;
func zmin = 0;
func zmax = 1;
int MaxLayer = 10;

// Mesh
border a(t=0, 1.0){x=t; y=0; label=1;};
border b(t=0, 0.5){x=1; y=t; label=2;};
border c(t=0, 0.5){x=1-t; y=0.5; label=3;};
border d(t=0.5, 1){x=0.5; y=t; label=4;};
border e(t=0.5, 1){x=1-t; y=1; label=5;};
border f(t=0.0, 1){x=0; y=1-t; label=6;};
mesh Th = buildmesh(a(6) + b(4) + c(4) + d(4) + e(4) + f(6));
mesh3 Th3 = buildlayers(Th, MaxLayer, zbound=[zmin, zmax]);

// Fespace
fespace Vh3(Th3, P2);
Vh3 u3, v3;

fespace Vh3P1(Th3, P1);
Vh3P1 usol;

// Problem
problem Problem2(u3, v3, solver=sparsesolver)
    = int3d(Th3)(
          u3*v3*1.0e-10
        + dx(u3)*dx(v3)
        + dy(u3)*dy(v3)
        + dz(u3)*dz(v3)
    )
    - int3d(Th3)(
          v3
    )
    +on(0, 1, 2, 3, 4, 5, 6, u3=0)
    ;

// Solve
Problem2;
cout &lt;&lt; u3[].min &lt;&lt; &quot; &quot; &lt;&lt; u3[].max &lt;&lt; endl;

medit(&quot;Sol&quot;, Th3, u3);

real[int] bb = mshmet(Th3,u3);
cout &lt;&lt; &quot;Metric:&quot; &lt;&lt; bb &lt;&lt; endl;
for (int ii = 0; ii &lt; Th3.nv; ii++)
    usol[][ii] = bb[ii];

medit(&quot;Metric&quot;, Th3, usol);
```
</pre></div>
</div>
</div>
<div class="section" id="freeyams">
<h3>FreeYams<a class="headerlink" href="#freeyams" title="Permalink to this headline">¶</a></h3>
<p>FreeYams is a surface mesh adaptation software which is developed by P.
Frey. This software is a new version of yams. The adapted surface mesh
is constructed with a geometric metric tensor field. This field is based
on the intrinsic properties of the discrete surface.</p>
<p>Also, this software allows to construct a simplification of a mesh. This
decimation is based on the Hausdorff distance between the initial and
the current triangulation. Compared to the software yams, FreeYams can
be used also to produce anisotropic triangulations adapted to levelset
simulations. A technical report on freeYams documentation is available
<a class="reference external" href="https://www.ljll.math.upmc.fr/frey/publications/RT-0252.pdf">here</a>.</p>
<p>To call FreeYams in FreeFem++, we used the keyword
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>freeyams</code>. The arguments of this function are the initial
mesh and/or metric. The metric with <code class="code freefem docutils literal highlight highlight-freefem"><span></span>freeyams</code> are a
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>func</code>, a <code class="code freefem docutils literal highlight highlight-freefem"><span></span>fespace</code> function, a symmetric
tensor function, a symmetric tensor <code class="code freefem docutils literal highlight highlight-freefem"><span></span>fespace</code> function or a
vector of double (<code class="code freefem docutils literal highlight highlight-freefem"><span></span>real[int]</code>). If the metric is a vector
of double, this data must be given in <code class="code freefem docutils literal highlight highlight-freefem"><span></span>metric</code> parameter.
Otherwise, the metric is given in the argument.</p>
<p>For example, the adapted mesh of <code class="docutils literal highlight highlight-freefem"><span></span>Thinit</code> defined by the metric
<span class="math notranslate nohighlight">\(u\)</span> defined as <code class="code freefem docutils literal highlight highlight-freefem"><span></span>fespace</code> function is obtained by
writing:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>fespace Vh(Thinit, P1);
Vh u;
mesh3 Th = freeyams(Thinit, u);
</pre></div>
</div>
<p>The symmetric tensor argument for <code class="code freefem docutils literal highlight highlight-freefem"><span></span>freeyams</code> keyword is
defined as this type of data for datasol argument.</p>
<ul>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>aniso=</code> (b) aniso or iso metric (default 0, iso)</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>mem=</code> (l) memory of for freeyams in Mb (default -1,
freeyams choose)</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>hmin=</code> (d)</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>hmax=</code> (d)</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>gradation=</code> (d)</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>option=</code> (l)</p>
<ul class="simple">
<li>0 : mesh optimization (smoothing+swapping)</li>
<li>1 : decimation+enrichment adaptated to a metric map. (default)</li>
<li>-1 : decimation adaptated to a metric map.</li>
<li>2 : decimation+enrichment with a Hausdorff-like method</li>
<li>-2 : decimation with a Hausdorff-like method</li>
<li>4 : split triangles recursively.</li>
<li>9 : No-Shrinkage Vertex Smoothing</li>
</ul>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>ridgeangle=</code> (d)</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>absolute=</code> (b)</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>verbosity=</code> (i)</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>metric=</code> vector expression. This parameters contains
the metric at the different vertices on the initial mesh. With
<span class="math notranslate nohighlight">\(nv\)</span> is the number of vertices, this vector is</p>
<div class="math notranslate nohighlight">
\[M_{iso}= ( m(V_0), m(V_1), \ldots, m(V_{nv}) )^t\]</div>
<p>for a scalar metric <span class="math notranslate nohighlight">\(m\)</span>. For a symmetric tensor metric
<span class="math notranslate nohighlight">\(h=\left(\begin{array}{ccc} m_{1 1} &amp; m_{1 2} &amp; m_{1 3}\\ m_{2 1} &amp; m_{2 2} &amp; m_{2 3} \\ m_{3 1} &amp; m_{3 2} &amp; m_{3 3} \end{array}\right)\)</span>
, the parameters <code class="code freefem docutils literal highlight highlight-freefem"><span></span>metric</code> is</p>
<div class="math notranslate nohighlight">
\[M_{aniso}= ( H(V_{0}), \ldots, H(V_{nv}) )^t\]</div>
<p>where <span class="math notranslate nohighlight">\(H(V_{i})\)</span> is the vector of size 6 defined by
<span class="math notranslate nohighlight">\([m11,m21,m22,m31,m32,m33]\)</span></p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>loptions=</code> a vector of integer of size 13. This vectors
contains the integer options of FreeYams. (just for the expert)</p>
<ul class="simple">
<li>loptions(0): anisotropic parameter (default 0). If you give an
anisotropic metric 1 otherwise 0.</li>
<li>loptions(1): Finite Element correction parameter (default 0). 1
for <em>no</em> Finite Element correction otherwise 0.</li>
<li>loptions(2): Split multiple connected points parameter (default
1). 1 for splitting multiple connected points otherwise 0.</li>
<li>loptions(3): maximum value of memory size in Mbytes (default -1:
the size is given by freeyams).</li>
<li>loptions(4): set the value of the connected component which we
want to obtain. (Remark: freeyams give an automatic value at each
connected component).</li>
<li>loptions(5): level of verbosity</li>
<li>loptions(6): Create point on straight edge (no mapping) parameter
(default 0). 1 for creating point on straight edge otherwise 0.</li>
<li>loptions(7): validity check during smoothing parameter. This
parameter is only used with No-Shrinkage Vertex Smoothing
optimization (optimization option parameter 9). 1 for No validity
checking during smoothing otherwise 0.</li>
<li>loptions(8): number of desired’s vertices (default -1).</li>
<li>loptions(9): number of iteration of optimizations (default 30).</li>
<li>loptions(10): no detection parameter (default 0) . 1 for detecting
the ridge on the mesh otherwise 0. The ridge definition is given
in the parameter doptions(12).</li>
<li>loptions(11): no vertex smoothing parameter (default 0). 1 for
smoothing the vertices otherwise 0.</li>
<li>loptions(12): Optimization level parameter (default 0).<ul>
<li>0 : mesh optimization (smoothing+swapping)</li>
<li>1 : decimation+enrichment adaptated to a metric map.</li>
<li>-1: decimation adaptated to a metric map.</li>
<li>2 : decimation+enrichment with a Hausdorff-like method</li>
<li>-2: decimation with a Hausdorff-like method</li>
<li>4 : split triangles recursively.</li>
<li>9 : No-Shrinkage Vertex Smoothing</li>
</ul>
</li>
</ul>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>doptions=</code> a vector of double of size 11. This vectors
contains the real options of freeyams.</p>
<ul class="simple">
<li>doptions(0): Set the geometric approximation (Tangent plane
deviation) (default 0.01).</li>
<li>doptions(1): Set the lamda parameter (default -1).</li>
<li>doptions(2): Set the mu parmeter (default -1).</li>
<li>doptions(3): Set the gradation value (Mesh density control)
(default 1.3).</li>
<li>doptions(4): Set the minimal size(hmin) (default -2.0: the size is
automatically computed).</li>
<li>doptions(5): Set the maximal size(hmax) (default -2.0: the size is
automatically computed).</li>
<li>doptions(6): Set the tolerance of the control of Chordal deviation
(default -2.0).</li>
<li>doptions(7): Set the quality of degradation (default 0.599).</li>
<li>doptions(8): Set the declic parameter (default 2.0).</li>
<li>doptions(9): Set the angular walton limitation parameter (default
45 degree).</li>
<li>doptions(10): Set the angular ridge detection (default 45 degree).</li>
</ul>
</li>
</ul>
<p>!!!example “<code class="code freefem docutils literal highlight highlight-freefem"><span></span>freeyams</code>” <code class="code freefem docutils literal highlight highlight-freefem"><span></span>load &quot;msh3&quot; load &quot;medit&quot; load &quot;freeyams&quot;</code></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
int nn = 20;
real zmin = 0;
real zmax = 1;

// Mesh
mesh Th2 = square(nn, nn);
int[int] rup = [0, 2], rdown = [0, 1];
int[int] rmid = [1, 1, 2, 1, 3, 1, 4, 1];
mesh3 Th = buildlayers(Th2, nn, zbound=[zmin, zmax], reffacemid=rmid, reffaceup=rup, reffacelow=rdown);
mesh3 Th3 = freeyams(Th);

medit(&quot;SurfaceMesh&quot;, Th3);
```
</pre></div>
</div>
</div>
<div class="section" id="mmg3d">
<h3>mmg3d<a class="headerlink" href="#mmg3d" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="index-4">
<p class="first admonition-title">Todo</p>
<p class="last">mmg3d-v4.0</p>
</div>
<p><a class="reference external" href="http://www.mmgtools.org">Mmg3d</a> is a 3D remeshing software developed
by C. Dobrzynski and P. Frey.</p>
<p>This software allows to remesh an initial mesh made of tetrahedra. This
initial mesh is adapted to a geometric metric tensor field or to a
displacement vector (moving rigid body). The metric can be obtained with
<cite>:freefem:`mshmet</cite> &lt;#mshmet&gt;`__.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">* If no metric is given, an isotropic metric is computed by
analyzing the size of the edges in the initial mesh. * if a
displacement is given, the vertices of the surface triangles are moved
without verifying the geometrical structure of the new surface mesh.</p>
</div>
<p>The parameters of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mmg3d</code> are :</p>
<ul>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>options=</code> vector expression. This vector contains the
option parameters of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mmg3d</code>. It is a vector of 6
values, with the following meaning:</p>
<ul>
<li><p class="first">Optimization parameters : (default 1)</p>
<p>0 : mesh optimization.</p>
<p>1 : adaptation with metric (deletion and insertion vertices) and
optimization.</p>
<p>-1 : adaptation with metric (deletion and insertion vertices)
without optimization.</p>
<p>4 : split tetrahedra (be careful modify the surface).</p>
<p>9 : moving mesh with optimization.</p>
<p>-9 : moving mesh without optimization.</p>
</li>
<li><p class="first">Debug mode : (default 0)</p>
<p>1 : turn on debug mode.</p>
<p>0 : otherwise.</p>
</li>
<li><p class="first">Specify the size of bucket per dimension (default 64)</p>
</li>
<li><p class="first">Swapping mode : (default 0)</p>
<p>1 : no edge or face flipping.</p>
<p>0 : otherwise.</p>
</li>
<li><p class="first">Insert points mode : (default 0)</p>
<p>1 : no edge splitting or collapsing and no insert points.</p>
<p>0 : otherwise.</p>
</li>
</ul>
<ol class="arabic simple" start="5">
<li>Verbosity level (default 3)</li>
</ol>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>memory=</code> integer expression. Set the maximum memory
size of new mesh in Mbytes. By default the number of maximum
vertices, tetrahedra and triangles are respectively 500 000, 3000
000, 100000 which represent approximately a memory of 100 Mo.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>metric=</code> vector expression. This vector contains the
metric given at <code class="code freefem docutils literal highlight highlight-freefem"><span></span>mmg3d</code>. It is a vector of size
<span class="math notranslate nohighlight">\(nv\)</span> or 6 <span class="math notranslate nohighlight">\(nv\)</span> respectively for an isotropic and
anisotropic metric where <span class="math notranslate nohighlight">\(nv\)</span> is the number of vertices in the
initial mesh. The structure of <code class="code freefem docutils literal highlight highlight-freefem"><span></span>metric</code> vector is
described in the <cite>:freefem:`mshmet</cite> &lt;#mshmet&gt;`__.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>displacement=</code> <span class="math notranslate nohighlight">\([\Phi1, \Phi2, \Phi3]\)</span> set the
displacement vector of the initial mesh
<span class="math notranslate nohighlight">\(\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]\)</span>.</p>
</li>
<li><p class="first"><code class="code freefem docutils literal highlight highlight-freefem"><span></span>displVect=</code> sets the vector displacement in a vector
expression. This vector contains the displacement at each point of
the initial mesh. It is a vector of size 3 <span class="math notranslate nohighlight">\(nv\)</span>.</p>
</li>
</ul>
<p>!!!example “<code class="code freefem docutils literal highlight highlight-freefem"><span></span>mmg3d</code>” <code class="code freefem docutils literal highlight highlight-freefem"><span></span>load &quot;msh3&quot; load &quot;medit&quot; load &quot;mmg3d&quot; include &quot;Cube.idp&quot;</code></p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
int n = 6;
int[int] Nxyz = [12, 12, 12];
real [int, int] Bxyz = [[0., 1.], [0., 1.], [0., 1.]];
int [int, int] Lxyz = [[1, 1], [2, 2], [2, 2]];

// Mesh
mesh3 Th = Cube(Nxyz, Bxyz, Lxyz);

real[int] isometric(Th.nv);
for (int ii = 0; ii &lt; Th.nv; ii++)
    isometric[ii] = 0.17;

mesh3 Th3 = mmg3d(Th, memory=100, metric=isometric);

// Plot
medit(&quot;Initial&quot;, Th);
medit(&quot;Isometric&quot;, Th3);
```
</pre></div>
</div>
<p>!!! example “Falling spheres” ```freefem load “msh3” load “TetGen” load
“medit” load “mmg3d” include “MeshSurface.idp”</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
real hs = 0.8;
int[int] N = [4/hs, 8/hs, 11.5/hs];
real [int, int] B = [[-2, 2], [-2, 6], [-10, 1.5]];
int [int, int] L = [[311, 311], [311, 311], [311, 311]];

int[int] opt = [9, 0, 64, 0, 0, 3];
real[int] vit=[0, 0, -0.3];
func zero = 0.;
func dep = vit[2];

// Mesh
mesh3 ThH = SurfaceHex(N, B, L, 1);
mesh3 ThSg = Sphere(1, hs, 300, -1);
mesh3 ThSd = Sphere(1, hs, 310, -1);
ThSd = movemesh3(ThSd, transfo=[x, 4+y, z]);
mesh3 ThHS = ThH + ThSg + ThSd;//gluing surface meshes
medit(&quot;ThHS&quot;, ThHS);

real voltet = (hs^3)/6.;
real[int] domain = [0, 0, -4, 1, voltet];
real [int] holes = [0, 0, 0, 0, 4, 0];
mesh3 Th = tetg(ThHS, switch=&quot;pqaAAYYQ&quot;, nbofregions=1, regionlist=domaine, nbofholes=2, holelist=holes);
medit(&quot;Box-With-two-Ball&quot;, Th);

// Fespace
fespace Vh(Th, P1);
Vh uh,vh;

// Macro
macro Grad(u) [dx(u),dy(u),dz(u)]

// Problem
problem Lap (uh, vh, solver=CG)
    = int3d(Th)(
          Grad(uh)&#39; * Grad(vh)
    )
    + on(310, 300, uh=dep)
    + on(311, uh=0.)
    ;

// Falling loop
for(int it = 0; it &lt; 29; it++){
    cout &lt;&lt; &quot; ITERATION &quot; &lt;&lt; it &lt;&lt; endl;

    // Solve
    Lap;

    // Plot
    plot(Th, uh);

    // Sphere falling
    Th = mmg3d(Th, options=opt, displacement=[zero, zero, uh], memory=1000);
}
```
</pre></div>
</div>
</div>
<div class="section" id="a-first-3d-isotrope-mesh-adaptation-process">
<h3>A first 3d isotrope mesh adaptation process<a class="headerlink" href="#a-first-3d-isotrope-mesh-adaptation-process" title="Permalink to this headline">¶</a></h3>
<p>!!!example “Adaptation 3D” ```freefem load “msh3” load “TetGen” load
“mshmet” load “medit”</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
int nn = 6;
int[int] l1111 = [1, 1, 1, 1]; //labels
int[int] l01 = [0, 1];
int[int] l11 = [1, 1];

real errm = 1e-2; //level of error

// Mesh
mesh3 Th3 = buildlayers(square(nn, nn, region=0, label=l1111),
    nn, zbound=[0, 1], labelmid=l11, labelup=l01, labeldown=l01);

Th3 = trunc(Th3, (x&lt;0.5) | (y &lt; 0.5) | (z &lt; 0.5), label=1); //remove the ]0.5,1[^3 cube

// Fespace
fespace Vh(Th3, P1);
Vh u, v, usol, h;

// Macro
macro Grad(u) [dx(u), dy(u), dz(u)] // EOM

// Problem
problem Poisson (u, v, solver=CG)
    = int3d(Th3)(
          Grad(u)&#39; * Grad(v)
    )
    - int3d(Th3)(
          1*v
    )
    + on(1, u=0)
    ;

// Loop
for (int ii = 0; ii &lt; 5; ii++){
    // Solve
    Poisson;
    cout &lt;&lt; &quot;u min, max = &quot; &lt;&lt; u[].min &lt;&lt; &quot; &quot;&lt;&lt; u[].max &lt;&lt; endl;

    h=0.; //for resizing h[] because the mesh change
    h[] = mshmet(Th3, u, normalization=1, aniso=0, nbregul=1, hmin=1e-3, hmax=0.3, err=errm);
    cout &lt;&lt; &quot;h min, max = &quot; &lt;&lt; h[].min &lt;&lt; &quot; &quot;&lt;&lt; h[].max &lt;&lt; &quot; &quot; &lt;&lt; h[].n &lt;&lt; &quot; &quot; &lt;&lt; Th3.nv &lt;&lt; endl;
    plot(u, wait=true);

    errm *= 0.8; //change the level of error
    cout &lt;&lt; &quot;Th3 &quot; &lt;&lt; Th3.nv &lt; &quot; &quot; &lt;&lt; Th3.nt &lt;&lt; endl;
    Th3 = tetgreconstruction(Th3, switch=&quot;raAQ&quot;, sizeofvolume=h*h*h/6.); //rebuild mesh
    medit(&quot;U-adap-iso-&quot;+ii, Th3, u, wait=true);
}
```
</pre></div>
</div>
</div>
<div class="section" id="build-a-2d-mesh-from-a-isoline">
<h3>Build a 2d mesh from a isoline<a class="headerlink" href="#build-a-2d-mesh-from-a-isoline" title="Permalink to this headline">¶</a></h3>
<p>The idea is to get the discretization of an isoline of fluid meshes,
this tool can be useful to construct meshes from image. First, we give
an example of the isovalue meshes <span class="math notranslate nohighlight">\(0.2\)</span> of analytical function
<span class="math notranslate nohighlight">\(\sqrt{(x-1/2)^2 +(y-1/2)^2}\)</span>, on unit square.</p>
<p>!!!example “iosline” ```freefem load “isoline”</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>real[int,int] xy(3, 1); //to store the isoline points
int[int] be(1); //to store the begin, end couple of lines
{
    mesh Th = square(10, 10);
    fespace Vh(Th, P1);
    Vh u = sqrt(square(x-0.5) + square(y-0.5));
    real iso = 0.2 ;
    real[int] viso = [iso];
    plot(u, viso=viso,Th);//to see the iso line

    int nbc = isoline(Th, u, xy, close=1, iso=iso, beginend=be, smoothing=0.1);
```
</pre></div>
</div>
<p>The <code class="code freefem docutils literal highlight highlight-freefem"><span></span>isoline</code> parameters are <code class="code freefem docutils literal highlight highlight-freefem"><span></span>Th</code> the mesh,
the expression <span class="math notranslate nohighlight">\(u\)</span>, the bidimentionnal array <code class="code freefem docutils literal highlight highlight-freefem"><span></span>xy</code> to
store the list coordinate of the points. The list of named parameter are
:</p>
<ul class="simple">
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>iso=</code> value of the isoline to compute (0 is the default
value)</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>close=</code> close the isoline with the border (default
<code class="code freefem docutils literal highlight highlight-freefem"><span></span>true</code>), we add the part of the mesh border such the
value is less than the isovalue</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>smoothing=</code> number of smoothing process is the
<span class="math notranslate nohighlight">\({l} ^{r} {s}\)</span> where <span class="math notranslate nohighlight">\(l\)</span> is the length of the current
line component, <span class="math notranslate nohighlight">\(r\)</span> the ratio, <span class="math notranslate nohighlight">\(s\)</span> is smoothing value.
The smoothing default value is 0.</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>ratio=</code> the ratio (1 by default).</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>eps=</code> relative <span class="math notranslate nohighlight">\(\varepsilon\)</span> (default 1e-10)</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>beginend=</code> array to get begin, end couple of each of
sub line (resize automatically)</li>
<li><code class="code freefem docutils literal highlight highlight-freefem"><span></span>file=</code> to save the data curve in data file for gnu plot</li>
</ul>
<p>In the array <code class="code freefem docutils literal highlight highlight-freefem"><span></span>xy</code> you get the list of vertices of the
isoline, each connex line go from <span class="math notranslate nohighlight">\(i= i_0^c ,\dots, i_1^c-1\)</span> with
<span class="math notranslate nohighlight">\(i_0^c =be(2*c)\)</span> <span class="math notranslate nohighlight">\(i_1^c =be(2*c+1)\)</span>, and where
<span class="math notranslate nohighlight">\(x_i= xy(0,i), y_i=yx( 1,i), l_i=xy(2,i)\)</span>.</p>
<p>Here <span class="math notranslate nohighlight">\(l_i\)</span> is the length of the line (the origin of the line is
point <span class="math notranslate nohighlight">\(i_0^c\)</span>).</p>
<p>The sense of the isoline is such that the upper part is at the left size
of the isoline. So here : the minimum is a point <span class="math notranslate nohighlight">\(0.5,05\)</span> so the
curve 1 turn in the clockwise sense, the order of each component are
sort such that the number of point by component is decreasing.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>    cout &lt;&lt; &quot;Number of the line component = &quot; &lt;&lt; nbc &lt;&lt; endl;
    cout &lt;&lt; &quot;Number of points = &quot; &lt;&lt; xy.m &lt;&lt; endl;
    cout &lt;&lt; &quot;be = &quot; &lt;&lt; be &lt;&lt; endl;

    // shows the lines component
    for (int c = 0; c &lt; nbc; ++c){
        int i0 = be[2*c], i1 = be[2*c+1]-1;
        cout &lt;&lt; &quot;Curve &quot; &lt;&lt; c &lt;&lt; endl;
        for(int i = i0; i &lt;= i1; ++i)
            cout &lt;&lt; &quot;x= &quot; &lt;&lt; xy(0,i) &lt;&lt; &quot; y= &quot; &lt;&lt; xy(1,i) &lt;&lt; &quot; s= &quot; &lt;&lt; xy(2, i) &lt;&lt; endl;
        plot([xy(0, i0:i1), xy(1, i0:i1)], wait=true, viso=viso, cmm=&quot; curve &quot;+c);
    }
}

cout &lt;&lt; &quot;length of last curve = &quot; &lt;&lt; xy(2, xy.m-1) &lt;&lt; endl;
</pre></div>
</div>
<p>We also have a new function to easily parametrize a discrete curve
defined by the couple <span class="math notranslate nohighlight">\(be, xy\)</span>.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>border Curve0(t=0, 1){
    int c=0; //component 0
    int i0=be[2*c], i1=be[2*c+1]-1;
    P=Curve(xy, i0, i1, t); //Curve 0
    label=1;
}

border Curve1(t=0, 1){
    int c=1; //component 1
    int i0=be[2*c], i1=be[2*c+1]-1;
    P=Curve(xy, i0, i1, t); //Curve 1
    label=1;
}

plot(Curve1(100)); //show curve
mesh Th = buildmesh(Curve1(-100));
plot(Th, wait=true);
</pre></div>
</div>
<p>Secondly, we use this idea to build meshes from an image, we use the
plugins <code class="code freefem docutils literal highlight highlight-freefem"><span></span>ppm2rnm</code> to read <code class="code freefem docutils literal highlight highlight-freefem"><span></span>pgm</code> a gray scale
image and then we extract the gray contour at level 0.25.</p>
<p>!!!example “Leman lake” ```freefem load “ppm2rnm” load “isoline”</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span>// Parameters
string leman = &quot;LemanLake.pgm&quot;;
real AreaLac = 580.03; //in km^2
real hsize = 5;
real[int, int] Curves(3, 1);
int[int] be(1);
int nc; //nb of curve
{
    real[int, int] ff1(leman); //read image
    //and set it in a rect. array
    int nx = ff1.n, ny = ff1.m;
    //build a Cartesian mesh such that the origin is in the right place.
    mesh Th = square(nx-1, ny-1, [(nx-1)*(x), (ny-1)*(1-y)]);
    //warning the numbering of the vertices (x,y) is
    //given by $i = x/nx + nx* y/ny $
    fespace Vh(Th, P1);
    Vh f1;
    f1[] = ff1; //transform array in finite element functions.
    nc = isoline(Th, f1, iso=0.25, close=1, Curves, beginend=be, smoothing=.1, ratio=0.5);
}

//The longest isoline: the lake
int ic0 = be(0), ic1 = be(1)-1;
plot([Curves(0, ic0:ic1), Curves(1, ic0:ic1)], wait=true);

int NC = Curves(2, ic1)/hsize;
real xl = Curves(0, ic0:ic1).max - 5;
real yl = Curves(1, ic0:ic1).min + 5;
border G(t=0, 1){P=Curve(Curves, ic0, ic1, t); label=1+(x&gt;xl)*2+(y&lt;yl);}
plot(G(-NC), wait=true);

mesh Th = buildmesh(G(-NC));
plot(Th, wait=true);

real scale = sqrt(AreaLac/Th.area);
Th = movemesh(Th, [x*scale, y*scale]);
cout &lt;&lt; &quot;Th.area = &quot; &lt;&lt; Th.area &lt;&lt; &quot; Km^2 &quot; &lt;&lt; &quot; == &quot; &lt;&lt; AreaLac &lt;&lt; &quot; Km^2 &quot; &lt;&lt; endl;
plot(Th, wait=true, ps=&quot;leman.eps&quot;);
```
</pre></div>
</div>
<p>Fig. 40: The image of the Leman lake meshes Fig. 41: the mesh of the lake</p>
<p><img alt="lake" src="../_images/MeshGeneration_Isoline1.jpg" />                                      <img alt="leman mesh" src="../_images/MeshGeneration_Isoline2.png" /></p>
</div>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<p>HECHT, F. The mesh adapting software: bamg. INRIA report, 1998,
vol.&nbsp;250, p.&nbsp;252.</p>
<p>SI, Hang. TetGen Users’ guide: A quality tetrahedral mesh generator and
three-dimensional delaunay triangulator. 2006</p>
<p>SHEWCHUK, Jonathan Richard. Tetrahedral mesh generation by Delaunay
refinement. In : Proceedings of the fourteenth annual symposium on
Computational geometry. ACM, 1998. p.&nbsp;86-95.</p>
<p>HECHT, F. Outils et algorithmes pour la méthode des éléments finis. HdR,
Université Pierre et Marie Curie, France, 1992.</p>
<p>HECHT, Frédéric. BAMG: bidimensional anisotropic mesh generator. User
Guide. INRIA, Rocquencourt, 1998.</p>
</div>
</div>
</div>


        </div>
        <div class="side-doc-outline">
            <div class="side-doc-outline--content"> 
<div class="localtoc">
    <p class="caption">
      <span class="caption-text">Table Of Contents</span>
    </p>
    <ul>
<li><a class="reference internal" href="#">Mesh Generation</a><ul>
<li><a class="reference internal" href="#square">Square</a></li>
<li><a class="reference internal" href="#border">Border</a></li>
<li><a class="reference internal" href="#multi-border">Multi-Border</a></li>
<li><a class="reference internal" href="#data-structures-and-read-write-statements-for-a-mesh">Data Structures and Read/Write Statements for a Mesh</a></li>
<li><a class="reference internal" href="#mesh-connectivity-and-data">Mesh Connectivity and data</a></li>
<li><a class="reference internal" href="#the-keyword-triangulate">The keyword “triangulate”</a><ul>
<li><a class="reference internal" href="#boundary-fem-spaces-built-as-empty-meshes">Boundary FEM Spaces Built as Empty Meshes</a></li>
<li><a class="reference internal" href="#remeshing">Remeshing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#movemesh">Movemesh</a><ul>
<li><a class="reference internal" href="#regular-triangulation-htriangle">Regular Triangulation: hTriangle</a></li>
<li><a class="reference internal" href="#adaptmesh">Adaptmesh</a></li>
<li><a class="reference internal" href="#trunc">Trunc</a></li>
<li><a class="reference internal" href="#splitmesh">Splitmesh</a></li>
<li><a class="reference internal" href="#meshing-examples">Meshing Examples</a></li>
<li><a class="reference internal" href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh">How to change the label of elements and border elements of a mesh</a></li>
<li><a class="reference internal" href="#mesh-in-three-dimensions">Mesh in three dimensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cube">Cube</a></li>
<li><a class="reference internal" href="#read-write-statements-for-a-mesh-in-3d">Read/Write Statements for a Mesh in 3D</a></li>
<li><a class="reference internal" href="#tetgen-a-tetrahedral-mesh-generator">TetGen: A tetrahedral mesh generator</a></li>
<li><a class="reference internal" href="#reconstruct-refine-a-three-dimensional-mesh-with-tetgen">Reconstruct/Refine a three dimensional mesh with TetGen</a></li>
<li><a class="reference internal" href="#moving-mesh-in-three-dimensions">Moving mesh in three dimensions</a></li>
<li><a class="reference internal" href="#layer-mesh">Layer mesh</a><ul>
<li><a class="reference internal" href="#meshing-examples-1">Meshing examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-a-3d-mesh-of-a-cube-with-a-balloon">Build a 3d mesh of a cube with a balloon</a><ul>
<li><a class="reference internal" href="#medit">Medit</a></li>
<li><a class="reference internal" href="#mshmet">Mshmet</a></li>
<li><a class="reference internal" href="#freeyams">FreeYams</a></li>
<li><a class="reference internal" href="#mmg3d">mmg3d</a></li>
<li><a class="reference internal" href="#a-first-3d-isotrope-mesh-adaptation-process">A first 3d isotrope mesh adaptation process</a></li>
<li><a class="reference internal" href="#build-a-2d-mesh-from-a-isoline">Build a 2d mesh from a isoline</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
            </div>
        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
     <a id="button-prev" href="notations.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="P">
         <i class="pagenation-arrow-L material-icons">arrow_back</i>
         <div class="pagenation-text">
            <span class="pagenation-direction">Previous</span>
            <div>Notations</div>
         </div>
     </a>
     <a id="button-next" href="finiteElement.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="N">
        <i class="pagenation-arrow-R material-icons">arrow_forward</i>
        <div class="pagenation-text">
            <span class="pagenation-direction">Next</span>
            <div>Finite element</div>
        </div>
     </a>
  </div>
        <footer class="mdl-mini-footer">
    <div class="mdl-mini-footer__left-section">
      <div class="mdl-logo">FreeFem++</div>
      <div>
        
        <p class="caption"><span class="caption-text">Table of contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Language references</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model/index.html">Mathematical Models</a></li>
</ul>

      </div>
    </div>

    <div class="mdl-mini-footer__right-section">
        <div>&copy; Copyright 2018, FreeFem++.</div>
      <div>Generated by <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.3 using <a href="https://github.com/myyasuda/sphinx_materialdesign_theme">sphinx_materialdesign_theme</a>.</div>
    </div>
</footer>
        </main>
    </div>
  </body>
</html>