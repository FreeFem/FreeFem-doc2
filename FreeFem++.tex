%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}




\usepackage[margin=8pt]{subcaption}
\captionsetup{labelfont=bf}
\def\R{{\mathbb{R}}}
\def\C{{\mathbb{C}}}
\def\P{{\mathbb{P}}}
\def\p{{\partial}}
\def\n{{\nabla}}
\def\boldx{{\mathbf{x}}}
\def\boldxi{{\boldsymbol{\xi}}}
\def\arccosh{{\text{arccosh}}}
\def\arcsinh{{\text{arcsinh}}}
\def\arctanh{{\text{arctanh}}}
\def\vecttwo#1#2{\left|\begin{smallmatrix} #1 \\ #2 \end{smallmatrix}\right.}
\def\vectthree#1#2#3{\left|\begin{smallmatrix} #1 \\ #2 \\ #3\end{smallmatrix}\right.}
\def\bR{{\bf R}}
\def\bP{{\bf P}}
\def\bZ{{\bf Z}}
\def\bC{{\bf C}}
\def\VS{\bR^2}
\def\SVS{\underline V}
\def\SO{{\bf SO}}
\def\Sym{{\bf Sym}}
\def\qi{{\bf i}}
\def\qj{{\bf j}}
\def\qk{{\bf k}}
\def\ec{\hat{\bf e}}
\def\xc{\hat{\bf x}}
\def\bdr{\partial}
\def\PD{\partial_}
\def\strain{\underline \epsilon}
\def\stress{\underline \sigma}
\def\strainrate{\underline \epsilon^.}
\def\stressrate{\underline \sigma^.}
\def\stiff{\; \underline{\underline C}\;}
\def\comply{\underline{\underline \kappa}\;}
\def\Id{{\bf I}}
\def\Div{\nabla \cdot}
\def\Grad{\mathbf{\nabla}}
\def\rot{\nabla \times}
\def\lap{\triangle}
\def\tr{{\bf tr}\;}
\def\udH{\underline H}
\def\refX{\mathbf X}
\def\Jac{\overline{J}}
\def\spatx{\mathbf x}
\def\ani{\overline a}
\def\mat{\left[\begin{array}}
\def\tam{\end{array}\right]}
\def\arr{\left.\begin{array}}
\def\rra{\end{array}\right\}}
\def\arl{\left\{\begin{array}}
\def\lra{\end{array}\right.}
\def\ar{\begin{array}}
\def\ra{\end{array}}
\def\const{\mbox{ const.}}
\def\eps{\; \epsilon}
\def\sig{\; \sigma}
\def\th{\theta}
\def\sgn{\mbox{sgn}}
\def\qed{\; Q.E.D.\\}
\def\ranqe{\end{eqnarray}}
\def\ol{\overline}
\def\ul{\underline}
\def\bB{{\bf B}}
\def\bC{{\bf C}}
\def\bD{{\bf D}}
\def\bE{{\bf E}}
\def\bF{{\bf F}}
\def\bK{{\bf K}}
\def\bP{{\bf P}}
\def\bS{{\bf S}}
\def\bT{{\bf T}}
\def\bsig{{\bf \sigma}}
\def\T{{\mathbb{T}}}
\def\d{{text{d}}}
    

\title{FreeFem++ Documentation}
\date{Mar 12, 2019}
\release{4.0}
\author{Frederic Hecht}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{introduction/index:introduction}}\label{\detokenize{introduction/index::doc}}
\sphinxstylestrong{FreeFem++} is a partial differential equation solver for non-linear multi-physics systems in 2D and 3D.

Problems involving partial differential equations from several branches of physics, such as fluid-structure interactions, require interpolations of data on several meshes and their manipulation within one program.
\sphinxstylestrong{FreeFem++} includes a fast interpolation algorithm and a language for the manipulation of data on multiple meshes.

\sphinxstylestrong{FreeFem++} is written in C++ and its language is a C++ idiom.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.650\linewidth]{{Logo}.png}\hspace*{\fill}}


\section{Download FreeFem++}
\label{\detokenize{introduction/download:download-freefem}}\label{\detokenize{introduction/download:download}}\label{\detokenize{introduction/download::doc}}

\subsection{Latest binary packages}
\label{\detokenize{introduction/download:latest-binary-packages}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Operating System
&\sphinxstyletheadfamily 
FreeFem++ Version
&\sphinxstyletheadfamily 
Size
&\sphinxstyletheadfamily 
Date
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/download/3.61/FreeFem++-3.61-1-MacOS\_10.13.pkg}{MacOS 10.13}
&
\sphinxcode{\sphinxupquote{3.61}}
&
445.3 Mb
&
May 09, 2018
\\
\hline
\sphinxhref{http://www3.freefem.org/ff++/ftp/FreeFem++-3.59-MacOS\_10.12.pkg}{MacOS 10.12}
&
\sphinxcode{\sphinxupquote{3.59}}
&
507.1 Mb
&
Mar 16, 2018
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/download/3.61/FreeFem++-3.61-1-MacOS\_10.11.pkg}{MacOS 10.11}
&
\sphinxcode{\sphinxupquote{3.61}}
&
376.5 Mb
&
Jul 12, 2018
\\
\hline
\sphinxhref{http://www3.freefem.org/ff++/ftp/FreeFem++-3.59-MacOS\_10.10.pkg}{MacOS 10.10}
&
\sphinxcode{\sphinxupquote{3.59}}
&
507.1 Mb
&
Mar 16, 2018
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/download/3.62/freefem\_1-3.62\_amd64.deb}{Ubuntu}
&
\sphinxcode{\sphinxupquote{3.62}}
&
27.6 Mb
&
Jan 14, 2019
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/download/3.61/FreeFem++-3.61-1-win64.exe}{Windows 64bits}
&
\sphinxcode{\sphinxupquote{3.61}}
&
87.6 Mb
&
Jul 12, 2018
\\
\hline
\sphinxhref{http://www3.freefem.org/ff++/ftp/FreeFem++-3.46-win32.exe}{Windows 32bits}
&
\sphinxcode{\sphinxupquote{3.46}}
&
66.4 Mb
&
May 09, 2017
\\
\hline
\sphinxhref{http://www3.freefem.org/ff++/ftp/freefem++-4.0-beta.tar.gz}{Source\_4.0}
&
\sphinxcode{\sphinxupquote{4.0-beta}}
&
3.2 Mb
&
Jan 18, 2019
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/latest}{Source}
&
\sphinxcode{\sphinxupquote{latest}}
&
\sphinxcode{\sphinxupquote{-}}
&
Feb 22, 2018
\\
\hline
\sphinxhref{http://www3.freefem.org/ff++/ftp/}{Older versions}
&
\sphinxcode{\sphinxupquote{-}}
&
\sphinxcode{\sphinxupquote{-}}
&
\sphinxcode{\sphinxupquote{-}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The source code is available on the \sphinxhref{https://github.com/FreeFem/FreeFem-sources}{FreeFem++ GitHub Repository}.


\subsection{Syntax highlighters}
\label{\detokenize{introduction/download:syntax-highlighters}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Lexer type
&\sphinxstyletheadfamily 
Version
&\sphinxstyletheadfamily 
Description
\\
\hline
Emacs
&
\sphinxcode{\sphinxupquote{0.3}}
&
\sphinxhref{https://github.com/FreeFem/freefem-parser-emacs}{freefem-mode.el}
\\
\hline
Textmate 2
&
\sphinxcode{\sphinxupquote{1.0}}
&
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-textmate}{FreeFem.tmbundle}
\\
\hline
Gedit
&
\sphinxcode{\sphinxupquote{1.0}}
&
\sphinxhref{https://github.com/FreeFem/Freefem-parser-gedit}{ffpp.lang}
\\
\hline
Atom
&
\sphinxcode{\sphinxupquote{0.3}}
&
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-atom}{language-freefem} or via the Atom package manager
\\
\hline
Pygments
&
\sphinxcode{\sphinxupquote{1.0}}
&
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-pygments}{freefem.py}
\\
\hline
Vim
&
\sphinxcode{\sphinxupquote{0.1}}
&
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-vim}{edp.vim}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Installation guide}
\label{\detokenize{introduction/installation:installation-guide}}\label{\detokenize{introduction/installation::doc}}

\subsection{Easy installation}
\label{\detokenize{introduction/installation:easy-installation}}
First, go to the {\hyperref[\detokenize{introduction/download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{download page}}}} and choose your platform: Linux, MacOS or Windows.

\begin{sphinxadmonition}{note}{Note:}
Binary packages are available for Microsoft Windows, MacOS and some Linux distributions.
\end{sphinxadmonition}

Install \sphinxstylestrong{FreeFem++} by double-clicking on the appropriate file. Under Linux and MacOS the install directory is one of the following \sphinxcode{\sphinxupquote{/usr/local/bin}}, \sphinxcode{\sphinxupquote{/usr/local/share/freefem++}}, \sphinxcode{\sphinxupquote{/usr/local/lib/ff++}}


\subsubsection{Windows binary installation}
\label{\detokenize{introduction/installation:windows-binary-installation}}
First download the windows installation executable, then double click to install \sphinxstylestrong{FreeFem++}.

In most cases just answer yes (or type return) to all questions.

Otherwise in the Additional Task windows, check the box “Add application directory to your system path.” This is required otherwise the program \sphinxcode{\sphinxupquote{ffglut.exe}} will not be found.

By now you should have two new icons on your desktop:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{FreeFem++ (VERSION).exe}}, the \sphinxcode{\sphinxupquote{freefem++}} application.

\item {} 
\sphinxcode{\sphinxupquote{FreeFem++ (VERSION) Examples}}, a link to the \sphinxcode{\sphinxupquote{freefem++}} examples folder.

\end{itemize}

where \sphinxcode{\sphinxupquote{(VERSION)}} is the version of the files (for example 3.59).

By default, the installed files are in \sphinxcode{\sphinxupquote{C:\textbackslash{}Programs Files\textbackslash{}FreeFem++}}. In this directory, you have all the \sphinxcode{\sphinxupquote{.dll}} files and other applications: \sphinxcode{\sphinxupquote{FreeFem++-nw.exe}}, \sphinxcode{\sphinxupquote{ffglut.exe}}, … The syntax for the command-line tools are the same as those of \sphinxcode{\sphinxupquote{FreeFem.exe}}.


\subsubsection{MacOS X binary installation}
\label{\detokenize{introduction/installation:macos-x-binary-installation}}
Download the MacOS X binary version file, extract all the files by double clicking on the icon of the file, go the the directory and put the \sphinxcode{\sphinxupquote{FreeFem+.app}} application in the \sphinxcode{\sphinxupquote{/Applications}} directory.

If you want terminal access to \sphinxstylestrong{FreeFem++} just copy the file \sphinxcode{\sphinxupquote{FreeFem++}} in a directory of your \sphinxcode{\sphinxupquote{\$PATH}} shell environment variable.


\subsubsection{Arch AUR package}
\label{\detokenize{introduction/installation:arch-aur-package}}
An up-to-date package of \sphinxstylestrong{FreeFem++} for Arch is available on the \sphinxhref{https://aur.archlinux.org/packages/freefem\%2B\%2B-git/}{Archlinux user repository}.

To install it:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://aur.archlinux.org/freefem++\PYGZhy{}git.git
\PYG{n+nb}{cd} freefem++\PYGZhy{}git
makepkg \PYGZhy{}si
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Thanks to \sphinxhref{https://github.com/stefanhusmann}{Stephan Husmann}
\end{sphinxadmonition}


\subsection{Text-editor}
\label{\detokenize{introduction/installation:text-editor}}

\subsubsection{Atom}
\label{\detokenize{introduction/installation:atom}}
In order to get the syntax highlighting in \sphinxhref{https://atom.io/}{Atom}, you have to install the \sphinxhref{https://atom.io/packages/language-freefem-official}{FreeFem++ language support}.

You can do it directly in Atom: Edit -\textgreater{} Preferences -\textgreater{} Install, and search for \sphinxcode{\sphinxupquote{language-freefem-offical}}.

To launch scripts directly from Atom, you have to install the \sphinxcode{\sphinxupquote{atom-runner}} package. Once installed, modify the Atom configuration file (Edit -\textgreater{} Config…) to have something like that:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+s+s2}{\PYGZdq{}*\PYGZdq{}}:
   ...

   runner:
      extensions:
         edp: \PYG{l+s+s2}{\PYGZdq{}FreeFem++\PYGZdq{}}
      scopes:
         \PYG{l+s+s2}{\PYGZdq{}Freefem++\PYGZdq{}}: \PYG{l+s+s2}{\PYGZdq{}FreeFem++\PYGZdq{}}
\end{sphinxVerbatim}

Reboot Atom, and use Alt+R to run a FreeFem++ script.


\subsubsection{Gedit}
\label{\detokenize{introduction/installation:gedit}}
In order to get the syntax highlighting in Gedit, you have to downlaod the \sphinxhref{https://github.com/FreeFem/FreeFem-parser-gedit}{Gedit parser} and copy it in \sphinxcode{\sphinxupquote{/usr/share/gtksourceview-3.0/language-specs/}}.


\subsection{Compilation}
\label{\detokenize{introduction/installation:compilation}}

\subsubsection{Compilation on OSX (\textgreater{}=10.13)}
\label{\detokenize{introduction/installation:compilation-on-osx-10-13}}
Remark: Blocks of code are shell commands in terminal.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Install Xcode, Xcode Command Line tools and Xcode Additional Tools from the \sphinxhref{https://developer.apple.com/download/more/}{Apple website}

\item {} 
Install gcc from \sphinxhref{http://hpc.sourceforge.net/}{http://hpc.sourceforge.net}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
curl \PYGZhy{}O http://prdownloads.sourceforge.net/hpc/gfortran\PYGZhy{}7.1\PYGZhy{}bin.tar.gz?download
sudo tar zxvf gfortran\PYGZhy{}7.1\PYGZhy{}bin.tar.gz \PYGZhy{}C /
\end{sphinxVerbatim}

\item {} 
Install autoconf and automake from \sphinxhref{https://www.macports.org}{macport} or with \sphinxhref{https://brew.sh}{Homebrew}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo port install autoconf
sudo port install automake
\end{sphinxVerbatim}

\item {} 
Install mactex from \sphinxhref{http://mirrors.ctan.org/systems/mac/mactex/MacTeX.pkg}{ctan}

\item {} 
Install the \sphinxhref{https://www.open-mpi.org/software/ompi/v4.0/}{openmpi} source code

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./configure \PYG{n+nv}{CC}\PYG{o}{=}/usr/local/bin/gcc \PYG{n+nv}{CXX}\PYG{o}{=}/usr/local/bin/g++ \PYG{n+nv}{F77}\PYG{o}{=}/usr/local/bin/gfortran \PYG{n+nv}{FC}\PYG{o}{=}/usr/local/bin/gfortran
make
sudo make install
\end{sphinxVerbatim}

\item {} 
Install \sphinxhref{https://www.gnu.org/software/gsl}{gsl}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
curl \PYGZhy{}O https://fr.mirror.babylon.network/gnu/gsl/gsl\PYGZhy{}2.4.tar.gz
tar zxvf gsl\PYGZhy{}2.4.tar.gz
\PYG{n+nb}{cd} gsl\PYGZhy{}2.4
./configure \PYG{n+nv}{CC}\PYG{o}{=}/usr/local/bin/gcc
make
sudo make install
\end{sphinxVerbatim}

\item {} 
Install \sphinxhref{https://git-scm.com/download/mac}{git}

\item {} 
Download the \sphinxstylestrong{FreeFem++} source from the repository

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources.git
\end{sphinxVerbatim}

\end{enumerate}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi )}
\makeatletter\def\p@enumii{\p@enumi \theenumi )}\makeatother
\setcounter{enumi}{8}
\item {} 
Compile \sphinxstylestrong{FreeFem++}. Don’t forget to update the MacOS SDK version with your own in the command below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
./configure \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}with\PYGZhy{}suffix=macos\PYGZhy{}10.13\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}without\PYGZhy{}fltk\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}enable\PYGZhy{}download\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}enable\PYGZhy{}optim\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}MPIRUN=/usr/local/bin/mpirun\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}enable\PYGZhy{}m64\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}without\PYGZhy{}x\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}CC=clang \PYGZhy{}isysroot /Applications/Xcode.app//Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}CFLAGS=\PYGZhy{}mmacosx\PYGZhy{}version\PYGZhy{}min=10.13\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}CXXFLAGS=\PYGZhy{}mmacosx\PYGZhy{}version\PYGZhy{}min=10.13 \PYGZhy{}std=c++11\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}CXX=clang++ \PYGZhy{}isysroot /Applications/Xcode.app//Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}F77=/usr/local/bin/gfortran\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}FC=/usr/local/bin/gfortran\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}MPICXX=/usr/local/bin/mpic++\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}MPICC=/usr/local/bin/mpicc\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}MPIFC=/usr/local/bin/mpif90\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}MPIF77=/usr/local/bin/mpif90\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}enable\PYGZhy{}maintainer\PYGZhy{}mode\PYGZsq{}}
make
sudo make install
\end{sphinxVerbatim}

\end{enumerate}


\subsubsection{Compilation on Ubuntu}
\label{\detokenize{introduction/installation:compilation-on-ubuntu}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Install the following dependencies

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo apt\PYGZhy{}get update \PYG{o}{\PYGZam{}\PYGZam{}} sudo apt\PYGZhy{}get upgrade
sudo apt\PYGZhy{}get install cpp freeglut3\PYGZhy{}dev g++ gcc gfortran \PYG{l+s+se}{\PYGZbs{}}
    ghostscript m4 make patch pkg\PYGZhy{}config wget python unzip \PYG{l+s+se}{\PYGZbs{}}
    libopenblas\PYGZhy{}dev liblapack\PYGZhy{}dev libhdf5\PYGZhy{}dev libgsl\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
    libscotch\PYGZhy{}dev libfftw3\PYGZhy{}dev libarpack2\PYGZhy{}dev libsuitesparse\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
    libmumps\PYGZhy{}seq\PYGZhy{}dev libnlopt\PYGZhy{}dev coinor\PYGZhy{}libipopt\PYGZhy{}dev libgmm++\PYGZhy{}dev libtet1.5\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
    gnuplot\PYGZhy{}qt autoconf automake autotools\PYGZhy{}dev bison flex gdb valgrind git cmake

\PYG{c+c1}{\PYGZsh{} mpich is required for the FreeFem parallel computing version}
sudo apt\PYGZhy{}get install mpich
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
In the oldest distribution of Ubuntu, \sphinxcode{\sphinxupquote{libgsl-dev}} does not exists, use \sphinxcode{\sphinxupquote{libgsl2-dev}} instead
\end{sphinxadmonition}

\item {} 
Download \sphinxstylestrong{FreeFem++} source from the repository

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources.git
\end{sphinxVerbatim}

\item {} 
Autoconf

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
autoreconf \PYGZhy{}i
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
if your autoreconf version is too old, do \sphinxcode{\sphinxupquote{tar zxvf AutoGeneratedFile.tar.gz}}
\end{sphinxadmonition}

\item {} 
Configure

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYGZhy{}\PYGZhy{}enable\PYGZhy{}optim \PYGZhy{}\PYGZhy{}disable\PYGZhy{}pastix
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
To see all the options, type \sphinxcode{\sphinxupquote{./configure -{-}help}}
\end{sphinxadmonition}

\item {} 
Download the packages

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./download/getall \PYGZhy{}a
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
All the third party packages have their own licence
\end{sphinxadmonition}

\item {} 
Download and compile petsc \& slepc

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} download/ff\PYGZhy{}petsc
make petsc\PYGZhy{}slepc \PYG{n+nv}{SUDO}\PYG{o}{=}sudo
\PYG{n+nb}{cd} \PYGZhy{}
\end{sphinxVerbatim}

\item {} 
Reconfigure with petsc and slepc

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./reconfigure
\end{sphinxVerbatim}

\item {} 
Build

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
make
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
If your computer has many threads, you can run \sphinxcode{\sphinxupquote{make}} in parallel using \sphinxcode{\sphinxupquote{make -j16}} for 16 threads, for example.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Optionnally, check the compilation with \sphinxcode{\sphinxupquote{make check}}
\end{sphinxadmonition}

\item {} 
Install

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo make install
\end{sphinxVerbatim}

\end{enumerate}


\subsubsection{Compilation on Arch Linux}
\label{\detokenize{introduction/installation:compilation-on-arch-linux}}
\begin{sphinxadmonition}{warning}{Warning:}
As Arch is in rolling release, the following information can be quickly outdated !
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxstylestrong{FreeFem++} fails to compile using the newest version of gcc 8.1.0, use an older one instead.
\end{sphinxadmonition}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Install the following dependencies:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
pacman \PYGZhy{}Syu
pacman \PYGZhy{}S git openmpi gcc\PYGZhy{}fortran wget python
    freeglut ghostscript m4 make patch gmm
    blas lapack hdf5 gsl fftw arpack suitesparse
    gnuplot autoconf automake bison flex gdb
    valgrind cmake texlive\PYGZhy{}most
\end{sphinxVerbatim}

\item {} 
Download the \sphinxstylestrong{FreeFem++} source from the repository

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources.git
\end{sphinxVerbatim}

\item {} 
Autoconf

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
autoreconf \PYGZhy{}i
\end{sphinxVerbatim}

\item {} 
Configure

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYGZhy{}\PYGZhy{}enable\PYGZhy{}optim \PYGZhy{}\PYGZhy{}disable\PYGZhy{}pastix
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
To see all the options, type \sphinxcode{\sphinxupquote{./configure -{-}help}}
\end{sphinxadmonition}

\item {} 
Download the packages

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./download/getall \PYGZhy{}a
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
All the third party packages have their own licence
\end{sphinxadmonition}

\item {} 
Download and compile petsc \& slepc

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} download/ff\PYGZhy{}petsc
make petsc\PYGZhy{}slepc \PYG{n+nv}{SUDO}\PYG{o}{=}sudo
\PYG{n+nb}{cd} \PYGZhy{}
\end{sphinxVerbatim}

\item {} 
Reconfigure with petsc and slepc

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./reconfigure
\end{sphinxVerbatim}

\item {} 
Build

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
make
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
If your computer has many threads, you can run \sphinxcode{\sphinxupquote{make}} in parallel using \sphinxcode{\sphinxupquote{make -j16}} for 16 threads, for example.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Optionnally, check the compilation with \sphinxcode{\sphinxupquote{make check}}
\end{sphinxadmonition}

\item {} 
Install

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo make install
\end{sphinxVerbatim}

\end{enumerate}


\subsubsection{Compilation on Linux with Intel software tools}
\label{\detokenize{introduction/installation:compilation-on-linux-with-intel-software-tools}}
Follow the \sphinxhref{https://software.intel.com/en-us/articles/building-freefem-with-intel-software-tools-for-developers}{guide}


\subsubsection{Compilation on Windows}
\label{\detokenize{introduction/installation:compilation-on-windows}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Install \sphinxhref{https://www.microsoft.com/en-us/download/details.aspx?id=49926}{MS MPI v7} (msmpisdk.msi and MSMpiSetup.exe)

\item {} 
Install \sphinxhref{https://www.msys2.org/}{Msys2} (x86\_64 version)

\item {} 
Start MSYS2 MSYS

\item {} 
Open \sphinxcode{\sphinxupquote{MSYS2 MSYS terminal}} to install dependancies
\begin{itemize}
\item {} 
for 64bits system:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
pacman \PYGZhy{}Syu
pacman \PYGZhy{}S autoconf automake\PYGZhy{}wrapper bash bash\PYGZhy{}completion \PYG{l+s+se}{\PYGZbs{}}
    bison bsdcpio bsdtar bzip2 coreutils curl dash file filesystem \PYG{l+s+se}{\PYGZbs{}}
    findutils flex gawk gcc gcc\PYGZhy{}fortran gcc\PYGZhy{}libs grep gzip inetutils info less lndir \PYG{l+s+se}{\PYGZbs{}}
    make man\PYGZhy{}db git mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}freeglut mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}gcc \PYG{l+s+se}{\PYGZbs{}}
    mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}gcc\PYGZhy{}fortran mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}gsl mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}hdf5 \PYG{l+s+se}{\PYGZbs{}}
    mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}openblas mintty msys2\PYGZhy{}keyring msys2\PYGZhy{}launcher\PYGZhy{}git \PYG{l+s+se}{\PYGZbs{}}
    msys2\PYGZhy{}runtime ncurses pacman pacman\PYGZhy{}mirrors pactoys\PYGZhy{}git patch pax\PYGZhy{}git \PYG{l+s+se}{\PYGZbs{}}
    perl pkg\PYGZhy{}config pkgfile rebase sed tar tftp\PYGZhy{}hpa \PYG{n+nb}{time} tzcode unzip util\PYGZhy{}linux which
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
for 32bits system:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
pacman \PYGZhy{}Syu
pacman \PYGZhy{}S autoconf automake\PYGZhy{}wrapper bash bash\PYGZhy{}completion \PYG{l+s+se}{\PYGZbs{}}
    bison bsdcpio bsdtar bzip2 coreutils curl dash file filesystem \PYG{l+s+se}{\PYGZbs{}}
    findutils flex gawk gcc gcc\PYGZhy{}fortran gcc\PYGZhy{}libs grep gzip inetutils info less lndir \PYG{l+s+se}{\PYGZbs{}}
    make man\PYGZhy{}db git mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}freeglut mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}gcc \PYG{l+s+se}{\PYGZbs{}}
    mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}gcc\PYGZhy{}fortran mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}gsl mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}hdf5 \PYG{l+s+se}{\PYGZbs{}}
    mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}openblas mintty msys2\PYGZhy{}keyring msys2\PYGZhy{}launcher\PYGZhy{}git \PYG{l+s+se}{\PYGZbs{}}
    msys2\PYGZhy{}runtime ncurses pacman pacman\PYGZhy{}mirrors pactoys\PYGZhy{}git patch pax\PYGZhy{}git \PYG{l+s+se}{\PYGZbs{}}
perl pkg\PYGZhy{}config pkgfile rebase sed tar tftp\PYGZhy{}hpa \PYG{n+nb}{time} tzcode unzip util\PYGZhy{}linux which
\end{sphinxVerbatim}

\item {} 
Open \sphinxcode{\sphinxupquote{MingW64 terminal}} (or \sphinxcode{\sphinxupquote{MingW32}}) to compile \sphinxstylestrong{FreeFem++}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
autoreconf \PYGZhy{}i
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYGZhy{}\PYGZhy{}disable\PYGZhy{}pastix \PYGZhy{}\PYGZhy{}disable\PYGZhy{}hips
./download/getall \PYGZhy{}a
make \PYGZhy{}j4
make check
make install
\end{sphinxVerbatim}

The \sphinxstylestrong{FreeFem++} executable (and some other like \sphinxcode{\sphinxupquote{ffmedit}}, …)
are in \sphinxcode{\sphinxupquote{C:\textbackslash{}msys64\textbackslash{}mingw64\textbackslash{}bin}} (or \sphinxcode{\sphinxupquote{C:\textbackslash{}msys32\textbackslash{}mingw32\textbackslash{}bin}}).

\end{enumerate}


\subsection{Environment variables and init file}
\label{\detokenize{introduction/installation:environment-variables-and-init-file}}
\sphinxstylestrong{FreeFem++} reads a user’s init file named \sphinxcode{\sphinxupquote{freefem++.pref}} to initialize global variables: \sphinxcode{\sphinxupquote{verbosity}}, \sphinxcode{\sphinxupquote{includepath}}, \sphinxcode{\sphinxupquote{loadpath}}.

\begin{sphinxadmonition}{note}{Note:}
The variable \sphinxcode{\sphinxupquote{verbosity}} changes the level of internal printing (0: nothing unless there are syntax errors, 1: few, 10: lots, etc. …), the default value is 2.

The included files are found in the \sphinxcode{\sphinxupquote{includepath}} list and the load files are found in the \sphinxcode{\sphinxupquote{loadpath}} list.
\end{sphinxadmonition}

The syntax of the file is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{verbosity} \PYG{o}{=} \PYG{l+m}{5}
\PYG{n+nv}{loadpath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Library/FreeFem++/lib\PYGZdq{}}
\PYG{n+nv}{loadpath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Users/hecht/Library/FreeFem++/lib\PYGZdq{}}
\PYG{n+nv}{includepath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Library/FreeFem++/edp\PYGZdq{}}
\PYG{n+nv}{includepath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Users/hecht/Library/FreeFem++/edp\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{} This is a comment}
\PYG{n+nv}{load} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}funcTemplate\PYGZdq{}}
\PYG{n+nv}{load} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}myfunction\PYGZdq{}}
\PYG{n+nv}{load} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}MUMPS\PYGZus{}seq\PYGZdq{}}
\end{sphinxVerbatim}

The possible paths for this file are
\begin{itemize}
\item {} 
under Unix and MacOs

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
/etc/freefem++.pref
\PYG{k}{\PYGZdl{}(}HOME\PYG{k}{)}/.freefem++.pref
freefem++.pref
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
under windows

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
freefem++.pref
\end{sphinxVerbatim}

We can also use shell environment variables to change verbosity and the search rule before the init files.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}VERBOSITY}\PYG{o}{=}\PYG{l+m}{50}
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}INCLUDEPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}dir;;dir2\PYGZdq{}}
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}LOADPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}dir;;dir3\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The separator between directories must be “;” and not “:” because “:” is used under Windows.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
To show the list of init of \sphinxstylestrong{FreeFem++} , do

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}VERBOSITY}\PYG{o}{=}\PYG{l+m}{100}\PYG{p}{;}
./FreeFem++\PYGZhy{}nw
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Contributing}
\label{\detokenize{introduction/contributing:contributing}}\label{\detokenize{introduction/contributing::doc}}

\subsection{Bug report}
\label{\detokenize{introduction/contributing:bug-report}}

\subsubsection{Concerning the \sphinxstylestrong{FreeFem++} documentation}
\label{\detokenize{introduction/contributing:concerning-the-freefem-documentation}}
Open an \sphinxhref{https://github.com/FreeFem/FreeFem-doc/issues}{Issue} on \sphinxstylestrong{FreeFem-doc} repository.


\subsubsection{Concerning the \sphinxstylestrong{FreeFem++} compilation or usage}
\label{\detokenize{introduction/contributing:concerning-the-freefem-compilation-or-usage}}
Open an \sphinxhref{https://github.com/FreeFem/FreeFem-sources/issues}{Issue} on \sphinxstylestrong{FreeFem-sources} repository.


\subsection{Improve content}
\label{\detokenize{introduction/contributing:improve-content}}
Ask one of the contributors for Collaborator Access or make a \sphinxhref{https://github.com/FreeFem/FreeFem-doc/pulls}{Pull Request}.


\section{Citation}
\label{\detokenize{introduction/citation:citation}}\label{\detokenize{introduction/citation::doc}}

\subsection{If you use \sphinxstylestrong{FreeFem++}, please cite the following reference in your work:}
\label{\detokenize{introduction/citation:if-you-use-freefem-please-cite-the-following-reference-in-your-work}}

\subsubsection{APA}
\label{\detokenize{introduction/citation:apa}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Hecht, F. (2012). New development in FreeFem++. Journal of numerical mathematics, 20(3\PYGZhy{}4), 251\PYGZhy{}266.
\end{sphinxVerbatim}


\subsubsection{ISO690}
\label{\detokenize{introduction/citation:iso690}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
HECHT, Frédéric. New development in FreeFem++. Journal of numerical mathematics, 2012, vol. 20, no 3\PYGZhy{}4, p. 251\PYGZhy{}266.
\end{sphinxVerbatim}


\subsubsection{MLA}
\label{\detokenize{introduction/citation:mla}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Hecht, Frédéric. \PYGZdq{}New development in FreeFem++.\PYGZdq{} Journal of numerical mathematics 20.3\PYGZhy{}4 (2012): 251\PYGZhy{}266.
\end{sphinxVerbatim}


\subsubsection{BibTeX}
\label{\detokenize{introduction/citation:bibtex}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nc}{@article}\PYG{p}{\PYGZob{}}\PYG{n+nl}{MR3043640}\PYG{p}{,}
  \PYG{n+na}{AUTHOR} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{Hecht, F.}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{TITLE} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{New development in FreeFem++}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{JOURNAL} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{J. Numer. Math.}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{FJOURNAL} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{Journal of Numerical Mathematics}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{VOLUME} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{20}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,} \PYG{n+na}{YEAR} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{2012}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{NUMBER} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{3\PYGZhy{}4}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,} \PYG{n+na}{PAGES} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{251\PYGZhy{}\PYGZhy{}265}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{ISSN} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{1570\PYGZhy{}2820}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{MRCLASS} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{65Y15}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{MRNUMBER} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{3043640}\PYG{l+s}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Authors}
\label{\detokenize{introduction/authors:authors}}\label{\detokenize{introduction/authors::doc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Frédéric Hecht
\\
\hline
Professor at \sphinxhref{https://www.ljll.math.upmc.fr/}{Laboratoire Jacques Louis
Lions} (LJLL), Pierre and Marie
Curie University, Paris
\\
\hline
\sphinxhref{mailto:frederic.hecht@sorbonne-universite.fr}{frederic.hecht@sorbonne-universite.fr}
\\
\hline
\sphinxurl{https://www.ljll.math.upmc.fr/hecht/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Sylvain Auliac
\\
\hline
Former PhD student at LJLL, optimization interface with
\sphinxhref{https://nlopt.readthedocs.io/en/latest/}{nlopt},
\sphinxhref{https://projects.coin-or.org/Ipopt}{ipopt},
\sphinxhref{https://en.wikipedia.org/wiki/CMA-ES}{cmaes}, …
\\
\hline
\sphinxurl{https://www.ljll.math.upmc.fr/auliac/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Olivier Pironneau
\\
\hline
Professor of numerical analysis at the Paris VI university and at
LJLL, numerical methods in fluid
\\
\hline
Member of the \sphinxhref{http://www.iufrance.fr/}{Institut Universitaire de
France} and \sphinxhref{http://www.academie-sciences.fr/fr/}{Academie des
Sciences}
\\
\hline
\sphinxurl{https://www.ljll.math.upmc.fr/pironneau/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Jacques Morice
\\
\hline
Former Post-Doc at LJLL, three dimensions mesh generation and
coupling with
\sphinxhref{https://www.ljll.math.upmc.fr/frey/logiciels/Docmedit.dir/index.html}{medit}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Antoine Le Hyaric
\\
\hline
Research engineer from \sphinxhref{http://www.cnrs.fr}{CNRS}, expert in
software engineering for scientific applications, electromagnetics
simulations, parallel computing and three-dimensionsal visualization
\\
\hline
\sphinxurl{https://www.ljll.math.upmc.fr/lehyaric/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Kohji Ohtsuka
\\
\hline
Professor at \sphinxhref{http://www.hkg.ac.jp/html/}{Hiroshima Kokusai Gakuin
University}, Japan and chairman of the
\sphinxhref{http://www.wseas.org}{World Scientific and Engineering Academy and
Society}, Japan. Fracture dynamic, modeling
and computing
\\
\hline
\sphinxurl{https://sites.google.com/a/comfos.org/comfos/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Pierre Jolivet
\\
\hline
\sphinxhref{http://www.cnrs.fr}{CNRS} researcher, MPI interface with \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc}, \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM}, …
\\
\hline
\sphinxurl{http://jolivet.perso.enseeiht.fr/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

And all the dedicated \sphinxhref{https://github.com/FreeFem/FreeFem-doc/graphs/contributors}{Github contributors}


\chapter{Tutorials}
\label{\detokenize{tutorial/index:tutorials}}\label{\detokenize{tutorial/index:tutorial}}\label{\detokenize{tutorial/index::doc}}
The \sphinxstylestrong{FreeFem++} language is {\hyperref[\detokenize{reference/types:referencetypes}]{\sphinxcrossref{\DUrole{std,std-ref}{typed}}}}, polymorphic and reentrant with {\hyperref[\detokenize{reference/types:typemacrodesign}]{\sphinxcrossref{\DUrole{std,std-ref}{macro generation}}}}.

Every variable must be typed and declared in a statement. Each statement is separated from the next by a semicolon \sphinxcode{\sphinxupquote{;}}.

The \sphinxstylestrong{FreeFem++} language is a C++ idiom with something that is more akin to LaTeX.

For the specialist, one key guideline is that \sphinxstylestrong{FreeFem++} rarely generates an internal finite element array, this was adopted for speed and consequently \sphinxstylestrong{FreeFem++} could be hard to beat in terms of execution speed, except for the time lost in the interpretation of the language (which can be reduced by a systematic usage of \sphinxcode{\sphinxupquote{varf}} and \sphinxcode{\sphinxupquote{matrix}} instead of \sphinxcode{\sphinxupquote{problem}}).

The Development Cycle: Edit\textendash{}Run/Visualize\textendash{}Revise

Many examples and tutorials are given there after and in the {\hyperref[\detokenize{example/index:examples}]{\sphinxcrossref{\DUrole{std,std-ref}{examples section}}}}.
It is better to study them and learn by example.

If you are a beginner in the finite element method, you may also have to read a book on variational formulations.

The development cycle includes the following steps:

\sphinxstylestrong{Modeling:} From strong forms of PDE to weak forms, one must know the variational formulation to use \sphinxstylestrong{FreeFem++}; one should also have an eye on the reusability of the variational formulation so as to keep the same internal matrices; a typical example is the time dependent heat equation with an implicit time scheme: the internal matrix can be factorized only once and \sphinxstylestrong{FreeFem++} can be taught to do so.

\sphinxstylestrong{Programming:} Write the code in \sphinxstylestrong{FreeFem++} language using a text editor such as the one provided in your integrated environment.

\sphinxstylestrong{Run:} Run the code (here written in file \sphinxcode{\sphinxupquote{mycode.edp}}).
That can also be done in terminal mode by :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
FreeFem++ mycode.edp
\end{sphinxVerbatim}

\sphinxstylestrong{Visualization:} Use the keyword \sphinxcode{\sphinxupquote{plot}} directly in \sphinxcode{\sphinxupquote{mycode.edp}} to display functions while \sphinxstylestrong{FreeFem++} is running.
Use the plot-parameter \sphinxcode{\sphinxupquote{wait=1}} to stop the program at each plot.

\sphinxstylestrong{Debugging:} A global variable \sphinxcode{\sphinxupquote{debug}} (for example) can help as in \sphinxcode{\sphinxupquote{wait=true}} to \sphinxcode{\sphinxupquote{wait=false}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{debug} \PYG{o}{=} \PYG{k+kr}{true}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{n}{debug}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//plot the borders to see the intersection}
\PYG{c+c1}{//so change (0.8 in 0.3 in b)}
\PYG{c+c1}{//if debug == true, press Enter to continue}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{n}{debug}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//plot Th then press Enter}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{g} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{n}{debug}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//plot the function f}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{n}{debug}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//plot the function g}
\end{sphinxVerbatim}

Changing debug to false will make the plots flow continuously.
Watching the flow of graphs on the screen (while drinking coffee) can then become a pleasant experience.

Error management

Error messages are displayed in the console window.
They are not always very explicit because of the template structure of the C++ code (we did our best!).
Nevertheless they are displayed at the right place.
For example, if you forget parenthesis as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{debug} \PYG{o}{=} \PYG{k+kr}{true}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then you will get the following message from \sphinxstylestrong{FreeFem++}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{l+m}{2} : mesh \PYG{n+nv}{Th} \PYG{o}{=} square\PYG{o}{(}\PYG{l+m}{10},10\PYG{p}{;}
 Error line number \PYG{l+m}{2}, in file bb.edp, before  token \PYG{p}{;}
parse error
  current \PYG{n+nv}{line} \PYG{o}{=} \PYG{l+m}{2}
Compile error : parse error
        line number :2, \PYG{p}{;}
error Compile error : parse error
        line number :2, \PYG{p}{;}
 \PYG{n+nv}{code} \PYG{o}{=} \PYG{l+m}{1}
\end{sphinxVerbatim}

If you use the same symbol twice as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{aaa} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{aaa}\PYG{p}{;}
\end{sphinxVerbatim}

then you will get the message:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{2} : real aaa\PYG{p}{;} The identifier aaa exists
      the existing \PYG{n+nb}{type} is \PYGZlt{}Pd\PYGZgt{}
      the new  \PYG{n+nb}{type} is \PYGZlt{}Pd\PYGZgt{}
\end{sphinxVerbatim}

If you find that the program isn’t doing what you want you may also use \sphinxcode{\sphinxupquote{cout}} to display in text format on the console window the value of variables, just as you would do in C++.

The following example works:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{fespace} \PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A}\PYG{p}{;}
\end{sphinxVerbatim}

Another trick is to \sphinxstyleemphasis{comment in and out} by using \sphinxcode{\sphinxupquote{//}} as in C++.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{aaa} \PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{c+c1}{// real aaa;}
\end{sphinxVerbatim}


\section{Getting started}
\label{\detokenize{tutorial/poisson:getting-started}}\label{\detokenize{tutorial/poisson:tutorialpoisson}}\label{\detokenize{tutorial/poisson::doc}}
For a given function \(f(x,y)\), find a function \(u(x,y)\) satisfying :
\begin{equation}\label{equation:tutorial/poisson:eqn:Poisson}
\begin{split}\begin{array}{rcl}
    -\Delta u(x,y) &= f(x,y) & \mbox{ for all }(x,y)\mbox{ in }\Omega\\
    u(x,y) &= 0 & \mbox{ for all }(x,y)\mbox{ on }\partial\Omega
\end{array}\end{split}
\end{equation}
Here \(\partial\Omega\) is the boundary of the bounded open set \(\Omega\subset\mathbb{R}^2\) and \(\Delta u = \frac{\partial^2 u}{\partial x^2 } + \frac{\partial^2 u}{\partial y^2}\).

We will compute \(u\) with \(f(x,y)=xy\) and \(\Omega\) the unit disk. The boundary \(C=\partial\Omega\) is defined as:
\begin{equation*}
\begin{split}C=\{(x,y)|\; x=\cos(t),\, y=\sin(t),\, 0\le t\le 2\pi\}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
In \sphinxstylestrong{FreeFem++}, the domain \(\Omega\) is assumed to be described by the left side of its boundary.
\end{sphinxadmonition}

The following is the \sphinxstylestrong{FreeFem++} program which computes \(u\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Define mesh boundary}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// The triangulated domain Th is on the left side of its boundary}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// The finite element space defined over Th is called here Vh}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}\PYG{c+c1}{// Define u and v as piecewise\PYGZhy{}P1 continuous functions}

\PYG{c+c1}{// Define a function f}
\PYG{k+kt}{func} \PYG{n}{f}\PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Get the clock in second}
\PYG{k+kt}{real} \PYG{n}{cpu}\PYG{o}{=}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Define the PDE}
\PYG{k+kt}{solve} \PYG{n+nf}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}    \PYG{c+c1}{// The bilinear part}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}    \PYG{c+c1}{// The right hand side}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{// The Dirichlet boundary condition}

\PYG{c+c1}{// Plot the result}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Display the total computational time}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CPU time = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

As illustrated in \hyperref[\detokenize{tutorial/poisson:figpoissonu}]{Fig.\@ \ref{\detokenize{tutorial/poisson:figpoissonu}}}, we can see the isovalue of \(u\) by using \sphinxstylestrong{FreeFem++} \sphinxcode{\sphinxupquote{plot}} command (see line 29 above).

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{firstTh}.png}
\caption{Mesh Th by \sphinxcode{\sphinxupquote{buildmesh(C(50))}}}\label{\detokenize{tutorial/poisson:id1}}\label{\detokenize{tutorial/poisson:figpoissonmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{firstU}.png}
\caption{Isovalue by \sphinxcode{\sphinxupquote{plot(u)}}}\label{\detokenize{tutorial/poisson:id2}}\label{\detokenize{tutorial/poisson:figpoissonu}}\end{subfigure}
\caption{Poisson’s equation}\phantomsection\label{\detokenize{tutorial/poisson:Poisson}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
The qualifier \sphinxcode{\sphinxupquote{solver=LU}} (line 18) is not required and by default a multi-frontal \sphinxcode{\sphinxupquote{LU}} is used.

The lines containing \sphinxcode{\sphinxupquote{clock}} are equally not required.
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Note how close to the mathematics \sphinxstylestrong{FreeFem++} language is.

Lines 19 to 24 correspond to the mathematical variational equation:
\begin{equation*}
\begin{split}\int_{T_h}
(
   \frac{\partial u}{\partial x}\frac{\partial v}{\partial x}
   + \frac{\partial u}{\partial y}\frac{\partial v}{\partial y}
)\text{d} x \text{d} y
= \int_{T_h}f v\text{d} x\text{d} y\end{split}
\end{equation*}
for all \(v\) which are in the finite element space \(V_h\) and zero on the boundary \(C\).
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Change \sphinxcode{\sphinxupquote{P1}} into \sphinxcode{\sphinxupquote{P2}} and run the program.
\end{sphinxadmonition}

This first example shows how \sphinxstylestrong{FreeFem++} executes with no effort all the usual steps required by the finite element method (FEM).
Let’s go through them one by one.

\sphinxstylestrong{On the line 2}:

The boundary \(\Gamma\) is described analytically by a parametric equation for \(x\) and for \(y\).
When \(\Gamma=\sum_{j=0}^J \Gamma_j\) then each curve \(\Gamma_j\) must be specified and crossings of \(\Gamma_j\) are not allowed except at end points.

The keyword \sphinxcode{\sphinxupquote{label}} can be added to define a group of boundaries for later use (boundary conditions for instance).
Hence the circle could also have been described as two half circle with the same label:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{Gamma1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Boundaries can be referred to either by name (\sphinxcode{\sphinxupquote{Gamma1}} for example) or by label (\sphinxcode{\sphinxupquote{C}} here) or even by its internal number here 1 for the first half circle and 2 for the second (more examples are in {\hyperref[\detokenize{example/meshGeneration:examplemeshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Meshing Examples}}}}).

\sphinxstylestrong{On the line 5}

The triangulation \(\mathcal{T}_h\) of \(\Omega\) is automatically generated by \sphinxcode{\sphinxupquote{buildmesh(C(50))}} using 50 points on \sphinxcode{\sphinxupquote{C}} as in \hyperref[\detokenize{tutorial/poisson:figpoissonmesh}]{Fig.\@ \ref{\detokenize{tutorial/poisson:figpoissonmesh}}}.

The domain is assumed to be on the left side of the boundary which is implicitly oriented by the parametrization. So an elliptic hole can be added by typing:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

If by mistake one had written:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

then the inside of the ellipse would be triangulated as well as the outside.

\begin{sphinxadmonition}{note}{Note:}
Automatic mesh generation is based on the Delaunay-Voronoi algorithm.
Refinement of the mesh are done by increasing the number of points on \(\Gamma\), for example \sphinxcode{\sphinxupquote{buildmesh(C(100))}}, because inner vertices are determined by the density of points on the boundary.

Mesh adaptation can be performed also against a given function \sphinxtitleref{f} by calling \sphinxcode{\sphinxupquote{adaptmesh(Th,f)}}.
\end{sphinxadmonition}

Now the name \(\mathcal{T}_h\) (\sphinxcode{\sphinxupquote{Th}} in \sphinxstylestrong{FreeFem++}) refers to the family \(\{T_k\}_{k=1,\cdots,n_t}\) of triangles shown in \hyperref[\detokenize{tutorial/poisson:figpoissonmesh}]{Fig.\@ \ref{\detokenize{tutorial/poisson:figpoissonmesh}}}.

Traditionally \(h\) refers to the mesh size, \(n_t\) to the number of triangles in \(\mathcal{T}_h\) and \(n_v\) to the number of vertices, but it is seldom that we will have to use them explicitly.

If \(\Omega\) is not a polygonal domain, a “skin” remains between the exact domain \(\Omega\) and its approximation \(\Omega_h=\cup_{k=1}^{n_t}T_k\).
However, we notice that all corners of \(\Gamma_h = \partial\Omega_h\) are on \(\Gamma\).

\sphinxstylestrong{On line 8:}

A finite element space is, usually, a space of polynomial functions on elements, triangles here only, with certain matching properties at edges, vertices etc. Here \sphinxcode{\sphinxupquote{fespace Vh(Th, P1)}} defines \(V_h\) to be the space of continuous functions which are affine in \(x,y\) on each triangle of \(T_h\).

As it is a linear vector space of finite dimension, basis can be found.
The canonical basis is made of functions, called the \sphinxstyleemphasis{hat function} \(\phi_k\) which are continuous piecewise affine and are equal to 1 on one vertex and 0 on all others. A typical hat function is shown on \hyperref[\detokenize{tutorial/poisson:figpoissonhat}]{Fig.\@ \ref{\detokenize{tutorial/poisson:figpoissonhat}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{meshTh_2}.png}
\caption{\sphinxcode{\sphinxupquote{mesh Th}}}\label{\detokenize{tutorial/poisson:id3}}\label{\detokenize{tutorial/poisson:figpoissonmesh2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{hat_functions}.png}
\caption{Graph of \(\phi_1\) (left) and \(\phi_6\) (right)}\label{\detokenize{tutorial/poisson:id4}}\label{\detokenize{tutorial/poisson:figpoissonhat}}\end{subfigure}
\caption{Hat functions}\phantomsection\label{\detokenize{tutorial/poisson:HatFunctions}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
The easiest way to define \(\phi_k\) is by making use of the \sphinxstyleemphasis{barycentric coordinates} \(\lambda_i(x,y),~i=1,2,3\) of a point \(q=(x,y)\in T\), defined by \(\sum_i\lambda_i=1,~~~\sum_i\lambda_i\vec q^i=\vec q\) where \(q^i,~i=1,2,3\) are the 3 vertices of \(T\).
Then it is easy to see that the restriction of \(\phi_k\) on \(T\) is precisely \(\lambda_k\).
\end{sphinxadmonition}

Then:
\begin{equation}\label{equation:tutorial/poisson:equation3}
\begin{split}V_h(\mathcal{T}_h,P_1)=\left\{w(x,y)\left|\; w(x,y)=\sum_{k=1}^{M}w_k\phi_k(x,y),\, w_k\textrm{ are real numbers}\right.\right\}\end{split}
\end{equation}
where \(M\) is the dimension of \(V_h\), i.e. the number of vertices.
The \(w_k\) are called the \sphinxstyleemphasis{degree of freedom} of \(w\) and \(M\) the number of degree of freedom.

It is said also that the \sphinxstyleemphasis{nodes} of this finite element method are the vertices.

\sphinxstylestrong{Setting the problem}

On line 9, \sphinxcode{\sphinxupquote{Vh u, v}} declares that \(u\) and \(v\) are approximated as above, namely:
\begin{equation}\label{equation:tutorial/poisson:defu}
\begin{split}u(x,y)\simeq u_h(x,y)=\sum_{k=0}^{M-1} u_k\phi_k(x,y)\end{split}
\end{equation}
On the line 12, the right hand side \sphinxcode{\sphinxupquote{f}} is defined analytically using the keyword \sphinxcode{\sphinxupquote{func}}.

Line 18 to 26 define the bilinear form of equation \eqref{equation:tutorial/poisson:eqn:Poisson} and its Dirichlet boundary conditions.

This \sphinxstyleemphasis{variational formulation} is derived by multiplying \eqref{equation:tutorial/poisson:eqn:Poisson} by \(v(x,y)\) and integrating the result over \(\Omega\):
\begin{equation*}
\begin{split}-\int_{\Omega}v\Delta u \,\text{d} x\text{d} y = \int_{\Omega} vf\, \text{d} x\text{d} y\end{split}
\end{equation*}
Then, by Green’s formula, the problem is converted into finding \(u\) such that
\begin{equation*}
\begin{split}a(u,v) - \ell(f,v) = 0 \quad \forall v \mbox{ satisfying }v=0\mbox{ on }\partial\Omega.\end{split}
\end{equation*}
with:
\begin{equation}\label{equation:tutorial/poisson:eqn:weakform}
\begin{split}\begin{array}{rcl}
    a(u,v) &=& \int_{\Omega}\nabla u\cdot \nabla v \,\text{d} x\text{d} y\\
    \ell(f,v) &=& \int_{\Omega}fv\, \text{d} x\text{d} y
\end{array}\end{split}
\end{equation}
In \sphinxstylestrong{FreeFem++} the \sphinxstylestrong{Poisson} problem can be declared only as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{;} \PYG{k+kt}{problem} \PYG{n}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

and solved later as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Poisson}\PYG{p}{;} \PYG{c+c1}{//the problem is solved here}
\end{sphinxVerbatim}

or declared and solved at the same time as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{;} \PYG{k+kt}{solve} \PYG{n}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

and \eqref{equation:tutorial/poisson:eqn:weakform} is written with \sphinxcode{\sphinxupquote{dx(u)}} \(=\partial u/\partial x\), \sphinxcode{\sphinxupquote{dy(u)}} \(=\partial u/\partial y\) and:

\(\displaystyle{\int_{\Omega}\nabla u\cdot \nabla v\, \text{d} x\text{d} y \longrightarrow}\)
\sphinxcode{\sphinxupquote{int2d(Th)( dx(u)*dx(v) + dy(u)*dy(v) )}}

\(\displaystyle{\int_{\Omega}fv\, \text{d} x\text{d} y \longrightarrow}\)
\sphinxcode{\sphinxupquote{int2d(Th)( f*v )}} (Notice here, \(u\) is unused)

\begin{sphinxadmonition}{warning}{Warning:}
In \sphinxstylestrong{FreeFem++} \sphinxstylestrong{bilinear terms and linear terms should not be under the same integral} indeed to construct the linear systems \sphinxstylestrong{FreeFem++} finds out which integral contributes to the bilinear form by checking if both terms, the unknown (here \sphinxcode{\sphinxupquote{u}}) and test functions (here \sphinxcode{\sphinxupquote{v}}) are present.
\end{sphinxadmonition}

\sphinxstylestrong{Solution and visualization}

On line 15, the current time in seconds is stored into the real-valued variable \sphinxcode{\sphinxupquote{cpu}}.

Line 18, the problem is solved.

Line 29, the visualization is done as illustrated in \hyperref[\detokenize{tutorial/poisson:figpoissonu}]{Fig.\@ \ref{\detokenize{tutorial/poisson:figpoissonu}}}.

\sphinxstylestrong{(see} {\hyperref[\detokenize{documentation/visualization:plot}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot}}}} \sphinxstylestrong{for zoom, postscript and other commands).}

Line 32, the computing time (not counting graphics) is written on the console. Notice the C++-like syntax; the user needs not study C++ for using \sphinxstylestrong{FreeFem++}, but it helps to guess what is allowed in the language.

\sphinxstylestrong{Access to matrices and vectors}

Internally \sphinxstylestrong{FreeFem++} will solve a linear system of the type
\begin{equation}\label{equation:tutorial/poisson:eqn:Equation}
\begin{split}\sum_{j=0}^{M-1} A_{ij}u_j - F_i=0 ,\quad i=0,\cdots,M-1;\qquad
F_i=\int_{\Omega}f\phi_i\, \text{d} x\text{d} y\end{split}
\end{equation}
which is found by using \eqref{equation:tutorial/poisson:defu} and replacing \(v\) by \(\phi_i\) in \eqref{equation:tutorial/poisson:eqn:weakform}.
The Dirichlet conditions are implemented by penalty, namely by setting \(A_{ii}=10^{30}\) and \(F_i=10^{30}*0\) if \(i\) is a boundary degree of freedom.

\begin{sphinxadmonition}{note}{Note:}
The number \(10^{30}\) is called \sphinxcode{\sphinxupquote{tgv}} (\sphinxstyleemphasis{très grande valeur} or \sphinxstyleemphasis{very high value} in english) and it is generally possible to change this value, see the item :freefem{}`solve, tgv={}`
\end{sphinxadmonition}

The matrix \(A=(A_{ij})\) is called \sphinxstyleemphasis{stiffness matrix}.
If the user wants to access \(A\) directly he can do so by using (see section {\hyperref[\detokenize{documentation/finiteElement:variationalformsparsematrixpde}]{\sphinxcrossref{\DUrole{std,std-ref}{Variational form, Sparse matrix, PDE data vector}}}} for details).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{a}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//stiffness matrix}
\end{sphinxVerbatim}

The vector \(F\) in \eqref{equation:tutorial/poisson:eqn:Equation} can also be constructed manually:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{l}\PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,} \PYG{k+kr}{unused}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{F}\PYG{p}{;}
\PYG{n}{F}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{l}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//F[] is the vector associated to the function F}
\end{sphinxVerbatim}

The problem can then be solved by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{F}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//u[] is the vector associated to the function u}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Here \sphinxcode{\sphinxupquote{u}} and \sphinxcode{\sphinxupquote{F}} are finite element function, and \sphinxcode{\sphinxupquote{u{[}{]}}} and \sphinxcode{\sphinxupquote{F{[}{]}}} give the array of value associated (\sphinxcode{\sphinxupquote{u{[}{]}}} \(\equiv (u_i)_{i=0,\dots,M-1}\) and \sphinxcode{\sphinxupquote{F{[}{]}}} \(\equiv (F_i)_{i=0,\dots,M-1}\)).

So we have:
\begin{equation*}
\begin{split}\mathtt{u}(x,y) = \sum_{i=0}^{M-1} \mathtt{u[][}i\mathtt{]} \phi_i(x,y) ,
\qquad \mathtt{F}(x,y) = \sum_{i=0}^{M-1} \mathtt{F[][}i\mathtt{]} \phi_i(x,y)\end{split}
\end{equation*}
where \(\phi_i, i=0...,,M-1\) are the basis functions of \sphinxtitleref{Vh} like in equation (ref\{equation3\}), and \(M = \mathtt{Vh.ndof}\) is the number of degree of freedom (i.e. the dimension of the space \sphinxtitleref{Vh}).
\end{sphinxadmonition}

The linear system \eqref{equation:tutorial/poisson:eqn:Equation} is solved by \sphinxcode{\sphinxupquote{UMFPACK}} unless another option is mentioned specifically as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

meaning that \sphinxcode{\sphinxupquote{Poisson}} is declared only here and when it is called (by simply writing \sphinxcode{\sphinxupquote{Poisson;}}) then \eqref{equation:tutorial/poisson:eqn:Equation} will be solved by the Conjugate Gradient method.


\section{Classification of partial differential equations}
\label{\detokenize{tutorial/equationsClassification:classification-of-partial-differential-equations}}\label{\detokenize{tutorial/equationsClassification::doc}}
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{It is usually not easy to determine the type of a system.}
\sphinxstyleemphasis{Yet the approximations and algorithms suited to the problem depend on its type:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Finite Elements compatible (LBB conditions) for elliptic systems}

\item {} 
\sphinxstyleemphasis{Finite difference on the parabolic variable and a time loop on each elliptic subsystem of parabolic systems; better stability diagrams when the schemes are implicit in time.}

\item {} 
\sphinxstyleemphasis{Upwinding, Petrov-Galerkin, Characteristics-Galerkin, Discontinuous-Galerkin, Finite Volumes for hyperbolic systems plus, possibly, a time loop.}

\end{itemize}

\sphinxstyleemphasis{When the system changes type, then expect difficulties (like shock discontinuities) !}

\sphinxstylestrong{Elliptic, parabolic and hyperbolic equations}

A partial differential equation (PDE) is a relation between a function of several variables and its derivatives.
\begin{equation*}
\begin{split}F\left(\varphi(x),{\partial\varphi\over\partial
x_1}(x),\cdots,{\partial\varphi\over\partial
x_d}(x),{\partial^2\varphi\over\partial
x^2_1}(x),\cdots,{\partial^m\varphi\over\partial x^m_d}(x)\right) =
0,\quad\forall x\in\Omega\subset \mathbb{R}^d\end{split}
\end{equation*}
The range of \(x\) over which the equation is taken, here \(\Omega\), is called the \sphinxstyleemphasis{domain} of the PDE.
The highest derivation index, here \(m\), is called the \sphinxstyleemphasis{order}.
If \(F\) and \(\varphi\) are vector valued functions, then the PDE is actually a \sphinxstyleemphasis{system} of PDEs.

Unless indicated otherwise, here by convention \sphinxstyleemphasis{one} PDE corresponds to one scalar valued \(F\) and \(\varphi\).
If \(F\) is linear with respect to its arguments, then the PDE is said to be \sphinxstyleemphasis{linear}.

The general form of a second order, linear scalar PDE is \({\partial^2\varphi\over\partial x_i\partial x_j}\) and \(A:B\) means \(\sum^d_{i,j=1} a_{ij} b_{ij}.\)
\begin{equation*}
\begin{split}\alpha\varphi + a\cdot\nabla\varphi + B :\nabla(\nabla\varphi) =
f{\quad\hbox{ in }\quad}\Omega\subset \mathbb{R}^d,\end{split}
\end{equation*}
where \(f(x),\alpha(x)\in \mathbb{R}\), \(a(x)\in \mathbb{R}^d\), \(B(x)\in \mathbb{R}^{d\times d}\) are the PDE \sphinxstyleemphasis{coefficients}.
If the coefficients are independent of \(x\), the PDE is said to have \sphinxstyleemphasis{constant coefficients}.

To a PDE we associate a quadratic form, by replacing \(\varphi\) by \(1\), \(\partial\varphi/\partial x_i\) by \(z_i\) and \(\partial^2\varphi/\partial x_i\partial x_j\) by \(z_i z_j\), where \(z\) is a vector in \(\mathbb{R}^d\):
\begin{equation*}
\begin{split}\alpha + A\cdot z + z^T Bz = f.\end{split}
\end{equation*}
If it is the equation of an ellipse (ellipsoid if \(d \geq 2\)), the PDE is said to be \sphinxstyleemphasis{elliptic}; if it is the equation of a parabola or a hyperbola, the PDE is said to be \sphinxstyleemphasis{parabolic} or \sphinxstyleemphasis{hyperbolic}.

If \(A \equiv 0\), the degree is no longer 2 but 1, and for reasons that will appear more clearly later, the PDE is still said to be hyperbolic.

These concepts can be generalized to systems, by studying whether or not the polynomial system \(P(z)\) associated with the PDE system has branches at infinity (ellipsoids have no branches at infinity, paraboloids have one, and hyperboloids have several).

If the PDE is not linear, it is said to be \sphinxstyleemphasis{non-linear}.
Those are said to be locally elliptic, parabolic, or hyperbolic according to the type of the linearized equation.

For example, for the non-linear equation
\begin{equation*}
\begin{split}{\partial^2\varphi\over\partial t^2} - {\partial\varphi\over\partial x}{\partial^2\varphi\over\partial x^2} = 1\end{split}
\end{equation*}
we have \(d=2\), \(x_1 = t\), \(x_2 = x\) and its linearized form is:
\begin{equation*}
\begin{split}{\partial^2 u\over\partial t^2} - {\partial u\over\partial x}{\partial^2\varphi\over\partial x^2} - {\partial\varphi\over\partial x}{\partial^2 u\over\partial x^2} = 0\end{split}
\end{equation*}
which for the unknown \(u\) is locally elliptic if \({\partial\varphi\over\partial x} < 0\) and locally hyperbolic if \({\partial\varphi\over\partial x} > 0\).

\begin{sphinxadmonition}{tip}{Tip:}
Laplace’s equation is elliptic:
\begin{equation*}
\begin{split}\Delta\varphi \equiv {\partial^2\varphi\over\partial x^2_1}
    + {\partial^2\varphi\over\partial x^2_2}
    + \cdots
    + {\partial^2\varphi\over\partial x^2_d} = f,\ \forall x
    \in \Omega\subset \mathbb{R}^d\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
The \sphinxstyleemphasis{heat} equation is parabolic in \(Q = \Omega\times]0,T[\subset \mathbb{R}^{d+1}\):
\begin{equation*}
\begin{split}{\partial\varphi\over\partial t} - \mu\Delta\varphi = f
    \ \forall x\in\Omega\subset \mathbb{R}^d, \ \forall t\in]0,T[\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
If \(\mu>0\), the \sphinxstyleemphasis{wave} equation is hyperbolic:
\begin{equation*}
\begin{split}{\partial^2\varphi\over\partial t^2} - \mu\Delta\varphi
    = f{\ \hbox{ in }\ } Q.\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
The \sphinxstyleemphasis{convection diffusion} equation is parabolic if \(\mu \neq 0\) and hyperbolic otherwise:
\begin{equation*}
\begin{split}{\partial\varphi\over\partial t}
    + a\nabla\varphi
    - \mu\Delta\varphi
    = f\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
The \sphinxstyleemphasis{biharmonic} equation is elliptic:
\begin{equation*}
\begin{split}\Delta(\Delta\varphi) = f{\ \hbox{ in }\ }\Omega.\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxstylestrong{Boundary conditions}

A relation between a function and its derivatives is not sufficient to define the function.
Additional information on the boundary \(\Gamma=\partial\Omega\) of \(\Omega\), or on part of \(\Gamma\) is necessary.
Such information is called a \sphinxstyleemphasis{boundary condition}.

For example:
\begin{equation*}
\begin{split}\varphi(x) \ \hbox{given},\ \forall x\in \Gamma,\end{split}
\end{equation*}
is called a \sphinxstyleemphasis{Dirichlet boundary condition}. The \sphinxstyleemphasis{Neumann} condition is
\begin{equation*}
\begin{split}{\partial\varphi\over\partial \mathbf{n}}(x) \ \hbox{given on }\
\Gamma \hbox{ (or } \mathbf{n}\cdot B\nabla\varphi,\hbox{given on }\
\Gamma\hbox{ for a general second order PDE)}\end{split}
\end{equation*}
where \(\mathbf{n}\) is the normal at \(x\in\Gamma\) directed towards the exterior of \(\Omega\) (by definition \({\partial\varphi\over\partial \mathbf{n}}=\nabla\varphi\cdot \mathbf{n}\)).

Another classical condition, called a \sphinxstyleemphasis{Robin} (or \sphinxstyleemphasis{Fourier}) condition is written as:
\begin{equation*}
\begin{split}\varphi(x) + \beta(x) {\partial\varphi\over\partial n}(x) \ \hbox{given on}\ \Gamma.\end{split}
\end{equation*}
Finding a set of boundary conditions that defines a unique \(\varphi\) is a difficult art.

In general, an elliptic equation is well posed (\sphinxstyleemphasis{i.e.} \(\varphi\) is unique) with one Dirichlet, Neumann or Robin condition on the whole boundary.

Thus, Laplace’s equation is well posed with a Dirichlet or Neumann condition but also with :
\begin{equation*}
\begin{split}\varphi \ \hbox{given on}\ \Gamma_1,\ {\partial\varphi\over\partial n} \ \hbox{given on}\ \Gamma_2, \ \Gamma_1\cup\Gamma_2 =\Gamma,\ {\dot{\Gamma_1}\cap\dot{\Gamma_2}} =\emptyset.\end{split}
\end{equation*}
Parabolic and hyperbolic equations rarely require boundary conditions on all of \(\Gamma\times]0,T[\).
For instance, the heat equation is well posed with :
\begin{equation*}
\begin{split}\varphi \ \hbox{given at}\ t=0 \ \hbox{and Dirichlet or Neumann or mixed conditions on}\
\partial\Omega.\end{split}
\end{equation*}
Here \(t\) is time so the first condition is called an initial condition.
The whole set of conditions is also called Cauchy condition.

The wave equation is well posed with :
\begin{equation*}
\begin{split}\varphi \ \hbox{and}\ {\partial\varphi\over\partial t} \
\hbox{given at}\ t=0
\ \hbox{and Dirichlet or Neumann or mixed conditions on}\
\partial\Omega.\end{split}
\end{equation*}

\section{Membrane}
\label{\detokenize{tutorial/membrane:membrane}}\label{\detokenize{tutorial/membrane:tutorialmembrane}}\label{\detokenize{tutorial/membrane::doc}}
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{Here we shall learn how to solve a Dirichlet and/or mixed Dirichlet Neumann problem for the Laplace operator with application to the equilibrium of a membrane under load.
We shall also check the accuracy of the method and interface with other graphics packages}

An elastic membrane \(\Omega\) is attached to a planar rigid support \(\Gamma\), and a force \(f(x) dx\) is exerted on each surface element \(\text{d}{x}=\text{d}{x}_1 \text{d}{x}_2\).
The vertical membrane displacement, \(\varphi(x)\), is obtained by solving Laplace’s equation:
\begin{equation*}
\begin{split}-\Delta \varphi =f ~\hbox{in}~ \Omega\end{split}
\end{equation*}
As the membrane is fixed to its planar support, one has:
\begin{equation*}
\begin{split}\varphi |_{\Gamma }=0\end{split}
\end{equation*}
If the support wasn’t planar but had an elevation \(z(x_1,x_2)\) then the boundary conditions would be of non-homogeneous Dirichlet type.
\begin{equation*}
\begin{split}\varphi|_{\Gamma}=z\end{split}
\end{equation*}
If a part \(\Gamma_2\) of the membrane border \(\Gamma\) is not fixed to the support but is left hanging, then due to the membrane’s rigidity the angle with the normal vector \(n\) is zero; thus the boundary conditions are:
\begin{equation*}
\begin{split}\varphi|_{\Gamma_1}=z,~~~~\frac{\partial\varphi}{\partial n}|_{\Gamma_2}=0\end{split}
\end{equation*}
where \(\Gamma_1=\Gamma-\Gamma_2\); recall that \(\frac{\partial\varphi}{\partial n}=\nabla\varphi\cdot n\)
Let us recall also that the Laplace operator \(\Delta\) is defined by:
\begin{equation*}
\begin{split}\Delta \varphi = {\partial ^{2}\varphi \over \partial x^{2}_{1} }
+ {\partial ^{2}\varphi \over \partial x_{2}^{2} }\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{\label{tutorial/membrane:index-0}Todo:}
Check references
\end{sphinxadmonition}

With such \sphinxstyleemphasis{“mixed boundary conditions”} the problem has a unique solution (see Dautray-Lions (1988), Strang (1986) and Raviart-Thomas (1983)).
The easiest proof is to notice that \(\varphi\) is the state of least energy, i.e.
\begin{equation*}
\begin{split}E(\phi) =\min_{\varphi-z\in V} E(v) ,\quad \mbox{with} \quad E(v)=\int_\Omega(\frac12|\nabla v|^2-fv )\end{split}
\end{equation*}
and where \(V\) is the subspace of the Sobolev space \(H^1(\Omega)\) of functions which have zero trace on \(\Gamma_1\).
Recall that (\(x\in\mathbb{R}^d,~d=2\) here):
\begin{equation*}
\begin{split}H^1(\Omega)=\{u\in L^2(\Omega)~:~\nabla u\in (L^2(\Omega))^d\}\end{split}
\end{equation*}
Calculus of variation shows that the minimum must satisfy, what is known as the weak form of the PDE or its variational formulation (also known here as the theorem of virtual work)
\begin{equation*}
\begin{split}\int_\Omega \nabla\varphi\cdot\nabla w = \int_\Omega f w\quad\forall w\in V\end{split}
\end{equation*}
Next an integration by parts (Green’s formula) will show that this is equivalent to the PDE when second derivatives exist.

\begin{sphinxadmonition}{warning}{Warning:}
Unlike Freefem+ which had both weak and strong forms, \sphinxstylestrong{FreeFem++} implements only weak formulations.
It is not possible to go further in using this software if you don’t know the weak form (i.e. variational formulation) of your problem: either you read a book, or ask help form a colleague or drop the matter.
Now if you want to solve a system of PDE like \(A(u,v)=0,~ B(u,v)=0\) don’t close this manual, because in weak form it is
\end{sphinxadmonition}
\begin{equation*}
\begin{split}\int_\Omega(A(u,v)w_1+B(u,v)w_2)=0~~\forall w_1,w_2...\end{split}
\end{equation*}
\sphinxstylestrong{Example}

Let an ellipse have the length of the semimajor axis \(a=2\), and unitary the semiminor axis.
Let the surface force be \(f=1\).
Programming this case with \sphinxstylestrong{FreeFem++} gives:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{c+c1}{//The length of the semimajor axis}
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//The length of the semiminor axis}
\PYG{k+kt}{func} \PYG{k+kr}{z} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{theta}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma2}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//P2 conforming triangular FEM}
\PYG{n}{Vh} \PYG{n}{phi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{f}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{solve} \PYG{n+nf}{Laplace}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{w}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{,} \PYG{n}{phi}\PYG{o}{=}\PYG{k+kr}{z}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{membrane.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Plot phi}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{membraneTh.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Plot Th}

\PYG{c+c1}{// Save mesh}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

A triangulation is built by the keyword \sphinxcode{\sphinxupquote{buildmesh}}.
This keyword calls a triangulation subroutine based on the Delaunay test, which first triangulates with only the boundary points, then adds internal points by subdividing the edges.
How fine the triangulation becomes is controlled by the size of the closest boundary edges.

The PDE is then discretized using the triangular second order finite element method on the triangulation; as was briefly indicated in the previous chapter, a linear system is derived from the discrete formulation whose size is the number of vertices plus the number of mid-edges in the triangulation.

The system is solved by a multi-frontal Gauss LU factorization implemented in the package \sphinxcode{\sphinxupquote{UMFPACK}}.

The keyword \sphinxcode{\sphinxupquote{plot}} will display both \(\T_h\) and \(\varphi\) (remove \sphinxcode{\sphinxupquote{Th}} if \(\varphi\) only is desired) and the qualifier \sphinxcode{\sphinxupquote{fill=true}} replaces the default option (colored level lines) by a full color display.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,}\PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Plot phi with full color display}
\end{sphinxVerbatim}

Results are on \hyperref[\detokenize{tutorial/membrane:figmembranemesh}]{Fig.\@ \ref{\detokenize{tutorial/membrane:figmembranemesh}}} and \hyperref[\detokenize{tutorial/membrane:figmembranelevellines}]{Fig.\@ \ref{\detokenize{tutorial/membrane:figmembranelevellines}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{membraneTh}.png}
\caption{Mesh of the ellipse}\label{\detokenize{tutorial/membrane:id1}}\label{\detokenize{tutorial/membrane:figmembranemesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{membrane}.png}
\caption{Level lines of the membrane deformation}\label{\detokenize{tutorial/membrane:id2}}\label{\detokenize{tutorial/membrane:figmembranelevellines}}\end{subfigure}
\caption{Membrane}\phantomsection\label{\detokenize{tutorial/membrane:Membrane}}

\end{figure}


Next we would like to check the results !

One simple way is to adjust the parameters so as to know the solutions.
For instance on the unit circle \sphinxcode{\sphinxupquote{a=1}}, \(\varphi_e=\sin(x^2+y^2-1)\) solves the problem when:
\begin{equation*}
\begin{split}z=0, f=-4(\cos(x^2+y^2-1)-(x^2+y^2)\sin(x^2+y^2-1))\end{split}
\end{equation*}
except that on \(\Gamma_2\) \(\partial_n\varphi=2\) instead of zero.
So we will consider a non-homogeneous Neumann condition and solve:
\begin{equation*}
\begin{split}\int_\Omega\nabla\varphi\cdot\nabla w = \int_\Omega f w+\int_{\Gamma_2}2w\quad\forall w\in V\end{split}
\end{equation*}
We will do that with two triangulations, compute the \(L^2\) error:
\begin{equation*}
\begin{split}\epsilon = \int_\Omega|\varphi-\varphi_e|^2\end{split}
\end{equation*}
and print the error in both cases as well as the log of their ratio an indication of the rate of convergence.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//  Parameters}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//to remove all default output}
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//the length of the semimajor axis}
\PYG{k+kt}{real} \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//the length of the semiminor axis}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{phiexact} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{theta}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Error loop}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L2error}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//an array of two values}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Mesh}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma2}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Fespace}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{phi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{solve} \PYG{n+nf}{Laplace}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{f}\PYG{o}{*}\PYG{n}{w}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Gamma2}\PYG{p}{)}\PYG{p}{(}
              \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{w}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{,}\PYG{n}{phi}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{membrane.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{n}{L2error}\PYG{p}{[}\PYG{k+kr}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n}{phi}\PYG{o}{\PYGZhy{}}\PYG{n}{phiexact}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Display loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{L2error }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{L2error}\PYG{p}{[}\PYG{k+kr}{n}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Convergence rate}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{convergence rate = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{log}\PYG{p}{(}\PYG{n}{L2error}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{/}\PYG{n}{L2error}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n+nf}{log}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
L2error \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{0}.00462991
L2error \PYG{n+nv}{1} \PYG{o}{=} \PYG{l+m}{0}.00117128
convergence \PYG{n+nv}{rate} \PYG{o}{=} \PYG{l+m}{1}.9829
times: compile \PYG{l+m}{0}.02s, execution \PYG{l+m}{6}.94s
\end{sphinxVerbatim}

We find a rate of 1.93591, which is not close enough to the 3 predicted by the theory.

The Geometry is always a polygon so we lose one order due to the geometry approximation in \(O(h^2)\).

Now if you are not satisfied with the \sphinxcode{\sphinxupquote{.eps}} plot generated by \sphinxstylestrong{FreeFem++} and you want to use other graphic facilities, then you must store the solution in a file very much like in \sphinxcode{\sphinxupquote{C++}}.
It will be useless if you don’t save the triangulation as well, consequently you must do

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{phi.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{phi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For the triangulation the name is important: \sphinxstylestrong{the extension determines the format}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{gnumembrane}.png}
\caption{The 3D version drawn by \sphinxcode{\sphinxupquote{gnuplot}} from a file generated by \sphinxstylestrong{FreeFem++}}\label{\detokenize{tutorial/membrane:figmembrane}}\end{figure}

Still that may not take you where you want. Here is an interface with gnuplot to produce the \hyperref[\detokenize{tutorial/membrane:figmembrane}]{Fig.\@ \ref{\detokenize{tutorial/membrane:figmembrane}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//to build a gnuplot data file}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{graph.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{phi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

        \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{phi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

We use the finite element numbering, where \sphinxcode{\sphinxupquote{Wh(i,j)}} is the global index of \(j^{Th}\) degrees of freedom of triangle number \(i\).

Then open \sphinxcode{\sphinxupquote{gnuplot}} and do:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{set} \PYG{n+nb}{palette} \PYG{n}{rgbformulae} \PYG{l+m+mi}{30}\PYG{o}{,}\PYG{l+m+mi}{31}\PYG{o}{,}\PYG{l+m+mi}{32}
\PYG{k}{splot} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{graph.txt}\PYG{l+s}{\PYGZdq{}} \PYG{n+nb}{w} \PYG{n}{l} \PYG{n}{pal}
\end{sphinxVerbatim}

This works with \sphinxcode{\sphinxupquote{P2}} and \sphinxcode{\sphinxupquote{P1}}, but not with \sphinxcode{\sphinxupquote{P1nc}} because the 3 first degrees of freedom of \sphinxcode{\sphinxupquote{P2}} or \sphinxcode{\sphinxupquote{P2}} are on vertices and not with \sphinxcode{\sphinxupquote{P1nc}}.


\section{Heat Exchanger}
\label{\detokenize{tutorial/heatExchanger:heat-exchanger}}\label{\detokenize{tutorial/heatExchanger::doc}}
\sphinxstylestrong{Summary:}
\sphinxstyleemphasis{Here we shall learn more about geometry input and triangulation files, as well as read and write operations.}

\sphinxstylestrong{The problem} Let \(\{C_{i}\}_{1,2}\), be 2 thermal conductors within an enclosure \(C_0\) (see \hyperref[\detokenize{tutorial/heatExchanger:figheatmesh}]{Fig.\@ \ref{\detokenize{tutorial/heatExchanger:figheatmesh}}}).

The first one is held at a constant temperature \({u} _{1}\) the other one has a given thermal conductivity \(\kappa_2\) 5 times larger than the one of \(C_0\).

We assume that the border of enclosure \(C_0\) is held at temperature \(20^\circ C\) and that we have waited long enough for thermal equilibrium.

In order to know \({u} (x)\) at any point \(x\) of the domain \(\Omega\), we must solve:
\begin{equation*}
\begin{split}\nabla\cdot(\kappa\nabla{u}) = 0 \hbox{ in } \Omega,
\quad {u}_{|\Gamma} = g\end{split}
\end{equation*}
where \(\Omega\) is the interior of \(C_0\) minus the conductor \(C_1\) and \(\Gamma\) is the boundary of \(\Omega\), that is \(C_0\cup C_1\).

Here \(g\) is any function of \(x\) equal to \({u}_i\) on \(C_i\).

The second equation is a reduced form for:
\begin{equation*}
\begin{split}{u} ={u} _{i} \hbox{ on } C_{i}, \quad i=0,1.\end{split}
\end{equation*}
The variational formulation for this problem is in the subspace \(H^1_0(\Omega) \subset H^1(\Omega)\) of functions which have zero traces on \(\Gamma\).
\begin{equation*}
\begin{split}u-g\in H^1_0(\Omega): \int_{\Omega}{\nabla u \nabla v} = 0\forall v\in H^1_0(\Omega)\end{split}
\end{equation*}
Let us assume that \(C_0\) is a circle of radius 5 centered at the origin, \(C_i\) are rectangles, \(C_1\) being at the constant temperature \(u_1=60^\circ C\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{C1}\PYG{o}{=}\PYG{l+m+mi}{99}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{C2}\PYG{o}{=}\PYG{l+m+mi}{98}\PYG{p}{;} \PYG{c+c1}{//could be anything such that !=0 and C1!=C2}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C14}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.}\PYG{o}{+}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C23}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C24}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.}\PYG{o}{+}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{plot}\PYG{p}{(}   \PYG{n}{C0}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{c+c1}{//to see the border of the domain}
    \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C22}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C23}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C24}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,}
    \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{heatexb.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C22}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C23}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C24}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{kappa}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{solve} \PYG{n+nf}{a}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{kappa}\PYG{o}{*}\PYG{p}{(}
              \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HeatExchanger.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note the following:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{C0}} is oriented counterclockwise by \(t\), while \sphinxcode{\sphinxupquote{C1}} is oriented clockwise and \sphinxcode{\sphinxupquote{C2}} is oriented counterclockwise.
This is why \sphinxcode{\sphinxupquote{C1}} is viewed as a hole by \sphinxcode{\sphinxupquote{buildmesh}}.

\item {} 
\sphinxcode{\sphinxupquote{C1}} and \sphinxcode{\sphinxupquote{C2}} are built by joining pieces of straight lines.
To group them in the same logical unit to input the boundary conditions in a readable way we assigned a label on the boundaries.
As said earlier, borders have an internal number corresponding to their order in the program (check it by adding a \sphinxcode{\sphinxupquote{cout \textless{}\textless{} C22;}} above).
This is essential to understand how a mesh can be output to a file and re-read (see below).

\item {} 
As usual the mesh density is controlled by the number of vertices assigned to each boundary.
It is not possible to change the (uniform) distribution of vertices but a piece of boundary can always be cut in two or more parts, for instance \sphinxcode{\sphinxupquote{C12}} could be replaced by \sphinxcode{\sphinxupquote{C121+C122}}:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// border C12(t=0.,1.)\PYGZob{}x=2.; y=3.\PYGZhy{}6.*t; label=C1;\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C121}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C122}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{c+cm}{/*+ C12(20) */} \PYG{o}{+} \PYG{n}{C121}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C122}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{heat_exchangerTh}.png}
\caption{Heat exchanger mesh}\label{\detokenize{tutorial/heatExchanger:id1}}\label{\detokenize{tutorial/heatExchanger:figheatmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{heat_exchanger}.png}
\caption{Heat exchanger solution}\label{\detokenize{tutorial/heatExchanger:id2}}\label{\detokenize{tutorial/heatExchanger:figheatsolution}}\end{subfigure}
\caption{Heat exchanger}\phantomsection\label{\detokenize{tutorial/heatExchanger:HeatExchanger}}

\end{figure}


\begin{sphinxadmonition}{tip}{Tip:}
\sphinxstylestrong{Exercise :}

Use the symmetry of the problem with respect to the axes.

Triangulate only one half of the domain, and set Dirichlet conditions on the vertical axis, and Neumann conditions on the horizontal axis.
\end{sphinxadmonition}

\sphinxstylestrong{Writing and reading triangulation files} Suppose that at the end of the previous program we added the line

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{condensor.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and then later on we write a similar program but we wish to read the mesh from that file.
Then this is how the condenser should be computed:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Sh} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{condensor.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{us}\PYG{p}{,} \PYG{n}{vs}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{solve} \PYG{n+nf}{b}\PYG{p}{(}\PYG{n}{us}\PYG{p}{,} \PYG{n}{vs}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vs}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vs}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{us}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{99}\PYG{p}{,} \PYG{n}{us}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{98}\PYG{p}{,} \PYG{n}{us}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note that the names of the boundaries are lost but either their internal number (in the case of \sphinxcode{\sphinxupquote{C0}}) or their label number (for \sphinxcode{\sphinxupquote{C1}} and \sphinxcode{\sphinxupquote{C2}}) are kept.


\section{Acoustics}
\label{\detokenize{tutorial/acoustics:acoustics}}\label{\detokenize{tutorial/acoustics::doc}}
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{Here we go to grip with ill posed problems and eigenvalue problems}

Pressure variations in air at rest are governed by the wave equation:
\begin{equation*}
\begin{split}{\partial^2 u \over \partial t^2} - c^2 \Delta u =0\end{split}
\end{equation*}
When the solution wave is monochromatic (and that depends on the boundary and initial conditions), \(u\) is of the form \(u(x,t)=Re(v(x) e^{ik t})\) where \(v\) is a solution of Helmholtz’s equation:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    k^{2}v + c^{2}\Delta v &= 0 &\hbox{ in } \Omega\\
    \frac{\partial v}{\partial n}|_\Gamma &= g &
\end{array}\end{split}
\end{equation*}
where \(g\) is the source.

Note the “+” sign in front of the Laplace operator and that \(k > 0\) is real.
This sign may make the problem ill posed for some values of \(\frac c k\), a phenomenon called “resonance”.

At resonance there are non-zero solutions even when \(g=0\).
So the following program may or may not work:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{kc2} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{k+kr}{y}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a6}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{l+m+mf}{4.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a2}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{a3}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a4}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a5}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a6}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{solve} \PYG{n+nf}{sound}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v} \PYG{o}{*} \PYG{n}{kc2}
      \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
      \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{a4}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{g} \PYG{o}{*} \PYG{n}{v}
   \PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sound.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Results are on \hyperref[\detokenize{tutorial/acoustics:figacoustics1}]{Fig.\@ \ref{\detokenize{tutorial/acoustics:figacoustics1}}}. But when \(kc2\) is an eigenvalue of the problem, then the solution is not unique:
\begin{itemize}
\item {} 
if \(u_e \neq 0\) is an eigen state, then for any given solution \(u+u_e\) is \sphinxstylestrong{another} solution.

\end{itemize}

To find all the \(u_e\) one can do the following :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{c+c1}{//value of the shift}

\PYG{c+c1}{// Problem}
\PYG{c+c1}{// OP = A \PYGZhy{} sigma B ; // The shifted matrix}
\PYG{k+kt}{varf} \PYG{k+kp}{op}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
      \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
      \PYG{o}{\PYGZhy{}} \PYG{k+kp}{sigma}\PYG{o}{*} \PYG{n}{u1}\PYG{o}{*}\PYG{n}{u2}
   \PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{b}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u2}\PYG{p}{]}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u1}\PYG{o}{*}\PYG{n}{u2}
   \PYG{p}{)}
   \PYG{p}{;} \PYG{c+c1}{// No Boundary condition see note \PYGZbs{}ref\PYGZob{}note BC EV\PYGZcb{}}

\PYG{k+kt}{matrix} \PYG{n}{OP} \PYG{o}{=} \PYG{k+kp}{op}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Crout}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}20}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Eigen values}
\PYG{k+kt}{int} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{// Number of requested eigenvalues near sigma}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ev}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// To store the nev eigenvalue}
\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{eV}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// To store the nev eigenvector}

\PYG{k+kt}{int} \PYG{n}{k}\PYG{o}{=}\PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{n}{OP}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{k+kp}{sym}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{k+kp}{sigma}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{n}{ev}\PYG{p}{,} \PYG{k+kp}{vector}\PYG{o}{=}\PYG{n}{eV}\PYG{p}{,}
   \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kp}{maxit}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{ncv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ev}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ 2 eigen values }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ev}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{v} \PYG{o}{=} \PYG{n}{eV}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{eigen.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{acoustics_0}.png}
\caption{Amplitude of an acoustic signal coming from the left vertical wall.}\label{\detokenize{tutorial/acoustics:id1}}\label{\detokenize{tutorial/acoustics:figacoustics1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{acoustics}.png}
\caption{First eigen state (\(\lambda=(k/c)^2=19.4256\)) close to \(20\) of eigenvalue problem: \(-\Delta \varphi = \lambda\varphi\) and \(\frac{\partial \varphi}{\partial n} = 0\) on \(\Gamma\)\}}\label{\detokenize{tutorial/acoustics:id2}}\label{\detokenize{tutorial/acoustics:figacoustics2}}\end{subfigure}
\caption{Acoustics}\phantomsection\label{\detokenize{tutorial/acoustics:figAcoustics0}}

\end{figure}



\section{Thermal Conduction}
\label{\detokenize{tutorial/thermalConduction:thermal-conduction}}\label{\detokenize{tutorial/thermalConduction:thermalconduction}}\label{\detokenize{tutorial/thermalConduction::doc}}
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{Here we shall learn how to deal with a time dependent parabolic problem.
We shall also show how to treat an axisymmetric problem and show also how to deal with a nonlinear problem}

\sphinxstylestrong{How air cools a plate}

We seek the temperature distribution in a plate \((0,Lx)\times(0,Ly)\times(0,Lz)\) of rectangular cross section \(\Omega=(0,6)\times(0,1)\); the plate is surrounded by air at temperature \(u_e\) and initially at temperature \(u=u_0+\frac x L u_1\).
In the plane perpendicular to the plate at \(z=Lz/2\), the temperature varies little with the coordinate \(z\); as a first approximation the problem is 2D.

We must solve the temperature equation in \(\Omega\) in a time interval (0,T).
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \partial_t u -\nabla\cdot(\kappa\nabla u) &= 0 & \hbox{ in } \Omega\times(0,T)\\
    u(x,y,0) &= u_0+x u_1 &\\
    \kappa\frac{\partial u}{\partial n} +\alpha(u-u_e) &= 0 & \hbox{ on } \Gamma\times(0,T)
\end{array}\end{split}
\end{equation*}
Here the diffusion \(\kappa\) will take two values, one below the middle horizontal line and ten times less above, so as to simulate a thermostat.

The term \(\alpha(u-u_e)\) accounts for the loss of temperature by convection in air.
Mathematically this boundary condition is of Fourier (or Robin, or mixed) type.

The variational formulation is in \(L^2(0,T;H^1(\Omega))\); in loose terms and after applying an implicit Euler finite difference approximation in time; we shall seek \(u^n(x,y)\) satisfying for all \(w\in H^1(\Omega)\):
\begin{equation*}
\begin{split}\int_\Omega(\frac{u^n-u^{n-1}}{\delta t} w + \kappa\nabla u^n\nabla w) +\int_\Gamma\alpha(u^n-u_ue)w=0\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{u0} \PYG{o}{=} \PYG{l+m+mf}{10.} \PYG{o}{+} \PYG{l+m+mf}{90.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ue} \PYG{o}{=} \PYG{l+m+mf}{25.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.1} \PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uold}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{thermic}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{k}\PYG{o}{*}\PYG{p}{(}
              \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{ue}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{uold}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Time iterations}
\PYG{k+kt}{ofstream} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{thermic.dat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{uold} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//equivalent to u\PYGZca{}\PYGZob{}n\PYGZhy{}1\PYGZcb{} = u\PYGZca{}n}
    \PYG{n}{thermic}\PYG{p}{;} \PYG{c+c1}{//here the thermic problem is solved}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
We must separate by hand the bilinear part from the linear one.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
The way we store the temperature at point (3, 0.5) for all times in file \sphinxcode{\sphinxupquote{thermic.dat}}.
Should a one dimensional plot be required, the same procedure can be used. For instance to print \(x\mapsto \frac{\partial u}{\partial y}(x,0.9)\) one would do:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{6.0}\PYG{o}{*}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{20.0}\PYG{p}{,}\PYG{l+m+mf}{0.9}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

Results are shown on \hyperref[\detokenize{tutorial/thermalConduction:figthermalt}]{Fig.\@ \ref{\detokenize{tutorial/thermalConduction:figthermalt}}} and \hyperref[\detokenize{tutorial/thermalConduction:figthermalcurve}]{Fig.\@ \ref{\detokenize{tutorial/thermalConduction:figthermalcurve}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{thermic}.png}
\caption{Temperature at \(t=4.9\).}\label{\detokenize{tutorial/thermalConduction:id1}}\label{\detokenize{tutorial/thermalConduction:figthermalt}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{thermicvst}.png}
\caption{Decay of temperature versus time at \(x=3, y=0.5\)}\label{\detokenize{tutorial/thermalConduction:id2}}\label{\detokenize{tutorial/thermalConduction:figthermalcurve}}\end{subfigure}
\caption{Thermal conduction}

\end{figure}



\subsection{Axisymmetry: 3D Rod with circular section}
\label{\detokenize{tutorial/thermalConduction:axisymmetry-3d-rod-with-circular-section}}\label{\detokenize{tutorial/thermalConduction:ThermalConduction}}
Let us now deal with a cylindrical rod instead of a flat plate.
For simplicity we take \(\kappa=1\).

In cylindrical coordinates, the Laplace operator becomes (\(r\) is the distance to the axis, \(z\) is the distance along the axis, \(\theta\) polar angle in a fixed plane perpendicular to the axis):
\begin{equation*}
\begin{split}\Delta u = {1\over r}\partial _r(r\partial _r u) + {1\over r^2}\partial ^2_{\theta\theta} u
 + \partial ^2_{z z}.\end{split}
\end{equation*}
Symmetry implies that we loose the dependence with respect to \(\theta\); so the domain \(\Omega\) is again a rectangle \(]0,R[\times]0,|[\) .
We take the convention of numbering of the edges as in \sphinxcode{\sphinxupquote{square()}} (1 for the bottom horizontal …); the problem is now:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    r\partial_t u-\partial _r(r\partial _r u) - \partial _z(r\partial _z u) &= 0 &\hbox{ in } \Omega\\
    u(t=0) &= u_0 + \frac z{L_z} (u_1-u)&\\
    u|_{\Gamma_4} &= u_0&\\
    u|_{\Gamma_2} &= u_1&\\
    \alpha(u-u_e) + {\partial u\over \partial n} |_{\Gamma_1\cup\Gamma_3} &= 0&
\end{array}\end{split}
\end{equation*}
Note that the PDE has been multiplied by \(r\).

After discretization in time with an implicit scheme, with time steps \sphinxcode{\sphinxupquote{dt}}, in the FreeFem++ syntax \(r\) becomes \(x\) and \(z\) becomes \(y\) and the problem is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n+nf}{thermaxi}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{ue}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{uold}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The bilinear form degenerates at \(x=0\).
Still one can prove existence and uniqueness for \(u\) and because of this degeneracy no boundary conditions need to be imposed on \(\Gamma_1\).
\end{sphinxadmonition}


\subsection{A Nonlinear Problem : Radiation}
\label{\detokenize{tutorial/thermalConduction:a-nonlinear-problem-radiation}}
Heat loss through radiation is a loss proportional to the absolute temperature to the fourth power (Stefan’s Law).
This adds to the loss by convection and gives the following boundary condition:
\begin{equation*}
\begin{split}\kappa{\partial u\over \partial n} +\alpha(u-u_e) + c[(u + 273)^4 - (u_e+273)^4] = 0\end{split}
\end{equation*}
The problem is nonlinear, and must be solved iteratively.
If \(m\) denotes the iteration index, a semi-linearization of the radiation condition gives
\begin{equation*}
\begin{split}{\partial u^{m+1}\over \partial n} + \alpha(u^{m+1}-u_e)+ c(u^{m+1}-u_e)
(u^m+u_e +546) ((u^m + 273)^2 + (u_e+273)^2) = 0,\end{split}
\end{equation*}
because we have the identity \(a^4 - b^4 = (a-b)(a+b)(a^2+b^2)\).

The iterative process will work with \(v=u-u_e\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{rad}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{uek}\PYG{o}{=}\PYG{n}{ue}\PYG{o}{+}\PYG{l+m+mi}{273}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{vold}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{n}{u0}\PYG{o}{\PYGZhy{}}\PYG{n}{ue}\PYG{p}{,} \PYG{n}{b}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{thermradia}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{k}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{*} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{*} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{b}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{n}{w}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{vold}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{n}{u0}\PYG{o}{\PYGZhy{}}\PYG{n}{ue}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{k+kp}{t}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{;}\PYG{k+kp}{t}\PYG{o}{+}\PYG{o}{=}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{vold} \PYG{o}{=} \PYG{n}{v}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{b} \PYG{o}{=} \PYG{n}{alpha} \PYG{o}{+} \PYG{n}{rad} \PYG{o}{*} \PYG{p}{(}\PYG{n}{v} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{uek}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{n}{v}\PYG{o}{+}\PYG{n}{uek}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{uek}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{thermradia}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{n}{vold} \PYG{o}{=} \PYG{n}{v}\PYG{o}{+}\PYG{n}{ue}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{vold}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Irrotational Fan Blade Flow and Thermal effects}
\label{\detokenize{tutorial/fanBlade:irrotational-fan-blade-flow-and-thermal-effects}}\label{\detokenize{tutorial/fanBlade::doc}}
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{Here we will learn how to deal with a multi-physics system of PDEs on a complex geometry, with multiple meshes within one problem.
We also learn how to manipulate the region indicator and see how smooth is the projection operator from one mesh to another.}

\sphinxstylestrong{Incompressible flow}

Without viscosity and vorticity incompressible flows have a velocity given by:
\begin{equation*}
\begin{split}u=\left(\begin{matrix}{\partial \psi \over \partial x_{2} }\\ -{\partial \psi
\over \partial x_{1}} \end{matrix}\right), \quad
\mbox{ where }\psi\mbox{ is solution of }\quad \Delta \psi =0\end{split}
\end{equation*}
This equation expresses both incompressibility (\(\nabla\cdot u=0\)) and absence of vortex (\(\nabla\times u =0\)).

As the fluid slips along the walls, normal velocity is zero, which means that \(\psi\) satisfies:
\begin{equation*}
\begin{split}\psi \hbox{ constant on the walls}.\end{split}
\end{equation*}
One can also prescribe the normal velocity at an artificial boundary, and this translates into non constant Dirichlet data for \(\psi\).

\sphinxstylestrong{Airfoil}

Let us consider a wing profile \(S\) in a uniform flow.
Infinity will be represented by a large circle \(C\) where the flow is assumed to be of uniform velocity; one way to model this problem is to write:
\begin{equation*}
\begin{split}\Delta \psi =0 ~\hbox{~in~}~ \Omega, \qquad
\psi |_{S}=0, \quad
\psi|_{C}= {u_\infty}y\end{split}
\end{equation*}
where \(\partial\Omega=C\cup S\)

\sphinxstylestrong{The NACA0012 Airfoil}

An equation for the upper surface of a NACA0012 (this is a classical wing profile in aerodynamics) is:
\begin{equation*}
\begin{split}y = 0.17735\sqrt{x}-0.075597x- 0.212836x^2+0.17363x^3-0.06254x^4.\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{S} \PYG{o}{=} \PYG{l+m+mi}{99}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Splus}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t}
   \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{S}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Sminus}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t}
   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{S}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Splus}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Sminus}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{psi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{solve} \PYG{n+nf}{potential}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
      \PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,} \PYG{n}{psi} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{S}\PYG{p}{,} \PYG{n}{psi}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

A zoom of the streamlines are shown on \hyperref[\detokenize{tutorial/fanBlade:figfanpotential}]{Fig.\@ \ref{\detokenize{tutorial/fanBlade:figfanpotential}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{potential}.png}
\caption{Zoom around the NACA0012 airfoil showing the streamlines (curve \(\psi=\) constant).
To obtain such a plot use the interactive graphic command: “+” and p.}\label{\detokenize{tutorial/fanBlade:id1}}\label{\detokenize{tutorial/fanBlade:figfanpotential}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{potential_heat}.png}
\caption{Temperature distribution at time T=25 (now the maximum is at 90 instead of 120).
Note that an incidence angle has been added here.}\label{\detokenize{tutorial/fanBlade:id2}}\label{\detokenize{tutorial/fanBlade:figfantemperature}}\end{subfigure}
\caption{The NACA0012 Airfoil}

\end{figure}



\subsection{Heat Convection around the airfoil}
\label{\detokenize{tutorial/fanBlade:heat-convection-around-the-airfoil}}\label{\detokenize{tutorial/fanBlade:Potential}}
Now let us assume that the airfoil is hot and that air is there to cool it.
Much like in the previous section the heat equation for the temperature \(v\) is
\begin{equation*}
\begin{split}\partial_t v -\nabla\cdot(\kappa\nabla v) + u\cdot\nabla v =0,~~v(t=0)=v_0, ~~\frac{\partial v}{\partial n}|_C=0\end{split}
\end{equation*}
But now the domain is outside AND inside \(S\) and \(\kappa\) takes a different value in air and in steel.
Furthermore there is convection of heat by the flow, hence the term \(u\cdot\nabla v\) above.

Consider the following, to be plugged at the end of the previous program:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{S} \PYG{o}{=} \PYG{l+m+mi}{99}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{nbT}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Splus}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t}
   \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{S}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Sminus}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t}
   \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{S}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{D}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{// Added to have a fine mesh at trail}
\PYG{k+kt}{mesh} \PYG{n}{Sh} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Splus}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{90}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Sminus}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{90}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{steel}\PYG{o}{=}\PYG{n}{Sh}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{,} \PYG{n}{air}\PYG{o}{=}\PYG{n}{Sh}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}

\PYG{c+c1}{// Fespaces}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{psi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{W0}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,}\PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{W0} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{air}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{steel}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{W0} \PYG{n}{u1}\PYG{o}{=}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{air}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{air}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{vold} \PYG{o}{=} \PYG{l+m+mi}{120}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{steel}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{thermic}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{v}\PYG{o}{*}\PYG{n}{vv}\PYG{o}{/}\PYG{n}{dt}
      \PYG{o}{+} \PYG{n}{k}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{*} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{*} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
      \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{+}\PYG{n}{u2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vv}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{vold}\PYG{o}{*}\PYG{n}{vv}\PYG{o}{/}\PYG{n}{dt}
   \PYG{p}{)}
   \PYG{p}{;}

\PYG{k}{for}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nbT}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{v} \PYG{o}{=} \PYG{n}{vold}\PYG{p}{;}
   \PYG{n}{thermic}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
How steel and air are identified by the mesh parameter region which is defined when buildmesh is called and takes an integer value corresponding to each connected component of \(\Omega\);

How the convection terms are added without upwinding.
Upwinding is necessary when the Pecley number \(|u|L/\kappa\) is large (here is a typical length scale), The factor 10 in front of the convection terms is a quick way of multiplying the velocity by 10 (else it is too slow to see something).

The solver is Gauss’ LU factorization and when \sphinxcode{\sphinxupquote{init}} \(\neq 0\) the LU decomposition is reused so it is much faster after the first iteration.
\end{sphinxadmonition}


\section{Pure Convection : The Rotating Hill}
\label{\detokenize{tutorial/rotatingHill:pure-convection-the-rotating-hill}}\label{\detokenize{tutorial/rotatingHill::doc}}
\sphinxstylestrong{Summary:}
\sphinxstyleemphasis{Here we will present two methods for upwinding for the simplest convection problem.
We will learn about Characteristics-Galerkin and Discontinuous-Galerkin Finite Element Methods.}

Let \(\Omega\) be the unit disk centered at \((0,0)\); consider the rotation vector field
\begin{equation*}
\begin{split}\mathbf{u} = [u1,u2], \qquad u_1 = y,\quad u_2 = -x\end{split}
\end{equation*}
Pure convection by \(\mathbf{u}\) is
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \partial_t c + \mathbf{u}.\nabla c &= 0 &\hbox{ in } \Omega\times(0,T)\\
    c (t=0) &= c ^0 &\hbox{ in } \Omega.
\end{array}\end{split}
\end{equation*}
The exact solution \(c(x_t,t)\) at time \(t\) en point \(x_t\) is given by:
\begin{equation*}
\begin{split}c(x_t,t)=c^0(x,0)\end{split}
\end{equation*}
where \(x_t\) is the particle path in the flow starting at point \(x\) at time \(0\). So \(x_t\) are solutions of
\begin{equation*}
\begin{split}\dot{x_t} = u(x_t), \quad\ x_{t=0} =x , \quad\mbox{where}\quad \dot{x_t} = \frac{\text{d} ( t \mapsto x_t)}{\text{d} t}\end{split}
\end{equation*}
The ODE are reversible and we want the solution at point \(x\) at time \(t\) ( not at point \(x_t\)) the initial point is \(x_{-t}\), and we have
\begin{equation*}
\begin{split}c(x,t)=c^0(x_{-t},0)\end{split}
\end{equation*}
The game consists in solving the equation until \(T=2\pi\), that is for a full revolution and to compare the final solution with the initial one; they should be equal.


\subsection{Solution by a Characteristics-Galerkin Method}
\label{\detokenize{tutorial/rotatingHill:solution-by-a-characteristics-galerkin-method}}
In FreeFem++ there is an operator called \sphinxcode{\sphinxupquote{convect({[}u1,u2{]}, dt, c)}} which compute \(c\circ X\) with \(X\) is the convect field defined by \(X(x)= x_{dt}\) and where \(x_\tau\) is particule path in the steady state velocity field \(\mathbf{u}=[u1,u2]\) starting at point \(x\) at time \(\tau=0\), so \(x_\tau\) is solution of the following ODE:
\begin{equation*}
\begin{split}\dot{x}_\tau = u(x_\tau), \mathbf{x}_{\tau=0}=x.\end{split}
\end{equation*}
When \(\mathbf{u}\) is piecewise constant; this is possible because \(x_\tau\) is then a polygonal curve which can be computed exactly and the solution exists always when \(\mathbf{u}\) is divergence free; convect returns \(c(x_{df})=C\circ X\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.17}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Uh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{cold}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{u1} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{u2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{;}
    \PYG{n}{cold} \PYG{o}{=} \PYG{n}{c}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{cold}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kp}{t} \PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{c}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, max=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{c}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
3D plots can be done by adding the qualifyer \sphinxcode{\sphinxupquote{dim=3}} to the plot instruction.
\end{sphinxadmonition}

The method is very powerful but has two limitations:
\begin{itemize}
\item {} 
it is not conservative

\item {} 
it may diverge in rare cases when \(|\mathbf{u}|\) is too small due to quadrature error.

\end{itemize}


\subsection{Solution by Discontinuous-Galerkin FEM}
\label{\detokenize{tutorial/rotatingHill:solution-by-discontinuous-galerkin-fem}}
Discontinuous Galerkin methods take advantage of the discontinuities of \(c\) at the edges to build upwinding.
There are may formulations possible.
We shall implement here the so-called dual-\(P_1^{DC}\) formulation (see \sphinxcite{reference:ern2006}):
\begin{equation*}
\begin{split}\int_\Omega(\frac{c^{n+1}-c^n}{\delta t} +u\cdot\nabla c)w
+\int_E(\alpha|n\cdot u|-\frac 12 n\cdot u)[c]w
=\int_{E_\Gamma^-}|n\cdot u| cw~~~\forall w\end{split}
\end{equation*}
where \(E\) is the set of inner edges and \(E_\Gamma^-\) is the set of boundary edges where \(u\cdot n<0\) (in our case there is no such edges).
Finally \([c]\) is the jump of \(c\) across an edge with the convention that \(c^+\) refers to the value on the right of the oriented edge.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{al}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{w}\PYG{p}{,} \PYG{n}{ccold}\PYG{p}{,} \PYG{n}{v1} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{v2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{cc} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{k+kr}{n}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{v1} \PYG{o}{+} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{v2}\PYG{p}{)} \PYG{c+c1}{// Macro without parameter}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Adual}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{cc}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{+}\PYG{p}{(}\PYG{n}{v1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{)}\PYG{o}{+}\PYG{n}{v2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{nTonEdge}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{ccold}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Time iterations}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{ccold} \PYG{o}{=} \PYG{n}{cc}\PYG{p}{;}
    \PYG{n}{Adual}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{cc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, max=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{cc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{1.1}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ConvectCG.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ConvectDG.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
New keywords: \sphinxcode{\sphinxupquote{intalledges}} to integrate on all edges of all triangles
\begin{equation*}
\begin{split}\mathtt{intalledges}(\mathtt{Th}) \equiv \sum_{T\in\mathtt{Th}}\int_{\partial T }\end{split}
\end{equation*}\end{sphinxadmonition}

(so all internal edges are see two times), nTonEdge which is one if the triangle has a boundary edge and two otherwise, \sphinxcode{\sphinxupquote{jump}} to implement \([c]\).

Results of both methods are shown on \hyperref[\detokenize{tutorial/rotatingHill:figrotatingcg}]{Fig.\@ \ref{\detokenize{tutorial/rotatingHill:figrotatingcg}}} nad \hyperref[\detokenize{tutorial/rotatingHill:figrotatingdg}]{Fig.\@ \ref{\detokenize{tutorial/rotatingHill:figrotatingdg}}} with identical levels for the level line; this is done with the plot-modifier viso.

Notice also the macro where the parameter \(\mathbf{u}\) is not used (but the syntax needs one) and which ends with a \sphinxcode{\sphinxupquote{//}}; it simply replaces the name \sphinxcode{\sphinxupquote{n}} by \sphinxcode{\sphinxupquote{(N.x*v1+N.y*v2)}}.
As easily guessed \sphinxcode{\sphinxupquote{N.x,N.y}} is the normal to the edge.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{convectCG}.png}
\caption{The rotating hill after one revolution with Characteristics-Galerkin}\label{\detokenize{tutorial/rotatingHill:id2}}\label{\detokenize{tutorial/rotatingHill:figrotatingcg}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{convectDG}.png}
\caption{The rotating hill after one revolution with Discontinuous \(P_1\) Galerkin}\label{\detokenize{tutorial/rotatingHill:id3}}\label{\detokenize{tutorial/rotatingHill:figrotatingdg}}\end{subfigure}
\caption{Rotating hill}\phantomsection\label{\detokenize{tutorial/rotatingHill:RotatingHill}}

\end{figure}


Now if you think that DG is too slow try this:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{al}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{w}\PYG{p}{,} \PYG{n}{ccold}\PYG{p}{,} \PYG{n}{v1} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{v2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{cc} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{rhs}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{k+kr}{n}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{v1} \PYG{o}{+} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{v2}\PYG{p}{)} \PYG{c+c1}{// Macro without parameter}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vAdual} \PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{cc}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{+}\PYG{p}{(}\PYG{n}{v1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{)}\PYG{o}{+}\PYG{n}{v2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{nTonEdge}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vBdual} \PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
    \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{ccold}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{AA} \PYG{o}{=} \PYG{n}{vAdual}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{BB} \PYG{o}{=} \PYG{n}{vBdual}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{set} \PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Time iterations}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{ccold} \PYG{o}{=} \PYG{n}{cc}\PYG{p}{;}
    \PYG{n}{rhs}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{BB} \PYG{o}{*} \PYG{n}{ccold}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{cc}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{AA}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{rhs}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{cc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, max=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{cc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Notice the new keyword \sphinxcode{\sphinxupquote{set}} to specify a solver in this framework; the modifier \sphinxcode{\sphinxupquote{init}} is used to tell the solver that the matrix has not changed (\sphinxcode{\sphinxupquote{init=true}}), and the name parameter are the same that in problem definition (see {\hyperref[\detokenize{documentation/finiteElement:problemdefinition}]{\sphinxcrossref{\DUrole{std,std-ref}{Problem}}}})


\subsection{\sphinxstylestrong{Finite Volume Methods} can also be handled with FreeFem++ but it requires programming.}
\label{\detokenize{tutorial/rotatingHill:finite-volume-methods-can-also-be-handled-with-freefem-but-it-requires-programming}}
For instance the \(P_0-P_1\) Finite Volume Method of Dervieux \sphinxstyleemphasis{et al} associates to each \(P_0\) function \(c^1\) a \(P_0\) function \(c^0\) with constant value around each vertex \(q^i\) equal to \(c^1(q^i)\) on the cell \(\sigma_i\) made by all the medians of all triangles having \(q^i\) as vertex.

Then upwinding is done by taking left or right values at the median:
\begin{equation*}
\begin{split}\int_{\sigma_i}\frac 1{\delta t}({c^1}^{n+1}-{c^1}^n) + \int_{\partial\sigma_i}u\cdot n c^-=0, \forall i\end{split}
\end{equation*}
It can be programmed as :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mat\PYGZus{}dervieux}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{c+c1}{//External module in C++ must be loaded}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.025}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{vh}\PYG{p}{,} \PYG{n}{vold}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{v}\PYG{o}{=}\PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{vWall}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{rhs}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{c+c1}{//qf1pTlump means mass lumping is used}
\PYG{k+kt}{problem} \PYG{n+nf}{FVM}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,}\PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf1pTlump}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{*}\PYG{n}{vh}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,}\PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf1pTlump}\PYG{p}{)}\PYG{p}{(}\PYG{n}{vold}\PYG{o}{*}\PYG{n}{vh}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,}\PYG{n}{a}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u2}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u2}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vWall}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)}
\PYG{o}{+} \PYG{n}{rhs}\PYG{p}{[}\PYG{p}{]} \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A}\PYG{p}{;}
\PYG{n}{MatUpWind0}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{th}\PYG{p}{,} \PYG{n}{vold}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi} \PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{vold} \PYG{o}{=} \PYG{n}{v}\PYG{p}{;}
    \PYG{n}{rhs}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A} \PYG{o}{*} \PYG{n}{vold}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{FVM}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

the “mass lumping” parameter forces a quadrature formula with Gauss points at the vertices so as to make the mass matrix diagonal; the linear system solved by a conjugate gradient method for instance will then converge in one or two iterations.

The right hand side \sphinxcode{\sphinxupquote{rhs}} is computed by an external C++ function \sphinxcode{\sphinxupquote{MatUpWind0(...)}} which is programmed as :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
// Computes matrix a on a triangle for the Dervieux FVM
int fvmP1P0(double q[3][2], // the 3 vertices of a triangle T
    double u[2], // convection velocity on T
    double c[3], // the P1 function on T
    double a[3][3],// output matrix
    double where[3]) // where\PYGZgt{}0 means we\PYGZsq{}re on the boundary
\PYGZob{}
    for (int i = 0; i \PYGZlt{} 3; i++)
        for(int j = 0; j \PYGZlt{} 3; j++) a[i][j] = 0;

    for(int i = 0; i \PYGZlt{} 3; i++)\PYGZob{}
        int ip = (i+1)\PYGZpc{}3, ipp = (ip+1)\PYGZpc{}3;
        double unL = \PYGZhy{}((q[ip][1] + q[i][1] \PYGZhy{} 2*q[ipp][1])*u[0]
            \PYGZhy{} (q[ip][0] + q[i][0] \PYGZhy{} 2*q[ipp][0])*u[1])/6.;
        if (unL \PYGZgt{} 0)\PYGZob{}
            a[i][i] += unL;
            a[ip][i] \PYGZhy{}=unL;
        \PYGZcb{}
        else\PYGZob{}
            a[i][ip] += unL;
            a[ip][ip] \PYGZhy{}=unL;
        \PYGZcb{}
        if (where[i] \PYGZam{}\PYGZam{} where[ip])\PYGZob{} // this is a boundary edge
            unL = ((q[ip][1] \PYGZhy{} q[i][1])*u[0] \PYGZhy{} (q[ip][0] \PYGZhy{} q[i][0])*u[1])/2;
            if (unL \PYGZgt{} 0)\PYGZob{}
                a[i][i] += unL;
                a[ip][ip] += unL;
            \PYGZcb{}
        \PYGZcb{}
    \PYGZcb{}
    return 1;
\PYGZcb{}
\end{sphinxVerbatim}

It must be inserted into a larger .cpp file, shown in Appendix A, which is the load module linked to FreeFem++.


\section{The System of elasticity}
\label{\detokenize{tutorial/elasticity:the-system-of-elasticity}}\label{\detokenize{tutorial/elasticity::doc}}
\sphinxstylestrong{Elasticity}

Solid objects deform under the action of applied forces:

a point in the solid, originally at \((x,y,z)\) will come to \((X,Y,Z)\) after some time; the vector \(\mathbf{u}=(u_1,u_2,u_3) = (X-x, Y-y, Z-z)\) is called the displacement.
When the displacement is small and the solid is elastic, Hooke’s law gives a relationship between the stress tensor \(\sigma(u)=(\sigma_{ij}(u) )\) and the strain tensor \(\epsilon(u)=\epsilon_{ij}(u)\)
\begin{equation*}
\begin{split}\sigma_{ij}(u) = \lambda \delta_{ij} \nabla.\mathbf{u}+ 2\mu\epsilon_{ij}(u),\end{split}
\end{equation*}
where the Kronecker symbol \(\delta_{ij} = 1\) if \(i=j\), \(0\) otherwise, with
\begin{equation*}
\begin{split}\epsilon_{ij}(u) = {1\over 2}({\partial u_i\over\partial x_j} + {\partial u_j\over\partial x_i} ),\end{split}
\end{equation*}
and where \(\lambda, \mu\) are two constants that describe the mechanical properties of the solid, and are themselves related to the better known constants \(E\), Young’s modulus, and \(\nu\), Poisson’s ratio:
\begin{equation*}
\begin{split}\mu = {E\over 2( 1+\nu)}, \quad \lambda = {E\nu\over (1+\nu)(1-2\nu)}.\end{split}
\end{equation*}
\sphinxstylestrong{Lamé’s system}

Let us consider a beam with axis \(Oz\) and with perpendicular section \(\Omega\).
The components along \(x\) and \(y\) of the strain \({\bf u}(x)\) in a section \(\Omega\) subject to forces \({\bf f}\) perpendicular to the axis are governed by:
\begin{equation*}
\begin{split}-\mu \Delta {\bf u} - (\mu+\lambda) \nabla (\nabla .{\bf u})={\bf f}~~\hbox{in}~~\Omega,\end{split}
\end{equation*}
where \(\lambda\) ,\(\mu\) are the Lamé coefficients introduced above.

Remark, we do not use this equation because the associated variational form does not give the right boundary condition, we simply use:
\begin{equation*}
\begin{split}- div( \sigma ) = \mathbf{f} \quad \mbox{in}~~\Omega\end{split}
\end{equation*}
where the corresponding variational form is:
\begin{equation*}
\begin{split}\int_{\Omega} \sigma(u) : \epsilon(\mathbf{v})\;dx - \int_{\Omega} \mathbf{v} f \;dx =0;\end{split}
\end{equation*}
where \(:\) denotes the tensor scalar product, i.e. \(a: b = \sum_{i,j} a_{ij}b_{ij}\).

So the variational form can be written as :
\begin{equation*}
\begin{split}\int_{\Omega} \lambda \nabla.u \nabla.v + 2 \mu \epsilon(\mathbf{u}):\epsilon(\mathbf{v}) \; dx - \int_{\Omega} \mathbf{v} f \;dx =0;\end{split}
\end{equation*}
\begin{sphinxadmonition}{tip}{Tip:}
Consider an elastic plate with the undeformed rectangle shape \([0,20]\times [-1,1]\).

The body force is the gravity force \(\mathbf{f}\) and the boundary force \(\mathbf{g}\) is zero on lower, upper and right sides.
The left vertical side of the beam is fixed.
The boundary conditions are:
\begin{equation*}
\begin{split}\begin{array}{rcll}
    \sigma . {\bf n} &= \mathbf{g} &= 0 & \hbox{ on }\Gamma_1, \Gamma_4, \Gamma_3, \\
    {\bf u} &= \mathbf{0} && \hbox{ on }\Gamma_2
\end{array}\end{split}
\end{equation*}\end{sphinxadmonition}

Here \({\bf u}=(u,v)\) has two components.

The above two equations are strongly coupled by their mixed derivatives, and thus any iterative solution on each of the components is risky.
One should rather use \sphinxstylestrong{FreeFem++}’s system approach and write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21e5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{0.28}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{real} \PYG{n}{sqrt2}\PYG{o}{=}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n+nf}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{c+c1}{// The sqrt2 is because we want: epsilon(u1,u2)\PYGZsq{}* epsilon(v1,v2) = epsilon(u): epsilon(v)}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{p}{(} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{mu}\PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{nu}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{n}{nu}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{nu}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{nu}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{solve} \PYG{n+nf}{lame}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{lambda} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}
      \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{mu} \PYG{o}{*} \PYG{p}{(} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)} \PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{vv}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{k+kt}{real} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lamevect.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{k+kp}{coef}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Move mesh}
\PYG{k+kt}{mesh} \PYG{n}{th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{v}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th1}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lamedeform.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Output}
\PYG{k+kt}{real} \PYG{n}{dxmin} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dymin} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} dep. max x = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dxmin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ y=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dymin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{   dep. (20, 0) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZhy{}\PYGZhy{} square mesh : nb \PYG{n+nv}{vertices}  \PYG{o}{=}\PYG{l+m}{121} ,  nb \PYG{n+nv}{triangles} \PYG{o}{=} \PYG{l+m}{200} ,  nb boundary edges \PYG{l+m}{40}
\PYGZhy{}\PYGZhy{} Solve :           min \PYGZhy{}0.00174137  max \PYG{l+m}{0}.00174105
         min \PYGZhy{}0.0263154  max \PYG{l+m}{1}.47016e\PYGZhy{}29
\PYGZhy{} dep.  max   \PYG{n+nv}{x} \PYG{o}{=} \PYGZhy{}0.00174137 \PYG{n+nv}{y}\PYG{o}{=}\PYGZhy{}0.0263154
   dep.  \PYG{o}{(}\PYG{l+m}{20},0\PYG{o}{)}  \PYG{o}{=} \PYGZhy{}1.8096e\PYGZhy{}07 \PYGZhy{}0.0263154
times: compile \PYG{l+m}{0}.010219s, execution \PYG{l+m}{1}.5827s
\end{sphinxVerbatim}

Solution of Lamé’s equations for elasticity for a 2D beam deflected by its own weight and clamped by its left vertical side is shown \hyperref[\detokenize{tutorial/elasticity:figelasticityvector}]{Fig.\@ \ref{\detokenize{tutorial/elasticity:figelasticityvector}}} and \hyperref[\detokenize{tutorial/elasticity:figelasticitydeformation}]{Fig.\@ \ref{\detokenize{tutorial/elasticity:figelasticitydeformation}}}.
Result are shown with a amplification factor equal to 100.
The size of the arrow is automatically bound, but the color gives the real length.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{lame_vector}.png}
\caption{Vector}\label{\detokenize{tutorial/elasticity:id1}}\label{\detokenize{tutorial/elasticity:figelasticityvector}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{lame_deformation}.png}
\caption{Deformation}\label{\detokenize{tutorial/elasticity:id2}}\label{\detokenize{tutorial/elasticity:figelasticitydeformation}}\end{subfigure}
\caption{Elasticity}\phantomsection\label{\detokenize{tutorial/elasticity:Elasticity}}

\end{figure}



\section{The System of Stokes for Fluids}
\label{\detokenize{tutorial/stokes:the-system-of-stokes-for-fluids}}\label{\detokenize{tutorial/stokes::doc}}
In the case of a flow invariant with respect to the third coordinate (two-dimensional flow), flows at low Reynolds number (for instance micro-organisms) satisfy,
\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\Delta \mathbf{u} + \nabla p &=& 0\\
    \nabla\cdot \mathbf{u} &=& 0
\end{array}\end{split}
\end{equation*}
where \(\mathbf{u}=(u_1,u_2)\) is the fluid velocity and \(p\) its pressure.

The driven cavity is a standard test.
It is a box full of liquid with its lid moving horizontally at speed one.
The pressure and the velocity must be discretized in compatible fintie element spaces for the LBB conditions to be satisfied:
\begin{equation*}
\begin{split}\sup_{p\in P_h}\frac{(\mathbf{u},\nabla p)}{|p|}\geq \beta|\mathbf{u}|~~~\forall \mathbf{u}\in U_h\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Uh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1b}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{p}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{stokes} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{o}{*}\PYG{n}{uu}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vv}
        \PYG{o}{+} \PYG{n}{pp}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{o}{*}\PYG{n}{p}\PYG{o}{*}\PYG{n}{pp}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
We add a stabilization term \(\bf{-10e-10*p*pp}\) to fix the constant part of the pressure.
\end{sphinxadmonition}

Results are shown on \hyperref[\detokenize{tutorial/stokes:figstokes}]{Fig.\@ \ref{\detokenize{tutorial/stokes:figstokes}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{stokes}.png}
\caption{Solution of Stokes’ equations for the driven cavity problem, showing the velocity field and the pressure level lines.}\label{\detokenize{tutorial/stokes:figstokes}}\end{figure}


\section{A projection algorithm for the Navier-Stokes equations}
\label{\detokenize{tutorial/navierStokesProjection:a-projection-algorithm-for-the-navier-stokes-equations}}\label{\detokenize{tutorial/navierStokesProjection::doc}}
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{Fluid flows require good algorithms and good triangultions. We show here an example of a complex algorithm and or first example of mesh adaptation.}

An incompressible viscous fluid satisfies:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \partial_t \mathbf{u} + \mathbf{u}\cdot\nabla\mathbf{u} + \nabla p - \nu\Delta\mathbf{u} &= 0 &\hbox{ in } \Omega\times ]0,T[\\
    \nabla\cdot\mathbf{u} &= 0 &\hbox{ in } \Omega\times ]0,T[\\
    \mathbf{u}|_{t=0} &= \mathbf{u}^0\\
    \mathbf{u}|_\Gamma &= \mathbf{u}_\Gamma
\end{array}\end{split}
\end{equation*}
A possible algorithm, proposed by Chorin, is:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    {1\over \delta t}[\mathbf{u}^{m+1} - \mathbf{u}^mo\mathbf{X}^m] + \nabla p^m -\nu\Delta \mathbf{u}^m &=& 0\\
    \mathbf{u}|_\Gamma &=& \mathbf{u}_\Gamma\\
    \nu \partial_n \mathbf{u}|_{\Gamma_{out}} &=&0
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\Delta p^{m+1} &= -\nabla\cdot \mathbf{u}^mo\mathbf{X}^m &\\
    \partial_n p^{m+1} &= 0 &\mbox{ on } \Gamma\\
    p^{m+1} &= 0 &\mbox{ on } \Gamma_{out}
\end{array}\end{split}
\end{equation*}
where \(\mathbf{u}o\mathbf{X}(x) = \mathbf{u}(\mathbf{x}-\mathbf{u}(\mathbf{x})\delta t)\) since \(\partial_t \mathbf{u} + \mathbf{u}\cdot\nabla \mathbf{u}\) is approximated by the method of characteristics, as in the previous section.

We use the Chorin’s algorithm with free boundary condition at outlet (i.e. \(p=0,\nu \partial_n u = 0\)), to compute a correction, q, to the pressure.
\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\Delta q &= \nabla\cdot\mathbf{u}&\\
    q &= 0 \mbox{ on } &\Gamma_{out}
\end{array}\end{split}
\end{equation*}
and define
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \mathbf{u}^{m+1} &=& \tilde{\mathbf{u}} + P \nabla q\delta t\\
    p^{m+1} &=& p^m-q
\end{array}\end{split}
\end{equation*}
where \(\tilde{\mathbf{u}}\) is the \((\mathbf{u}^{m+1}, v^{m+1})\) of Chorin’s algorithm, and where \(P\) is the \(L^2\) projection with mass lumping ( a sparse matrix).

\sphinxstylestrong{The backward facing step}

The geometry is that of a channel with a backward facing step so that the inflow section is smaller than the outflow section.
This geometry produces a fluid recirculation zone that must be captured correctly.

This can only be done if the triangulation is sufficiently fine, or well adapted to the flow.

\begin{sphinxadmonition}{note}{Note:}
There is a technical difficulty in the example: the output B.C.
Here we put \(p=0\) and \(\nu \partial_n u = 0\).
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{0.0025}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{epsv} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{epsu} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{epsp} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{18}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{18}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{20}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a2}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a3}\PYG{p}{(}\PYG{l+m+mi}{150}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a4}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a5}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{q}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Definition of Matrix dtMx and dtMy}
\PYG{k+kt}{matrix} \PYG{n}{dtM1x}\PYG{p}{,} \PYG{n}{dtM1y}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{BuildMat}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}   \PYG{c+cm}{/* for memory managenemt */}
    \PYG{k+kt}{varf} \PYG{n}{vM}\PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n}{vdx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n}{vdy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Mlump} \PYG{o}{=} \PYG{n}{vM}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{one}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{one} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{M1} \PYG{o}{=} \PYG{n}{one} \PYG{p}{.}\PYG{o}{/} \PYG{n}{Mlump}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{dM1} \PYG{o}{=} \PYG{n}{M1}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{Mdx} \PYG{o}{=} \PYG{n}{vdx}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{Mdy} \PYG{o}{=} \PYG{n}{vdy}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dtM1x} \PYG{o}{=} \PYG{n}{dM1}\PYG{o}{*}\PYG{n}{Mdx}\PYG{p}{;}
    \PYG{n}{dtM1y} \PYG{o}{=} \PYG{n}{dM1}\PYG{o}{*}\PYG{n}{Mdy}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//}

\PYG{c+c1}{// Build matrices}
\PYG{n}{BuildMat}

\PYG{c+c1}{// Time iterations}
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{outflux} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{300}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{n}{Vh} \PYG{n}{uold}\PYG{o}{=}\PYG{n}{u}\PYG{p}{,} \PYG{n}{vold}\PYG{o}{=}\PYG{n}{v}\PYG{p}{,} \PYG{n}{pold}\PYG{o}{=}\PYG{n}{p}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{solve} \PYG{n+nf}{pb4u} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsu}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{u}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
            \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uold}\PYG{p}{,} \PYG{n}{vold}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{uold}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{*}\PYG{n}{w}
            \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{solve} \PYG{n+nf}{pb4v} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsv}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
            \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uold}\PYG{p}{,}\PYG{n}{vold}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{vold}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{*}\PYG{n}{w}
            \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}
        \PYG{p}{)}
        \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{k+kt}{solve} \PYG{n+nf}{pb4p} \PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsp}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{q}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{c+c1}{//to have absolute epsilon in CG algorithm.}
    \PYG{n}{epsv} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{epsv}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{epsu} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{epsu}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{epsp} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{epsp}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{p} \PYG{o}{=} \PYG{n}{pold}\PYG{o}{\PYGZhy{}}\PYG{n}{q}\PYG{p}{;}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dtM1x}\PYG{o}{*}\PYG{n}{q}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dtM1y}\PYG{o}{*}\PYG{n}{q}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{50} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{49}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{l+m+mf}{0.04}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{BuildMat} \PYG{c+c1}{// Rebuild mat.}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Error \PYGZam{} Outflux}
    \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{uold}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{v}\PYG{o}{\PYGZhy{}}\PYG{n}{vold}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{outflux} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{p}{[}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ iter }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Err L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ outflux = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{outflux} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Verification}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{outflux}\PYG{p}{)}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2e\PYGZhy{}3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NSprojP.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NSprojU.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Rannacher’s projection algorithm: result on an adapted mesh, \hyperref[\detokenize{tutorial/navierStokesProjection:fignavierprojectionmesh}]{Fig.\@ \ref{\detokenize{tutorial/navierStokesProjection:fignavierprojectionmesh}}}, showing the pressure, \hyperref[\detokenize{tutorial/navierStokesProjection:fignavierprojectionp}]{Fig.\@ \ref{\detokenize{tutorial/navierStokesProjection:fignavierprojectionp}}}, and the horizontal velocity \hyperref[\detokenize{tutorial/navierStokesProjection:fignavierprojectionu}]{Fig.\@ \ref{\detokenize{tutorial/navierStokesProjection:fignavierprojectionu}}} for a Reynolds number of 400 where mesh adaptation is done after 50 iterations on the first mesh.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.9\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{navier_stokes_projection_Th}.png}
\caption{Adapted mesh}\label{\detokenize{tutorial/navierStokesProjection:id1}}\label{\detokenize{tutorial/navierStokesProjection:fignavierprojectionmesh}}\end{subfigure}
\begin{subfigure}[t]{0.9\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{navier_stokes_projection_P}.png}
\caption{Pressure}\label{\detokenize{tutorial/navierStokesProjection:id2}}\label{\detokenize{tutorial/navierStokesProjection:fignavierprojectionp}}\end{subfigure}
\begin{subfigure}[t]{0.9\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{navier_stokes_projection_U}.png}
\caption{Velocity}\label{\detokenize{tutorial/navierStokesProjection:id3}}\label{\detokenize{tutorial/navierStokesProjection:fignavierprojectionu}}\end{subfigure}
\caption{Navier-Stokes projection}\phantomsection\label{\detokenize{tutorial/navierStokesProjection:NavierStokesProjection}}

\end{figure}



\section{Newton Method for the Steady Navier-Stokes equations}
\label{\detokenize{tutorial/navierStokesNewton:newton-method-for-the-steady-navier-stokes-equations}}\label{\detokenize{tutorial/navierStokesNewton::doc}}
The problem is find the velocity field \(\mathbf{u}=(u_i)_{i=1}^d\) and the pressure \(p\) of a Flow satisfying in the domain \(\Omega \subset \mathbb{R}^d (d=2,3)\):
\begin{equation*}
\begin{split}\begin{array}{rcl}
    (\mathbf{u}\cdot\nabla) \mathbf{u}-\nu \Delta \mathbf{u}+\nabla p&=&0\\
    \nabla\cdot \mathbf{u}&=&0
\end{array}\end{split}
\end{equation*}
where \(\nu\) is the viscosity of the fluid, \(\nabla = (\partial_i )_{i=1}^d\), the dot product is \(\cdot\), and \(\Delta = \nabla\cdot\nabla\) with the same boundary conditions (\(\mathbf{u}\) is given on \(\Gamma\)).

The weak form is find \(\mathbf{u}, p\) such that for \(\forall \mathbf{v}\) (zero on \(\Gamma\)), and \(\forall q\):
\begin{equation*}
\begin{split}\int_\Omega  ((\mathbf{u}\cdot\nabla) \mathbf{u} ). \mathbf{v} + \nu \nabla \mathbf{u}:\nabla \mathbf{v}
- p \nabla\cdot \mathbf{v} - q \nabla\cdot \mathbf{u} = 0\end{split}
\end{equation*}
The Newton Algorithm to solve nonlinear problem is:

Find \(u\in V\) such that \(F(u)=0\) where \(F : V \mapsto V\).
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
choose \(u_0\in \mathbb{R}^n\) , ;

\item {} 
for ( \(i =0\); \(i\) \textless{} niter; \(i = i+1\))
\begin{enumerate}
\def\theenumii{\arabic{enumii}}
\def\labelenumii{\theenumii .}
\makeatletter\def\p@enumiii{\p@enumii \theenumii .}\makeatother
\item {} 
solve \(DF(u_i) w_i = F(u_i)\);

\item {} 
\(u_{i+1} = u_i - w_i\);

\end{enumerate}

\end{enumerate}

break \(|| w_i|| < \varepsilon\).

Where \(DF(u)\) is the differential of \(F\) at point \(u\), this is a linear application such that:
\begin{equation*}
\begin{split}F(u+\delta) = F(u) + DF(u) \delta + o(\delta)\end{split}
\end{equation*}
For Navier Stokes, \(F\) and \(DF\) are:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    F(\mathbf{u},p) &=& \int_\Omega((\mathbf{u}\cdot\nabla) \mathbf{u} ). \mathbf{v} + \nu \nabla \mathbf{u}:\nabla \mathbf{v}
    - p \nabla\cdot \mathbf{v} - q \nabla\cdot \mathbf{u}\\
    DF(\mathbf{u},p)(\mathbf{\delta u} ,\delta p) &=& \int_\Omega ((\mathbf{\delta u}\cdot\nabla) \mathbf{u} ). \mathbf v + ((\mathbf{u}\cdot\nabla) \mathbf{\delta u} ). \mathbf{v} \\
    &+& \nu \nabla \mathbf{\delta u}:\nabla \mathbf{v} - \delta p \nabla\cdot \mathbf{v} - q \nabla\cdot \mathbf{\delta u}
\end{array}\end{split}
\end{equation*}
So the Newton algorithm become:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{R} \PYG{o}{=} \PYG{l+m+mf}{5.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mf}{15.}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{50.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{nufinal} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mf}{200.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cnu} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}

\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{ce}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{R}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{R}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{beb}\PYG{p}{(}\PYG{n}{tt}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{tt}\PYG{o}{\PYGZca{}}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{R}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{beu}\PYG{p}{(}\PYG{n}{tt}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{tt}\PYG{o}{\PYGZca{}}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{R}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{beo}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{R}\PYG{p}{,} \PYG{n}{R}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bei}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{R}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{R}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ce}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{beb}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{beu}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{beo}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bei}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//bounding box for the plot}
\PYG{k+kt}{func} \PYG{k+kp}{bb} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{du1}\PYG{p}{,}\PYG{n}{du2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1p}\PYG{p}{,}\PYG{n}{u2p}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{p}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{q}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{dp}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{pp}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{UgradV}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{)} \PYG{p}{[}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
                        \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Initialization}
\PYG{n}{u1} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{u2} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Viscosity loop}
\PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{err}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// Newton loop}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{15}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Newton}
        \PYG{k+kt}{solve} \PYG{n}{Oseen} \PYG{p}{(}\PYG{p}{[}\PYG{n}{du1}\PYG{p}{,} \PYG{n}{du2}\PYG{p}{,} \PYG{n}{dp}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
            \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                    \PYG{n}{nu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{du1}\PYG{p}{,}\PYG{n}{du2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{)}
                \PYG{o}{+} \PYG{n}{UgradV}\PYG{p}{(}\PYG{n}{du1}\PYG{p}{,}\PYG{n}{du2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{]}
                \PYG{o}{+} \PYG{n}{UgradV}\PYG{p}{(} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,}\PYG{n}{du1}\PYG{p}{,}\PYG{n}{du2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{]}
                \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{du1}\PYG{p}{,}\PYG{n}{du2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q}
                \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{dp}
                \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{o}{*}\PYG{n}{dp}\PYG{o}{*}\PYG{n}{q} \PYG{c+c1}{//stabilization term}
            \PYG{p}{)}
            \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)} \PYG{p}{(}
                    \PYG{n}{nu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{)}
                \PYG{o}{+} \PYG{n}{UgradV}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{]}
                \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q}
                \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{p}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{du1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{du2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{;}

        \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{du1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{du2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{p}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{dp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

        \PYG{k+kt}{real} \PYG{n}{Lu1}\PYG{o}{=}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{,} \PYG{n}{Lu2}\PYG{o}{=}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{,} \PYG{n}{Lp}\PYG{o}{=}\PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{;}
        \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{du1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{o}{/}\PYG{n}{Lu1} \PYG{o}{+} \PYG{n}{du2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{o}{/}\PYG{n}{Lu2} \PYG{o}{+} \PYG{n}{dp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{o}{/}\PYG{n}{Lp}\PYG{p}{;}

        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ rey = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;} \PYG{c+c1}{//converge}
        \PYG{k}{if}\PYG{p}{(} \PYG{k+kr}{n}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kp}{err} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{10.}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;} \PYG{c+c1}{//blowup}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if}\PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps}\PYG{p}{)}\PYG{p}{\PYGZob{}}  \PYG{c+c1}{//converge: decrease \PYGZdl{}\PYGZbs{}nu\PYGZdl{} (more difficult)}
        \PYG{c+c1}{// Plot}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ rey = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nu} \PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{o}{=}\PYG{k+kp}{bb}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// Change nu}
        \PYG{k}{if}\PYG{p}{(} \PYG{n}{nu} \PYG{o}{=}\PYG{o}{=} \PYG{n}{nufinal}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{n}{cnu} \PYG{o}{=} \PYG{n}{cnu}\PYG{o}{\PYGZca{}}\PYG{l+m+mf}{1.5}\PYG{p}{;} \PYG{c+c1}{//fast converge =\PYGZgt{} change faster}
        \PYG{n}{nu} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{nufinal}\PYG{p}{,} \PYG{n}{nu}\PYG{o}{*} \PYG{n}{cnu}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//new viscosity}

        \PYG{c+c1}{// Update}
        \PYG{n}{u1p} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{;}
        \PYG{n}{u2p} \PYG{o}{=} \PYG{n}{u2}\PYG{p}{;}
        \PYG{n}{pp} \PYG{o}{=} \PYG{n}{p}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}\PYG{p}{\PYGZob{}}   \PYG{c+c1}{//blowup: increase \PYGZdl{}\PYGZbs{}nu\PYGZdl{} (more simple)}
        \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{cnu}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.95}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the method finally blowup}

        \PYG{c+c1}{// Recover nu}
        \PYG{n}{nu} \PYG{o}{=} \PYG{n}{nu}\PYG{o}{/}\PYG{n}{cnu}\PYG{p}{;}
        \PYG{n}{cnu}\PYG{o}{=} \PYG{n}{cnu}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//no conv. =\PYGZgt{} change lower}
        \PYG{n}{nu} \PYG{o}{=} \PYG{n}{nu}\PYG{o}{*} \PYG{n}{cnu}\PYG{p}{;} \PYG{c+c1}{//new viscosity}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ restart nu = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Rey = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ (cnu = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cnu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ) }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

        \PYG{c+c1}{// Recover a correct solution}
        \PYG{n}{u1} \PYG{o}{=} \PYG{n}{u1p}\PYG{p}{;}
        \PYG{n}{u2} \PYG{o}{=} \PYG{n}{u2p}\PYG{p}{;}
        \PYG{n}{p} \PYG{o}{=} \PYG{n}{pp}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
We use a trick to make continuation on the viscosity \(\nu\), because the Newton method blowup owe start with the final viscosity \(\nu\).

\(\nu\) is gradually increased to the desired value.
\end{sphinxadmonition}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{NSNewtonTh}.jpg}
\caption{Mesh}\label{\detokenize{tutorial/navierStokesNewton:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{NSNewtonUP}.jpg}
\caption{Velocity and pressure}\label{\detokenize{tutorial/navierStokesNewton:id2}}\end{subfigure}
\caption{Naver-Stokes newton}\phantomsection\label{\detokenize{tutorial/navierStokesNewton:NSNewton}}

\end{figure}



\section{A Large Fluid Problem}
\label{\detokenize{tutorial/aLargeFluidProblem:a-large-fluid-problem}}\label{\detokenize{tutorial/aLargeFluidProblem::doc}}
A friend of one of us in Auroville-India was building a ramp to access an air conditioned room.
As I was visiting the construction site he told me that he expected to cool air escaping by the door to the room to slide down the ramp and refrigerate the feet of the coming visitors.
I told him “no way” and decided to check numerically.

The fluid velocity and pressure are solution of the Navier-Stokes equations with varying density function of the temperature.

The geometry is trapezoidal with prescribed inflow made of cool air at the bottom and warm air above and so are the initial conditions; there is free outflow, slip velocity at the top (artificial) boundary and no-slip at the bottom.
However the Navier-Stokes cum temperature equations have a RANS \(k-\epsilon\) model and a Boussinesq approximation for the buoyancy.
This comes to :
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \partial_t\theta+u\nabla\theta-\nabla\cdot(\kappa_T^m\nabla\theta) &=& 0\\
    \partial_t u +u\nabla u -\nabla\cdot(\mu_T\nabla u) +\nabla p+ e(\theta-\theta_0)\vec e_2 &=&0\\
    \nabla\cdot u &=& 0\\
    \mu_T &=& c_\mu\frac{k^2}\epsilon\\
    \kappa_T &=& \kappa\mu_T\\
    \partial_t k + u\nabla k + \epsilon -\nabla\cdot(\mu_T\nabla k) &=& \frac{\mu_T}2|\nabla u+\nabla u^T|^2\\
    \partial_t\epsilon+u\nabla\epsilon + c_2\frac{\epsilon^2} k -\frac{c_\epsilon}{c_\mu}\nabla\cdot (\mu_T\nabla\epsilon) &=& \frac{c_1}2 k|\nabla u+\nabla u^T|^2\\
\end{array}\end{split}
\end{equation*}
We use a time discretization which preserves positivity and uses the method of characteristics (\(X^m(x)\approx x-u^m(x)\delta t\))
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \frac 1{\delta t}(\theta^{m+1}-\theta^m \circ X^m)-\nabla\cdot(\kappa_T^m\nabla\theta^{m+1}) &=& 0\\
    \frac1{\delta t}(u^{m+1}-u^m \circ X^m) -\nabla\cdot(\mu_T^m\nabla u^{m+1}) +\nabla p^{m+1}+ e(\theta^{m+1}-\theta_0)\vec e_2 &=& 0\\
    \nabla\cdot u^{m+1} &=& 0\\
    \frac1{\delta t}(k^{m+1}-k^m \circ X^m) + k^{m+1}\frac{\epsilon^m}{k^m} -\nabla\cdot(\mu_T^m\nabla k^{m+1}) &=& \frac{\mu_T^m}2|\nabla u^m+{\nabla u^m}^T|^2\\
    \frac1{\delta t}(\epsilon^{m+1}-\epsilon^m \circ X^m) + c_2\epsilon^{m+1}\frac{\epsilon^m} {k^m} -\frac{c_\epsilon}{c_\mu}\nabla\dot(\mu_T^m\nabla\epsilon^{m+1}) &=& \frac{c_1}2 k^m|\nabla u^m+{\nabla u^m}^T|^2\\
    \mu_T ^{m+1} &=& c_\mu\frac{{k^{m+1}}^2}{\epsilon^{m+1}}\\
    \kappa_T^{m+1} &=& \kappa\mu_T^{m+1}
\end{array}\end{split}
\end{equation*}
In variational form and with appropriated boundary conditions the problem is :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{15}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nnPlus} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mf}{15.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{hSlope} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{H} \PYG{o}{=} \PYG{l+m+mf}{6.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{reylnods} \PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{beta} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{9.81}\PYG{o}{/}\PYG{l+m+mf}{303.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{numu} \PYG{o}{=} \PYG{n}{nu}\PYG{o}{/}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{0.09}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{nuep} \PYG{o}{=} \PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{,}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{4.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{Penalty} \PYG{o}{=} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{hSlope}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{hSlope}\PYG{o}{*}\PYG{p}{(}\PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{,} \PYG{n}{H}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{H}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{H}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b6}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{(}\PYG{n}{nnPlus}\PYG{o}{*}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{l}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{n}{hSlope}\PYG{o}{*}\PYG{p}{(}\PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{p}{(}\PYG{n}{H} \PYG{o}{+} \PYG{n}{hSlope}\PYG{o}{*}\PYG{p}{(}\PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b4}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{L}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b5}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{p}{(}\PYG{n}{H}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b6}\PYG{p}{(}\PYG{n}{nnPlus}\PYG{o}{*}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespaces}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1b}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{Vx}\PYG{p}{,} \PYG{n}{Vy}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{q}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{Tp}\PYG{p}{,} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mi}{35}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mf}{0.0001}\PYG{p}{,} \PYG{n}{kp}\PYG{o}{=}\PYG{n}{k}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ep}\PYG{o}{=}\PYG{l+m+mf}{0.0001}\PYG{p}{,} \PYG{n}{epp}\PYG{o}{=}\PYG{n}{ep}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{V0h}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{V0h} \PYG{n}{muT}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{V0h} \PYG{n}{prodk}\PYG{p}{,} \PYG{n}{prode}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{kappa}\PYG{o}{=}\PYG{l+m+mf}{0.25e\PYGZhy{}4}\PYG{p}{,} \PYG{n}{stress}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)} \PYG{p}{[}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Div}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Functions}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{Temperature}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha} \PYG{o}{*} \PYG{n}{T} \PYG{o}{*} \PYG{n}{q}
      \PYG{o}{+} \PYG{n}{kappa}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
      \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{Tp}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b6}\PYG{p}{,} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mi}{25}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{KineticTurbulence}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{n}{epp}\PYG{o}{/}\PYG{n}{kp} \PYG{o}{+} \PYG{n}{alpha}\PYG{p}{)} \PYG{o}{*} \PYG{n}{k} \PYG{o}{*} \PYG{n}{q}
      \PYG{o}{+} \PYG{n}{muT}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{prodk} \PYG{o}{*} \PYG{n}{q}
      \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{kp}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b5}\PYG{p}{,} \PYG{n}{b6}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mf}{0.00001}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{n}{beta}\PYG{o}{*}\PYG{n}{numu}\PYG{o}{*}\PYG{n}{stress}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{ViscosityTurbulence}\PYG{p}{(}\PYG{n}{ep}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{l+m+mf}{1.92}\PYG{o}{*}\PYG{n}{epp}\PYG{o}{/}\PYG{n}{kp} \PYG{o}{+} \PYG{n}{alpha}\PYG{p}{)} \PYG{o}{*} \PYG{n}{ep} \PYG{o}{*} \PYG{n}{q}
      \PYG{o}{+} \PYG{n}{muT} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{ep}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{T} \PYG{o}{*} \PYG{n}{q} \PYG{o}{*} \PYG{l+m+mf}{0.001}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{prode} \PYG{o}{*} \PYG{n}{q}
      \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{epp}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b5}\PYG{p}{,} \PYG{n}{b6}\PYG{p}{,} \PYG{n}{ep}\PYG{o}{=}\PYG{l+m+mf}{0.00001}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{ep}\PYG{o}{=}\PYG{n}{beta}\PYG{o}{*}\PYG{n}{nuep}\PYG{o}{*}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{stress}\PYG{p}{,}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Initialization with stationary solution}
\PYG{k+kt}{solve} \PYG{n+nf}{NavierStokes} \PYG{p}{(}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Vx}\PYG{p}{,} \PYG{n}{Vy}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha} \PYG{o}{*} \PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{]}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{p}{[}\PYG{n}{Vx}\PYG{p}{,} \PYG{n}{Vy}\PYG{p}{]}
      \PYG{o}{+} \PYG{n}{muT} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)} \PYG{o}{:} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}\PYG{p}{)}
      \PYG{o}{+} \PYG{n}{p} \PYG{o}{*} \PYG{n}{q} \PYG{o}{*} \PYG{n}{Penalty}
      \PYG{o}{\PYGZhy{}} \PYG{n}{p} \PYG{o}{*} \PYG{n}{Div}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
      \PYG{o}{\PYGZhy{}} \PYG{n}{Div}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{b4}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Ux} \PYG{o}{*} \PYG{n}{Vx} \PYG{o}{*} \PYG{l+m+mf}{0.1}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{k+kp}{eps} \PYG{o}{*} \PYG{p}{(}\PYG{n}{T}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{*} \PYG{n}{Vx}
      \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{Upx}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Vx}
      \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Vy}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b6}\PYG{p}{,} \PYG{n}{Ux}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b5}\PYG{p}{,} \PYG{n}{Ux}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b4}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b2}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{Upx}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{/}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b3}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[Ux, Uy] \PYGZhy{} p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{21}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{20.}\PYG{p}{;}
      \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ux}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{20.}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{pp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{p}\PYG{p}{(}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{20.}\PYG{p}{,}\PYG{l+m+mf}{0.999}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{yy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Ux x=0.5 cup}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{yy}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{p y=0.999 cup}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Initialization}
\PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{c+c1}{//probably too big}
\PYG{k+kt}{int} \PYG{k+kp}{nbiter} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{coefdt} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kp}{nbiter}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{coefcut} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kp}{nbiter}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cut} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{tol} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{coeftol} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kp}{nbiter}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{reylnods}\PYG{p}{;}

\PYG{n}{T} \PYG{o}{=} \PYG{n}{T} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Convergence loop}
\PYG{k+kt}{real} \PYG{n}{T0} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k+kp}{nbiter}\PYG{p}{;} \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Iteration }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iter} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} dt = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dt} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;}

   \PYG{c+c1}{// Time loop}
   \PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{500}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{;}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time step }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} t = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

      \PYG{c+c1}{// Update}
      \PYG{n}{Upx} \PYG{o}{=} \PYG{n}{Ux}\PYG{p}{;}
      \PYG{n}{Upy} \PYG{o}{=} \PYG{n}{Uy}\PYG{p}{;}
      \PYG{n}{kp} \PYG{o}{=} \PYG{n}{k}\PYG{p}{;}
      \PYG{n}{epp} \PYG{o}{=} \PYG{n}{ep}\PYG{p}{;}
      \PYG{n}{Tp} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for beauty only should be removed}
      \PYG{n}{Tp} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{Tp}\PYG{p}{,} \PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for security only should be removed}
      \PYG{n}{kp} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{;} \PYG{n}{epp} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{ep}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// to be secure: should not be active}
      \PYG{n}{muT} \PYG{o}{=} \PYG{l+m+mf}{0.09}\PYG{o}{*}\PYG{n}{kp}\PYG{o}{*}\PYG{n}{kp}\PYG{o}{/}\PYG{n}{epp}\PYG{p}{;}

      \PYG{c+c1}{// Solve NS}
      \PYG{n}{NavierStokes}\PYG{p}{;}

      \PYG{c+c1}{// Update}
      \PYG{n}{prode} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.126}\PYG{o}{*}\PYG{n}{kp}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
      \PYG{n}{prodk} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{prode}\PYG{o}{*}\PYG{n}{kp}\PYG{o}{/}\PYG{n}{epp}\PYG{o}{*}\PYG{l+m+mf}{0.09}\PYG{o}{/}\PYG{l+m+mf}{0.126}\PYG{p}{;}
      \PYG{n}{kappa} \PYG{o}{=} \PYG{n}{muT}\PYG{o}{/}\PYG{l+m+mf}{0.41}\PYG{p}{;}
      \PYG{n}{stress} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

      \PYG{c+c1}{// Solve k\PYGZhy{}eps\PYGZhy{}T}
      \PYG{n}{KineticTurbulence}\PYG{p}{;}
      \PYG{n}{ViscosityTurbulence}\PYG{p}{;}
      \PYG{n}{Temperature}\PYG{p}{;}

      \PYG{c+c1}{// Plot}
      \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
      \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ [Ux, Uy] \PYGZhy{} p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{WindowIndex}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

      \PYG{c+c1}{// Time}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Time = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{T0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+c1}{// Check}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{iter} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{k+kp}{nbiter}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

   \PYG{c+c1}{// Adaptmesh}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{abserror}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{cutoff}\PYG{o}{=}\PYG{n}{cut}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{k+kp}{tol}\PYG{p}{,} \PYG{k+kp}{inquire}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{k+kp}{hmin}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// Update}
   \PYG{n}{dt} \PYG{o}{=} \PYG{n}{dt} \PYG{o}{*} \PYG{n}{coefdt}\PYG{p}{;}
   \PYG{k+kp}{tol} \PYG{o}{=} \PYG{k+kp}{tol} \PYG{o}{*} \PYG{n}{coeftol}\PYG{p}{;}
   \PYG{n}{cut} \PYG{o}{=} \PYG{n}{cut} \PYG{o}{*} \PYG{n}{coefcut}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Total Time = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{T0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_T_100}.png}
\caption{Temperature at time step 100}\label{\detokenize{tutorial/aLargeFluidProblem:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_U_100}.png}
\caption{Velocity at time step 100}\label{\detokenize{tutorial/aLargeFluidProblem:id2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_T_200}.png}
\caption{Temperature at time step 200}\label{\detokenize{tutorial/aLargeFluidProblem:id3}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_U_200}.png}
\caption{Velocity at time step 200}\label{\detokenize{tutorial/aLargeFluidProblem:id4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_T_300}.png}
\caption{Temperature at time step 300}\label{\detokenize{tutorial/aLargeFluidProblem:id5}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_U_300}.png}
\caption{Velocity at time step 300}\label{\detokenize{tutorial/aLargeFluidProblem:id6}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_T_400}.png}
\caption{Temperature at time step 400}\label{\detokenize{tutorial/aLargeFluidProblem:id7}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_U_400}.png}
\caption{Velocity at time step 400}\label{\detokenize{tutorial/aLargeFluidProblem:id8}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_T_500}.png}
\caption{Temperature at time step 500}\label{\detokenize{tutorial/aLargeFluidProblem:id9}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_U_500}.png}
\caption{Velocity at time step 500}\label{\detokenize{tutorial/aLargeFluidProblem:id10}}\end{subfigure}
\caption{A large fluid problem}\phantomsection\label{\detokenize{tutorial/aLargeFluidProblem:ALargeFluidProblem}}

\end{figure}



\section{An Example with Complex Numbers}
\label{\detokenize{tutorial/complexNumbers:an-example-with-complex-numbers}}\label{\detokenize{tutorial/complexNumbers::doc}}
In a microwave oven heat comes from molecular excitation by an electromagnetic field.
For a plane monochromatic wave, amplitude is given by Helmholtz’s equation:
\begin{equation*}
\begin{split}\beta v + \Delta v = 0.\end{split}
\end{equation*}
We consider a rectangular oven where the wave is emitted by part of the upper wall.
So the boundary of the domain is made up of a part \(\Gamma_1\) where \(v=0\) and of another part \(\Gamma_2=[c,d]\) where for instance \(\displaystyle v=\sin\left(\pi{y-c\over c-d}\right)\).

Within an object to be cooked, denoted by \(B\), the heat source is proportional to \(v^2\).
At equilibrium, one has :
\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\Delta\theta &=& v^2 I_B\\
    \theta_\Gamma &=& 0
\end{array}\end{split}
\end{equation*}
where \(I_B\) is \(1\) in the object and \(0\) elsewhere.

In the program below \(\beta = 1/(1-i/2)\) in the air and \(2/(1-i/2)\) in the object (\(i=\sqrt{-1}\)):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{20.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{20.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{15.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{8.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mf}{12.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{g} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{b0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{o}{+}\PYG{n}{e}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{g}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{g}\PYG{o}{+}\PYG{n}{l}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{n}{e}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{l}\PYG{o}{+}\PYG{n}{g}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{l}\PYG{o}{+}\PYG{n}{g}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a2}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a3}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+}\PYG{n}{a4}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a5}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{b0}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{meat} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{n}{e}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{g}\PYG{o}{+}\PYG{n}{l}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{air}\PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{R}\PYG{o}{=}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{\PYGZhy{}}\PYG{n}{air}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{meat}\PYG{o}{\PYGZhy{}}\PYG{n}{air}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{vr}\PYG{p}{,} \PYG{n}{vi}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Uh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{ff}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{muwave}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{R}\PYG{p}{)}
      \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.5}\PYG{n}{i}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{;}

\PYG{n}{vr} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{vi} \PYG{o}{=} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{vr}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rmuonde.ps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{imuonde.ps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem (temperature)}
\PYG{n}{ff}\PYG{o}{=}\PYG{l+m+mf}{1e5}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vr}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{vi}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{R}\PYG{p}{;}

\PYG{k+kt}{solve} \PYG{n+nf}{temperature}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}\PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{ff}\PYG{o}{*}\PYG{n}{uu}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tempmuonde.ps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Results are shown on \hyperref[\detokenize{tutorial/complexNumbers:figcomplexreal}]{Fig.\@ \ref{\detokenize{tutorial/complexNumbers:figcomplexreal}}}, \hyperref[\detokenize{tutorial/complexNumbers:figcompleximaginary}]{Fig.\@ \ref{\detokenize{tutorial/complexNumbers:figcompleximaginary}}} and \hyperref[\detokenize{tutorial/complexNumbers:figcomplextemperature}]{Fig.\@ \ref{\detokenize{tutorial/complexNumbers:figcomplextemperature}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{real_microwave}.png}
\caption{Real part}\label{\detokenize{tutorial/complexNumbers:id1}}\label{\detokenize{tutorial/complexNumbers:figcomplexreal}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{imaginary_microwave}.png}
\caption{Imaginary part}\label{\detokenize{tutorial/complexNumbers:id2}}\label{\detokenize{tutorial/complexNumbers:figcompleximaginary}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{temperature_microwave}.png}
\caption{Temperature}\label{\detokenize{tutorial/complexNumbers:id3}}\label{\detokenize{tutorial/complexNumbers:figcomplextemperature}}\end{subfigure}
\caption{Microwave}\phantomsection\label{\detokenize{tutorial/complexNumbers:Microwave}}

\end{figure}



\section{Optimal Control}
\label{\detokenize{tutorial/optimalControl:optimal-control}}\label{\detokenize{tutorial/optimalControl::doc}}
Thanks to the function \sphinxcode{\sphinxupquote{BFGS}} it is possible to solve complex nonlinear optimization problem within \sphinxstylestrong{FreeFem++}.
For example consider the following inverse problem
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \min_{b, c, d\in R}J &=& \int_E(u-u_d)^2\\
    -\nabla(\kappa(b, c, d)\cdot\nabla u) &=& 0\\
    u|_\Gamma &=& u_\Gamma
\end{array}\end{split}
\end{equation*}
where the desired state \(u_d\), the boundary data \(u_\Gamma\) and the observation set \(E\subset\Omega\) are all given.
Furthermore let us assume that:
\begin{equation*}
\begin{split}\kappa(x)=1+bI_B(x)+cI_C(x)+dI_D(x)\quad\forall x\in\Omega\end{split}
\end{equation*}
where \(B,C,D\) are separated subsets of \(\Omega\).

To solve this problem by the quasi-Newton BFGS method we need the derivatives of \(J\) with respect to \(b,c,d\).
We self explanatory notations, if \(\delta b,\delta c,\delta d\) are variations of \(b,c,d\) we have:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \delta J &\approx& 2\int_E(u-u_d)\delta u\\
    -\nabla(\kappa\cdot\nabla\delta u) &\approx& \nabla(\delta\kappa\cdot\nabla u)\\
    \delta u|_\Gamma &=& 0
\end{array}\end{split}
\end{equation*}
Obviously \(J'_b\) is equal to \(\delta J\) when \(\delta b=1,\delta c=0,\delta d=0\), and so on for \(J'_c\) and \(J'_d\).

All this is implemented in the following program:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{aa}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{+}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{dd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{+}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{+} \PYG{n}{cc}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dd}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{Ib}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1.0001}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{Ic}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1.0001}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{Id}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1.0001}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{Ie}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{ud}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{du}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{z}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ib}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ic}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Id}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{k+kp}{A}\PYG{p}{;}
\PYG{n}{ud} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

\PYG{k+kt}{ofstream} \PYG{n+nf}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{Z}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{z}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{k+kr}{z}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{n}{Z}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kp}{A}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{Ie}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{ud}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Problem BFGS}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dJdz}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{k+kp}{B} \PYG{p}{(}\PYG{n}{du}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ib}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ic}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Id}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{du}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{du}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ib}\PYG{o}{+}\PYG{n+nf}{dz}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ic}\PYG{o}{+}\PYG{n+nf}{dz}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Id}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{n}{du}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{Z}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{z}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n+nf}{dz}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
         \PYG{n+nf}{dz}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{n+nf}{dz}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
      \PYG{k+kp}{B}\PYG{p}{;}
      \PYG{n}{dJdz}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{Ie}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{ud}\PYG{p}{)}\PYG{o}{*}\PYG{n}{du}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{return} \PYG{n}{dJdz}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Z}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{z}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
   \PYG{n}{Z}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{n+nf}{BFGS}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{DJ}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{n}{nbiterline}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BFGS: J(z) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{z}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{z}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{ud}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In this example the sets \(B,C,D,E\) are circles of boundaries \(bb,cc,dd,ee\) and the domain \(\Omega\) is the circle of boundary \(aa\).

The desired state \(u_d\) is the solution of the PDE for \(b=2,c=3,d=4\). The unknowns are packed into array \(z\).

\begin{sphinxadmonition}{note}{Note:}
It is necessary to recopy \(Z\) into \(z\) because one is a local variable while the other one is global.
\end{sphinxadmonition}

The program found \(b=2.00125,c=3.00109,d=4.00551\).

\hyperref[\detokenize{tutorial/optimalControl:figoptimalu}]{Fig.\@ \ref{\detokenize{tutorial/optimalControl:figoptimalu}}} and \hyperref[\detokenize{tutorial/optimalControl:figoptimalj}]{Fig.\@ \ref{\detokenize{tutorial/optimalControl:figoptimalj}}} show \(u\) at convergence and the successive function evaluations of \(J\).

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{u-bfgs}.png}
\caption{Level line of \(u\).}\label{\detokenize{tutorial/optimalControl:id1}}\label{\detokenize{tutorial/optimalControl:figoptimalu}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{OptimalControl_J}.png}
\caption{Successive evaluations of \(J\) by BFGS (5 values above 500 have been removed for readability)}\label{\detokenize{tutorial/optimalControl:id2}}\label{\detokenize{tutorial/optimalControl:figoptimalj}}\end{subfigure}
\caption{Optimal control}\phantomsection\label{\detokenize{tutorial/optimalControl:OptimalControl}}

\end{figure}


Note that an \sphinxstyleemphasis{adjoint state} could have been used.
Define \(p\) by:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\nabla\cdot(\kappa\nabla p) &=& 2I_E(u-u_d)\\
    p|_\Gamma &=& 0
\end{array}\end{split}
\end{equation*}
Consequently:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \delta J &=& -\int_{\Omega}(\nabla\cdot(\kappa\nabla p))\delta u\nonumber\\
    &=& \int_\Omega(\kappa\nabla p\cdot\nabla\delta u)\\
    &=&-\int_\Omega(\delta\kappa\nabla p\cdot\nabla u)
\end{array}\end{split}
\end{equation*}
Then the derivatives are found by setting \(\delta b=1, \delta c=\delta d=0\) and so on:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    J'_b&=&-\int_B \nabla p\cdot\nabla u\\
    J'_c&=&-\int_C \nabla p\cdot\nabla u\\
    J'_d&=&-\int_D \nabla p\cdot\nabla u
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
As BFGS stores an \(M\times M\) matrix where \(M\) is the number of unknowns, it is dangerously expensive to use this method when the unknown \(x\) is a Finite Element Function.
One should use another optimizer such as the NonLinear Conjugate Gradient \sphinxcode{\sphinxupquote{NLCG}} (also a key word of \sphinxstylestrong{FreeFem++}).
\end{sphinxadmonition}


\section{A Flow with Shocks}
\label{\detokenize{tutorial/flowWithShocks:a-flow-with-shocks}}\label{\detokenize{tutorial/flowWithShocks::doc}}
Compressible Euler equations should be discretized with Finite Volumes or FEM with flux up-winding scheme but these are not implemented in \sphinxstylestrong{FreeFem++}.
Nevertheless acceptable results can be obtained with the method of characteristics provided that the mean values \(\displaystyle \bar f=\frac12\left(f^++f^-\right)\) are used at shocks in the scheme, and finally mesh adaptation.
\begin{equation}\label{equation:tutorial/flowWithShocks:euler}
\begin{split}\begin{array}{rcl}
    \partial_t\rho+\bar u\nabla\rho + \bar\rho\nabla\cdot u &=& 0\nonumber\\
    \bar\rho( \partial_t u+\frac{\overline{\rho u}}{\bar\rho}\nabla u +\nabla p &=& 0\nonumber\\
    \partial_t p + \bar u\nabla p +(\gamma-1)\bar p\nabla\cdot u &=& 0\\
\end{array}\end{split}
\end{equation}
One possibility is to couple \(u,p\) and then update \(\rho\), i.e.:
\begin{equation}\label{equation:tutorial/flowWithShocks:eulalgo}
\begin{split}\begin{array}{rcl}
    \frac 1{(\gamma-1)\delta t\bar p^m} (p^{m+1}-p^m \circ X^m) + \nabla\cdot u^{m+1} &=& 0\nonumber\\
    \frac{\bar\rho^m}{\delta t}(u^{m+1}-u^m \circ {\tilde X}^m ) +\nabla p^{m+1} &=& 0\nonumber\\
    \rho^{m+1} = \rho^m \circ X^m + \frac{\bar\rho^m}{(\gamma-1)\bar p^m}(p^{m+1} &-& p^m \circ X^m)
\end{array}\end{split}
\end{equation}
A numerical result is given on \hyperref[\detokenize{tutorial/flowWithShocks:figflowmach}]{Fig.\@ \ref{\detokenize{tutorial/flowWithShocks:figflowmach}}} and the \sphinxstylestrong{FreeFem++} script is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{anew} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{rr} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{u0} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{err0} \PYG{o}{=} \PYG{l+m+mf}{0.00625}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{pena} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ccc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{ddd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{aaa1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{x0}\PYG{o}{\PYGZhy{}}\PYG{n}{rr}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{cercle}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{x0}\PYG{o}{+}\PYG{n}{rr}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{y0}\PYG{o}{+}\PYG{n}{rr}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{aaa2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{x0}\PYG{o}{+}\PYG{n}{rr}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{bbb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

 \PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{p}{;}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{anew}\PYG{p}{)}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh} \PYG{p}{(}\PYG{n}{ccc}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ddd}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{aaa1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{cercle}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{aaa2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bbb}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th\PYGZus{}circle.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{r}\PYG{p}{,} \PYG{n}{rh}\PYG{p}{,} \PYG{n}{r1}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{dn}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{+}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Initialization}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{anew}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{u1} \PYG{o}{=} \PYG{n}{u0}\PYG{p}{;}
   \PYG{n}{v1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{r1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{ifstream} \PYG{n}{g}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{g} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{ifstream} \PYG{n+nf}{gg}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{v.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{gg} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{v1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{ifstream} \PYG{n+nf}{ggg}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{ggg} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{eta.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{err0} \PYG{o}{=} \PYG{n}{err0}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
   \PYG{n}{dt} \PYG{o}{=} \PYG{n}{dt}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{euler}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{,} \PYG{n}{rh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{uh} \PYG{o}{+} \PYG{n}{v}\PYG{o}{*}\PYG{n}{vh} \PYG{o}{+} \PYG{n}{r}\PYG{o}{*}\PYG{n}{rh}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
      \PYG{o}{+} \PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{o}{*}\PYG{n}{uh} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rh}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rh}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
      \PYG{o}{\PYGZhy{}} \PYG{p}{(}
           \PYG{n}{rh}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{r1}\PYG{p}{)}
         \PYG{o}{+} \PYG{n}{uh}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{u1}\PYG{p}{)}
         \PYG{o}{+} \PYG{n}{vh}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{v1}\PYG{p}{)}
      \PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
   \PYG{p}{)}
   \PYG{o}{+}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{rh}\PYG{o}{*}\PYG{n}{u}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Iterations}
\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{80}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{if}\PYG{p}{(}\PYG{n}{k}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{err0} \PYG{o}{=} \PYG{n}{err0}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
      \PYG{n}{dt} \PYG{o}{=} \PYG{n}{dt}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
      \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+c1}{// Solve}
   \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{euler}\PYG{p}{;}
      \PYG{n}{u1}\PYG{o}{=}\PYG{n}{u}\PYG{p}{;}
      \PYG{n}{v1}\PYG{o}{=}\PYG{n}{v}\PYG{p}{;}
      \PYG{n}{r1}\PYG{o}{=}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{k = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ E = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{v}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{r}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+c1}{// Mesh adaptation}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh} \PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{40000}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{err0}\PYG{p}{,} \PYG{k+kp}{abserror}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbjacoby}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{omega}\PYG{o}{=}\PYG{l+m+mf}{1.8}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{l+m+mf}{1.8}\PYG{p}{,} \PYG{k+kp}{nbsmooth}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{maxsubdiv}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kp}{rescaling}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{u} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
   \PYG{n}{v} \PYG{o}{=} \PYG{n}{v}\PYG{p}{;}
   \PYG{n}{r} \PYG{o}{=} \PYG{n}{r}\PYG{p}{;}

   \PYG{c+c1}{// Save}
   \PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th\PYGZus{}circle.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{ofstream} \PYG{n+nf}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{ofstream} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{v.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{ofstream} \PYG{n+nf}{fff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{fff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{r1} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{u}\PYG{o}{+}\PYG{n}{v}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mach.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{r1} \PYG{o}{=} \PYG{n}{r}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{mach_2r}.png}
\caption{Pressure for a Euler flow around a disk at Mach 2 computed by \eqref{equation:tutorial/flowWithShocks:eulalgo}}\label{\detokenize{tutorial/flowWithShocks:figflowmach}}\end{figure}


\section{Time dependent schema optimization for heat equations}
\label{\detokenize{tutorial/heatEquationOptimization:time-dependent-schema-optimization-for-heat-equations}}\label{\detokenize{tutorial/heatEquationOptimization::doc}}
First, it is possible to define variational forms, and use this forms to build matrix and vector to make very fast script (4 times faster here).

For example solve the {\hyperref[\detokenize{tutorial/thermalConduction:thermalconduction}]{\sphinxcrossref{\DUrole{std,std-ref}{ThermalConduction}}}} problem, we must solve the temperature equation in \(\Omega\) in a time interval (0,T).
\begin{equation*}
\begin{split}\begin{array}{rcll}
    \partial_t u -\nabla\cdot(\kappa\nabla u) &=& 0 &\hbox{ in } \Omega\times(0,T)\\
    u(x,y,0) &=& u_0 + x u_1\\
    u &=& 30 &\hbox{ on } \Gamma_{24}\times(0,T)\\
    \kappa\frac{\partial u}{\partial n} + \alpha(u-u_e) &=& 0 &\hbox{ on } \Gamma\times(0,T)
\end{array}\end{split}
\end{equation*}
The variational formulation is in \(L^2(0,T;H^1(\Omega))\); we shall seek \(u^n\) satisfying:
\begin{equation*}
\begin{split}\forall w \in V_{0};\ \int_\Omega \frac{u^n-u^{n-1}}{\delta t} w + \kappa\nabla u^n\nabla w) +\int_\Gamma\alpha(u^n-u_{ue})w=0\end{split}
\end{equation*}
where \(V_0 = \{w\in H^1(\Omega)/ w_{|\Gamma_{24}}=0\}\).

So, to code the method with the matrices \(A=(A_{ij})\), \(M=(M_{ij})\), and the vectors \(u^n, b^n, b',b", b_{cl}\) (notation if \(w\) is a vector then \(w_i\) is a component of the vector).
\begin{equation*}
\begin{split}u^n = A^{-1} b^n,
    \quad b' = b_0 + M u^{n-1},
    \quad b"= \frac{1}{\varepsilon} \; b_{cl} ,
    \quad b^n_i = \left\{
        \begin{array}{cl}
            b''_i & \mbox{if }\ i \in \Gamma_{24} \\
            b'_i & \mbox{else }
        \end{array}\right.
    \label{eq tgv}\end{split}
\end{equation*}
Where with \(\frac{1}{\varepsilon} = \mathtt{tgv} = 10^{30}\):
\begin{equation*}
\begin{split}\begin{array}{rcl}
    A_{ij} &=&
      \left\{\begin{array}{cl}
      \frac{1}{\varepsilon} & \mbox{if } i \in \Gamma_{24}, \mbox{and}\quad j=i\\
      \displaystyle{\int_{\Omega} w_j w_i / dt + k (\nabla w_j. \nabla w_i ) + \int_{\Gamma_{13}} \alpha w_j w_i} & \mbox{else}
      \end{array}\right.\\
    M_{ij} &=&
      \left\{\begin{array}{cl}
      \frac{1}{\varepsilon} & \mbox{if } i \in \Gamma_{24}, \mbox{and}\quad j=i \\
      \displaystyle n{\int_{\Omega} w_j w_i / dt} & \mbox{else}
      \end{array}\right. \\
    b_{0,i} &=& n{\int_{\Gamma_{13}} \alpha u_{ue} w_i } \\
    b_{cl} &=& u^{0} \quad \mbox{the initial data}
\end{array}\end{split}
\end{equation*}
The Fast version script:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Vh} \PYG{n}{u0}\PYG{o}{=}\PYG{n}{fu0}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{;}
\end{sphinxVerbatim}

Create three variational formulation, and build the matrices \(A\),\(M\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{vthermic} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{k}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vthermic0} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{ue}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vMass} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{tgv} \PYG{o}{=} \PYG{l+m+mf}{1e30}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vthermic}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{k+kp}{tgv}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{M} \PYG{o}{=} \PYG{n}{vMass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now, to build the right hand size; we need 4 vectors.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b0} \PYG{o}{=} \PYG{n}{vthermic0}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//constant part of RHS}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bcn} \PYG{o}{=} \PYG{n}{vthermic}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//tgv on Dirichlet part}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bcl} \PYG{o}{=} \PYG{k+kp}{tgv}\PYG{o}{*}\PYG{n}{u0}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}   \PYG{c+c1}{//the Dirichlet B.C. part}

\PYG{c+c1}{// The fast loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b0}\PYG{p}{;}   \PYG{c+c1}{//the RHS}
    \PYG{n}{b} \PYG{o}{+}\PYG{o}{=} \PYG{n}{M}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//add the the time dependent part}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{bcn} \PYG{o}{?} \PYG{n+nl}{bcl} \PYG{o}{:} \PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//do \PYGZdl{}\PYGZbs{}forall i\PYGZdl{}: b[i] = bcn[i] ? bcl[i] : b[i];}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//solve linear problem}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Tutorial to write a transient Stokes solver in matrix form}
\label{\detokenize{tutorial/timeDependentStokes:tutorial-to-write-a-transient-stokes-solver-in-matrix-form}}\label{\detokenize{tutorial/timeDependentStokes::doc}}
Consider the following script to solve a time dependent Stokes problem in a cavity

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Qh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Qh} \PYG{n}{p}\PYG{p}{;}
\PYG{n}{Qh} \PYG{n}{pp}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{stokes} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{uu}\PYG{o}{+}\PYG{n}{v}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n}{pp}\PYG{o}{*}\PYG{l+m+mf}{1.e\PYGZhy{}6}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{pp}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{uold}\PYG{o}{*}\PYG{n}{uu}\PYG{o}{+}\PYG{n}{vold}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k+kt}{int} \PYG{k+kr}{m}\PYG{p}{,} \PYG{n}{M} \PYG{o}{=} \PYG{n}{T}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{n}{M}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{stokes}\PYG{p}{;}
    \PYG{n}{uold} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
    \PYG{n}{vold} \PYG{o}{=} \PYG{n}{v}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{m}\PYG{o}{*}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Every iteration is in fact of the form \(A[u,v,p] = B[uold,vold,pold] + b\) where \(A,B\) are matrices and \(b\) is a vector containing the boundary conditions.
\(A,B,b\) are constructed by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{aa} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{uu}\PYG{o}{+}\PYG{n}{v}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n}{pp}\PYG{o}{*}\PYG{l+m+mf}{1.e\PYGZhy{}6}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{pp}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{k+kp}{bb} \PYG{p}{(}\PYG{p}{[}\PYG{n}{uold}\PYG{p}{,} \PYG{n}{vold}\PYG{p}{,} \PYG{n}{pold}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{uold}\PYG{o}{*}\PYG{n}{uu}\PYG{o}{+}\PYG{n}{vold}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{c+c1}{//+ on(1, 2, 4, uold=0, vold=0)}
    \PYG{c+c1}{//+ on(3, uold=1, vold=0)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{bcl} \PYG{p}{(}\PYG{p}{[}\PYG{n}{uold}\PYG{p}{,} \PYG{n}{vold}\PYG{p}{,} \PYG{n}{pold}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{uold}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{vold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{aa}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{bcl}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note that the boundary conditions are not specified in \(bb\).
Removing the comment \sphinxcode{\sphinxupquote{//}} would cause the compiler to multiply the diagonal terms corresponding to a Dirichlet degree of freedom by a very large term (\sphinxcode{\sphinxupquote{tgv}}); if so \(b\) would not be needed, on the condition that \(uold=1\) on boundary 3 initially.
Note also that b has a tgv on the Dirichlet nodes, by construction, and so does A.

The loop will then be:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sol}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{aux}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{n}{M}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{aux} \PYG{o}{=} \PYG{k+kp}{B}\PYG{o}{*}\PYG{n}{sol}\PYG{p}{;} \PYG{n}{aux} \PYG{o}{+}\PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
    \PYG{n}{sol} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{aux}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

There is yet a difficulty with the initialization of \sphinxcode{\sphinxupquote{sol}} and with the solution from \sphinxcode{\sphinxupquote{sol}}.
For this we need a temporary vector in \(X_h\) and here is a solution:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Xh} \PYG{p}{[}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{wp}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{uold}\PYG{p}{,} \PYG{n}{vold}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{sol} \PYG{o}{=} \PYG{n}{w1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//cause also the copy of w2 and wp}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{n}{M}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{aux} \PYG{o}{=} \PYG{k+kp}{B}\PYG{o}{*}\PYG{n}{sol}\PYG{p}{;} \PYG{n}{aux} \PYG{o}{+}\PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
    \PYG{n}{sol} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{aux}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{w1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=}\PYG{n}{sol}\PYG{p}{;} \PYG{n}{u}\PYG{o}{=}\PYG{n}{w1}\PYG{p}{;} \PYG{n}{v}\PYG{o}{=} \PYG{n}{w2}\PYG{p}{;} \PYG{n}{p}\PYG{o}{=}\PYG{n}{wp}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{m}\PYG{o}{*}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The freefem team agrees that the line \sphinxcode{\sphinxupquote{sol=w1{[}{]};}} is mysterious as it copies also w2 and wp into sol.
Structured data such as vectors of \(X_h\) here cannot be written component by component.
Hence \sphinxcode{\sphinxupquote{w1=u}} is not allowed.


\section{Wifi Propagation}
\label{\detokenize{tutorial/wifiPropagation:wifi-propagation}}\label{\detokenize{tutorial/wifiPropagation::doc}}

\subsection{Summary}
\label{\detokenize{tutorial/wifiPropagation:summary}}
In this tutorial, we will study the wifi signal power in a flat.
An awesome flat is especially designed for the experiment, with \sphinxstylestrong{2} walls:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{house}.png}
\caption{Flat}\label{\detokenize{tutorial/wifiPropagation:id1}}\end{figure}

Even if the flat seems small enough to be covered by wifi everywhere, it is still interesting to study where the signal’s power is the lowest.
We will study where to put the hotspot to get the best coverage, and as we’re a bit lazy we will only put it next to the left wall.


\subsection{Physics}
\label{\detokenize{tutorial/wifiPropagation:physics}}
In a nutshell, the Wifi is a electromagnetic wave that contains a signal : Internet data.
Electromagnetic waves are well know by physicists and are ruled by the \sphinxstylestrong{4 Maxwell equations} which give you the solution for \sphinxstyleemphasis{E}, the electrical field, and \sphinxstyleemphasis{B}, the magnetic field, in space but also in time.

We don’t care about the time here, because the signal period is really short so our internet quality will not change with time.
Without time, we’re looking for stationaries solutions, and the Maxwell equations can be simplified to one equation, the Helmholtz one :
\begin{equation*}
\begin{split}\nabla^{2}E + \frac{k^{2}}{n^{2}}E = 0\end{split}
\end{equation*}
Where \sphinxstyleemphasis{k} is the angular wavenumber of the wifi signal, and \sphinxstyleemphasis{n} the refractive index of the material the wave is in.

Indeed, the main point of this study is the impact of \sphinxstylestrong{walls} on the signal’s power, where the \sphinxstyleemphasis{n} is different from air (where it is 1).
In walls, the refractive index is a complex number in which the two parts have a physic interpretation:
\begin{itemize}
\item {} 
The \sphinxstyleemphasis{real part} defines the \sphinxstylestrong{reflexion} of the wall (the amount of signal that doesn’t pass).

\item {} 
The \sphinxstyleemphasis{imaginary part} defines the \sphinxstylestrong{absorption} of the wall (the amount that disappears).

\end{itemize}

The wifi hotspot (simulated by a simple circle) will be the boundary condition, with a non null value for our electrical field.


\subsection{Coding}
\label{\detokenize{tutorial/wifiPropagation:coding}}

\subsubsection{The domain}
\label{\detokenize{tutorial/wifiPropagation:the-domain}}
In order to create the domain of experimentation, we need to create \sphinxcode{\sphinxupquote{border}} objects, like this :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{a00}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a10}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a20}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a30}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{+}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{+}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{+}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a31}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{+}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real} \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{q} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b00}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{p}\PYG{o}{+}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{q}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b10}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{p}\PYG{o}{+}\PYG{n+nf}{d}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{q}\PYG{o}{+}\PYG{n}{e}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b20}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{p}\PYG{o}{+}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{q}\PYG{o}{+}\PYG{n}{e}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b30}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{p}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{q}\PYG{o}{+}\PYG{n}{e}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=}\PYG{l+m+mi}{1} \PYG{p}{,} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{15}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c00}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{+}\PYG{n}{j}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{s}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c10}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{+}\PYG{n}{j}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{s}\PYG{o}{+}\PYG{n}{u}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c20}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{+}\PYG{n}{j}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{s}\PYG{o}{+}\PYG{n}{u}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c30}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{s}\PYG{o}{+}\PYG{n}{u}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Let’s create a mesh}
\label{\detokenize{tutorial/wifiPropagation:lets-create-a-mesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=}\PYG{l+m+mi}{13}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Sh} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a00}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a10}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a20}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a30}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{a01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a11}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a21}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a31}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{b00}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b10}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b20}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b30}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{c00}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c10}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c20}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c30}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

So we are creating a \sphinxcode{\sphinxupquote{mesh}}, and plotting it :

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{mesh}.png}
\caption{Mesh}\label{\detokenize{tutorial/wifiPropagation:id2}}\end{figure}

There is currently no wifi hotspot, and as we want to resolve the equation for a multiple number of position next to the left wall, let’s do a \sphinxcode{\sphinxupquote{for}} loop:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{bx}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{bx} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{bx} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;} \PYG{n}{bx}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{border} \PYG{n}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bx}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a00}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a10}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a20}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a30}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{a01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a11}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a21}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a31}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{b00}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b10}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b20}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b30}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{c00}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c10}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c20}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c30}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The border \sphinxcode{\sphinxupquote{C}} is our hotspot and as you can see a simple circle.
\sphinxcode{\sphinxupquote{Th}} is our final mesh, with all borders and the hotspot.
Let’s resolve this equation !

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{wall}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{Th}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{=}\PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{Th}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{=}\PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mf}{20.5}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{Th}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{=}\PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{30.5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
   \PYG{k}{else} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{,}\PYG{n}{w}\PYG{p}{;}

\PYG{n+nf}{randinit}\PYG{p}{(}\PYG{l+m+mi}{900}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{wallreflexion} \PYG{o}{=} \PYG{n+nf}{randreal1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{wallabsorption} \PYG{o}{=} \PYG{n+nf}{randreal1}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{n}{i}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Reflexion of walls : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{wallreflexion} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Absorption of walls : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{wallabsorption} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{muwave}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{w}\PYG{p}{)} \PYG{o}{=}
    \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{k}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{p}{(}\PYG{n}{wallreflexion}\PYG{o}{+}\PYG{n}{wallabsorption}\PYG{p}{)}\PYG{o}{*}\PYG{n}{wall}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}
        \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n}{muwave}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{vm} \PYG{o}{=} \PYG{n+nf}{log}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{vm}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{65}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

A bit of understanding here :
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{fespace}} keyword defines a finite elements space, no need to know more here.

\item {} 
The function \sphinxcode{\sphinxupquote{wall}} return 0 if in air and 1 if in a wall (x and y are global variables).

\item {} 
For this example, random numbers are used for the reflexion and the absorption.

\item {} 
The problem is defined with \sphinxcode{\sphinxupquote{problem}} and we solve it by calling it.

\end{itemize}

Finally, I plotted the \(\log\) of the module of the solution \sphinxcode{\sphinxupquote{v}} to see the signal’s power, and here we are :

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{point1}.png}
\caption{Solution}\label{\detokenize{tutorial/wifiPropagation:id3}}\end{figure}

Beautiful isn’t it ? This is the first position for the hotspot, but there are 6 others, and the electrical field is evolving depending on the position.
You can see the other positions here :

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point2}.png}
\caption{Point 2}\label{\detokenize{tutorial/wifiPropagation:id4}}\end{subfigure}
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point3}.png}
\caption{Point 3}\label{\detokenize{tutorial/wifiPropagation:id5}}\end{subfigure}
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point4}.png}
\caption{Point 4}\label{\detokenize{tutorial/wifiPropagation:id6}}\end{subfigure}
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point5}.png}
\caption{Point 5}\label{\detokenize{tutorial/wifiPropagation:id7}}\end{subfigure}
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point6}.png}
\caption{Point 6}\label{\detokenize{tutorial/wifiPropagation:id8}}\end{subfigure}
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point7}.png}
\caption{Point 7}\label{\detokenize{tutorial/wifiPropagation:id9}}\end{subfigure}
\caption{Wifi propagation}\phantomsection\label{\detokenize{tutorial/wifiPropagation:WifiPropagation}}

\end{figure}



\section{Plotting in Matlab and Octave}
\label{\detokenize{tutorial/matlabOctavePlot:plotting-in-matlab-and-octave}}\label{\detokenize{tutorial/matlabOctavePlot:tutorialmatlaboctaveplot}}\label{\detokenize{tutorial/matlabOctavePlot::doc}}

\subsection{Overview}
\label{\detokenize{tutorial/matlabOctavePlot:overview}}
In order to create a plot of a FreeFem++ simulation in \sphinxhref{https://www.mathworks.com/}{Matlab©} or \sphinxhref{https://www.gnu.org/software/octave/}{Octave} two steps are necessary:
\begin{itemize}
\item {} 
The mesh, the finite element space connectivity and the simulation data must be exported into files

\item {} 
The files must be imported into the Matlab / Octave workspace. Then the data can be visualized with the \sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib} library

\end{itemize}

The steps are explained in more detail below using the example of a stripline capacitor.

\begin{sphinxadmonition}{note}{Note:}
Finite element variables must be in P1 or P2. The simulation data can be 2D or 3D.
\end{sphinxadmonition}


\subsection{2D Problem}
\label{\detokenize{tutorial/matlabOctavePlot:d-problem}}
Consider a stripline capacitor problem which is also shown in \hyperref[\detokenize{tutorial/matlabOctavePlot:figmatlabboundaryplot}]{Fig.\@ \ref{\detokenize{tutorial/matlabOctavePlot:figmatlabboundaryplot}}}. On the two boundaries (the electrodes) \(C_{A}\), \(C_{K}\) a Dirichlet condition and on the enclosure \(C_{B}\) a Neumann condition is set. The electrostatic potential \(u\) between the two electrodes is given by the Laplace equation
\begin{equation*}
\begin{split}\Delta u(x,y) = 0\end{split}
\end{equation*}
and the electrostatic field \(\mathbf{E}\) is calculated by
\begin{equation*}
\begin{split}\mathbf{E} = -\nabla u\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{CA}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{CK}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{CB}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{w2}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{h}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{n}{d2}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{bottomA}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{,}\PYG{n}{w2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{d2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CA}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{rightA}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{d2}\PYG{p}{,}\PYG{n}{d2}\PYG{o}{+}\PYG{n}{h}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{w2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CA}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{topA}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{w2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{d2}\PYG{o}{+}\PYG{n}{h}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CA}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{leftA}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{d2}\PYG{o}{+}\PYG{n}{h}\PYG{p}{,}\PYG{n}{d2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CA}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{bottomK}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{,}\PYG{n}{w2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CK}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{rightK}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{w2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CK}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{topK}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{w2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CK}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{leftK}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CK}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{enclosure}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CB}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{enclosure}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}
             \PYG{n}{bottomA}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{topA}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{rightA}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{leftA}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}
             \PYG{n}{bottomK}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{topK}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{rightK}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{leftK}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{u0}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{Laplace}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{,}\PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)} \PYG{o}{=}
          \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{CA}\PYG{p}{,}\PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{CK}\PYG{p}{,}\PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{error}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Laplace}\PYG{p}{;}
   \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{error}\PYG{o}{=}\PYG{n}{error}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{Laplace}\PYG{p}{;}

\PYG{n}{Vh} \PYG{n}{Ex}\PYG{p}{,} \PYG{n}{Ey}\PYG{p}{;}
\PYG{n}{Ex} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ey} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{p}{[}\PYG{n}{Ex}\PYG{p}{,}\PYG{n}{Ey}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Exporting Data}
\label{\detokenize{tutorial/matlabOctavePlot:exporting-data}}
The mesh is stored with the FreeFem++ command {\hyperref[\detokenize{documentation/meshGeneration:meshdatastructurereadwrite}]{\sphinxcrossref{\DUrole{std,std-ref}{savemesh()}}}}, while the connectivity of the finite element space and the simulation data are stored with the macro commands \sphinxcode{\sphinxupquote{ffSaveVh()}} and \sphinxcode{\sphinxupquote{ffSaveData()}}. These two commands are located in the \sphinxcode{\sphinxupquote{ffmatlib.idp}} file which is included in the \sphinxcode{\sphinxupquote{ffmatlib}}. Therefore, to export the stripline capacitor data the following statement sequence must be added to the FreeFem++ code:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmatlib.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{//Save mesh}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{capacitor.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Save finite element space connectivity}
\PYG{n}{ffSaveVh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{capacitor\PYGZus{}vh.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Save some scalar data}
\PYG{n}{ffSaveData}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{capacitor\PYGZus{}potential.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Save a 2D vector field}
\PYG{n}{ffSaveData2}\PYG{p}{(}\PYG{n}{Ex}\PYG{p}{,}\PYG{n}{Ey}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{capacitor\PYGZus{}field.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Importing Data}
\label{\detokenize{tutorial/matlabOctavePlot:importing-data}}
The mesh file can be loaded into the Matlab / Octave workspace using the \sphinxcode{\sphinxupquote{ffreadmesh()}} command. A mesh file consists of {\hyperref[\detokenize{documentation/meshGeneration:meshdatastructurereadwrite}]{\sphinxcrossref{\DUrole{std,std-ref}{three main sections}}}}:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
The mesh points as nodal coordinates

\item {} 
A list of boundary edges including boundary labels

\item {} 
List of triangles defining the mesh in terms of connectivity

\end{enumerate}

The three data sections mentioned are returned in the variables \sphinxcode{\sphinxupquote{p}}, \sphinxcode{\sphinxupquote{b}} and \sphinxcode{\sphinxupquote{t}}. The finite element space connectivity and the simulation data can be loaded using the \sphinxcode{\sphinxupquote{ffreaddata()}} command. Therefore, to load the example data the following statement sequence must be executed in Matlab / Octave:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZpc{}Add ffmatlib to the search path}
\PYG{n}{addpath}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add here the link to the ffmatlib\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{}Load the mesh}
\PYG{p}{[}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{nv}\PYG{p}{,}\PYG{n}{nbe}\PYG{p}{,}\PYG{n}{nt}\PYG{p}{,}\PYG{n}{labels}\PYG{p}{]}\PYG{p}{=}\PYG{n}{ffreadmesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{capacitor.msh\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{}Load the finite element space connectivity}
\PYG{n}{vh}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{capacitor\PYGZus{}vh.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{}Load scalar data}
\PYG{n}{u}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{capacitor\PYGZus{}potential.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{}Load 2D vector field data}
\PYG{p}{[}\PYG{n}{Ex}\PYG{p}{,}\PYG{n}{Ey}\PYG{p}{]}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{capacitor\PYGZus{}field.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{2D Plot Examples}
\label{\detokenize{tutorial/matlabOctavePlot:d-plot-examples}}
\sphinxcode{\sphinxupquote{ffpdeplot()}} is a plot solution for creating patch, contour, quiver, mesh, border, and region plots of 2D geometries. The basic syntax is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{[}\PYG{n}{handles}\PYG{p}{,}\PYG{n}{varargout}\PYG{p}{]} \PYG{p}{=} \PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{varargin}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{varargin}} specifies parameter name / value pairs to control the plot behaviour.
A table showing all options can be found in the \sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib} documentation. A small selection of possible plot commands is given as follows:
\begin{itemize}
\item {} 
Plot of the boundary and the mesh:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Boundary\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{capacitor_boundary_mesh_500x400}.png}
\caption{Boundary and Mesh}\label{\detokenize{tutorial/matlabOctavePlot:figmatlabboundaryplot}}\end{figure}
\begin{itemize}
\item {} 
Patch plot (2D map or density plot) including mesh and boundary:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VhSeq\PYGZsq{}}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XYData\PYGZsq{}}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Boundary\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,} \PYG{c}{...}
          \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XLim\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YLim\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{capacitor_patch_500x400}.png}
\caption{Patch Plot with Mesh}\label{\detokenize{tutorial/matlabOctavePlot:figmatlabpatchplot}}\end{figure}
\begin{itemize}
\item {} 
3D surf plot:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VhSeq\PYGZsq{}}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XYData\PYGZsq{}}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ZStyle\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{continuous\PYGZsq{}}\PYG{p}{,} \PYG{c}{...}
          \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{lighting} \PYG{n}{gouraud}\PYG{p}{;}
\PYG{n}{view}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{47}\PYG{p}{,}\PYG{l+m+mi}{24}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{camlight}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{headlight\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{capacitor_surf_500x400}.png}
\caption{3D Surf Plot}\label{\detokenize{tutorial/matlabOctavePlot:figmatlabsurf}}\end{figure}
\begin{itemize}
\item {} 
Contour (isovalue) and quiver (vector field) plot:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VhSeq\PYGZsq{}}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XYData\PYGZsq{}}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Boundary\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,} \PYG{c}{...}
          \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XLim\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YLim\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Contour\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{CColor\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b\PYGZsq{}}\PYG{p}{,} \PYG{c}{...}
          \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XYStyle\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{CGridParam\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{150}\PYG{p}{,} \PYG{l+m+mi}{150}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ColorBar\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{,} \PYG{c}{...}
          \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FlowData\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{n}{Ex}\PYG{p}{,}\PYG{n}{Ey}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FGridParam\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{capacitor_contour_quiver_500x400}.png}
\caption{Contour and Quiver Plot}\label{\detokenize{tutorial/matlabOctavePlot:figmatlabcontour}}\end{figure}

\sphinxstylestrong{Download run through example:}

\sphinxcode{\sphinxupquote{Matlab / Octave file}}

\sphinxcode{\sphinxupquote{FreeFem++ script}}


\subsection{3D Plot Examples}
\label{\detokenize{tutorial/matlabOctavePlot:id1}}
3D problems are handled by the \sphinxcode{\sphinxupquote{ffpdeplot3D()}} command, which works similarly to the \sphinxcode{\sphinxupquote{ffpdeplot()}} command. In particular in three-dimensions cross sections of the solution can be created. The following example shows a cross-sectional problem of a three-dimensional parallel plate capacitor.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{capacitor3d_slice_500x400}.png}
\caption{Slice on a 3D Parallel Plate Capacitor}\label{\detokenize{tutorial/matlabOctavePlot:figmatlabslice}}\end{figure}

\sphinxstylestrong{Download run through example:}

\sphinxcode{\sphinxupquote{Matlab / Octave file}}

\sphinxcode{\sphinxupquote{FreeFem++ script}}


\subsection{References}
\label{\detokenize{tutorial/matlabOctavePlot:references}}\begin{itemize}
\item {} 
\sphinxhref{https://www.gnu.org/software/octave/}{Octave}

\item {} 
\sphinxhref{https://www.mathworks.com/}{Matlab}

\item {} 
\sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib}

\end{itemize}


\chapter{Documentation}
\label{\detokenize{documentation/index:documentation}}\label{\detokenize{documentation/index::doc}}
The fruit of a long maturing process, \sphinxstylestrong{freefem}, in its last avatar, \sphinxstylestrong{FreeFem++} , is a high level integrated development environment (IDE) for numerically solving partial differential equations (PDE) in dimension 2 and 3.
It is the ideal tool for teaching the finite element method but it is also perfect for research to quickly test new ideas or multi-physics and complex applications.

\sphinxstylestrong{FreeFem++} has an advanced automatic mesh generator, capable of a posteriori mesh adaptation; it has a general purpose elliptic solver interfaced with fast algorithms, such as the multi-frontal method UMFPACK, SuperLU, MUMPS.
Hyperbolic and parabolic problems are solved by iterative algorithms prescribed by the user with the high level language of \sphinxstylestrong{FreeFem++}.
It has several triangular finite elements, including discontinuous elements.
Everything is there in \sphinxstylestrong{FreeFem++} to prepare research quality reports with online color display, zooming and other features as well as postscript printouts.

This manual is meant for students at a Masters level, for researchers at any level, and for engineers (including financial engineering) with some understanding of variational methods for partial differential equations.

Introduction

A partial differential equation is a relation between a function of several variables and its (partial) derivatives.
Many problems in physics, engineering, mathematics and even banking are modeled by one or several partial differential equations.

\sphinxstylestrong{FreeFem++} is a software to solve these equations numerically.
As its name implies, it is a free software (see the copyrights for full detail) based on the Finite Element Method; it is not a package, it is an integrated product with its own high level programming language.
This software runs on all UNIX OS (with g++ 3.3 or later, and OpenGL), on Window XP, Vista and 7, 8, 10 and on MacOS 10 intel.

Moreover \sphinxstylestrong{FreeFem++} is highly adaptive.
Many phenomena involve several coupled systems.
Fluid-structure interactions, Lorentz forces for aluminum casting and ocean-atmosphere problems are three such systems.
These require different finite element approximations and polynomial degrees, possibly on different meshes.
Some algorithms like the Schwarz’ domain decomposition method also requires data interpolation on multiple meshes within one program.
\sphinxstylestrong{FreeFem++} can handle these difficulties, i.e. arbitrary finite element spaces on arbitrary unstructured and adapted bi-dimensional meshes.

The characteristics of \sphinxstylestrong{FreeFem++} are:
\begin{itemize}
\item {} 
Problem description (real or complex valued) by their variational formulations, with access to the internal vectors and matrices if needed.

\item {} 
Multi-variables, multi-equations, bi-dimensional and three-dimensional static or time dependent, linear or nonlinear coupled systems; however the user is required to describe the iterative procedures which reduce the problem to a set of linear problems.

\item {} 
Easy geometric input by analytic description of boundaries by pieces; however this part is not a CAD system; for instance when two boundaries intersect, the user must specify the intersection points.

\item {} 
Automatic mesh generator, based on the Delaunay-Voronoi algorithm; the inner point density is proportional to the density of points on the boundaries \sphinxcite{reference:george1996}.

\item {} 
Metric-based anisotropic mesh adaptation.
The metric can be computed automatically from the Hessian of any \sphinxstylestrong{FreeFem++} function \sphinxcite{reference:hecht1998}.

\item {} 
High level user friendly typed input language with an algebra of analytic and finite element functions.

\item {} 
Multiple finite element meshes within one application with automatic interpolation of data on different meshes and possible storage of the interpolation matrices.

\item {} 
A large variety of triangular finite elements: linear, quadratic Lagrangian elements and more, discontinuous P1 and Raviart-Thomas elements, elements of a non-scalar type, the mini-element,… (but no quadrangles).

\item {} 
Tools to define discontinuous Galerkin finite element formulations P0, P1dc, P2dc and keywords: jump, mean, intalledges.

\item {} 
A large variety of linear direct and iterative solvers (LU, Cholesky, Crout, CG, GMRES, UMFPACK, MUMPS, SuperLU, …) and eigenvalue and eigenvector solvers (ARPARK) .

\item {} 
Near optimal execution speed (compared with compiled \sphinxcode{\sphinxupquote{C++}} implementations programmed directly).

\item {} 
Online graphics, generation of ,.txt,.eps,.gnu, mesh files for further manipulations of input and output data.

\item {} 
Many examples and tutorials: elliptic, parabolic and hyperbolic problems, Navier-Stokes flows, elasticity, fluid structure interactions, Schwarz’s domain decomposition method, eigenvalue problem, residual error indicator, …

\item {} 
A parallel version using MPI

\end{itemize}

History

The project has evolved from MacFem, PCfem, written in Pascal.
The first C version lead to \sphinxcode{\sphinxupquote{freefem 3.4}}; it offered mesh adaptivity on a single mesh only.

A thorough rewriting in \sphinxcode{\sphinxupquote{C++}} led to \sphinxcode{\sphinxupquote{freefem+}} (\sphinxcode{\sphinxupquote{freefem+}} 1.2.10 was its last release), which included interpolation over multiple meshes (functions defined on one mesh can be used on any other mesh); this software is no longer maintained but is still in use because it handles a problem description using the strong form of the PDEs.
Implementing the interpolation from one unstructured mesh to another was not easy because it had to be fast and non-diffusive; for each point, one had to find the containing triangle.
This is one of the basic problems of computational geometry (see \sphinxcite{reference:preparata1985} for example).
Doing it in a minimum number of operations was the challenge.
Our implementation is \(\mathcal{O}(n log n)\) and based on a quadtree.
This version also grew out of hand because of the evolution of the template syntax in \sphinxcode{\sphinxupquote{C++}}.

We have been working for a few years now on \sphinxstylestrong{FreeFem++} , entirely re-written again in \sphinxcode{\sphinxupquote{C++}} with a thorough usage of template and generic programming for coupled systems of unknown size at compile time.
Like all versions of \sphinxcode{\sphinxupquote{freefem}}, it has a high level user friendly input language which is not too far from the mathematical writing of the problems.

The \sphinxcode{\sphinxupquote{freefem}} language allows for a quick specification of any partial differential system of equations.
The language syntax of \sphinxstylestrong{FreeFem++} is the result of a new design which makes use of the STL \sphinxcite{reference:stroustrup2000}, templates, and bison for its implementation; more details can be found in \sphinxcite{reference:hecht2002}.
The outcome is a versatile software in which any new finite elements can be included in a few hours; but a recompilation is then necessary.
Therefore the library of finite elements available in \sphinxstylestrong{FreeFem++} will grow with the version number and with the number of users who program more new elements.
So far we have discontinuous \(P_0\) elements,linear \(P_1\) and quadratic \(P_2\) Lagrangian elements, discontinuous \(P_1\) and Raviart-Thomas elements and a few others like bubble elements.


\section{Notations}
\label{\detokenize{documentation/notations:notations}}\label{\detokenize{documentation/notations::doc}}
Here mathematical expressions and corresponding \sphinxstylestrong{FreeFem++} commands are explained.


\subsection{Generalities}
\label{\detokenize{documentation/notations:generalities}}\begin{itemize}
\item {} 
{[}\(\delta_{ij}\){]} Kronecker delta (\(0\) if \(i\neq j\), 1 if \(i=j\) for integers \(i,j\))

\item {} 
{[}\(\forall\){]} for all

\item {} 
{[}\(\exists\){]} there exists

\item {} 
{[}i.e.{]} that is

\item {} 
{[}PDE{]} partial differential equation (with boundary conditions)

\item {} 
{[}\(\emptyset\){]} the empty set

\item {} 
{[}\(\mathbb{N}\){]} the set of integers (\(a\in \mathbb{N}\Leftrightarrow\) \sphinxcode{\sphinxupquote{int a}}), \sphinxcode{\sphinxupquote{int}} means \sphinxcode{\sphinxupquote{long int}} inside \sphinxstylestrong{FreeFem++}

\item {} 
{[}\(\mathbb{R}\){]} the set of real numbers (\(a\in \mathbb{R}\Leftrightarrow\) \sphinxcode{\sphinxupquote{real a}}), \sphinxcode{\sphinxupquote{double}} inside \sphinxstylestrong{FreeFem++}

\item {} 
{[}\(\mathbb{C}\){]} the set of complex numbers (\(a\in \mathbb{C}\Leftrightarrow\) \sphinxcode{\sphinxupquote{complex a}}), \sphinxcode{\sphinxupquote{complex\textless{}double\textgreater{}}}

\item {} 
{[}\(\mathbb{R}^d\){]} \(d\)-dimensional Euclidean space

\end{itemize}


\subsection{Sets, Mappings, Matrices, Vectors}
\label{\detokenize{documentation/notations:sets-mappings-matrices-vectors}}
Let \(E,\, F,\, G\) be three sets and \(A\) the subset of \(E\).
\begin{itemize}
\item {} 
{[}\(\{x\in E|\; P\}\){]} the subset of \(E\) consisting of the elements possessing the property \(P\)

\item {} 
{[}\(E\cup F\){]} the set of elements belonging to \(E\) or \(F\)

\item {} 
{[}\(E\cap F\){]} the set of elements belonging to \(E\) and \(F\)

\item {} 
{[}\(E\setminus A\){]} the set \(\{x\in E|\; x\not\in A\}\)

\item {} 
{[}\(E+F\){]} \(E\cup F\) with \(E\cap F=\emptyset\)

\item {} 
{[}\(E\times F\){]} the Cartesian product of \(E\) and \(F\)

\item {} 
{[}\(E^n\){]} the \(n\)-th power of \(E\) (\(E^2=E\times E\), \(E^n=E\times E^{n-1}\))

\item {} 
{[}\(f:\; E\to F\){]} the mapping form \(E\) into \(F\), i.e., \(E\ni x\mapsto f(x)\in F\)

\item {} 
{[}\(I_E\) or \(I\){]} the identity mapping in \(E\),i.e., \(I(x)=x\quad \forall x\in E\)

\item {} 
{[}\(f\circ g\){]} for \(f:\; F\to G\) and \(g:\; E\to F\), \(E\ni x\mapsto (f\circ g)(x)=f(g(x))\in G\) (see {\hyperref[\detokenize{reference/types:typeelementaryfunctions}]{\sphinxcrossref{\DUrole{std,std-ref}{Elementary function}}}})

\item {} 
{[}\(f|_A\){]} the restriction of \(f:\; E\to F\) to the subset \(A\) of \(E\)

\item {} 
{[}\(\{a_k\}\){]} column vector with components \(a_k\)

\item {} 
{[}\((a_k)\){]} row vector with components \(a_k\)

\item {} 
{[}\((a_{k})^T\){]} denotes the transpose of a matrix \((a_{k})\), and is \(\{a_{k}\}\)

\item {} 
{[}\(\{a_{ij}\}\){]} matrix with components \(a_{ij}\), and \((a_{ij})^T=(a_{ji})\)

\end{itemize}


\subsection{Numbers}
\label{\detokenize{documentation/notations:numbers}}
For two real numbers \(a,b\)
\begin{itemize}
\item {} 
\([a,b]\) is the interval \(\{x\in \mathbb{R}|\; a\le x\le b\}\)

\item {} 
\(]a,b]\) is the interval \(\{x\in \mathbb{R}|\; a< x\le b\}\)

\item {} 
\([a,b[\) is the interval \(\{x\in \mathbb{R}|\; a\le x< b\}\)

\item {} 
\(]a,b[\) is the interval \(\{x\in \mathbb{R}|\; a< x< b\}\)

\end{itemize}


\subsection{Differential Calculus}
\label{\detokenize{documentation/notations:differential-calculus}}\begin{itemize}
\item {} 
{[}\(\partial f/\partial x\){]} the partial derivative of \(f:\mathbb{R}^d\to \mathbb{R}\) with respect to \(x\) (\sphinxcode{\sphinxupquote{dx(f)}})

\item {} 
{[}\(\nabla f\){]} the gradient of \(f:\Omega\to \mathbb{R}\),i.e., \(\nabla f=(\partial f/\partial x,\, \partial f/\partial y)\)

\item {} 
{[}\(\text{div}(\mathbf{f})\) or \(\nabla.\mathbf{f}\){]} the divergence of \(\mathbf{f}:\Omega\to \mathbb{R}^d\), i.e., \(\text{div}(\mathbf{f})=\partial f_1/\partial x+\partial f_2/\partial y\)

\item {} 
{[}\(\Delta f\){]} the Laplacian of \(f:\; \Omega\to \mathbb{R}\), i.e., \(\Delta f=\partial^2f/\partial x^2+\partial^2 f/\partial y^2\)

\end{itemize}


\subsection{Meshes}
\label{\detokenize{documentation/notations:meshes}}\begin{itemize}
\item {} 
{[}\(\Omega\){]} usually denotes a domain on which PDE is defined

\item {} 
{[}\(\Gamma\){]} denotes the boundary of \(\Omega\),i.e., \(\Gamma=\partial\Omega\) (keyword \sphinxcode{\sphinxupquote{border}}, see {\hyperref[\detokenize{documentation/meshGeneration:meshborder}]{\sphinxcrossref{\DUrole{std,std-ref}{Border}}}})

\item {} 
{[}\(\mathcal{T}_h\){]} the triangulation of \(\Omega\), i.e., the set of triangles \(T_k\), where \(h\) stands for mesh size (keyword \sphinxcode{\sphinxupquote{mesh}}, \sphinxcode{\sphinxupquote{buildmesh}}, see {\hyperref[\detokenize{documentation/meshGeneration:meshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation}}}})

\item {} 
{[}\(n_t\){]} the number of triangles in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.nt}})

\item {} 
{[}\(\Omega_h\){]} denotes the approximated domain \(\Omega_h=\cup_{k=1}^{n_t}T_k\) of \(\Omega\).
If \(\Omega\) is polygonal domain, then it will be \(\Omega=\Omega_h\)

\item {} 
{[}\(\Gamma_h\){]} the boundary of \(\Omega_h\)

\item {} 
{[}\(n_v\){]} the number of vertices in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.nv}})

\item {} 
{[}\(n_{be}\){]} the number of boundary element in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.nbe}})

\item {} 
{[}\(|\Omega_h|\){]} the measure (area or volume) in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.measure}})

\item {} 
{[}\(|\partial \Omega_h|\){]} the measure of the border (length or area) in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.bordermeasure}})

\item {} 
{[}\(h_{min}\){]} the minimum edge size of \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.hmin}})

\item {} 
{[}\(h_{max}\){]} the maximum edge size of \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.hmax}})

\item {} 
{[}{[}\(q^iq^j\){]}{]} the segment connecting \(q^i\) and \(q^j\)

\item {} 
{[}\(q^{k_1},q^{k_2},q^{k_3}\){]} the vertices of a triangle \(T_k\) with anti-clock direction (get the coordinate of \(q^{k_j}\) by \sphinxcode{\sphinxupquote{(Th{[}k-1{]}{[}j-1{]}.x, Th{[}k-1{]}{[}j-1{]}.y)}})

\item {} 
{[}\(I_{\Omega}\){]} the set \(\{i\in \mathbb{N}|\; q^i\not\in \Gamma_h\}\)

\end{itemize}


\subsection{Finite Element Spaces}
\label{\detokenize{documentation/notations:finite-element-spaces}}\begin{itemize}
\item {} 
{[}\(L^2(\Omega)\){]} the set \(\displaystyle{\left\{w(x,y)\left|\; \int_{\Omega}|w(x,y)|^2\text{d} x\text{d} y<\infty\right.\right\}}\)

\end{itemize}
\begin{quote}
\begin{equation*}
\begin{split}\textrm{norm:}\; \| w\|_{0,\Omega}&=\left(\int_{\Omega}|w(x,y)|^2\text{d} x\text{d} y\right)^{1/2}\\
\textrm{scalar product:}\; (v,w)&=\int_{\Omega}vw\end{split}
\end{equation*}\end{quote}
\begin{itemize}
\item {} 
{[}\(H^1(\Omega)\){]} the set \(\displaystyle{\left\{w\in L^2(\Omega)\left|\; \int_{\Omega}\left(|\partial w/\partial x|^2+|\partial w/\partial y|^2\right)\text{d} x\text{d} y <\infty\right.\right\}}\)

\end{itemize}
\begin{quote}
\begin{equation*}
\begin{split}\textrm{norm:}\; \| w\|_{1,\Omega}=\left(\| w\|_{0,\Omega}^2+\|\nabla u\|_{0.\Omega}^2\right)^{1/2}\end{split}
\end{equation*}\end{quote}
\begin{itemize}
\item {} 
{[}\(H^m(\Omega)\){]} the set \(\displaystyle{\left\{w\in L^2(\Omega)\left|\; \int_{\Omega}\frac{\partial^{|\alpha|} w}{\partial x^{\alpha_1}\partial y^{\alpha_2}}\in L^2(\Omega)\quad\forall \alpha=(\alpha_1,\alpha_2)\in \mathbb{N}^2,\, |\alpha|=\alpha_1+\alpha_2\right.\right\}}\)

\end{itemize}
\begin{quote}
\begin{equation*}
\begin{split}\textrm{scalar product:}\; (v,w)_{1,\Omega}=
\sum_{|\alpha|\le m}\int_{\Omega} D^{\alpha}v D^{\alpha}w\end{split}
\end{equation*}\end{quote}
\begin{itemize}
\item {} 
{[}\(H^1_0(\Omega)\){]} the set \(\left\{w\in H^1(\Omega)\left|\; u=0\quad \textrm{on }\Gamma\right.\right\}\)

{[}\(L^2(\Omega)^2\){]} denotes \(L^2(\Omega)\times L^2(\Omega)\), and also \(H^1(\Omega)^2=H^1(\Omega)\times H^1(\Omega)\)

\item {} 
{[}\(V_h\){]} denotes the finite element space created by \sphinxcode{\sphinxupquote{fespace Vh(Th, *)}} in \sphinxstylestrong{FreeFem++} (see {\hyperref[\detokenize{documentation/finiteElement:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Elements}}}} for \sphinxcode{\sphinxupquote{*}})

\item {} 
{[}\(\Pi_h f\){]} the projection of the function \(f\) into \(V_h\) (\sphinxcode{\sphinxupquote{func f=x\textasciicircum{}2*y\textasciicircum{}3; Vh v = f;}}) means \(v = Pi_h (f) * [\{v\}]\) for FE-function \(v\) in \(V_h\) means the column vector \((v_1,\cdots,v_M)^T\) if \(v=v_1\phi_1+\cdots+v_M\phi_M\), which is shown by \sphinxcode{\sphinxupquote{fespace Vh(Th, P2); Vh v; cout \textless{}\textless{} v{[}{]} \textless{}\textless{} endl;}}

\end{itemize}


\section{Mesh Generation}
\label{\detokenize{documentation/meshGeneration:mesh-generation}}\label{\detokenize{documentation/meshGeneration:meshgeneration}}\label{\detokenize{documentation/meshGeneration::doc}}
Let us begin with the two important keywords: \sphinxcode{\sphinxupquote{border}} and \sphinxcode{\sphinxupquote{buildmesh}}.


\subsection{Square}
\label{\detokenize{documentation/meshGeneration:square}}\label{\detokenize{documentation/meshGeneration:meshsquare}}
The command \sphinxcode{\sphinxupquote{square}} triangulates the unit square.

The following generates a \(4 \times 5\) grid in the unit square \([0,1]^2\). The labels of the boundaries are shown in \hyperref[\detokenize{documentation/meshGeneration:figboundarylabels}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figboundarylabels}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Square}.png}
\caption{Boundary labels of the mesh by \sphinxcode{\sphinxupquote{square(10,10)}}}\label{\detokenize{documentation/meshGeneration:figboundarylabels}}\end{figure}

To construct a \(n\times m\) grid in the rectangle \([x_0,x_1]\times [y_0,y_1]\), proceed as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mf}{1.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x1} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Adding the named parameter \sphinxcode{\sphinxupquote{flags=icase}} with icase:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{-1}
\item {} 
will produce a mesh where all quads are split with diagonal \(x-y=constant\)

\item {} 
will produce \sphinxstyleemphasis{Union Jack flag} type of mesh

\item {} 
will produce a mesh where all quads are split with diagonal \(x+y=constant\)

\item {} 
same as in case 0, except two corners where the triangles are the same as case 2 to avoid having 3 vertices on the boundary

\item {} 
same as in case 2, except two corners where the triangles are the same as case 0 to avoid having 3 vertices on the boundary

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{icase}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Adding the named parameter \sphinxcode{\sphinxupquote{label=labs}} will
change the 4 default label numbers to \sphinxcode{\sphinxupquote{labs{[}i-1{]}}}, for
example \sphinxcode{\sphinxupquote{int{[}int{]} labs={[}11, 12, 13, 14{]}}}, and adding the
named parameter \sphinxcode{\sphinxupquote{region=10}} will change the region number
to \(10\), for instance (v 3.8).

To see all of these flags at work, check {\hyperref[\detokenize{example/meshGeneration:examplemeshsquare}]{\sphinxcrossref{\DUrole{std,std-ref}{Square mesh example}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{labs} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{labs}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square flags = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Border}
\label{\detokenize{documentation/meshGeneration:border}}\label{\detokenize{documentation/meshGeneration:meshborder}}
Boundaries are defined piecewise by parametrized curves. The pieces can only intersect at their endpoints, but it is possible to join more than two endpoints. This can be used to structure the mesh if an area touches a border and create new regions by dividing larger ones:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{upper} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{others} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{inner} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C05}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C06}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
  \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
  \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 1 has region number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 2 has redion number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

Borders and mesh are respectively shown in \hyperref[\detokenize{documentation/meshGeneration:figmultipleborder}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figmultipleborder}}} and \hyperref[\detokenize{documentation/meshGeneration:figgeneratedmesh}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figgeneratedmesh}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border1}.png}
\caption{Multiple border ends intersect}\label{\detokenize{documentation/meshGeneration:id14}}\label{\detokenize{documentation/meshGeneration:figmultipleborder}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border2}.png}
\caption{Generated mesh}\label{\detokenize{documentation/meshGeneration:id15}}\label{\detokenize{documentation/meshGeneration:figgeneratedmesh}}\end{subfigure}
\caption{Border}\phantomsection\label{\detokenize{documentation/meshGeneration:MeshGeneration_Border}}

\end{figure}


Triangulation keywords assume that the domain is defined as being on the \sphinxstyleemphasis{left} (resp \sphinxstyleemphasis{right}) of its oriented parameterized boundary
\begin{equation*}
\begin{split}\Gamma_j = \{(x,y)\left|\; x=\varphi_x(t),\, y=\varphi_y(t),\, a_j\le t\le b_j\right.\}\end{split}
\end{equation*}
To check the orientation plot \(t\mapsto (\varphi_x(t),\varphi_y(t)),\, t_0\le t\le t_1\). If it is as in \hyperref[\detokenize{documentation/meshGeneration:figborder}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figborder}}}, then the domain lies on the shaded area, otherwise it lies on the opposite side.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{MeshGeneration_Border3}.png}
\caption{Orientation of the boundary defined by \((\phi_x(t),\phi_y(t))\)}\label{\detokenize{documentation/meshGeneration:figborder}}\end{figure}

The general expression to define a triangulation with \sphinxcode{\sphinxupquote{buildmesh}} is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Mesh\PYGZus{}Name} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{n}{m1}\PYG{p}{)}\PYG{o}{+}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{o}{+}\PYG{n}{GammaJ}\PYG{p}{(}\PYG{n}{mj}\PYG{p}{)}\PYG{p}{,} \PYG{n}{OptionalParameter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \(m_j\) are positive or negative numbers to indicate how many vertices should be on \(\Gamma_j,\, \Gamma=\cup_{j=1}^J \Gamma_J\), and the optional parameter (see also {\hyperref[\detokenize{reference/functions:referencebuildmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{References}}}}), separated with a comma, can be:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nbvx= int}}, to set the maximum number of vertices in the mesh.

\item {} 
\sphinxcode{\sphinxupquote{fixedborder= bool}}, to say if the mesh generator can change the boundary mesh or not (by default the boundary mesh can change; beware that with periodic boundary conditions (see. {\hyperref[\detokenize{documentation/finiteElement:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Element}}}}), it can be dangerous.

\end{itemize}

The orientation of boundaries can be changed by changing the sign of \(m_j\).

The following example shows how to change the orientation. The example generates the unit disk with a small circular hole, and assigns “1” to the unit disk (“2” to the circle inside). The boundary label \sphinxstylestrong{must be non-zero}, but it can also be omitted.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to see a plot of the border mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thwithouthole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thwithhole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithouthole}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thwithouthole.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithhole}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thwithhole.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Notice that the orientation is changed by \sphinxcode{\sphinxupquote{b(-30)}} in the 5th line. In the 7th line, \sphinxcode{\sphinxupquote{ps="fileName"}} is used to generate a postscript file with identification shown on the figure.
\end{sphinxadmonition}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border4}.png}
\caption{Mesh without hole}\label{\detokenize{documentation/meshGeneration:id16}}\label{\detokenize{documentation/meshGeneration:figmeswithouthhole}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border5}.png}
\caption{Mesh with hole}\label{\detokenize{documentation/meshGeneration:id17}}\label{\detokenize{documentation/meshGeneration:figmeshwithhole}}\end{subfigure}
\caption{Mesh with a hole}\phantomsection\label{\detokenize{documentation/meshGeneration:MeshWithHole}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
Borders are evaluated only at the time \sphinxcode{\sphinxupquote{plot}} or \sphinxcode{\sphinxupquote{buildmesh}} is called so the global variables are defined at this time. In this case, since \(r\) is changed between the two border calls, the following code will not work because the first border will be computed with r=0.3:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n}{r}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Thwithhole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// bug (a trap) because}
    \PYG{c+c1}{// the two circles have the same radius = :math:{}`0.3{}`}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Multi-Border}
\label{\detokenize{documentation/meshGeneration:multi-border}}
Sometimes it can be useful to make an array of the border, but unfortunately it is incompatible with the \sphinxstylestrong{FreeFem++} syntax. To bypass this problem, if the number of segments of the discretization \(n\) is an array, we make an implicit loop on all of the values of the array, and the index variable \(i\) of the loop is defined after the parameter definition, like in \sphinxcode{\sphinxupquote{border a(t=0, 2*pi; i)}} …

A first very small example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{nn} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//plot 3 circles with 10, 20, 30 points}
\end{sphinxVerbatim}

And a more complex example to define a square with small circles:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
          \PYG{n}{yy} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{c+c1}{//radius, center of the 4 circles}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{RC} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,}
          \PYG{n}{XC} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,}
          \PYG{n}{YC} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{NC} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//list number of :math:{}`\PYGZbs{}pm{}` segments of the 4 circles borders}

\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// i is the index variable of the multi border loop}
    \PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{4}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{t1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{t1} \PYG{o}{+} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{t1} \PYG{o}{+} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{RC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{+} \PYG{n}{XC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{RC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{+} \PYG{n}{YC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{label} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{nn} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//4 border, with 4, 4, 5, 7 segment respectively}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kp}{bb}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cc}\PYG{p}{(}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{k+kp}{bb}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{cc}\PYG{p}{(}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Data Structures and Read/Write Statements for a Mesh}
\label{\detokenize{documentation/meshGeneration:data-structures-and-read-write-statements-for-a-mesh}}\label{\detokenize{documentation/meshGeneration:meshdatastructurereadwrite}}
Users who want to read a triangulation made elsewhere should see the structure of the file generated below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The mesh is shown on \hyperref[\detokenize{documentation/meshGeneration:figbuildmesh}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figbuildmesh}}}.

The information about \sphinxcode{\sphinxupquote{Th}} are saved in the file \sphinxcode{\sphinxupquote{mesh.msh}} whose structure is shown on \hyperref[\detokenize{documentation/meshGeneration:tabmeshstructure}]{Table \ref{\detokenize{documentation/meshGeneration:tabmeshstructure}}}.

There, \(n_v\) denotes the number of vertices, \(n_t\) the number of triangles and \(n_s\) the number of edges on boundary.

For each vertex \(q^i,\, i=1,\cdots,n_v\), denoted by \((q^i_x,q^i_y)\) the \(x\)-coordinate and \(y\)-coordinate.

Each triangle \(T_k, k=1,\cdots,n_t\) has three vertices \(q^{k_1},\, q^{k_2},\,q^{k_3}\) that are oriented counter-clockwise.

The boundary consists of 10 lines \(L_i,\, i=1,\cdots,10\) whose end points are \(q^{i_1},\, q^{i_2}\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Data}.png}
\caption{Mesh by \sphinxcode{\sphinxupquote{buildmesh(C(10))}}}\label{\detokenize{documentation/meshGeneration:figbuildmesh}}\end{figure}

In the \hyperref[\detokenize{documentation/meshGeneration:figbuildmesh}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figbuildmesh}}}, we have the following.

\(n_v=14, n_t=16, n_s=10\)

\(q^1=(-0.309016994375, 0.951056516295)\)

\(\dots\)

\(q^{14}=(-0.309016994375, -0.951056516295)\)

The vertices of \(T_1\) are \(q^9, q^{12},\, q^{10}\).

\(\dots\)

The vertices of \(T_{16}\) are \(q^9, q^{10}, q^{6}\).

The edge of the 1st side \(L_1\) are \(q^6, q^5\).

\(\dots\)

The edge of the 10th side \(L_{10}\) are \(q^{10}, q^6\).


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{The structure of \sphinxstyleliteralintitle{\sphinxupquote{mesh\_sample.msh}}}\label{\detokenize{documentation/meshGeneration:tabmeshstructure}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Content of the file
&\sphinxstyletheadfamily 
Explanation
\\
\hline
14 16 10
&
\(n_v\quad n_t\quad n_e\)
\\
\hline
-0.309016994375 0.951056516295 1

0.309016994375 0.951056516295 1

…

-0.309016994375 -0.951056516295 1
&
\(q^1_x\quad q^1_y\quad\) boundary label \(=1\)

\(q^2_x\quad q^2_y\quad\) boundary label \(=1\)

…

\(q^{14}_x\quad q^{14}_y\quad\) boundary label \(=1\)
\\
\hline
9 12 10 0

5 9 6 0

…

9 10 6 0
&
\(1_1\quad 1_2\quad 1_3\quad\) region label \(=0\)

\(2_1\quad 2_2\quad 2_3\quad\) region label \(=0\)

…

\(16_1\quad 16_2\quad 16_3\quad\) region label \(=0\)
\\
\hline
6 5 1

5 2 1

…

10 6 1
&
\(1_1\quad 1_2\quad\) boundary label \(=1\)

\(2_1\quad 2_2\quad\) boundary label \(=1\)

…

\(10_1\quad 10_2\quad\) boundary label \(=1\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

In \sphinxstylestrong{FreeFem++} there are many mesh file formats available for communication with other tools such as \sphinxcode{\sphinxupquote{emc2}}, \sphinxcode{\sphinxupquote{modulef}}, … (see {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh format chapter}}}} ).

The extension of a file implies its format.
More details can be found on the file format .msh in the article by F. Hecht “bamg : a bidimensional anisotropic mesh generator” \sphinxcite{reference:hecht1998-2}.

A mesh file can be read into \sphinxstylestrong{FreeFem++} except that the names of the borders are lost and only their reference numbers are kept.
So these borders have to be referenced by the number which corresponds to their order of appearance in the program, unless this number is overwritten by the keyword \sphinxcode{\sphinxupquote{label}}. Here are some examples:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{floor}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{right}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{ceiling}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{left}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n+nf}{floor}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{right}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ceiling}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{left}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.am\PYGZus{}fmt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//\PYGZdq{}formatted Marrocco\PYGZdq{} format}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//\PYGZdq{}bamg\PYGZdq{}\PYGZhy{}type mesh}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//freefem format}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.nopo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//modulef format}
\PYG{k+kt}{mesh} \PYG{n}{th2} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//read the mesh}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{floor}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{right}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{ceiling}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{left}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n+nf}{floor}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{right}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ceiling}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{left}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//save mesh in different formats}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.am\PYGZus{}fmt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// format \PYGZdq{}formated Marrocco\PYGZdq{}}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// format database db mesh \PYGZdq{}bamg\PYGZdq{}}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// format freefem}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.nopo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// modulef format}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{femp1}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{femp1} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{femp1} \PYG{n}{g}\PYG{p}{;}

\PYG{c+c1}{//save the fespace function in a file}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//the file is automatically closed at the end of the block}
\PYG{c+c1}{//read a file and put it in a fespace function}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{ifstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{g}\PYG{p}{[}\PYG{p}{]} \PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{c+c1}{//the file is equally automatically closed}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2}
\PYG{c+c1}{//read the mesh for freefem format saved mesh}
\PYG{k+kt}{mesh} \PYG{n}{th2} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace 2}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{c+c1}{//solve:}
\PYG{c+c1}{//  \PYGZdl{}u + \PYGZbs{}Delta u = g\PYGZdl{} in \PYGZdl{}\PYGZbs{}Omega \PYGZdl{}}
\PYG{c+c1}{//  \PYGZdl{}u=0\PYGZdl{} on \PYGZdl{}\PYGZbs{}Gamma\PYGZus{}1\PYGZdl{}}
\PYG{c+c1}{//  \PYGZdl{}\PYGZbs{}frac\PYGZob{}\PYGZbs{}partial u \PYGZcb{}\PYGZob{}\PYGZbs{}partial n\PYGZcb{} = g\PYGZdl{} on \PYGZdl{}\PYGZbs{}Gamma\PYGZus{}2\PYGZdl{}}
\PYG{k+kt}{solve} \PYG{n+nf}{Problem}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
  \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
  \PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{)}\PYG{p}{(}
    \PYG{o}{\PYGZhy{}} \PYG{n}{g}\PYG{o}{*}\PYG{n}{v}
  \PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{g}\PYG{o}{*}\PYG{n}{v}
  \PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Mesh Connectivity and data}
\label{\detokenize{documentation/meshGeneration:mesh-connectivity-and-data}}
The following example explains methods to obtain mesh information.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Get data of the mesh}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{NbTriangles} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{MeshArea} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{BorderLenght} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{bordermeasure}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of triangle(s) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mesh area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{MeshArea} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Border length = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{BorderLenght} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Th(i) return the vextex i of Th}
    \PYG{c+c1}{// Th[k] return the triangle k of Th}
    \PYG{c+c1}{// Th[k][i] return the vertex i of the triangle k of Th}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} Th[i][j] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{x}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, y= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{y}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, label=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{label} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Hack to get vertex coordinates}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{fespace} \PYG{n}{femp1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{femp1} \PYG{n}{Thx}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{Thy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{NbVertices} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of vertices = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{NbVertices} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{NbVertices}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{label}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{old method: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Thx}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Thy}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Method to find information of point (0.55,0.6)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{TNumber} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{nuTriangle}\PYG{p}{;} \PYG{c+c1}{//the triangle number}
    \PYG{k+kt}{int} \PYG{n}{RLabel} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;} \PYG{c+c1}{//the region label}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Triangle number in point (0.55, 0.6): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Region label in point (0.55, 0.6): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{RLabel} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Information of triangle}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{TNumber} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{nuTriangle}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{TArea} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{TNumber}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{;} \PYG{c+c1}{//triangle area}
    \PYG{k+kt}{real} \PYG{n}{TRegion} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{TNumber}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;} \PYG{c+c1}{//triangle region}
    \PYG{k+kt}{real} \PYG{n}{TLabel} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{TNumber}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{label}\PYG{p}{;} \PYG{c+c1}{//triangle label, same as region for triangles}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Area of triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TArea} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Region of triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TRegion} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Label of triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TLabel} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Hack to get a triangle containing point x, y or region number (old method)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{fespace} \PYG{n}{femp0}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{femp0} \PYG{n}{TNumbers}\PYG{p}{;} \PYG{c+c1}{//a P0 function to get triangle numbering}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{TNumbers}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
    \PYG{n}{femp0} \PYG{n}{RNumbers} \PYG{o}{=} \PYG{k+kr}{region}\PYG{p}{;} \PYG{c+c1}{//a P0 function to get the region number}

    \PYG{k+kt}{int} \PYG{n}{TNumber} \PYG{o}{=} \PYG{n}{TNumbers}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Number of the triangle containing (0.55, 0,6)}
    \PYG{k+kt}{int} \PYG{n}{RNumber} \PYG{o}{=} \PYG{n}{RNumbers}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Number of the region containing (0.55, 0,6)}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Point (0.55,0,6) :}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Triangle number = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Region number = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{RNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// New method to get boundary information and mesh adjacent}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{e}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}

    \PYG{c+c1}{// Number of boundary elements}
    \PYG{k+kt}{int} \PYG{n}{NbBoundaryElements} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of boundary element = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{NbBoundaryElements} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Boundary element k in \PYGZob{}0, ..., Th.nbe\PYGZcb{}}
    \PYG{k+kt}{int} \PYG{n}{BoundaryElement} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{BoundaryElement} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Vertice l in \PYGZob{}0, 1\PYGZcb{} of boundary element k}
    \PYG{k+kt}{int} \PYG{n}{Vertex} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Vertex }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{l} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ of boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Vertex} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Triangle containg the boundary element k}
    \PYG{k+kt}{int} \PYG{n}{Triangle} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Element}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Triangle containing the boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Triangle} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Triangle egde nubmer containing the boundary element k}
    \PYG{k+kt}{int} \PYG{n}{Edge} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{whoinElement}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Triangle edge number containing the boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Edge} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Adjacent triangle of the triangle k by edge e}
    \PYG{k+kt}{int} \PYG{n}{Adjacent} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{adj}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//The value of e is changed to the corresponding edge in the adjacent triangle}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Adjacent triangle of the triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ by edge }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Adjacent} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Corresponding edge = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// If there is no adjacent triangle by edge e, the same triangle is returned}
    \PYG{c+c1}{//Th[k] == Th[k].adj(e)}
    \PYG{c+c1}{// Else a different triangle is returned}
    \PYG{c+c1}{//Th[k] != Th[k].adj(e)}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Print mesh connectivity }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{NbTriangles} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, label }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{label} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ee}\PYG{p}{;} \PYG{n}{e} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{e}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{c+c1}{//set ee to e, and ee is change by method adj,}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZlt{}=\PYGZgt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{adj}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ee}\PYG{o}{=}\PYG{n}{e}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ee}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, adj: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{adj}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ee}\PYG{o}{=}\PYG{n}{e}\PYG{p}{)}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{NbBoundaryElements} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{NbBoundaryElements}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , label }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{label}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Element}\PYG{p}{)}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{whoinElement} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{boundingbox}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{boundingbox:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xmin = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, xmax = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, ymin = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, ymax = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The output is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
// Get data of the mesh
Number of \PYG{n+nv}{triangle} \PYG{o}{=} \PYG{l+m}{8}
Mesh \PYG{n+nv}{area} \PYG{o}{=} \PYG{l+m}{1}
Border \PYG{n+nv}{length} \PYG{o}{=} \PYG{l+m}{4}
\PYG{l+m}{0} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{0} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{1}
\PYG{l+m}{0} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{1} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{3}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{2} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{2}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{2} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{5}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{3} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{1}
\PYG{l+m}{3} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{5}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{3} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{4} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{3}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{4} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{4} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{7}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{5} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{3}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{5} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{7}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{5} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{6}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{6} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{6} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{5}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{6} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{8}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{7} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{7} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{8}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{7} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{7}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
// Hack to get vertex coordinates
Number of \PYG{n+nv}{vertices} \PYG{o}{=} \PYG{l+m}{9}
Th\PYG{o}{(}\PYG{l+m}{0}\PYG{o}{)} : \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{4}
   old method: \PYG{l+m}{0} \PYG{l+m}{0}
Th\PYG{o}{(}\PYG{l+m}{1}\PYG{o}{)} : \PYG{l+m}{0}.5 \PYG{l+m}{0} \PYG{l+m}{1}
   old method: \PYG{l+m}{0}.5 \PYG{l+m}{0}
Th\PYG{o}{(}\PYG{l+m}{2}\PYG{o}{)} : \PYG{l+m}{1} \PYG{l+m}{0} \PYG{l+m}{2}
   old method: \PYG{l+m}{1} \PYG{l+m}{0}
Th\PYG{o}{(}\PYG{l+m}{3}\PYG{o}{)} : \PYG{l+m}{0} \PYG{l+m}{0}.5 \PYG{l+m}{4}
   old method: \PYG{l+m}{0} \PYG{l+m}{0}.5
Th\PYG{o}{(}\PYG{l+m}{4}\PYG{o}{)} : \PYG{l+m}{0}.5 \PYG{l+m}{0}.5 \PYG{l+m}{0}
   old method: \PYG{l+m}{0}.5 \PYG{l+m}{0}.5
Th\PYG{o}{(}\PYG{l+m}{5}\PYG{o}{)} : \PYG{l+m}{1} \PYG{l+m}{0}.5 \PYG{l+m}{2}
   old method: \PYG{l+m}{1} \PYG{l+m}{0}.5
Th\PYG{o}{(}\PYG{l+m}{6}\PYG{o}{)} : \PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{4}
   old method: \PYG{l+m}{0} \PYG{l+m}{1}
Th\PYG{o}{(}\PYG{l+m}{7}\PYG{o}{)} : \PYG{l+m}{0}.5 \PYG{l+m}{1} \PYG{l+m}{3}
   old method: \PYG{l+m}{0}.5 \PYG{l+m}{1}
Th\PYG{o}{(}\PYG{l+m}{8}\PYG{o}{)} : \PYG{l+m}{1} \PYG{l+m}{1} \PYG{l+m}{3}
   old method: \PYG{l+m}{1} \PYG{l+m}{1}
// Method to find the information of point \PYG{o}{(}\PYG{l+m}{0}.55,0.6\PYG{o}{)}
Triangle number in point \PYG{o}{(}\PYG{l+m}{0}.55, \PYG{l+m}{0}.6\PYG{o}{)}: \PYG{l+m}{7}
Region label in point \PYG{o}{(}\PYG{l+m}{0}.55, \PYG{l+m}{0}.6\PYG{o}{)}: \PYG{l+m}{0}
// Information of a triangle
Area of triangle \PYG{l+m}{7}: \PYG{l+m}{0}.125
Region of triangle \PYG{l+m}{7}: \PYG{l+m}{0}
Label of triangle \PYG{l+m}{7}: \PYG{l+m}{0}
// Hack to get a triangle containing point x, y or region number \PYG{o}{(}old method\PYG{o}{)}
Point \PYG{o}{(}\PYG{l+m}{0}.55,0,6\PYG{o}{)} :
   Triangle \PYG{n+nv}{number} \PYG{o}{=} \PYG{l+m}{7}
   Region \PYG{n+nv}{number} \PYG{o}{=} \PYG{l+m}{0}
// New method to get boundary information and mesh adjacent
Number of boundary \PYG{n+nv}{element} \PYG{o}{=} \PYG{l+m}{8}
Boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{0}
Vertex \PYG{l+m}{1} of boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{1}
Triangle containing the boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{0}
Triangle edge number containing the boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{2}
Adjacent triangle of the triangle \PYG{l+m}{0} by edge \PYG{n+nv}{1} \PYG{o}{=} \PYG{l+m}{1}
   Corresponding \PYG{n+nv}{edge} \PYG{o}{=} \PYG{l+m}{2}
// Print mesh connectivity
\PYG{l+m}{0} : \PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{4}, label \PYG{l+m}{0}
\PYG{l+m}{1} : \PYG{l+m}{0} \PYG{l+m}{4} \PYG{l+m}{3}, label \PYG{l+m}{0}
\PYG{l+m}{2} : \PYG{l+m}{1} \PYG{l+m}{2} \PYG{l+m}{5}, label \PYG{l+m}{0}
\PYG{l+m}{3} : \PYG{l+m}{1} \PYG{l+m}{5} \PYG{l+m}{4}, label \PYG{l+m}{0}
\PYG{l+m}{4} : \PYG{l+m}{3} \PYG{l+m}{4} \PYG{l+m}{7}, label \PYG{l+m}{0}
\PYG{l+m}{5} : \PYG{l+m}{3} \PYG{l+m}{7} \PYG{l+m}{6}, label \PYG{l+m}{0}
\PYG{l+m}{6} : \PYG{l+m}{4} \PYG{l+m}{5} \PYG{l+m}{8}, label \PYG{l+m}{0}
\PYG{l+m}{7} : \PYG{l+m}{4} \PYG{l+m}{8} \PYG{l+m}{7}, label \PYG{l+m}{0}
\PYG{l+m}{0} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{3} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{0} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{1} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{0} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{0} \PYG{l+m}{2}, adj: \PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{4} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{1} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{1} \PYG{l+m}{1}, adj: \PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{0} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{2} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{2} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{3} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{2} \PYG{l+m}{2}, adj: \PYG{l+m}{0}
\PYG{l+m}{3} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{6} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{3} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{0} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{3} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{2} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{4} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{7} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{4} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{5} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{4} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{1} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{5} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{5} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{5} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{5} \PYG{l+m}{1}, adj: \PYG{l+m}{0}
\PYG{l+m}{5} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{4} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{6} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{6} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{6} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{7} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{6} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{3} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{7} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{7} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{7} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{4} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{7} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{6} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{0} : \PYG{l+m}{0} \PYG{l+m}{1} , label \PYG{l+m}{1}, triangle \PYG{l+m}{0} \PYG{l+m}{2}
\PYG{l+m}{1} : \PYG{l+m}{1} \PYG{l+m}{2} , label \PYG{l+m}{1}, triangle \PYG{l+m}{2} \PYG{l+m}{2}
\PYG{l+m}{2} : \PYG{l+m}{2} \PYG{l+m}{5} , label \PYG{l+m}{2}, triangle \PYG{l+m}{2} \PYG{l+m}{0}
\PYG{l+m}{3} : \PYG{l+m}{5} \PYG{l+m}{8} , label \PYG{l+m}{2}, triangle \PYG{l+m}{6} \PYG{l+m}{0}
\PYG{l+m}{4} : \PYG{l+m}{6} \PYG{l+m}{7} , label \PYG{l+m}{3}, triangle \PYG{l+m}{5} \PYG{l+m}{0}
\PYG{l+m}{5} : \PYG{l+m}{7} \PYG{l+m}{8} , label \PYG{l+m}{3}, triangle \PYG{l+m}{7} \PYG{l+m}{0}
\PYG{l+m}{6} : \PYG{l+m}{0} \PYG{l+m}{3} , label \PYG{l+m}{4}, triangle \PYG{l+m}{1} \PYG{l+m}{1}
\PYG{l+m}{7} : \PYG{l+m}{3} \PYG{l+m}{6} , label \PYG{l+m}{4}, triangle \PYG{l+m}{5} \PYG{l+m}{1}
boundingbox:
\PYG{n+nv}{xmin} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{xmax} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{ymin} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{ymax} \PYG{o}{=} \PYG{l+m}{1}
\end{sphinxVerbatim}

The real characteristic function of a mesh \sphinxcode{\sphinxupquote{Th}} is \sphinxcode{\sphinxupquote{chi(Th)}} in 2D and 3D where:

\sphinxcode{\sphinxupquote{chi(Th)(P)=1}} if \(P\in Th\)

\sphinxcode{\sphinxupquote{chi(Th)(P)=0}} if \(P\not\in Th\)


\subsection{The keyword “triangulate”}
\label{\detokenize{documentation/meshGeneration:the-keyword-triangulate}}
\sphinxstylestrong{FreeFem++} is able to build a triangulation from a set of points.
This triangulation is a Delaunay mesh of the convex hull of the set of points.
It can be useful to build a mesh from a table function.

The coordinates of the points and the value of the table function are defined separately with rows of the form: \sphinxcode{\sphinxupquote{x y f(x,y)}} in a file such as:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mf}{0.51387} \PYG{l+m+mf}{0.175741} \PYG{l+m+mf}{0.636237}
\PYG{l+m+mf}{0.308652} \PYG{l+m+mf}{0.534534} \PYG{l+m+mf}{0.746765}
\PYG{l+m+mf}{0.947628} \PYG{l+m+mf}{0.171736} \PYG{l+m+mf}{0.899823}
\PYG{l+m+mf}{0.702231} \PYG{l+m+mf}{0.226431} \PYG{l+m+mf}{0.800819}
\PYG{l+m+mf}{0.494773} \PYG{l+m+mf}{0.12472} \PYG{l+m+mf}{0.580623}
\PYG{l+m+mf}{0.0838988} \PYG{l+m+mf}{0.389647} \PYG{l+m+mf}{0.456045}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Triangulate1}.png}
\caption{Delaunay mesh of the convex hull of point set in file xy}\label{\detokenize{documentation/meshGeneration:id18}}\label{\detokenize{documentation/meshGeneration:figdelaunaymesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Triangulate2}.png}
\caption{Isolvalue of table function}\label{\detokenize{documentation/meshGeneration:id19}}\label{\detokenize{documentation/meshGeneration:figisovalue}}\end{subfigure}
\caption{Triangulate}\phantomsection\label{\detokenize{documentation/meshGeneration:Triangulate}}

\end{figure}


The third column of each line is left untouched by the \sphinxcode{\sphinxupquote{triangulate}} command.
But you can use this third value to define a table function with rows of the form: \sphinxcode{\sphinxupquote{x y f(x,y)}}.

The following example shows how to make a mesh from the file \sphinxcode{\sphinxupquote{xyf}} with the format stated just above.
The command \sphinxcode{\sphinxupquote{triangulate}} only uses the 1st and 2nd columns.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Build the Delaunay mesh of the convex hull}
\PYG{k+kt}{mesh} \PYG{n}{Thxy}\PYG{o}{=}\PYG{n+nf}{triangulate}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xyf}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//points are defined by the first 2 columns of file {}`xyf{}`}

\PYG{c+c1}{// Plot the created mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thxy}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vhxy}\PYG{p}{(}\PYG{n}{Thxy}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vhxy} \PYG{n}{fxy}\PYG{p}{;}

\PYG{c+c1}{// Reading the 3rd column to define the function fxy}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ifstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xyf}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{fxy}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{xx} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{yy} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{fxy}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//to read third row only.}
                                      \PYG{c+c1}{//xx and yy are just skipped}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{fxy}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

One new way to build a mesh is to have two arrays: one for the \(x\) values and the other for the \(y\) values.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//set two arrays for the x\PYGZsq{}s and y\PYGZsq{}s}
\PYG{n}{Vhxy} \PYG{n}{xx}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{yy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{c+c1}{//build the mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{triangulate}\PYG{p}{(}\PYG{n}{xx}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Boundary FEM Spaces Built as Empty Meshes}
\label{\detokenize{documentation/meshGeneration:boundary-fem-spaces-built-as-empty-meshes}}
To define a Finite Element space on a boundary, we came up with the idea of a mesh with no internal points (called empty mesh).
It can be useful to handle Lagrange multipliers in mixed and mortar methods.

So the function \sphinxcode{\sphinxupquote{emptymesh}} removes all the internal points of a mesh except points on internal boundaries.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

It is also possible to build an empty mesh of a pseudo subregion with \sphinxcode{\sphinxupquote{emptymesh(Th, ssd)}} using the set of edges from the mesh \sphinxcode{\sphinxupquote{Th}}; an edge \(e\) is in this set when, with the two adjacent triangles \(e =t1\cap t2\) and \(ssd[T1] \neq ssd[T2]\) where \(ssd\) refers to the pseudo region numbering of triangles, they are stored in the \sphinxcode{\sphinxupquote{int{[}int{]}}} array of size “the number of triangles”.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ssd}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//build the pseudo region numbering}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ssd}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{iq} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//because 2 triangles per quad}
        \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
        \PYG{n}{ssd}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ix}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{n}{iy}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//build emtpy with all edges \PYGZdl{}e=T1 \PYGZbs{}cap T2\PYGZdl{} and \PYGZdl{}ssd[T1] \PYGZbs{}neq ssd[T2]\PYGZdl{}}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ssd}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{emptymesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_EmptyMesh1}.png}
\caption{The empty mesh with boundary}\label{\detokenize{documentation/meshGeneration:id20}}\label{\detokenize{documentation/meshGeneration:figemptymesh1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_EmptyMesh2}.png}
\caption{An empty mesh defined from a pseudo region numbering of triangle}\label{\detokenize{documentation/meshGeneration:id21}}\label{\detokenize{documentation/meshGeneration:figemptymesh2}}\end{subfigure}
\caption{Empty mesh}

\end{figure}



\subsubsection{Remeshing}
\label{\detokenize{documentation/meshGeneration:remeshing}}\label{\detokenize{documentation/meshGeneration:EmptyMesh}}

\subsection{Movemesh}
\label{\detokenize{documentation/meshGeneration:movemesh}}\label{\detokenize{documentation/meshGeneration:meshgenerationmovemesh}}
Meshes can be translated, rotated, and deformed by \sphinxcode{\sphinxupquote{movemesh}}; this is useful for elasticity to watch the deformation due to the displacement \(\mathbf{\Phi}(x,y)=(\Phi_1(x,y),\Phi_2(x,y))\) of shape.

It is also useful to handle free boundary problems or optimal shape problems.

If \(\Omega\) is triangulated as \(T_h(\Omega)\), and \(\mathbf{\Phi}\) is a displacement vector then \(\mathbf{\Phi}(T_h)\) is obtained by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{p}{[}\PYG{n}{Phi1}\PYG{p}{,} \PYG{n}{Phi2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Sometimes the transformed mesh is invalid because some triangles have flipped over (meaning it now has a negative area).
To spot such problems, one may check the minimum triangle area in the transformed mesh with \sphinxcode{\sphinxupquote{checkmovemesh}} before any real transformation.

For example:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \Phi_1(x,y) &=& x+k*\sin(y*\pi)/10)\\
    \Phi_2(x,y) &=& y+k*\cos(y\pi)/10)
\end{array}\end{split}
\end{equation*}
for a big number \(k>1\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lshape.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{uu} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{vv} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Checkmovemesh}
\PYG{k+kt}{real} \PYG{n}{minT0} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//return the min triangle area}
\PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{// find a correct move mesh}
    \PYG{k+kt}{real} \PYG{n}{minT} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{minT} \PYG{o}{\PYGZgt{}} \PYG{n}{minT0}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;} \PYG{c+c1}{//if big enough}
    \PYG{k+kp}{coef} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Movemesh}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MovedMesh.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_MoveMesh1}.png}
\caption{L-shape}\label{\detokenize{documentation/meshGeneration:id22}}\label{\detokenize{documentation/meshGeneration:figlshape}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_MoveMesh2}.png}
\caption{Moved L-shape}\label{\detokenize{documentation/meshGeneration:id23}}\label{\detokenize{documentation/meshGeneration:figmovedlshape}}\end{subfigure}
\caption{Move mesh}\phantomsection\label{\detokenize{documentation/meshGeneration:MoveMesh}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
Consider a function \(u\) defined on a mesh \sphinxcode{\sphinxupquote{Th}}.
A statement like \sphinxcode{\sphinxupquote{Th=movemesh(Th...)}} does not change \(u\) and so the old mesh still exists.
It will be destroyed when no function uses it.
A statement like \(u=u\) redefines \(u\) on the new mesh \sphinxcode{\sphinxupquote{Th}} with interpolation and therefore destroys the old \sphinxcode{\sphinxupquote{Th}}, if \(u\) was the only function using it.
\end{sphinxadmonition}

Now, we give an example of moving a mesh with a Lagrangian function \(u\) defined on the moving mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kp}{t} \PYG{o}{=} \PYG{n}{i}\PYG{o}{*}\PYG{n}{dt}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{f}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{minarea} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{f}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{minarea} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//movemesh will be ok}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{f}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Min area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{minarea} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{tmp}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//save the value}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{c+c1}{//to change the FEspace and mesh associated with u}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}\PYG{c+c1}{//set the value of u without any mesh update}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// In this program, since u is only defined on the last mesh, all the}
\PYG{c+c1}{// previous meshes are deleted from memory.}
\end{sphinxVerbatim}


\subsubsection{Regular Triangulation: hTriangle}
\label{\detokenize{documentation/meshGeneration:regular-triangulation-htriangle}}\label{\detokenize{documentation/meshGeneration:meshregulartriangulation}}
For a set \(S\), we define the diameter of \(S\) by
\begin{equation*}
\begin{split}\textrm{diam}(S)=\sup\{|\mathbf{x}-\mathbf{y}|; \; \mathbf{x},\, \mathbf{y}\in S\}\end{split}
\end{equation*}
The sequence \(\{\mathcal{T}_h\}_{h\rightarrow 0}\) of
\(\Omega\) is called \sphinxstyleemphasis{regular} if they satisfy the following:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\(\lim_{h\rightarrow 0}\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}=0\)

\item {} 
There is a number \(\sigma>0\) independent of \(h\) such that \(\frac{\rho(T_k)}{\textrm{diam}(T_k)}\ge \sigma\quad \textrm{for all }T_k\in \mathcal{T}_h\) where \(\rho(T_k)\) are the diameter of the inscribed circle of \(T_k\).

\end{enumerate}

We put \(h(\mathcal{T}_h)=\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}\), which is obtained by

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{h} \PYG{o}{=} \PYG{k+kr}{hTriangle}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{size of mesh = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Adaptmesh}
\label{\detokenize{documentation/meshGeneration:adaptmesh}}
The function:
\begin{equation*}
\begin{split}f(x,y) = 10.0x^3+y^3+\tan^{-1}[\varepsilon/(\sin(5.0y)-2.0x)],\ \varepsilon = 0.0001\end{split}
\end{equation*}
sharply varies in value and the initial mesh given by one of the commands in the {\hyperref[\detokenize{documentation/meshGeneration:meshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation part}}}} cannot reflect its sharp variations.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{0.0001}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{hmin} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{10.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{h}\PYG{o}{*}\PYG{n+nf}{atan2}\PYG{p}{(}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mf}{5.0}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;} \PYG{c+c1}{//old mesh is deleted}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{MeshGeneration_AdaptMesh1}.png}
\caption{3D graphs for the initial mesh and 1st and 2nd mesh adaptations}\label{\detokenize{documentation/meshGeneration:figmeshadaptation}}\end{figure}

\sphinxstylestrong{FreeFem++} uses a variable metric/Delaunay automatic meshing algorithm.

The command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{ATh} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

create the new mesh \sphinxcode{\sphinxupquote{ATh}} adapted to the Hessian
\begin{equation*}
\begin{split}D^2f=(\partial^2 f/\partial x^2,\, \partial^2 f/\partial x\partial y, \partial^2 f/\partial y^2)\end{split}
\end{equation*}
of a function (formula or FE-function).

Mesh adaptation is a very powerful tool when the solution of a problem varies locally and sharply.

Here we solve the {\hyperref[\detokenize{tutorial/poisson:tutorialpoisson}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson’s problem}}}}, when \(f=1\) and \(\Omega\) is a L-shape domain.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh2}.png}
\caption{L-shape domain and its boundary name}\label{\detokenize{documentation/meshGeneration:id24}}\label{\detokenize{documentation/meshGeneration:adaptmesh2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh3}.png}
\caption{Final solution after 4-times adaptation}\label{\detokenize{documentation/meshGeneration:id25}}\label{\detokenize{documentation/meshGeneration:adaptmesh3}}\end{subfigure}
\caption{Mesh adaptation}\phantomsection\label{\detokenize{documentation/meshGeneration:AdaptMesh}}

\end{figure}


\begin{sphinxadmonition}{tip}{Tip:}
The solution has the singularity \(r^{3/2},\, r=|x-\gamma|\) at the point \(\gamma\) of the intersection of two lines \(bc\) and \(bd\) (see \hyperref[\detokenize{documentation/meshGeneration:adaptmesh2}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:adaptmesh2}}}).
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kr}{be}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bf}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bd}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bf}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{Poisson}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{error} \PYG{o}{=} \PYG{n}{error}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

To speed up the adaptation, the default parameter \sphinxcode{\sphinxupquote{err}} of \sphinxcode{\sphinxupquote{adaptmesh}} is changed by hand; it specifies the required precision, so as to make the new mesh finer or coarser.

The problem is coercive and symmetric, so the linear system can be solved with the conjugate gradient method (parameter \sphinxcode{\sphinxupquote{solver=CG}}) with the stopping criteria on the residual, here \sphinxcode{\sphinxupquote{eps=1.e-6}}).

By \sphinxcode{\sphinxupquote{adaptmesh}}, the slope of the final solution is correctly computed near the point of intersection of \(bc\) and \(bd\) as in \hyperref[\detokenize{documentation/meshGeneration:adaptmesh3}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:adaptmesh3}}}.

This method is described in detail in \sphinxcite{reference:hecht1998}.
It has a number of default parameters which can be modified.

If \sphinxcode{\sphinxupquote{f1,f2}} are functions and \sphinxcode{\sphinxupquote{thold, Thnew}} are meshes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
   \PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Thold}\PYG{p}{,} \PYG{n}{f1} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Thold}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,}\PYG{n}{f2} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Thold}\PYG{p}{,} \PYG{p}{[}\PYG{n}{f1}\PYG{p}{,}\PYG{n}{f2}\PYG{p}{]} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The additional parameters of \sphinxcode{\sphinxupquote{adaptmesh}} are:

See {\hyperref[\detokenize{reference/functions:referenceadaptmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{Reference part}}}} for more inforamtions
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{hmin=}} Minimum edge size.}] \leavevmode
Its default is related to the size of the domain to be meshed and the precision of the mesh generator.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{hmax=}} Maximum edge size.}] \leavevmode
It defaults to the diameter of the domain to be meshed.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{err=}} \(P_1\) interpolation error level (0.01 is the default).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{errg=}} Relative geometrical error.}] \leavevmode
By default this error is 0.01, and in any case it must be lower than \(1/\sqrt{2}\).
Meshes created with this option may have some edges smaller than the \sphinxcode{\sphinxupquote{-hmin}} due to geometrical constraints.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{nbvx=}} Maximum number of vertices generated by the mesh generator (9000 is the default).

\item {} 
\sphinxcode{\sphinxupquote{nbsmooth=}} number of iterations of the smoothing procedure (5 is the default).

\item {} 
\sphinxcode{\sphinxupquote{nbjacoby=}} number of iterations in a smoothing procedure during the metric construction, 0 means no smoothing, 6 is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{ratio=}} ratio for a prescribed smoothing on the metric.}] \leavevmode
If the value is 0 or less than 1.1 no smoothing is done on the metric. 1.8 is the default.
If \sphinxcode{\sphinxupquote{ratio \textgreater{} 1.1}}, the speed of mesh size variations is bounded by \(log(\mathtt{ratio})\).

\begin{sphinxadmonition}{note}{Note:}
As \sphinxcode{\sphinxupquote{ratio}} gets closer to 1, the number of generated vertices increases.
This may be useful to control the thickness of refined regions near shocks or boundary layers.
\end{sphinxadmonition}

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{omega=}} relaxation parameter for the smoothing procedure. 1.0 is the default.

\item {} 
\sphinxcode{\sphinxupquote{iso=}} If true, forces the metric to be isotropic. \sphinxcode{\sphinxupquote{false}} is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{abserror=}} If false, the metric is evaluated using the criteria of equi-repartion of relative error.}] \leavevmode
\sphinxcode{\sphinxupquote{false}} is the default.
In this case the metric is defined by:
\begin{equation*}
\begin{split}\mathcal{M} = \left({1\over\mathtt{err}\,\, \mathtt{coef}^2} \quad {
|\mathcal{H}| \over max(\mathtt{CutOff},|\eta|)}\right)^p\end{split}
\end{equation*}
Otherwise, the metric is evaluated using the criteria of equi-distribution of errors.
In this case the metric is defined by:
\begin{equation*}
\begin{split}\mathcal{M} = \left({1\over \mathtt{err}\,\,\mathtt{coef}^2} \quad
{|{\mathcal{H}|} \over
{\sup(\eta)-\inf(\eta)}}\right)^p.\label{eq err abs}\end{split}
\end{equation*}
\end{description}

\item {} 
\sphinxcode{\sphinxupquote{cutoff=}} lower limit for the relative error evaluation.
1.0e-6 is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{verbosity=}} informational messages level (can be chosen between 0 and \(\infty\)).}] \leavevmode
Also changes the value of the global variable verbosity (obsolete).

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{inquire=}} To inquire graphically about the mesh.
\sphinxcode{\sphinxupquote{false}} is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{splitpbedge=}} If true, splits all internal edges in half with two boundary vertices.}] \leavevmode
\sphinxcode{\sphinxupquote{true}} is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{maxsubdiv=}} Changes the metric such that the maximum subdivision of a background edge is bound by \sphinxcode{\sphinxupquote{val}}.}] \leavevmode
Always limited by 10, and 10 is also the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{rescaling=}} if true, the function, with respect to which the mesh is adapted, is rescaled to be between 0 and 1.}] \leavevmode
\sphinxcode{\sphinxupquote{true}} is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{keepbackvertices=}} if true, tries to keep as many vertices from the original mesh as possible.}] \leavevmode
\sphinxcode{\sphinxupquote{true}} is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{IsMetric=}} if true, the metric is defined explicitly.}] \leavevmode
\sphinxcode{\sphinxupquote{false}} is the default.
If the 3 functions \(m_{11}, m_{12}, m_{22}\) are given, they directly define a symmetric matrix field whose Hessian is computed to define a metric.
If only one function is given, then it represents the isotropic mesh size at every point.

For example, if the partial derivatives \sphinxcode{\sphinxupquote{fxx}} (\(=\partial^2 f/\partial x^2\)), \sphinxcode{\sphinxupquote{fxy}} (\(=\partial^2 f/\partial x\partial y\)), \sphinxcode{\sphinxupquote{fyy}} (\(=\partial^2 f/\partial y^2\)) are given, we can set \sphinxcode{\sphinxupquote{Th = adaptmesh(Th, fxx, fxy, fyy, IsMetric=1, nbvx=10000, hmin=hmin);}}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{power=}} exponent power of the Hessian used to compute the metric.}] \leavevmode
1 is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{thetamax=}} minimum corner angle in degrees.}] \leavevmode
Default is \(10^\circ\) where the corner is \(ABC\) and the angle is the angle of the two vectors \({AB}, {BC}\), (\(0\) imply no corner, \(90\) imply perpendicular corner, …).

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{splitin2=}} boolean value.}] \leavevmode
If true, splits all triangles of the final mesh into 4 sub-triangles.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric=}} an array of 3 real arrays to set or get metric data information.}] \leavevmode
The size of these three arrays must be the number of vertices.
So if \sphinxcode{\sphinxupquote{m11,m12,m22}} are three P1 finite elements related to the mesh to adapt, you can write: \sphinxcode{\sphinxupquote{metric={[}m11{[}{]},m12{[}{]},m22{[}{]}{]}}} (see file \sphinxcode{\sphinxupquote{convect-apt.edp}} for a full example)

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{nomeshgeneration=}} If true, no adapted mesh is generated (useful to compute only a metric).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{periodic=}} Writing \sphinxcode{\sphinxupquote{periodic={[}{[}4,y{]},{[}2,y{]},{[}1,x{]},{[}3,x{]}{]};}} builds an adapted periodic mesh.}] \leavevmode
The sample builds a biperiodic mesh of a square.
(see {\hyperref[\detokenize{documentation/finiteElement:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{periodic finite element spaces}}}}, and see {\hyperref[\detokenize{example/meshGeneration:examplesphere}]{\sphinxcrossref{\DUrole{std,std-ref}{the Sphere example}}}} for a full example)

\end{description}

\end{itemize}

We can use the command \sphinxcode{\sphinxupquote{adaptmesh}} to build a uniform mesh with a constant mesh size.
To build a mesh with a constant mesh size equal to \(\frac{1}{30}\) try:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the initial mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square\PYGZhy{}0.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square\PYGZhy{}1.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//More the one time du to}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Adaptation bound {}`maxsubdiv={}`}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square\PYGZhy{}2.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh4}.png}
\caption{Initial mesh}\label{\detokenize{documentation/meshGeneration:id26}}\label{\detokenize{documentation/meshGeneration:adaptmesh4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh5}.png}
\caption{First iteration}\label{\detokenize{documentation/meshGeneration:id27}}\label{\detokenize{documentation/meshGeneration:adaptmesh5}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh6}.png}
\caption{Last iteration}\label{\detokenize{documentation/meshGeneration:id28}}\label{\detokenize{documentation/meshGeneration:adaptmesh6}}\end{subfigure}
\caption{Mesh adaptation}

\end{figure}



\subsubsection{Trunc}
\label{\detokenize{documentation/meshGeneration:trunc}}\label{\detokenize{documentation/meshGeneration:AdaptMesh2}}
Two operators have been introduced to remove triangles from a mesh or to divide them.
Operator \sphinxcode{\sphinxupquote{trunc}} has two parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{label=}} sets the label number of new boundary item, one by default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{split=}} sets the level \(n\) of triangle splitting.}] \leavevmode
Each triangle is split in \(n\times n\), one by default.

\end{description}

\end{itemize}

To create the mesh \sphinxcode{\sphinxupquote{Th3}} where all triangles of a mesh \sphinxcode{\sphinxupquote{Th}} are split in \(3{\times}3\), just write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The following example construct all “trunced” meshes to the support of the basic function of the space \sphinxcode{\sphinxupquote{Vh}} (cf. \sphinxcode{\sphinxupquote{abs(u)\textgreater{}0}}), split all the triangles in \(5{\times} 5\), and put a label number to \(2\) on a new boundary.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Loop on all degrees of freedom}
\PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=}\PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// The basis function i}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh} \PYG{n}{Sh1} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Sh1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{trunc}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// reset}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.490\linewidth]{{MeshGeneration_Trunc1}.png}
\caption{Mesh of support the function P1 number 0, split in \(5{\times}5\)}\label{\detokenize{documentation/meshGeneration:id29}}\label{\detokenize{documentation/meshGeneration:trunc1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.490\linewidth]{{MeshGeneration_Trunc1}.png}
\caption{Mesh of support the function P1 number 6, split in \(5{\times}5\)}\label{\detokenize{documentation/meshGeneration:id30}}\label{\detokenize{documentation/meshGeneration:trunc6}}\end{subfigure}
\caption{Trunc}

\end{figure}



\subsubsection{Splitmesh}
\label{\detokenize{documentation/meshGeneration:splitmesh}}\label{\detokenize{documentation/meshGeneration:Trunc}}
Another way to split mesh triangles is to use \sphinxcode{\sphinxupquote{splitmesh}}, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NotSplittedMesh.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Splitmesh}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{splitmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SplittedMesh.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_SplitMesh1}.png}
\caption{Initial mesh}\label{\detokenize{documentation/meshGeneration:id31}}\label{\detokenize{documentation/meshGeneration:splitmesh1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_SplitMesh2}.png}
\caption{All left mesh triangle is split conformaly in \sphinxcode{\sphinxupquote{int(1+5*(square(x-0.5)+y*y)\textasciicircum{}2}} triangles}\label{\detokenize{documentation/meshGeneration:id32}}\label{\detokenize{documentation/meshGeneration:splitmesh2}}\end{subfigure}
\caption{Split mesh}

\end{figure}



\subsubsection{Meshing Examples}
\label{\detokenize{documentation/meshGeneration:meshing-examples}}\label{\detokenize{documentation/meshGeneration:meshexamples}}\label{\detokenize{documentation/meshGeneration:SplitMesh}}
\begin{sphinxadmonition}{tip}{Tip:}
Two rectangles touching by a side

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{g}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{g}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n}{TH}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TouchSide.esp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_NACA0012_1}.png}
\caption{Two rectangles touching by a side}\label{\detokenize{documentation/meshGeneration:naca00121}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
NACA0012 Airfoil

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{upper}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{lower}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{upper}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lower}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NACA0012.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_NACA0012_2}.png}
\caption{NACA0012 Airfoil}\label{\detokenize{documentation/meshGeneration:naca00122}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Cardioid

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{a} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cardioid.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Cardioid1}.png}
\caption{Domain with Cardioid curve boundary}\label{\detokenize{documentation/meshGeneration:cardioid1}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Cassini Egg

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cassini.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Cardioid2}.png}
\caption{Domain with Cassini egg curve boundary}\label{\detokenize{documentation/meshGeneration:cardioid2}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
By cubic Bezier curve

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// A cubic Bezier curve connecting two points with two control points}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{bzi}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{p0}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{p1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q2}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{p0}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{q1}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{+} \PYG{n}{q2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{p1}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p00} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p11} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.95}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{q30} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{G1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{G1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G3}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G4}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Bezier.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Bezier}.png}
\caption{Boundary drawn by Bezier curves}\label{\detokenize{documentation/meshGeneration:bezier}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Section of Engine

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{L1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{/}\PYG{n}{a} \PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L6}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L7}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{+}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L8}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{l+m+mi}{26}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L3}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L4}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L5}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L6}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L7}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L8}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Engine.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Engine}.png}
\caption{Section of Engine}\label{\detokenize{documentation/meshGeneration:engine}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Domain with U-shape channel

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{c+c1}{//width of U\PYGZhy{}shape}
\PYG{k+kt}{border} \PYG{n+nf}{L1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{R}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{T}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{R}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{T}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{U\PYGZhy{}shape.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_UShape}.png}
\caption{Domain with U-shape channel changed by :freefem{}`d{}`}\label{\detokenize{documentation/meshGeneration:ushape}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Domain with V-shape cut

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{dAg} \PYG{o}{=} \PYG{l+m+mf}{0.02}\PYG{p}{;} \PYG{c+c1}{//angle of V\PYGZhy{}shape}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{dAg}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pa}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pb}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pc}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{seg1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{seg2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{seg1}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)} \PYG{o}{+} \PYG{n}{seg2}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{V\PYGZhy{}shape.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_VShape}.png}
\caption{Domain with V-shape cut changed by \sphinxcode{\sphinxupquote{dAg}}}\label{\detokenize{documentation/meshGeneration:vshape}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Smiling face

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n+nf}{d}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{F}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{E1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{E2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{st}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{F}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C4}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C0}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{E1}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{E2}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SmileFace.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_SmilingFace}.png}
\caption{Smiling face (Mouth is changeable)}\label{\detokenize{documentation/meshGeneration:smilingface}}\end{figure}
\end{sphinxadmonition}

. tip:: 3 points bending
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Square for Three\PYGZhy{}Point Bend Specimens fixed on Fix1, Fix2}
\PYG{c+c1}{// It will be loaded on Load.}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{m} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Left}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Right}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Load}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Left}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Fix1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Fix2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot3}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Right}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Load}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThreePoint.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{MeshGeneration_Example_ThreePoints}.png}
\caption{Domain for three-point bending test}\label{\detokenize{documentation/meshGeneration:threepoints}}\end{figure}
\end{quote}


\subsubsection{How to change the label of elements and border elements of a mesh}
\label{\detokenize{documentation/meshGeneration:how-to-change-the-label-of-elements-and-border-elements-of-a-mesh}}\label{\detokenize{documentation/meshGeneration:meshgenerationchangelabel}}
Changing the label of elements and border elements will be done using the keyword \sphinxcode{\sphinxupquote{change}}.
The parameters for this command line are for two dimensional and three dimensional cases:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{label =}} is a vector of integer that contains successive pairs of the old label number to the new label number.

\item {} 
\sphinxcode{\sphinxupquote{region =}} is a vector of integer that contains successive pairs of the old region number to new region number.

\item {} 
\sphinxcode{\sphinxupquote{flabel =}} is an integer function given the new value of the label.

\item {} 
\sphinxcode{\sphinxupquote{fregion=}} is an integer function given the new value of the region.

\end{itemize}

These vectors are composed of \(n_{l}\) successive pairs of numbers \(O,N\) where \(n_{l}\) is the number (label or region) that we want to change.
For example, we have :
\begin{equation}\label{equation:documentation/meshGeneration:eq.org.vector.change.label}
\begin{split}\mathtt{label} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ] \\
\mathtt{region} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ]\end{split}
\end{equation}
An example of using this function is given here:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//change the label of Edges 2 in 0.}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r2}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//change the label of Edges 4 in 0.}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Th1} \PYG{o}{+} \PYG{n}{Th2}\PYG{p}{;} \PYG{c+c1}{//\PYGZsq{}gluing together\PYGZsq{} of meshes Th1 and Th2}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nb lab = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}
     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{+}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// Definition of a macro}

\PYG{k+kt}{solve} \PYG{k+kr}{P}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{“gluing” different mesh} In line 17 of the previous file, the method to “gluing” different meshes of the same dimension in \sphinxstylestrong{FreeFem++} is using.
This function is the operator “+” between meshes.
The method implemented needs the point in adjacent meshes to be the same.


\subsubsection{Mesh in three dimensions}
\label{\detokenize{documentation/meshGeneration:mesh-in-three-dimensions}}

\subsection{Cube}
\label{\detokenize{documentation/meshGeneration:cube}}
A new function \sphinxcode{\sphinxupquote{cube}} like the function \sphinxcode{\sphinxupquote{square}} in 2d is the simple way to a build cubic object, in plugin \sphinxcode{\sphinxupquote{msh3}} (need \sphinxcode{\sphinxupquote{load "msh3"}}).

The following code generates a \(3\times 4 \times 5\) grid in the unit cube \([0, 1]^3\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

By default the labels are :
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
face \(y=0\),

\item {} 
face \(x=1\),

\item {} 
face \(y=1\),

\item {} 
face \(x=0\),

\item {} 
face \(z=0\),

\item {} 
face \(z=1\)

\end{enumerate}

and the region number is \(0\).

A full example of this function to build a mesh of cube \(]-1,1[^3\) with face label given by \((ix + 4*(iy+1) + 16*(iz+1))\) where \((ix, iy, iz)\) are the coordinates of the barycenter of the current face, is given below.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l6} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{37}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{57}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{r11} \PYG{o}{=} \PYG{l+m+mi}{11}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{z}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l6}\PYG{p}{,} \PYG{k+kp}{flags} \PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, border area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{bordermeasure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{k+kp}{err} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{sx} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{sy} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{sz} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sx}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sy}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{iz} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sz}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ix} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iy}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{16}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iz}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//value of ix,iy,iz =\PYGZgt{} face min 0, face max 2, no face 1}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Label = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, s = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ix} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iz} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(} \PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ii} \PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{real} \PYG{n}{volr11} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume region = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{volr11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{volr11} \PYG{o}{\PYGZhy{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nb err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kp}{err}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nl}{Enter}\PYG{o}{:} \PYG{n+nl}{BuildCube}\PYG{o}{:} \PYG{l+m+mi}{3}
  \PYG{n}{kind} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{k+kr}{n} \PYG{n}{tet} \PYG{n}{Cube} \PYG{o}{=} \PYG{l+m+mi}{6} \PYG{o}{/} \PYG{k+kr}{n} \PYG{n}{slip} \PYG{l+m+mi}{6} \PYG{l+m+mi}{19}
\PYG{n}{Cube}  \PYG{k+kr}{nv}\PYG{o}{=}\PYG{l+m+mi}{210} \PYG{k+kr}{nt}\PYG{o}{=}\PYG{l+m+mi}{720} \PYG{k+kr}{nbe}\PYG{o}{=}\PYG{l+m+mi}{296}
\PYG{n+nl}{Out}\PYG{o}{:}  \PYG{n}{BuildCube}
\PYG{n}{Volume} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{k+kt}{border} \PYG{k+kr}{area} \PYG{o}{=} \PYG{l+m+mi}{24}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{110} \PYG{o}{:} \PYG{l+m+mi}{25}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{37}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{101} \PYG{o}{:} \PYG{l+m+mi}{37}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mo}{011} \PYG{o}{:} \PYG{l+m+mi}{40}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{211} \PYG{o}{:} \PYG{l+m+mi}{42}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{121} \PYG{o}{:} \PYG{l+m+mi}{45}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{57}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{112} \PYG{o}{:} \PYG{l+m+mi}{57}
\PYG{n}{Volume} \PYG{k+kr}{region} \PYG{o}{=} \PYG{l+m+mi}{11}\PYG{o}{:} \PYG{l+m+mi}{8}
\PYG{n}{Nb} \PYG{k+kp}{err} \PYG{o}{=} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Cube}.jpg}
\caption{The mesh 3d of function \sphinxcode{\sphinxupquote{cube(4, 5, 6, flags=3)}}}\label{\detokenize{documentation/meshGeneration:meshgeneration-cube}}\end{figure}


\subsection{Read/Write Statements for a Mesh in 3D}
\label{\detokenize{documentation/meshGeneration:read-write-statements-for-a-mesh-in-3d}}\label{\detokenize{documentation/meshGeneration:meshreadwrite3d}}
In three dimensions, the file mesh format supported for input and output files by \sphinxstylestrong{FreeFem++} are the extension .msh and .mesh.
These formats are described in the {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}}.

\sphinxstylestrong{Extension file .msh} The structure of the files with extension .msh in 3D is given by:
\begin{equation*}
\begin{split}\begin{array}{cccccc}
    n_v & n_{tet} & n_{tri} & & \\
    q^1_x & q^1_y & q^1_z & Vertex label & \\
    q^2_x & q^2_y & q^2_z & Vertex label & \\
    \vdots & \vdots & \vdots & \vdots & \\
    q^{n_v}_x & q^{n_v}_y & q^{n_v}_z & Vertex label & \\
    1_1 & 1_2 & 1_3 & 1_4 & region label \\
    2_1 & 2_2 & 2_3 & 2_4 & region label \\
    \vdots & \vdots & \vdots & \vdots & \vdots \\
    (n_{tet})_1 & (n_{tet})_2 & (n_{tet})_3 & (n_{tet})_4 & region label \\
    1_1 & 1_2 & 1_3 & boundary label & \\
    2_1 & 2_2 & 2_3 & boundary label & \\
    \vdots & \vdots & \vdots & \vdots & \\
    (n_tri)_{1} & (n_{tri})_2 & (n_{tri})_3 & boundary label & \\
\end{array}\end{split}
\end{equation*}
In this structure, \(n_v\) denotes the number of vertices, \(n_{tet}\) the number of tetrahedra and \(n_{tri}\) the number of triangles.

For each vertex \(q^i,\, i=1,\cdots,n_v\), we denote by \((q^i_x,q^i_y,q^i_z)\) the \(x\)-coordinate, the \(y\)-coordinate and the \(z\)-coordinate.

Each tetrahedra \(T_k, k=1,\cdots,n_{tet}\) has four vertices \(q^{k_1},\, q^{k_2},\,q^{k_3}, \,q^{k_4}\).

The boundary consists of a union of triangles.
Each triangle \(be_j, j=1,\cdots,n_{tri}\) has three vertices \(q^{j_1},\, q^{j_2},\,q^{j_3}\).

\sphinxstylestrong{extension file .mesh} The data structure for a three dimensional mesh is composed of the data structure presented in {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}} and a data structure for the tetrahedra. The tetrahedra of a three dimensional mesh are referred using the following field:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Tetrahedra
NbTetrahedra
Vertex1 Vertex2 Vertex3 Vertex4 Label
...
Vertex1 Vertex2 Vertex3 Vertex4 Label
\end{sphinxVerbatim}

This field is express with the notation of {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}}.


\subsection{TetGen: A tetrahedral mesh generator}
\label{\detokenize{documentation/meshGeneration:tetgen-a-tetrahedral-mesh-generator}}
\sphinxstylestrong{TetGen}

TetGen is a software developed by Dr. Hang Si of Weierstrass Institute for Applied Analysis and Stochastics in Berlin, Germany \sphinxcite{reference:hang2006}.
TetGen is free for research and non-commercial use.
For any commercial license utilization, a commercial license is available upon request to Hang Si.

This software is a tetrahedral mesh generator of a three dimensional domain defined by its boundary.
The input domain takes into account a polyhedral or a piecewise linear complex.
This tetrahedralization is a constrained Delaunay tetrahedralization.

The method used in TetGen to control the quality of the mesh is a Delaunay refinement due to Shewchuk \sphinxcite{reference:shewchuk1998}.
The quality measure of this algorithm is the Radius-Edge Ratio (see Section 1.3.1 \sphinxcite{reference:hang2006} for more details).
A theoretical bound of this ratio of the Shewchuk algorithm is obtained for a given complex of vertices, constrained segments and facets of surface mesh, with no input angle less than 90 degrees.
This theoretical bound is 2.0.

The launch of TetGen is done with the keyword \sphinxcode{\sphinxupquote{tetg}}.
The parameters of this command line is:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{reftet=}} sets the label of tetrahedra.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} is a vector of integers that contains the old labels number at index \(2i\) and the new labels number at index \(2i+1\) of Triangles.}] \leavevmode
This parameter is initialized as a label for the keyword {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{switch=}} A string expression.}] \leavevmode
This string corresponds to the command line switch of TetGen see Section 3.2 of \sphinxcite{reference:hang2006}.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{nbofholes=}} Number of holes (default value: “size of \sphinxcode{\sphinxupquote{holelist}} / 3”).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{holelist=}} This array corresponds to \sphinxcode{\sphinxupquote{holelist}} of TetGenio data structure \sphinxcite{reference:hang2006}.}] \leavevmode
A real vector of size \sphinxcode{\sphinxupquote{3 * nbofholes}}.
In TetGen, each hole is associated with a point inside this domain.
This vector is \(x_{1}^{h}, y_{1}^{h}, z_{1}^{h}, x_{2}^{h}, y_{2}^{h}, z_{2}^{h}, \cdots,\) where \(x_{i}^{h},y_{i}^{h},z_{i}^{h}\) is the associated point with the \(i^{\mathrm{th}}\) hole.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{nbofregions=}} Number of regions (default value: “size of \sphinxcode{\sphinxupquote{regionlist}} / 5”).

\item {} 
\sphinxcode{\sphinxupquote{regionlist=}} This array corresponds to \sphinxcode{\sphinxupquote{regionlist}} of TetGenio data structure \sphinxcite{reference:hang2006}.

The attribute and the volume constraint of region are given in this real vector of size \sphinxcode{\sphinxupquote{5 * nbofregions}}.
The \(i^{\mathrm{th}}\) region is described by five elements: \(x-\)coordinate, \(y-\)coordinate and \(z-\)coordinate of a point inside this domain (\(x_{i},y_{i},z_{i}\)); the attribute (\(at_{i}\)) and the maximum volume for tetrahedra (\(mvol_{i}\)) for this region.

The \sphinxcode{\sphinxupquote{regionlist}} vector is: \(x_{1}, y_{1}, z_{1}, at_{1}, mvol_{1}, x_{2}, y_{2}, z_{2}, at_{2}, mvol_{2}, \cdots\).

\item {} 
\sphinxcode{\sphinxupquote{nboffacetcl=}} Number of facets constraints “size of \sphinxcode{\sphinxupquote{facetcl}} / 2”).

\item {} 
\sphinxcode{\sphinxupquote{facetcl=}} This array corresponds to \sphinxcode{\sphinxupquote{facetconstraintlist}} of TetGenio data structure \sphinxcite{reference:hang2006}.

The \(i^{th}\) facet constraint is defined by the facet marker \(Ref_{i}^{fc}\) and the maximum area for faces \(marea_{i}^{fc}\).
The \sphinxcode{\sphinxupquote{facetcl}} array is: \(Ref_{1}^{fc}, marea_{1}^{fc}, Ref_{2}^{fc}, marea_{2}^{fc}, \cdots\).

This parameters has no effect if switch \sphinxcode{\sphinxupquote{q}} is not selected.

\end{itemize}

Principal switch parameters in TetGen:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{p}} Tetrahedralization of boundary.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{q}} Quality mesh generation.}] \leavevmode
The bound of Radius-Edge Ratio will be given after the option \sphinxcode{\sphinxupquote{q}}.
By default, this value is 2.0.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{a}} Constructs with the volume constraints on tetrahedra.}] \leavevmode
These volumes constraints are defined with the bound of the previous switch \sphinxcode{\sphinxupquote{q}} or in the parameter \sphinxcode{\sphinxupquote{regionlist}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{A}} Attributes reference to region given in the \sphinxcode{\sphinxupquote{regionlist}}.}] \leavevmode
The other regions have label 0.

\end{description}

The option \sphinxcode{\sphinxupquote{AA}} gives a different label at each region.
This switch works with the option \sphinxcode{\sphinxupquote{p}}.
If option :freefem{}`r{}` is used, this switch has no effect.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{r}} Reconstructs and Refines a previously generated mesh.}] \leavevmode
This character is only used with the command line \sphinxcode{\sphinxupquote{tetgreconstruction}}.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{Y}} This switch preserves the mesh on the exterior boundary.

This switch must be used to ensure a conformal mesh between two adjacent meshes.

\item {} 
\sphinxcode{\sphinxupquote{YY}} This switch preserves the mesh on the exterior and interior boundary.

\item {} 
\sphinxcode{\sphinxupquote{C}} The consistency of the result’s mesh is testing by TetGen.

\item {} 
\sphinxcode{\sphinxupquote{CC}} The consistency of the result’s mesh is testing by TetGen and also constrained checks of Delaunay mesh (if \sphinxcode{\sphinxupquote{p}} switch is selected) or the consistency of Conformal Delaunay (if \sphinxcode{\sphinxupquote{q}} switch is selected).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{V}} Give information of the work of TetGen.}] \leavevmode
More information can be obtained in specified \sphinxcode{\sphinxupquote{VV}} or \sphinxcode{\sphinxupquote{VVV}}.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{Q}} Quiet: No terminal output except errors

\item {} 
\sphinxcode{\sphinxupquote{M}} The coplanar facets are not merging.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{T}} Sets a tolerance for coplanar test.}] \leavevmode
The default value is \(1e-8\).

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{d}} Intersections of facets are detected.

\end{itemize}

To obtain a tetrahedral mesh with TetGen, we need the surface mesh of a three dimensional domain.
We now give the command line in \sphinxstylestrong{FreeFem++} to construct these meshes.

\sphinxstylestrong{keyword: movemesh23}

A simple method to construct a surface is to place a two dimensional domain in a three dimensional space.
This corresponds to moving the domain by a displacement vector of this form \(\mathbf{\Phi(x,y)} = (\Phi1(x,y), \Phi2(x,y), \Phi3(x,y))\).

The result of moving a two dimensional mesh Th2 by this three dimensional displacement is obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The parameters of this command line are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{transfo=}} {[}\(\Phi 1\), \(\Phi 2\), \(\Phi 3\){]} sets the displacement vector of transformation \(\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]\).

\item {} 
\sphinxcode{\sphinxupquote{label=}} sets an integer label of triangles.

\item {} 
\sphinxcode{\sphinxupquote{orientation=}} sets an integer orientation of mesh.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{ptmerge=}} A real expression.}] \leavevmode
When you transform a mesh, some points can be merged.
This parameter is the criteria to define two merging points.
By default, we use
\begin{equation*}
\begin{split}ptmerge \: = \: 1e-7 \: \:Vol( B ),\end{split}
\end{equation*}
\end{description}

where \(B\) is the smallest axis, parallel boxes containing the discretized domain of \(\Omega\) and \(Vol(B)\) is the volume of this box.

\end{itemize}

We can do a “gluing” of surface meshes using the process given in {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{Change section}}}}.
An example to obtain a three dimensional mesh using the command line \sphinxcode{\sphinxupquote{tetg}} and \sphinxcode{\sphinxupquote{movemesh23}} is given below.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{x10} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x11} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y10} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y11} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{ZZ1min} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ1max} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{XX1} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY1} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{x20} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x21} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y20}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y21}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{ZZ2} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{XX2} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY2min} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY2max} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{x30}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x31}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y30}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y31}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{XX3min} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{XX3max} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY3} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ3} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thsq1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{35}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x10}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x11}\PYG{o}{\PYGZhy{}}\PYG{n}{x10}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{y10}\PYG{o}{+}\PYG{p}{(}\PYG{n}{y11}\PYG{o}{\PYGZhy{}}\PYG{n}{y10}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thsq2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x20}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x21}\PYG{o}{\PYGZhy{}}\PYG{n}{x20}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{y20}\PYG{o}{+}\PYG{p}{(}\PYG{n}{y21}\PYG{o}{\PYGZhy{}}\PYG{n}{y20}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thsq3} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x30}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x31}\PYG{o}{\PYGZhy{}}\PYG{n}{x30}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{y30}\PYG{o}{+}\PYG{p}{(}\PYG{n}{y31}\PYG{o}{\PYGZhy{}}\PYG{n}{y30}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2D to 3D surface}
\PYG{k+kt}{mesh3} \PYG{n}{Th31h} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq1}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1max}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th31b} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq1}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1min}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th32h} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX2}\PYG{p}{,} \PYG{n}{YY2max}\PYG{p}{,} \PYG{n}{ZZ2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th32b} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX2}\PYG{p}{,} \PYG{n}{YY2min}\PYG{p}{,} \PYG{n}{ZZ2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th33h} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq3}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX3max}\PYG{p}{,} \PYG{n}{YY3}\PYG{p}{,} \PYG{n}{ZZ3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th33b} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq3}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX3min}\PYG{p}{,} \PYG{n}{YY3}\PYG{p}{,} \PYG{n}{ZZ3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Gluing surfaces}
\PYG{k+kt}{mesh3} \PYG{n}{Th33} \PYG{o}{=} \PYG{n}{Th31h} \PYG{o}{+} \PYG{n}{Th31b} \PYG{o}{+} \PYG{n}{Th32h} \PYG{o}{+} \PYG{n}{Th32b} \PYG{o}{+} \PYG{n}{Th33h} \PYG{o}{+} \PYG{n}{Th33b}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th33}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th33}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Tetrahelize the interior of the cube with TetGen}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mf}{0.0025}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Thfinal} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th33}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thfinal}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thfinal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Build a mesh of a half cylindrical shell of interior radius 1, and exterior radius 2 and a height of 1.5}
\PYG{k+kt}{func} \PYG{n}{mv2x} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{mv2y} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{mv2z} \PYG{o}{=} \PYG{k+kr}{z}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Thmv2} \PYG{o}{=} \PYG{n}{movemesh3}\PYG{p}{(}\PYG{n}{Thfinal}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{mv2x}\PYG{p}{,} \PYG{n}{mv2y}\PYG{p}{,} \PYG{n}{mv2z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thmv2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thmv2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The command \sphinxcode{\sphinxupquote{movemesh3}} is described in the following section.

\sphinxstylestrong{The keyword tetgtransfo}

This keyword corresponds to a composition of command line \sphinxcode{\sphinxupquote{tetg}} and \sphinxcode{\sphinxupquote{movemesh23}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th3surf}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{,}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{Th3surf = movemesh23(Th2, transfo={[}Phi(1), Phi(2), Phi(3){]})}} and \sphinxcode{\sphinxupquote{Th2}} is the input two dimensional mesh of \sphinxcode{\sphinxupquote{tetgtransfo}}.

The parameters of this command line are, on one hand, the parameters \sphinxcode{\sphinxupquote{label}}, \sphinxcode{\sphinxupquote{switch}}, \sphinxcode{\sphinxupquote{regionlist}}, \sphinxcode{\sphinxupquote{nboffacetcl}}, \sphinxcode{\sphinxupquote{facetcl}} of keyword \sphinxcode{\sphinxupquote{tetg}} and on the other hand, the parameter \sphinxcode{\sphinxupquote{ptmerge}} of keyword \sphinxcode{\sphinxupquote{movemesh23}}.

\begin{sphinxadmonition}{note}{Note:}
To use \sphinxcode{\sphinxupquote{tetgtransfo}}, the result’s mesh of \sphinxcode{\sphinxupquote{movemesh23}} must be a closed surface and define one region only. Therefore, the parameter \sphinxcode{\sphinxupquote{regionlist}} is defined for one region.

An example of this keyword can be found in line 61 of the {\hyperref[\detokenize{example/meshGeneration:examplebuildlayermesh}]{\sphinxcrossref{\DUrole{std,std-ref}{Build layer mesh example}}}}.
\end{sphinxadmonition}

\sphinxstylestrong{The keyword tetgconvexhull}

\sphinxstylestrong{FreeFem++}, using TetGen, is able to build a tetrahedralization from a set of points.
This tetrahedralization is a Delaunay mesh of the convex hull of the set of points.

The coordinates of the points can be initialized in two ways.
The first is a file that contains the coordinate of points \(X_{i}=(x_{i}, y_{i}, z_{i})\).
This file is organized as follows:
\begin{equation*}
\begin{split}\begin{array}{ccc}
n_{v} & & \\
x_{1} & y_{1} & z_{1} \\
x_{2} & y_{2} & z_{2} \\
\vdots &\vdots & \vdots \\
x_{n_v} & y_{n_v} & z_{n_v}
\end{array}\end{split}
\end{equation*}
The second way is to give three arrays that correspond respectively to the \(x-\)coordinates, \(y-\)coordinates and \(z-\)coordinates.

The parameters of this command line are :
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{switch=}} A string expression.}] \leavevmode
This string corresponds to the command line \sphinxcode{\sphinxupquote{switch}} of TetGen see Section 3.2 of \sphinxcite{reference:hang2006}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{reftet=}} An integer expression.}] \leavevmode
Set the label of tetrahedra.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} An integer expression.}] \leavevmode
Set the label of triangles.

\end{description}

\end{itemize}

In the string \sphinxcode{\sphinxupquote{switch}}, we can’t used the option \sphinxcode{\sphinxupquote{p}} and \sphinxcode{\sphinxupquote{q}} of TetGen.


\subsection{Reconstruct/Refine a three dimensional mesh with TetGen}
\label{\detokenize{documentation/meshGeneration:reconstruct-refine-a-three-dimensional-mesh-with-tetgen}}
Meshes in three dimension can be refined using TetGen with the command line \sphinxcode{\sphinxupquote{tetgreconstruction}}.

The parameter of this keyword are
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{region=}} an integer array that changes the region number of tetrahedra.}] \leavevmode
This array is defined as the parameter \sphinxcode{\sphinxupquote{reftet}} in the keyword \sphinxcode{\sphinxupquote{change}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} an integer array that changes the label of boundary triangles.}] \leavevmode
This array is defined as the parameter \sphinxcode{\sphinxupquote{label}} in the keyword \sphinxcode{\sphinxupquote{change}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{sizeofvolume=}} a reel function.}] \leavevmode
This function constraints the volume size of the tetrahedra in the domain (see {\hyperref[\detokenize{documentation/meshGeneration:meshfirstisotropemeshadaptation}]{\sphinxcrossref{\DUrole{std,std-ref}{Isotrope mesh adaption section}}}} to build a 3d adapted mesh).

\end{description}

\end{itemize}

The parameters \sphinxcode{\sphinxupquote{switch}}, \sphinxcode{\sphinxupquote{nbofregions}}, \sphinxcode{\sphinxupquote{regionlist}}, \sphinxcode{\sphinxupquote{nboffacetcl}} and \sphinxcode{\sphinxupquote{facetcl}} of the command line which call TetGen (\sphinxcode{\sphinxupquote{tetg}}) is used for \sphinxcode{\sphinxupquote{tetgrefine}}.

In the parameter \sphinxcode{\sphinxupquote{switch=}}, the character \sphinxcode{\sphinxupquote{r}} should be used without the character \sphinxcode{\sphinxupquote{p}}.

For instance, see the manual of TetGen \sphinxcite{reference:hang2006} for effect of \sphinxcode{\sphinxupquote{r}} to other character.

The parameter \sphinxcode{\sphinxupquote{regionlist}} defines a new volume constraint in the region.
The label in the \sphinxcode{\sphinxupquote{regionlist}} will be the previous label of region.

This parameter and \sphinxcode{\sphinxupquote{nbofregions}} can’t be used with the parameter \sphinxcode{\sphinxupquote{sizeofvolume}}.

\sphinxstylestrong{Example refinesphere.edp}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZdl{}]\PYGZhy{}pi/2, pi/2[X]0, 2pi[ \PYGZdl{}}

\PYG{c+c1}{// A parametrization of a sphere}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Partial derivative of the parametrization DF}
\PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{// M = DF\PYGZca{}t DF}
\PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation}
\PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of the surface of spheres}
\PYG{k+kt}{real} \PYG{n}{Rmin} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f3}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1min}\PYG{p}{,} \PYG{n}{f2min}\PYG{p}{,} \PYG{n}{f3min}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Contruct the volume}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sph} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQYY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Refine}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{newlabel} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mi}{18}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domainrefine} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sphrefine} \PYG{o}{=} \PYG{n+nf}{tetgreconstruction}\PYG{p}{(}\PYG{n}{Th3sph}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{raAQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{reftet}\PYG{o}{=}\PYG{n}{newlabel}\PYG{p}{,}
    \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{,} \PYG{k+kp}{sizeofvolume}\PYG{o}{=}\PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Re\PYGZhy{}Refine}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{newlabel2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mi}{53}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fsize} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{z}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sphrefine2} \PYG{o}{=} \PYG{n+nf}{tetgreconstruction}\PYG{p}{(}\PYG{n}{Th3sph}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{raAQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{reftet}\PYG{o}{=}\PYG{n}{newlabel2}\PYG{p}{,}
    \PYG{k+kp}{sizeofvolume}\PYG{o}{=}\PYG{n}{fsize}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Medit}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sphere}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sph}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{isotroperefine}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sphrefine}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{anisotroperefine}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sphrefine2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Moving mesh in three dimensions}
\label{\detokenize{documentation/meshGeneration:moving-mesh-in-three-dimensions}}
Meshes in three dimensions can be translated, rotated, and deformed using the command line \sphinxcode{\sphinxupquote{movemesh}} as in the 2D case (see {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationmovemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{section movemesh}}}}).
If \(\Omega\) is tetrahedrized as \(T_{h}(\Omega)\), and \(\Phi(x,y)=(\Phi1(x,y,z), \Phi2(x,y,z), \Phi3(x,y,z))\) is a displacement vector then \(\Phi(T_{h})\) is obtained by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Phi1}\PYG{p}{,} \PYG{n}{Phi2}\PYG{p}{,} \PYG{n}{Phi3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The parameters of movemesh in three dimensions are:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{region=}} sets the integer labels of the tetrahedra.}] \leavevmode
0 by default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} sets the labels of the border faces.}] \leavevmode
This parameter is initialized as the label for the keyword {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{facemerge=}} An integer expression.}] \leavevmode
When you transform a mesh, some faces can be merged.
This parameter equals to one if the merges’ faces is considered.
Otherwise it equals to zero.
By default, this parameter is equal to 1.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{ptmerge =}} A real expression.}] \leavevmode
When you transform a mesh, some points can be merged.
This parameter is the criteria to define two merging points.
By default, we use
\begin{equation*}
\begin{split}ptmerge \: = \: 1e-7 \: \:Vol( B ),\end{split}
\end{equation*}
\end{description}

where \(B\) is the smallest axis parallel boxes containing the discretion domain of \(\Omega\) and \(Vol(B)\) is the volume of this box.

\item {} 
\sphinxcode{\sphinxupquote{orientation =}} An integer expression (1 by default), to reverse or not to reverse the orientation of the tetrahedra if it is not positive.

\end{itemize}

An example of this command can be found in the {\hyperref[\detokenize{example/misc:examplepoissonequation3d}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson’s equation 3D example}}}}.


\subsection{Layer mesh}
\label{\detokenize{documentation/meshGeneration:layer-mesh}}
In this section, we present the command line to obtain a Layer mesh: \sphinxcode{\sphinxupquote{buildlayers}}.
This mesh is obtained by extending a two dimensional mesh in the \(z\)-axis.

The domain \(\Omega_{3d}\) defined by the layer mesh is equal to \(\Omega_{3d} = \Omega_{2d} \times [zmin, zmax]\) where \(\Omega_{2d}\) is the domain defined by the two dimensional meshes.
\(zmin\) and \(zmax\) are functions of \(\Omega_{2d}\) in \(\R\) that defines respectively the lower surface and upper surface of \(\Omega_{3d}\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{MeshGeneration_LayerMesh}.png}
\caption{Example of Layer mesh in three dimensions.}\label{\detokenize{documentation/meshGeneration:meshgenerationlayermesh}}\end{figure}

For a vertex of a two dimensional mesh \(V_{i}^{2d} = (x_{i},y_{i})\), we introduce the number of associated vertices in the \(z-\)axis \(M_{i}+1\).

We denote by \(M\) the maximum of \(M_{i}\) over the vertices of the two dimensional mesh.
This value is called the number of layers (if \(\forall i, \; M_{i}=M\) then there are \(M\) layers in the mesh of \(\Omega_{3d}\)).
\(V_{i}^{2d}\) generated \(M+1\) vertices which are defined by:
\begin{equation*}
\begin{split}\forall j=0, \ldots, M, \quad V_{i,j}^{3d} = ( x_{i}, y_{i}, \theta_{i}(z_{i,j}) ),\end{split}
\end{equation*}
where \((z_{i,j})_{j=0,\ldots,M}\) are the \(M+1\) equidistant points on the interval \([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d})]\):
\begin{equation*}
\begin{split}z_{i,j} = j \: \delta \alpha + zmin(V_{i}^{2d}), \quad \delta \alpha= \frac{ zmax( V_{i}^{2d} ) - zmin( V_{i}^{2d}) }{M}.\end{split}
\end{equation*}
The function \(\theta_{i}\), defined on \([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]\), is given by:
\begin{equation*}
\begin{split}\theta_{i}(z) = \left \{
\begin{array}{cl}
\theta_{i,0} & \mbox{if} \: z=zmin(V_{i}^{2d}), \\
\theta_{i,j} & \mbox{if} \: z \in ] \theta_{i,j-1}, \theta_{i,j}],\\
\end{array}
\right.\end{split}
\end{equation*}
with \((\theta_{i,j})_{j=0,\ldots,M_{i}}\) are the \(M_{i}+1\) equidistant points on the interval \([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]\).

Set a triangle \(K=(V_{i1}^{2d}\), \(V_{i2}^{2d}\), \(V_{i3}^{2d})\) of the two dimensional mesh.
\(K\) is associated with a triangle on the upper surface (resp. on the lower surface) of layer mesh:

\(( V_{i1,M}^{3d}, V_{i2,M}^{3d}, V_{i3,M}^{3d} )\) (resp. \(( V_{i1,0}^{3d}, V_{i2,0}^{3d}, V_{i3,0}^{3d})\)).

Also \(K\) is associated with \(M\) volume prismatic elements which are defined by:
\begin{equation*}
\begin{split}\forall j=0,\ldots,M, \quad H_{j} = ( V_{i1,j}^{3d}, V_{i2,j}^{3d}, V_{i3,j}^{3d}, V_{i1,j+1}^{3d}, V_{i2,j+1}^{3d}, V_{i3,j+1}^{3d} ).\end{split}
\end{equation*}
Theses volume elements can have some merged point:
\begin{itemize}
\item {} 
0 merged point : prism

\item {} 
1 merged points : pyramid

\item {} 
2 merged points : tetrahedra

\item {} 
3 merged points : no elements

\end{itemize}

The elements with merged points are called degenerate elements.
To obtain a mesh with tetrahedra, we decompose the pyramid into two tetrahedra and the prism into three tetrahedra.
These tetrahedra are obtained by cutting the quadrilateral face of pyramid and prism with the diagonal which have the vertex with the maximum index (see \sphinxcite{reference:hecht1992} for the reason of this choice).

The triangles on the middle surface obtained with the decomposition of the volume prismatic elements are the triangles generated by the edges on the border of the two dimensional mesh.
The label of triangles on the border elements and tetrahedra are defined with the label of these associated elements.

The arguments of \sphinxcode{\sphinxupquote{buildlayers}} is a two dimensional mesh and the number of layers \(M\).

The parameters of this command are:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{zbound=}} \([zmin,zmax]\) where \(zmin\) and \(zmax\) are functions expression.}] \leavevmode
Theses functions define the lower surface mesh and upper mesh of surface mesh.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{coef=}} A function expression between {[}0,1{]}.}] \leavevmode
This parameter is used to introduce degenerate element in mesh.

\end{description}

The number of associated points or vertex \(V_{i}^{2d}\) is the integer part of \(coef(V_{i}^{2d}) M\).

\item {} 
\sphinxcode{\sphinxupquote{region=}} This vector is used to initialize the region of tetrahedra.

This vector contains successive pairs of the 2d region number at index \(2i\) and the corresponding 3d region number at index \(2i+1\), like {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\item {} 
\sphinxcode{\sphinxupquote{labelmid=}} This vector is used to initialize the 3d labels number of the vertical face or mid face from the 2d label number.

This vector contains successive pairs of the 2d label number at index \(2i\) and the corresponding 3d label number at index \(2i+1\), like {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\item {} 
\sphinxcode{\sphinxupquote{labelup=}} This vector is used to initialize the 3d label numbers of the upper/top face from the 2d region number.

This vector contains successive pairs of the 2d region number at index \(2i\) and the corresponding 3d label number at index \(2i+1\), like {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\item {} 
\sphinxcode{\sphinxupquote{labeldown=}} Same as the previous case but for the lower/down face label.

\end{itemize}

Moreover, we also add post processing parameters that allow to moving the mesh.
These parameters correspond to parameters \sphinxcode{\sphinxupquote{transfo}}, \sphinxcode{\sphinxupquote{facemerge}} and \sphinxcode{\sphinxupquote{ptmerge}} of the command line \sphinxcode{\sphinxupquote{movemesh}}.

The vector \sphinxcode{\sphinxupquote{region}}, \sphinxcode{\sphinxupquote{labelmid}}, \sphinxcode{\sphinxupquote{labelup}} and \sphinxcode{\sphinxupquote{labeldown}} These vectors are composed of \(n_{l}\) successive pairs of number \(O_i,N_l\) where \(n_{l}\) is the number (label or region) that we want to get.

An example of this command is given in the {\hyperref[\detokenize{example/meshGeneration:examplebuildlayermesh}]{\sphinxcrossref{\DUrole{std,std-ref}{Build layer mesh example}}}}.

\begin{sphinxadmonition}{tip}{Tip:}
Cube

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//Cube.idp}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{func} \PYG{k+kt}{mesh3} \PYG{n}{Cube} \PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{NN}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{BB}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x1} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{z0} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{z1} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{n}{NN}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny} \PYG{o}{=} \PYG{n}{NN}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nz} \PYG{o}{=} \PYG{n}{NN}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// 2D mesh}
    \PYG{k+kt}{mesh} \PYG{n}{Thx} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// 3D mesh}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rdown}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Thx}\PYG{p}{,} \PYG{n}{nz}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{z0}\PYG{p}{,}\PYG{n}{z1}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{labelup} \PYG{o}{=} \PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{labeldown} \PYG{o}{=} \PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{Th}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Unit cube

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cube.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{NN} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the number of step in each direction}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{BB} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the bounding box}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the label of the 6 face left,right, front, back, down, right}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Cube}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{BB}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_LayerMesh_Example1}.png}
\caption{The mesh of a cube made with \sphinxcode{\sphinxupquote{cube.edp}}}\label{\detokenize{documentation/meshGeneration:meshgenerationlayermeshexample1}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Cone

An axisymtric mesh on a triangle with degenerateness

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{RR} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{HH} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{nn}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Taxe}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{HH}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Hypo}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{HH}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{RR}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Vert}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{RR}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{HH}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Taxe}\PYG{p}{(}\PYG{n}{HH}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Hypo}\PYG{p}{(}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{HH}\PYG{o}{*}\PYG{n}{HH}\PYG{o}{+}\PYG{n}{RR}\PYG{o}{*}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Vert}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// 3D mesh}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nn}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayersT} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{n}{RR}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{c+c1}{//number of layers}
\PYG{k+kt}{real} \PYG{n}{zminT} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmaxT} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{c+c1}{//height 2*pi}
\PYG{k+kt}{func} \PYG{n}{fx} \PYG{o}{=} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fy} \PYG{o}{=} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fz} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1T} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r2T} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r4T} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{c+c1}{//trick function:}
\PYG{c+c1}{//The function defined the proportion}
\PYG{c+c1}{//of number layer close to axis with reference MaxLayersT}
\PYG{k+kt}{func} \PYG{n}{deg} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{l+m+mf}{.01}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{/}\PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{HH}\PYG{p}{,} \PYG{l+m+mf}{0.4}\PYG{p}{)}\PYG{o}{/}\PYG{n}{RR}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3T} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{n}{deg}\PYG{p}{,} \PYG{n}{MaxLayersT}\PYG{p}{,}
    \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zminT}\PYG{p}{,} \PYG{n}{zmaxT}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{fx}\PYG{p}{,} \PYG{n}{fy}\PYG{p}{,} \PYG{n}{fz}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{facemerge}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r1T}\PYG{p}{,} \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{r2T}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cone}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3T}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_LayerMesh_Example2}.png}
\caption{The mesh of a cone made with \sphinxcode{\sphinxupquote{cone.edp}}}\label{\detokenize{documentation/meshGeneration:meshgenerationlayermeshexample2}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Buildlayer mesh

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{C1} \PYG{o}{=} \PYG{l+m+mi}{99}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{C2} \PYG{o}{=} \PYG{l+m+mi}{98}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C14}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C23}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C24}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C23}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C24}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Ths} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a box with one hole and two regions}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayer} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{XX} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ} \PYG{o}{=} \PYG{k+kr}{z}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r3} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{;}  \PYG{c+c1}{//the triangles of uppper surface mesh}
                        \PYG{c+c1}{//generated by the triangle in the 2D region}
                        \PYG{c+c1}{//of mesh Th of label 4 as label 12}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r4} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{]}\PYG{p}{;}  \PYG{c+c1}{//the triangles of lower surface mesh}
                        \PYG{c+c1}{//generated by the triangle in the 2D region}
                        \PYG{c+c1}{//of mesh Th of label 4 as label 45.}

\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{MaxLayer}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{,}
    \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{,} \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{r3}\PYG{p}{,} \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{r4}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{box 2 regions 1 hole}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a sphere with TetGen}
\PYG{k+kt}{func} \PYG{n}{XX1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY1} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{test} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paACQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{test} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sph} \PYG{o}{=} \PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{switch}\PYG{o}{=}\PYG{n}{test}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sphere 2 regions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Meshing examples}
\label{\detokenize{documentation/meshGeneration:meshing-examples-1}}\label{\detokenize{documentation/meshGeneration:id13}}
\begin{sphinxadmonition}{tip}{Tip:}
Lake

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// 3D mesh}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rlow} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,}
    \PYG{k+kp}{coef}\PYG{o}{=}\PYG{k+kr}{max}\PYG{p}{(}\PYG{p}{(}\PYG{n}{zmax}\PYG{o}{\PYGZhy{}}\PYG{n}{zmin}\PYG{p}{)}\PYG{o}{/}\PYG{n}{zmax}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{,}
    \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,}\PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,}
    \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,}
    \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{rlow}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Hole region

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ]\PYGZhy{}pi/2, pi/2[X]0,2pi[}

\PYG{c+c1}{// 3D mesh}
\PYG{c+c1}{//parametrization of a sphere}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//partial derivative of the parametrization}
\PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{//M = DF\PYGZca{}t DF}
\PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//construction of the surface of spheres}
\PYG{k+kt}{real} \PYG{n}{Rmin} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f3}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th3sph} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1min}\PYG{p}{,} \PYG{n}{f2min}\PYG{p}{,} \PYG{n}{f3min}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{Rmax} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1max} \PYG{o}{=} \PYG{n}{Rmax}\PYG{o}{*}\PYG{n}{f1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2max} \PYG{o}{=} \PYG{n}{Rmax}\PYG{o}{*}\PYG{n}{f2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3max} \PYG{o}{=} \PYG{n}{Rmax}\PYG{o}{*}\PYG{n}{f3}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th3sph2} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1max}\PYG{p}{,} \PYG{n}{f2max}\PYG{p}{,} \PYG{n}{f3max}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//gluing meshse}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n}{Th3sph} \PYG{o}{+} \PYG{n}{Th3sph2}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ TetGen call without hole }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{18}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3fin} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQYY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain2}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sphere with two regions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3fin}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ TetGen call with hole }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{hole} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{53}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3finhole} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQYY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{k+kp}{nbofholes}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{holelist}\PYG{o}{=}\PYG{n}{hole}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sphere with a hole}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3finhole}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Build a 3d mesh of a cube with a balloon}
\label{\detokenize{documentation/meshGeneration:build-a-3d-mesh-of-a-cube-with-a-balloon}}
First the \sphinxcode{\sphinxupquote{MeshSurface.idp}} file to build boundary mesh of a Hexaedra and of a Sphere:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{mesh3} \PYG{n+nf}{SurfaceHex} \PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{k+kp}{B}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{L}\PYG{p}{,} \PYG{k+kt}{int} \PYG{k+kp}{orientation}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x1} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{z0} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{z1} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nz} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{mesh} \PYG{n}{Thx} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{ny}\PYG{p}{,} \PYG{n}{nz}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{z0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZhy{}}\PYG{n}{z0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh} \PYG{n}{Thy} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,} \PYG{n}{nz}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{z0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZhy{}}\PYG{n}{z0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh} \PYG{n}{Thz} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{refx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{refX} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//Xmin, Ymax faces labels renumbering}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{refy} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{refY} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//Ymin, Ymax faces labesl renumbering}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{refz} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{refZ} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//Zmin, Zmax faces labels renumbering}

    \PYG{k+kt}{mesh3} \PYG{n}{Thx0} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thx}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{x0}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refx}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Thx1} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thx}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{x1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{+}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refX}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Thy0} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thy}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{+}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refy}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Thy1} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thy}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refY}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Thz0} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thz}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{z0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refz}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Thz1} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thz}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{z1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{+}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refZ}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Thx0} \PYG{o}{+} \PYG{n}{Thx1} \PYG{o}{+} \PYG{n}{Thy0} \PYG{o}{+} \PYG{n}{Thy1} \PYG{o}{+} \PYG{n}{Thz0} \PYG{o}{+} \PYG{n}{Thz1}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{Th}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{mesh3} \PYG{n+nf}{Sphere} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{R}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{h}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{L}\PYG{p}{,} \PYG{k+kt}{int} \PYG{k+kp}{orientation}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//]\PYGZhy{}pi/2, pi/2[X]0,2pi[}

    \PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}

    \PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//to store the periodic condition}

    \PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{n}{h}\PYG{o}{/}\PYG{n}{R}\PYG{p}{;} \PYG{c+c1}{//hh mesh size on unite sphere}
    \PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ref} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{mesh3} \PYG{n}{ThS} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1}\PYG{o}{*}\PYG{n}{R}\PYG{p}{,} \PYG{n}{f2}\PYG{o}{*}\PYG{n}{R}\PYG{p}{,} \PYG{n}{f3}\PYG{o}{*}\PYG{n}{R}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{n}{refface}\PYG{o}{=}\PYG{n}{ref}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{ThS}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The test of the two functions and the call to \sphinxcode{\sphinxupquote{TetGen}} mesh generator:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MeshSurface.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hs} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{c+c1}{//mesh size on sphere}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{N} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{ThH} \PYG{o}{=} \PYG{n}{SurfaceHex}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{ThS} \PYG{o}{=} \PYG{n}{Sphere}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{ThHS} \PYG{o}{=} \PYG{n}{ThH} \PYG{o}{+} \PYG{n}{ThS}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hex\PYGZhy{}Sphere}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ThHS}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{voltet} \PYG{o}{=} \PYG{p}{(}\PYG{n}{hs}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{voltet = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{voltet} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{ThHS}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pqaAAYYQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cube with ball}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_CubeSphere1}.png}
\caption{The surface mesh of the hex with internal sphere}\label{\detokenize{documentation/meshGeneration:id33}}\label{\detokenize{documentation/meshGeneration:meshgenerationcubesphere1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_CubeSphere2}.png}
\caption{The tetrahedral mesh of the cube with internal ball}\label{\detokenize{documentation/meshGeneration:id34}}\label{\detokenize{documentation/meshGeneration:meshgenerationcubesphere2}}\end{subfigure}
\caption{Cube sphere}

\end{figure}



\subsubsection{Medit}
\label{\detokenize{documentation/meshGeneration:medit}}\label{\detokenize{documentation/meshGeneration:CubeSphere}}
The keyword \sphinxcode{\sphinxupquote{medit}} allows to display a mesh alone or a mesh and one or several functions defined on the mesh using the Pascal Frey’s freeware \sphinxcode{\sphinxupquote{medit}}.
\sphinxcode{\sphinxupquote{medit}} opens its own window and uses OpenGL extensively.
Naturally to use this command \sphinxcode{\sphinxupquote{medit}} must be installed.

A vizualisation with \sphinxcode{\sphinxupquote{medit}} of scalar solutions \(f1\) and \(f2\) continuous, piecewise linear and known at the vertices of the mesh Th is obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol1 sol2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The first plot named \sphinxcode{\sphinxupquote{sol1}} display f1.
The second plot names \sphinxcode{\sphinxupquote{sol2}} display f2.

The arguments of the function \sphinxcode{\sphinxupquote{medit}} are the name of the differents scenes (separated by a space) of \sphinxcode{\sphinxupquote{medit}}, a mesh and solutions.

Each solution is associated with one scene.
The scalar, vector and symmetric tensor solutions are specified in the format described in the section dealing with the keyword \sphinxcode{\sphinxupquote{savesol}}.

The parameters of this command line are :
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{order=}} 0 if the solution is given at the center of gravity of elements.}] \leavevmode
1 is the solution is given at the vertices of elements.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{meditff=}} set the name of execute command of medit.}] \leavevmode
By default, this string is medit.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{save=}} set the name of a file \sphinxcode{\sphinxupquote{.sol}} or \sphinxcode{\sphinxupquote{.solb}} to save solutions.

\end{itemize}

This command line allows also to represent two differents meshes and solutions on them in the same windows.
The nature of solutions must be the same.
Hence, we can vizualize in the same window the different domains in a domain decomposition method for instance.
A vizualisation with medit of scalar solutions \(h1\) and \(h2\) at vertices of the mesh Th1 and Th2 respectively are obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol2domain}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th1}\PYG{p}{,} \PYG{n}{h1}\PYG{p}{,} \PYG{n}{Th2}\PYG{p}{,} \PYG{n}{h2}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
Medit

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Initial Problem:}
\PYG{c+c1}{// Resolution of the following EDP:}
\PYG{c+c1}{// \PYGZhy{}Delta u\PYGZus{}s = f on \PYGZbs{}Omega = \PYGZob{} (x,y) \textbar{} 1 \PYGZlt{}= sqrt(x\PYGZca{}2+y\PYGZca{}2) \PYGZlt{}= 2 \PYGZcb{}}
\PYG{c+c1}{// \PYGZhy{}Delta u\PYGZus{}1 = f1 on \PYGZbs{}Omega\PYGZus{}1 = \PYGZob{} (x,y) \textbar{} 0.5 \PYGZlt{}= sqrt(x\PYGZca{}2+y\PYGZca{}2) \PYGZlt{}= 1. \PYGZcb{}}
\PYG{c+c1}{// u = 1 on Gamma}
\PYG{c+c1}{// Null Neumman condition on Gamma\PYGZus{}1 and on Gamma\PYGZus{}2}
\PYG{c+c1}{// We find the solution u by solving two EDP defined on domain Omega and Omega\PYGZus{}1}
\PYG{c+c1}{// This solution is visualize with medit}

\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Omega}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma2}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Omega\PYGZus{}1}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{us}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh1}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad2}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Lap2dOmega} \PYG{p}{(}\PYG{n}{us}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{us}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{Lap2dOmega1} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f1}\PYG{o}{*}\PYG{n}{v1}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Lap2dOmega}\PYG{p}{;}
\PYG{n}{Lap2dOmega1}\PYG{p}{;}

\PYG{c+c1}{// Plot with medit}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{us}\PYG{p}{,} \PYG{n}{Th1}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{save}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{testsavemedit.solb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Mshmet}
\label{\detokenize{documentation/meshGeneration:mshmet}}\label{\detokenize{documentation/meshGeneration:meshgenerationmshmet}}
Mshmet is a software developed by P. Frey that allows to compute an anisotropic metric based on solutions (i.e. Hessian-based).
This software can return also an isotropic metric.
Moreover, \sphinxcode{\sphinxupquote{mshmet}} can also construct a metric suitable for levelset interface capturing.
The solution can be defined on 2D or 3D structured/unstructured meshes.
For example, the solution can be an error estimate of a FE solution.

Solutions for \sphinxcode{\sphinxupquote{mshmet}} are given as an argument.
The solution can be a \sphinxcode{\sphinxupquote{func}}, a vector \sphinxcode{\sphinxupquote{func}}, a symmetric tensor, a \sphinxcode{\sphinxupquote{fespace}} function, a \sphinxcode{\sphinxupquote{fespace}} vector function and a \sphinxcode{\sphinxupquote{fespace}} symmetric tensor.
The symmetric tensor argument is defined as this type of data for datasol argument.
This software accepts more than one solution.

For example, the metric \(M\) computed with \sphinxcode{\sphinxupquote{mshmet}} for the solution \(u\) defined on the mesh \(Th\) is obtained by writing:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//a scalar fespace function}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{M} \PYG{o}{=} \PYG{n+nf}{mshmet}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The parameters of the keyword \sphinxcode{\sphinxupquote{mshmet}} are :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{normalization =}} (b) do a normalization of all solution in \([0,1]\).

\item {} 
\sphinxcode{\sphinxupquote{aniso =}} (b) build anisotropic metric if 1 (default 0: isotropic)

\item {} 
\sphinxcode{\sphinxupquote{levelset =}} (b) build metric for levelset method (default: \sphinxcode{\sphinxupquote{false}})

\item {} 
\sphinxcode{\sphinxupquote{verbosity =}} (l) level of verbosity

\item {} 
\sphinxcode{\sphinxupquote{nbregul =}} (l) number of regularization’s iteration of solutions given (default 0).

\item {} 
\sphinxcode{\sphinxupquote{hmin =}} (d)

\item {} 
\sphinxcode{\sphinxupquote{hmax =}} (d)

\item {} 
\sphinxcode{\sphinxupquote{err =}} (d) level of error.

\item {} 
\sphinxcode{\sphinxupquote{width =}} (d) the width

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric =}} a vector of double.}] \leavevmode
This vector contains an initial metric given to \sphinxcode{\sphinxupquote{mshmet}}.
The structure of the metric vector is described in the next paragraph.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{loptions =}} a vector of integer of size 7.}] \leavevmode
This vector contains the integer parameters of \sphinxcode{\sphinxupquote{mshmet}} (for expert only).
\begin{itemize}
\item {} 
loptions(0): normalization (default 1).

\item {} \begin{description}
\item[{loptions(1): isotropic parameters (default 0).}] \leavevmode
1 for isotropic metric results otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(2): level set parameters (default 0).}] \leavevmode
1 for building level set metric otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(3): debug parameters (default 0).}] \leavevmode
1 for turning on debug mode otherwise 0.

\end{description}

\item {} 
loptions(4): level of verbosity (default 10).

\item {} 
loptions(5): number of regularization’s iteration of solutions given (default 0).

\item {} \begin{description}
\item[{loptions(6): previously metric parameter (default 0).}] \leavevmode
1 for using previous metric otherwise 0.

\end{description}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{doptions=}} a vector of double of size 4.}] \leavevmode
This vector contains the real parameters of \sphinxcode{\sphinxupquote{mshmet}} (for expert only).
\begin{itemize}
\item {} 
doptions(0): hmin : min size parameters (default 0.01).

\item {} 
doptions(1): hmax : max size parameters (default 1.0).

\item {} 
doptions(2): eps : tolerance parameters (default 0.01).

\item {} 
doptions(2): width : relative width for Level Set (\(0<w<1\)) (default 0.05).

\end{itemize}

\end{description}

\end{itemize}

The result of the keyword \sphinxcode{\sphinxupquote{mshmet}} is a \sphinxcode{\sphinxupquote{real{[}int{]}}} which contains the metric computed by \sphinxcode{\sphinxupquote{mshmet}} at the different vertices \(V_{i}\) of the mesh.

With \(nv\) is the number of vertices, the structure of this vector is:
\begin{equation*}
\begin{split}M_{iso}= (m(V_0), m(V_1), \ldots, m(V_{nv}))^t\end{split}
\end{equation*}
for a isotropic metric \(m\).
For a symmetric tensor metric \(h=\left(\begin{array}{ccc} m_{1 1} & m_{1 2} & m_{1 3}\\ m_{2 1} & m_{2 2} & m_{2 3} \\ m_{3 1} & m_{3 2} & m_{3 3} \end{array}\right)\) , the parameters \sphinxcode{\sphinxupquote{metric}} is:
\begin{equation*}
\begin{split}M_{aniso}= (H(V_{0}), \ldots, H(V_{nv}) )^t\end{split}
\end{equation*}
where \(H(V_{i})\) is the vector of size 6 defined by \([m11,m21,m22,m31,m32,m33]\)

\begin{sphinxadmonition}{tip}{Tip:}
mshmet

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mshmet}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayer} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{MaxLayer}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh3}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh3} \PYG{n}{u3}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh3P1}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh3P1} \PYG{n}{usol}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Problem2}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u3}\PYG{o}{*}\PYG{n}{v3}\PYG{o}{*}\PYG{l+m+mf}{1.0e\PYGZhy{}10}
        \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{v3}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Problem2}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u3}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u3}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sol}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb} \PYG{o}{=} \PYG{n+nf}{mshmet}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Metric:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{usol}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Metric}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{usol}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{FreeYams}
\label{\detokenize{documentation/meshGeneration:freeyams}}
FreeYams is a surface mesh adaptation software which is developed by P. Frey.
This software is a new version of yams.
The adapted surface mesh is constructed with a geometric metric tensor field.
This field is based on the intrinsic properties of the discrete surface.

Also, this software allows to construct a simplification of a mesh.
This decimation is based on the Hausdorff distance between the initial and the current triangulation.
Compared to the software yams, FreeYams can be used also to produce anisotropic triangulations adapted to levelset simulations.
A technical report on freeYams documentation is available \sphinxhref{https://www.ljll.math.upmc.fr/frey/publications/RT-0252.pdf}{here}.

To call FreeYams in \sphinxstylestrong{FreeFem++}, we used the keyword \sphinxcode{\sphinxupquote{freeyams}}.
The arguments of this function are the initial mesh and/or metric.
The metric with \sphinxcode{\sphinxupquote{freeyams}} are a \sphinxcode{\sphinxupquote{func}}, a \sphinxcode{\sphinxupquote{fespace}} function, a symmetric tensor function, a symmetric tensor \sphinxcode{\sphinxupquote{fespace}} function or a vector of double (\sphinxcode{\sphinxupquote{real{[}int{]}}}).
If the metric is a vector of double, this data must be given in \sphinxcode{\sphinxupquote{metric}} parameter.
Otherwise, the metric is given in the argument.

For example, the adapted mesh of \sphinxcode{\sphinxupquote{Thinit}} defined by the metric \(u\) defined as \sphinxcode{\sphinxupquote{fespace}} function is obtained by writing:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Thinit}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{freeyams}\PYG{p}{(}\PYG{n}{Thinit}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The symmetric tensor argument for \sphinxcode{\sphinxupquote{freeyams}} keyword is defined as this type of data for datasol argument.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{aniso=}} (b) aniso or iso metric (default 0, iso)

\item {} 
\sphinxcode{\sphinxupquote{mem=}} (l) memory of for freeyams in Mb (default -1,
freeyams choose)

\item {} 
\sphinxcode{\sphinxupquote{hmin=}} (d)

\item {} 
\sphinxcode{\sphinxupquote{hmax=}} (d)

\item {} 
\sphinxcode{\sphinxupquote{gradation=}} (d)

\item {} 
\sphinxcode{\sphinxupquote{option=}} (l)
\begin{itemize}
\item {} 
0 : mesh optimization (smoothing+swapping)

\item {} 
1 : decimation+enrichment adaptated to a metric map. (default)

\item {} 
-1 : decimation adaptated to a metric map.

\item {} 
2 : decimation+enrichment with a Hausdorff-like method

\item {} 
-2 : decimation with a Hausdorff-like method

\item {} 
4 : split triangles recursively.

\item {} 
9 : No-Shrinkage Vertex Smoothing

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{ridgeangle=}} (d)

\item {} 
\sphinxcode{\sphinxupquote{absolute=}} (b)

\item {} 
\sphinxcode{\sphinxupquote{verbosity=}} (i)

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric=}} vector expression.}] \leavevmode
This parameters contains the metric at the different vertices on the initial mesh.
With \(nv\) is the number of vertices, this vector is:

\end{description}
\begin{equation*}
\begin{split}M_{iso}= ( m(V_0), m(V_1), \ldots, m(V_{nv}) )^t\end{split}
\end{equation*}
for a scalar metric \(m\).
For a symmetric tensor metric
\(h=\left(\begin{array}{ccc} m_{1 1} & m_{1 2} & m_{1 3}\\ m_{2 1} & m_{2 2} & m_{2 3} \\ m_{3 1} & m_{3 2} & m_{3 3} \end{array}\right)\), the parameters \sphinxcode{\sphinxupquote{metric}} is:
\begin{equation*}
\begin{split}M_{aniso}= ( H(V_{0}), \ldots, H(V_{nv}) )^t\end{split}
\end{equation*}
where \(H(V_{i})\) is the vector of size 6 defined by \([m11,m21,m22,m31,m32,m33]\)

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{loptions=}} a vector of integer of size 13.}] \leavevmode
This vectors contains the integer options of FreeYams. (just for the expert)
\begin{itemize}
\item {} \begin{description}
\item[{loptions(0): anisotropic parameter (default 0).}] \leavevmode
If you give an anisotropic metric 1 otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(1): Finite Element correction parameter (default 0).}] \leavevmode
1 for \sphinxstyleemphasis{no} Finite Element correction otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(2): Split multiple connected points parameter (default 1).}] \leavevmode
1 for splitting multiple connected points otherwise 0.

\end{description}

\item {} 
loptions(3): maximum value of memory size in Mbytes (default -1: the size is given by freeyams).

\item {} \begin{description}
\item[{loptions(4): set the value of the connected component which we want to obtain.}] \leavevmode
(Remark: freeyams give an automatic value at each connected component).

\end{description}

\item {} 
loptions(5): level of verbosity

\item {} \begin{description}
\item[{loptions(6): Create point on straight edge (no mapping) parameter (default 0).}] \leavevmode
1 for creating point on straight edge otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(7): validity check during smoothing parameter.}] \leavevmode
This parameter is only used with No-Shrinkage Vertex Smoothing optimization (optimization option parameter 9).
1 for No validity checking during smoothing otherwise 0.

\end{description}

\item {} 
loptions(8): number of desired’s vertices (default -1).

\item {} 
loptions(9): number of iteration of optimizations (default 30).

\item {} \begin{description}
\item[{loptions(10): no detection parameter (default 0).}] \leavevmode
1 for detecting the ridge on the mesh otherwise 0.
The ridge definition is given in the parameter doptions(12).

\end{description}

\item {} \begin{description}
\item[{loptions(11): no vertex smoothing parameter (default 0).}] \leavevmode
1 for smoothing the vertices otherwise 0.

\end{description}

\item {} 
loptions(12): Optimization level parameter (default 0).

\end{itemize}
\begin{itemize}
\item {} 
0 : mesh optimization (smoothing+swapping)

\item {} 
1 : decimation+enrichment adaptated to a metric map.

\item {} 
-1: decimation adaptated to a metric map.

\item {} 
2 : decimation+enrichment with a Hausdorff-like method

\item {} 
-2: decimation with a Hausdorff-like method

\item {} 
4 : split triangles recursively.

\item {} 
9 : No-Shrinkage Vertex Smoothing

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{doptions=}} a vector of double of size 11.}] \leavevmode
This vectors contains the real options of freeyams.

\end{description}
\begin{itemize}
\item {} 
doptions(0): Set the geometric approximation (Tangent plane deviation) (default 0.01).

\item {} 
doptions(1): Set the lamda parameter (default -1).

\item {} 
doptions(2): Set the mu parmeter (default -1).

\item {} 
doptions(3): Set the gradation value (Mesh density control) (default 1.3).

\item {} 
doptions(4): Set the minimal size(hmin) (default -2.0: the size is automatically computed).

\item {} 
doptions(5): Set the maximal size(hmax) (default -2.0: the size is automatically computed).

\item {} 
doptions(6): Set the tolerance of the control of Chordal deviation (default -2.0).

\item {} 
doptions(7): Set the quality of degradation (default 0.599).

\item {} 
doptions(8): Set the declic parameter (default 2.0).

\item {} 
doptions(9): Set the angular walton limitation parameter (default 45 degree).

\item {} 
doptions(10): Set the angular ridge detection (default 45 degree).

\end{itemize}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
freeyams

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{freeyams}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rdown} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{reffaceup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow}\PYG{o}{=}\PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{freeyams}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SurfaceMesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{mmg3d}
\label{\detokenize{documentation/meshGeneration:mmg3d}}
\begin{sphinxadmonition}{note}{\label{documentation/meshGeneration:index-0}Todo:}
mmg3d-v4.0
\end{sphinxadmonition}

\sphinxhref{http://www.mmgtools.org}{Mmg3d} is a 3D remeshing software developed by C. Dobrzynski and P. Frey.

This software allows to remesh an initial mesh made of tetrahedra.
This initial mesh is adapted to a geometric metric tensor field or to a displacement vector (moving rigid body).
The metric can be obtained with {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationmshmet}]{\sphinxcrossref{\DUrole{std,std-ref}{mshmet}}}}.

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
If no metric is given, an isotropic metric is computed by analyzing the size of the edges in the initial mesh.

\item {} 
If a displacement is given, the vertices of the surface triangles are moved without verifying the geometrical structure of the new surface mesh.

\end{itemize}
\end{sphinxadmonition}

The parameters of \sphinxcode{\sphinxupquote{mmg3d}} are :
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{options=}} vector expression.}] \leavevmode
This vector contains the option parameters of \sphinxcode{\sphinxupquote{mmg3d}}.
It is a vector of 6 values, with the following meaning:

\end{description}
\begin{itemize}
\item {} 
Optimization parameters : (default 1)

0 : mesh optimization.

1 : adaptation with metric (deletion and insertion vertices) and optimization.

-1 : adaptation with metric (deletion and insertion vertices) without optimization.

4 : split tetrahedra (be careful modify the surface).

9 : moving mesh with optimization.

-9 : moving mesh without optimization.

\item {} 
Debug mode : (default 0)

1 : turn on debug mode.

0 : otherwise.

\item {} 
Specify the size of bucket per dimension (default 64)

\item {} 
Swapping mode : (default 0)

1 : no edge or face flipping.

0 : otherwise.

\item {} 
Insert points mode : (default 0)

1 : no edge splitting or collapsing and no insert points.

0 : otherwise.

\end{itemize}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{4}
\item {} 
Verbosity level (default 3)

\end{enumerate}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{memory=}} integer expression.}] \leavevmode
Set the maximum memory size of new mesh in Mbytes.
By default the number of maximum vertices, tetrahedra and triangles are respectively 500 000, 3000 000, 100000 which represent approximately a memory of 100 Mo.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric=}} vector expression.}] \leavevmode
This vector contains the metric given at \sphinxcode{\sphinxupquote{mmg3d}}.
It is a vector of size \(nv\) or 6 \(nv\) respectively for an isotropic and anisotropic metric where \(nv\) is the number of vertices in the initial mesh.
The structure of \sphinxcode{\sphinxupquote{metric}} vector is described in the {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationmshmet}]{\sphinxcrossref{\DUrole{std,std-ref}{mshmet}}}}.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{displacement=}} \([\Phi1, \Phi2, \Phi3]\) set the displacement vector of the initial mesh \(\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]\).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{displVect=}} sets the vector displacement in a vector expression.}] \leavevmode
This vector contains the displacement at each point of the initial mesh.
It is a vector of size 3 \(nv\).

\end{description}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
mmg3d

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mmg3d}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cube.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Nxyz} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Bxyz} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Lxyz} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Cube}\PYG{p}{(}\PYG{n}{Nxyz}\PYG{p}{,} \PYG{n}{Bxyz}\PYG{p}{,} \PYG{n}{Lxyz}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{isometric}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{isometric}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.17}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{mmg3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{memory}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kp}{metric}\PYG{o}{=}\PYG{n}{isometric}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Initial}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Isometric}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Falling spheres

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mmg3d}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MeshSurface.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hs} \PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{N} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{o}{/}\PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{o}{/}\PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mf}{11.5}\PYG{o}{/}\PYG{n}{hs}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{l+m+mi}{311}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{l+m+mi}{311}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{l+m+mi}{311}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{opt} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vit}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zero} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{dep} \PYG{o}{=} \PYG{n}{vit}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{ThH} \PYG{o}{=} \PYG{n}{SurfaceHex}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{ThSg} \PYG{o}{=} \PYG{n}{Sphere}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{300}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{ThSd} \PYG{o}{=} \PYG{n}{Sphere}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{310}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ThSd} \PYG{o}{=} \PYG{n}{movemesh3}\PYG{p}{(}\PYG{n}{ThSd}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{ThHS} \PYG{o}{=} \PYG{n}{ThH} \PYG{o}{+} \PYG{n}{ThSg} \PYG{o}{+} \PYG{n}{ThSd}\PYG{p}{;}\PYG{c+c1}{//gluing surface meshes}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThHS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ThHS}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{voltet} \PYG{o}{=} \PYG{p}{(}\PYG{n}{hs}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{holes} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{ThHS}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pqaAAYYQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domaine}\PYG{p}{,} \PYG{k+kp}{nbofholes}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{holelist}\PYG{o}{=}\PYG{n}{holes}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Box\PYGZhy{}With\PYGZhy{}two\PYGZhy{}Ball}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Lap} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{310}\PYG{p}{,} \PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{n}{dep}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Falling loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{it} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{it} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{29}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ITERATION }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{Lap}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Sphere falling}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{mmg3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{options}\PYG{o}{=}\PYG{n}{opt}\PYG{p}{,} \PYG{k+kp}{displacement}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zero}\PYG{p}{,} \PYG{n}{zero}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{memory}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{A first 3d isotrope mesh adaptation process}
\label{\detokenize{documentation/meshGeneration:a-first-3d-isotrope-mesh-adaptation-process}}\label{\detokenize{documentation/meshGeneration:meshfirstisotropemeshadaptation}}
\begin{sphinxadmonition}{tip}{Tip:}
Adaptation 3D

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mshmet}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l1111} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//labels}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l01} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l11} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{errm} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}2}\PYG{p}{;} \PYG{c+c1}{//level of error}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l1111}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{l11}\PYG{p}{,} \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{l01}\PYG{p}{,} \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{l01}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{\textbar{}} \PYG{p}{(}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{\textbar{}} \PYG{p}{(}\PYG{k+kr}{z} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//remove the ]0.5,1[\PYGZca{}3 cube}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{usol}\PYG{p}{,} \PYG{n}{h}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve}
    \PYG{n}{Poisson}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u min, max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{h}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{c+c1}{//for resizing h[] because the mesh change}
    \PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{mshmet}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{normalization}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{aniso}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{nbregul}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{hmin}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{,} \PYG{k+kp}{hmax}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{errm}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{h min, max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{errm} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{;} \PYG{c+c1}{//change the level of error}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nv} \PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nt} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{tetgreconstruction}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{raAQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{sizeofvolume}\PYG{o}{=}\PYG{n}{h}\PYG{o}{*}\PYG{n}{h}\PYG{o}{*}\PYG{n}{h}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//rebuild mesh}
    \PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{U\PYGZhy{}adap\PYGZhy{}iso\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{ii}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Build a 2d mesh from a isoline}
\label{\detokenize{documentation/meshGeneration:build-a-2d-mesh-from-a-isoline}}
The idea is to get the discretization of an isoline of fluid meshes, this tool can be useful to construct meshes from image.
First, we give an example of the isovalue meshes \(0.2\) of analytical function \(\sqrt{(x-1/2)^2 +(y-1/2)^2}\), on unit square.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{isoline}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the isoline points}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the begin, end couple of lines}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{iso} \PYG{o}{=} \PYG{l+m+mf}{0.2} \PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso} \PYG{o}{=} \PYG{p}{[}\PYG{k+kp}{iso}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{,}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//to see the iso line}

    \PYG{k+kt}{int} \PYG{n}{nbc} \PYG{o}{=} \PYG{n+nf}{isoline}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{xy}\PYG{p}{,} \PYG{k+kp}{close}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{iso}\PYG{o}{=}\PYG{k+kp}{iso}\PYG{p}{,} \PYG{k+kp}{beginend}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{,} \PYG{k+kp}{smoothing}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{isoline}} parameters are \sphinxcode{\sphinxupquote{Th}} the mesh, the expression \(u\), the bidimentionnal array \sphinxcode{\sphinxupquote{xy}} to store the list coordinate of the points.
The list of named parameter are :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{iso=}} value of the isoline to compute (0 is the default value)

\item {} 
\sphinxcode{\sphinxupquote{close=}} close the isoline with the border (default \sphinxcode{\sphinxupquote{true}}), we add the part of the mesh border such the value is less than the isovalue

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{smoothing=}} number of smoothing process is the \({l} ^{r} {s}\) where \(l\) is the length of the current line component, \(r\) the ratio, \(s\) is smoothing value.}] \leavevmode
The smoothing default value is 0.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{ratio=}} the ratio (1 by default).

\item {} 
\sphinxcode{\sphinxupquote{eps=}} relative \(\varepsilon\) (default 1e-10)

\item {} 
\sphinxcode{\sphinxupquote{beginend=}} array to get begin, end couple of each of sub line (resize automatically)

\item {} 
\sphinxcode{\sphinxupquote{file=}} to save the data curve in data file for gnuplot

\end{itemize}

In the array \sphinxcode{\sphinxupquote{xy}} you get the list of vertices of the isoline, each connex line go from \(i= i_0^c ,\dots, i_1^c-1\) with \(i_0^c =be(2*c)\) \(i_1^c =be(2*c+1)\), and where \(x_i= xy(0,i), y_i=yx( 1,i), l_i=xy(2,i)\).

Here \(l_i\) is the length of the line (the origin of the line is point \(i_0^c\)).

The sense of the isoline is such that the upper part is at the left size of the isoline.
So here : the minimum is a point \(0.5,05\) so the curve 1 turn in the clockwise sense, the order of each component are sort such that the number of point by component is decreasing.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of the line component = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nbc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of points = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{.}\PYG{k+kr}{m} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{be = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{be} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

      \PYG{c+c1}{// shows the lines component}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{nbc}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{int} \PYG{n}{i0} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,} \PYG{n}{i1} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
         \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Curve }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
         \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{i0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{i1}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ y= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ s= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
         \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nl}{i0}\PYG{o}{:}\PYG{n}{i1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nl}{i0}\PYG{o}{:}\PYG{n}{i1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ curve }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{length of last curve = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{xy}\PYG{p}{.}\PYG{k+kr}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

We also have a new function to easily parametrize a discrete curve defined by the couple \(be, xy\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{Curve0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//component 0}
    \PYG{k+kt}{int} \PYG{n}{i0}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,} \PYG{n}{i1}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kr}{P}\PYG{o}{=}\PYG{n}{Curve}\PYG{p}{(}\PYG{n}{xy}\PYG{p}{,} \PYG{n}{i0}\PYG{p}{,} \PYG{n}{i1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Curve 0}
    \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{Curve1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//component 1}
    \PYG{k+kt}{int} \PYG{n}{i0}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,} \PYG{n}{i1}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kr}{P}\PYG{o}{=}\PYG{n}{Curve}\PYG{p}{(}\PYG{n}{xy}\PYG{p}{,} \PYG{n}{i0}\PYG{p}{,} \PYG{n}{i1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Curve 1}
    \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Curve1}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//show curve}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Curve1}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Secondly, we use this idea to build meshes from an image, we use the plugins \sphinxcode{\sphinxupquote{ppm2rnm}} to read \sphinxcode{\sphinxupquote{pgm}} a gray scale image and then we extract the gray contour at level 0.25.

\begin{sphinxadmonition}{tip}{Tip:}
Leman lake

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ppm2rnm}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{isoline}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{string} \PYG{n}{leman} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LemanLake.pgm}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{AreaLac} \PYG{o}{=} \PYG{l+m+mf}{580.03}\PYG{p}{;} \PYG{c+c1}{//in km\PYGZca{}2}
\PYG{k+kt}{real} \PYG{n}{hsize} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nc}\PYG{p}{;} \PYG{c+c1}{//nb of curve}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ff1}\PYG{p}{(}\PYG{n}{leman}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//read image}
    \PYG{c+c1}{//and set it in a rect. array}
    \PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{n}{ff1}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{,} \PYG{n}{ny} \PYG{o}{=} \PYG{n}{ff1}\PYG{p}{.}\PYG{k+kr}{m}\PYG{p}{;}
    \PYG{c+c1}{//build a Cartesian mesh such that the origin is in the right place.}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//warning the numbering of the vertices (x,y) is}
    \PYG{c+c1}{//given by \PYGZdl{}i = x/nx + nx* y/ny \PYGZdl{}}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{f1}\PYG{p}{;}
    \PYG{n}{f1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ff1}\PYG{p}{;} \PYG{c+c1}{//transform array in finite element functions.}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n+nf}{isoline}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,} \PYG{k+kp}{iso}\PYG{o}{=}\PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{k+kp}{close}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Curves}\PYG{p}{,} \PYG{k+kp}{beginend}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{,} \PYG{k+kp}{smoothing}\PYG{o}{=}\PYG{l+m+mf}{.1}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//The longest isoline: the lake}
\PYG{k+kt}{int} \PYG{n}{ic0} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ic1} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{NC} \PYG{o}{=} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{ic1}\PYG{p}{)}\PYG{o}{/}\PYG{n}{hsize}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{xl} \PYG{o}{=} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{yl} \PYG{o}{=} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{G}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{P}\PYG{o}{=}\PYG{n}{Curve}\PYG{p}{(}\PYG{n}{Curves}\PYG{p}{,} \PYG{n}{ic0}\PYG{p}{,} \PYG{n}{ic1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZgt{}}\PYG{n}{xl}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{n}{yl}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{G}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{G}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{scale} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{AreaLac}\PYG{o}{/}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{scale}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{scale}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th.area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{area} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Km\PYGZca{}2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{AreaLac} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Km\PYGZca{}2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{leman.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Isoline1}.jpg}
\caption{The image of the Leman lake meshes}\label{\detokenize{documentation/meshGeneration:id35}}\label{\detokenize{documentation/meshGeneration:meshgenerationisoline1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Isoline2}.png}
\caption{The mesh of the lake}\label{\detokenize{documentation/meshGeneration:id36}}\label{\detokenize{documentation/meshGeneration:meshgenerationisoline2}}\end{subfigure}
\caption{Isoline}\phantomsection\label{\detokenize{documentation/meshGeneration:Isoline}}

\end{figure}

\end{sphinxadmonition}


\section{Finite element}
\label{\detokenize{documentation/finiteElement:finite-element}}\label{\detokenize{documentation/finiteElement:finiteelement}}\label{\detokenize{documentation/finiteElement::doc}}
As stated in {\hyperref[\detokenize{tutorial/index:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{tutorials}}}}, FEM approximates all functions \(w\) as:
\begin{equation*}
\begin{split}w(x,y)\simeq w_0\phi_0(x,y)+w_1\phi_1(x,y)+\cdots+w_{M-1}\phi_{M-1}(x,y)\end{split}
\end{equation*}
with finite element basis functions \(\phi_k(x,y)\) and numbers \(w_k\) (\(k=0,\cdots,M-1\)).
The functions \(\phi_k(x,y)\) are constructed from the triangle \(T_{i_k}\), and called \sphinxstyleemphasis{shape functions}.

In \sphinxstylestrong{FreeFem++}, the finite element space:
\begin{equation*}
\begin{split}V_h=\left\{w\left|\; w_0\phi_0+w_1\phi_1+\cdots+w_{M-1}\phi_{M-1},\, w_i\in \R\right.\right\}\end{split}
\end{equation*}
is easily created by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{IDspace}\PYG{p}{(}\PYG{n}{IDmesh}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{IDFE}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or with \(\ell\) pairs of periodic boundary conditions in 2D:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{IDspace}\PYG{p}{(}\PYG{n}{IDmesh}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{IDFE}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{n}{la1}\PYG{p}{,} \PYG{n}{sa1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lb1}\PYG{p}{,} \PYG{n}{sb1}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
              \PYG{p}{[}\PYG{n}{lak}\PYG{p}{,} \PYG{n}{sak}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lbk}\PYG{p}{,} \PYG{n}{sbl}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and in 3D:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{IDspace}\PYG{p}{(}\PYG{n}{IDmesh}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{IDFE}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{n}{la1}\PYG{p}{,} \PYG{n}{sa1}\PYG{p}{,} \PYG{n}{ta1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lb1}\PYG{p}{,} \PYG{n}{sb1}\PYG{p}{,} \PYG{n}{tb1}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
              \PYG{p}{[}\PYG{n}{lak}\PYG{p}{,} \PYG{n}{sak}\PYG{p}{,} \PYG{n}{tak}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lbk}\PYG{p}{,} \PYG{n}{sbl}\PYG{p}{,} \PYG{n}{tbl}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{IDspace}} is the name of the space (e.g. \sphinxcode{\sphinxupquote{Vh}}), \sphinxcode{\sphinxupquote{IDmesh}} is the name of the associated mesh and \sphinxcode{\sphinxupquote{\textless{}IDFE\textgreater{}}} is an identifier of finite element type.

In 2D we have a pair of periodic boundary conditions, if \([la_i, sa_i]\), \([lb_i, sb_i]\) is a pair of \sphinxcode{\sphinxupquote{int}}, and the 2 labels \(la_i\) and \(lb_i\) refer to 2 pieces of boundary to be in equivalence.

If \([la_i, sa_i]\), \([lb_i, sb_i]\) is a pair of \sphinxcode{\sphinxupquote{real}}, then \(sa_i\) and \(sb_i\) give two common abscissa on the two boundary curves, and two points are identified as one if the two abscissa are equal.

In 2D, we have a pair of periodic boundary conditions, if \([la_i, sa_i, ta_i]\), \([lb_i, sb_i, tb_i]\) is a pair of \sphinxcode{\sphinxupquote{int}}, the 2 labels \(la_i\) and \(lb_i\) define the 2 pieces of boundary to be in equivalence.

If \([la_i, sa_i, ta_i]\), \([lb_i, sb_i, tb_i]\) is a pair of \sphinxcode{\sphinxupquote{real}}, then \(sa_i\), \(ta_i\) and \(sb_i\), \(tb_i\) give two common parameters on the two boundary surfaces, and two points are identified as one if the two parameters are equal.

\begin{sphinxadmonition}{note}{Note:}
The 2D mesh of the two identified borders must be the same, so to be sure, use the parameter \sphinxcode{\sphinxupquote{fixedborder=true}} in \sphinxcode{\sphinxupquote{buildmesh}} command (see {\hyperref[\detokenize{documentation/meshGeneration:meshborder}]{\sphinxcrossref{\DUrole{std,std-ref}{fixedborder}}}}).
\end{sphinxadmonition}

As of today, the known types of finite elements are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{{[}P0, P03d{]}}} piecewise constant discontinuous finite element (2d, 3d), the degrees of freedom are the barycenter element value.
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:P0}
\begin{split}\P^0_{h} = \left\{ v \in L^2(\Omega) \left|\; \textrm{for all }K \in \mathcal{T}_{h}\;\;\textrm{there is }\alpha_{K}\in \R : \;\; v_{|K} = \alpha_{K } \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P1, P13d{]}}} piecewise linear continuous finite element (2d, 3d), the degrees of freedom are the vertices values.
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:P1}
\begin{split}\P^1_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h},\ v_{|K} \in P_{1} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P1dc{]}}} piecewise linear discontinuous finite element
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:P1dc}
\begin{split}\P^1_{dc|h} = \left\{ v \in L^{2}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{1} \right.\right\}\end{split}
\end{equation}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
Due to an interpolation problem, the degree of freedom is not the vertices but three vertices which move inside \(T(X)= G + .99 (X-G)\) where \(G\) is the barycenter.
\end{sphinxadmonition}

\item {} 
\sphinxcode{\sphinxupquote{{[}P1b, P1b3d{]}}} piecewise linear continuous finite element plus bubble (2d, 3d)

\sphinxstylestrong{The 2D Case:}
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:P1b}
\begin{split}\P^1_{b|h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{1} \oplus \mathrm{Span}\{ \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \} \right.\right\}\end{split}
\end{equation}\end{quote}

\sphinxstylestrong{The 3D Case:}
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:P1b-3d}
\begin{split}\P^1_{b|h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{1} \oplus \mathrm{Span}\{ \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \lambda^{K}_{3} \} \right.\right\}\end{split}
\end{equation}
where \(\lambda^{K}_{i}, i=0,..,d\) are the \(d+1\) barycentric coordinate functions of the element \(K\) (triangle or tetrahedron).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{P1bl,P1bl3d}} piecewise linear continuous finite element plus linear bubble (2d, 3d).

The bubble is built by splitting the \(K\), a barycenter in \(d+1\) sub element. (need \sphinxcode{\sphinxupquote{load "Element\_P1bl"}})

\item {} 
\sphinxcode{\sphinxupquote{{[}P2, P23d{]}}} piecewise \(P_{2}\) continuous finite element (2d, 3d)
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{2} \right.\right\}\end{split}
\end{equation*}
where \(P_{2}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 2\).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P2b{]}}} piecewise \(P_{2}\) continuous finite element plus bubble
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{2} \oplus \mathrm{Span}\{ \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \} \right.\right\}\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P2dc{]}}} piecewise \(P_{2}\) discontinuous finite element
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{dc|h} = \left\{ v \in L^{2}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{2} \right.\right\}\end{split}
\end{equation*}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
Due to an interpolation problem, the degree of freedom is not the six P2 nodes but six nodes which move inside \(T(X)= G + .99 (X-G)\) where \(G\) is the barycenter.
\end{sphinxadmonition}

\item {} 
\sphinxcode{\sphinxupquote{{[}P2h{]}}} quadratic homogeneous continuous (without \sphinxcode{\sphinxupquote{P1}}).

\item {} 
\sphinxcode{\sphinxupquote{{[}P3{]}}} piecewise \(P_{3}\) continuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P3"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^3_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
where \(P_{3}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P3dc{]}}} piecewise \(P_{3}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P3dc"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^3_{dc|h} = \left\{ v \in L^2(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
where \(P_{3}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P4{]}}} piecewise \(P_{4}\) continuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P4"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^4_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h},\ v_{|K} \in P_{4} \right.\right\}\end{split}
\end{equation*}
where \(P_{4}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 4\).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P4dc{]}}} piecewise \(P_{4}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P4dc"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^4_{dc|h} = \left\{ v \in L^2(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
where \(P_{4}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P0Edge{]}}} piecewise \(P_{0}\) discontinuous finite element (2d) contained on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P1Edge{]}}} piecewise \(P_{1}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_1\) on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P2Edge{]}}} piecewise \(P_{2}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_2\) on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P3Edge{]}}} piecewise \(P_{3}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_3\) on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P4Edge{]}}} piecewise \(P_{4}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_4\) on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P5Edge{]}}} piecewise \(P_{5}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_5\) on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P2Morley{]}}} piecewise \(P_{2}\) non conform finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Morley"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{h} = \left\{ v \in L^2(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3},
\left\{\begin{array}{c}
    v \mbox{ continuous at vertices,}\\
    \p_n{v} \mbox{ continuous at middle of edge,}
\end{array}\right.
\right.\right\}\end{split}
\end{equation*}
where \(P_{2}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 2\).

\begin{sphinxadmonition}{warning}{Warning:}
To build the interplant of a function \(u\) (scalar) for this finite element, we need the function and 2 partial derivatives \((u,u_x, u_y)\), creating this vectorial finite element with 3 components \((u,u_x,u_y)\).
\end{sphinxadmonition}

See our example for solving the BiLaplacien problem:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Morley}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2Morley}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//The Morley finite element space}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vx}\PYG{p}{,} \PYG{n}{vy}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{bilaplacien}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n+nf}{dxy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dxy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n}{bilap} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vx}\PYG{p}{,} \PYG{n}{vy}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{bilaplacien}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ux}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}HCT{]}}} \(P_3\) \(C^1\) conforms finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_HCT"}}) one 3 sub triangles.
\begin{quote}

Lets call \(\mathcal{T}^\triangle_{h}\) the sub mesh of \(\mathcal{T}_{h}\) where all triangles are split in 3 at the barycenter.
\begin{equation*}
\begin{split}\P^{HCT}_{h} = \left\{ v \in C^1(\Omega) \left|\; \forall K \in \mathcal{T}^\triangle_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
where \(P_{3}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).

The degrees of freedom are the values of the normal derivative at the mid-point of each edge \sphinxcite{reference:bernadou1980}.

\begin{sphinxadmonition}{warning}{Warning:}
To build the interplant of a function \(u\) (scalar) for this finite element, we need the function and 2 partial derivatives \((u,u_x, u_y)\), creating this vectorial finite element with 3 components \((u,u_x,u_y)\) like in previous finite element.
\end{sphinxadmonition}
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P2BR{]}}} (needs \sphinxcode{\sphinxupquote{load "BernadiRaugel"}}) the Bernadi Raugel Finite Element is a Vectorial element (2d) with 2 components, see \sphinxcite{reference:bernardi1985}.
\begin{quote}

It is a 2D coupled Finite Element, where the Polynomial space is \(P_1^2\) with 3 normal bubble edge functions \((P_2)\).
There are 9 degrees of freedom:
\begin{itemize}
\item {} 
2 components at each of the 3 vertices and

\item {} 
the 3 flux on the 3 edges.

\end{itemize}
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}RT0, RT03d{]}}} Raviart-Thomas finite element of degree \(0\).
\begin{quote}

\sphinxstylestrong{The 2D Case:}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT0}
\begin{split}RT0_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in \mathcal{T}_{h} ,\ \mathbf{v}_{|K}(x,y) =
\vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{x}{y} \right.\right\}\end{split}
\end{equation}
\sphinxstylestrong{The 3D Case:}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT03d}
\begin{split}RT0_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in \mathcal{T}_{h},\ \mathbf{v}_{|K}(x,y,z) =
\vectthree{\alpha^1_{K}}{\alpha^2_{K}}{\alpha^3_{K}} + \beta_{K}\vectthree{x}{y}{z} \right.\right\}\end{split}
\end{equation}
where by writing \(\textrm{div }\mathbf{w}=\sum_{i=1}^d\p w_i/\p x_i\) with \(\mathbf{w}=(w_i)_{i=1}^d\):
\begin{equation*}
\begin{split}H(\textrm{div})=\left\{\mathbf{w}\in L^{2}(\Omega)^d\left|\textrm{div } \mathbf{w}\in L^{2}(\Omega)\right.\right\}\end{split}
\end{equation*}
and where \(\alpha^1_{K}\), \(\alpha^2_{K}\), \(\alpha^3_{K}\), \(\beta_{K}\) are real numbers.
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}RT0Ortho{]}}} Raviart-Thomas Orthogonal, or Nedelec finite element type I of degree \(0\) in dimension 2
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:RT0Ortho}
\begin{split}RT0Ortho{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in \mathcal{T}_{h},\ \mathbf{v}_{|K}(x,y) =
\vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{-y}{x} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}Edge03d{]}}} 3d Nedelec finite element or Edge Element of degree \(0\).
\begin{quote}
\begin{equation*}
\begin{split}Edge0_{h} = \left\{ \mathbf{v} \in H(\textrm{Curl}) \left|\; \forall K \in\mathcal{T}_{h}, \ \mathbf{v}_{|K}(x,y,z) =
    \vectthree{\alpha^1_{K}}{\alpha^2_{K}}{\alpha^3_{K}} + \vectthree{\beta^1_{K}}{\beta^2_{K}}{\beta^3_{K}}\times\vectthree{x}{y}{z} \right.\right\}
:label:eq:Edge03d\end{split}
\end{equation*}
where by writing \(\textrm{curl}\mathbf{w}=\vectthree{\p w_2/\p x_3-\p w_3/\p x_2}{\p w_3/\p x_1-\p w_1/\p x_3}{\p w_1/\p x_2-\p w_2/\p x_1}\) with \(\mathbf{w}=(w_i)_{i=1}^d\):
\begin{equation*}
\begin{split}H(\textrm{curl})=\left\{\mathbf{w}\in L^{2}(\Omega)^d\left|\textrm{curl } \mathbf{w}\in L^{2}(\Omega)^d\right.\right\}\end{split}
\end{equation*}
and \(\alpha^1_{K},\alpha^2_{K},\alpha^3_{K},\beta^1_{K},\beta^2_{K},\beta^3_{K}\) are real numbers.
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}Edge13d{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte3d"}}) 3d Nedelec finite element or Edge Element of degree \(1\).

\item {} 
\sphinxcode{\sphinxupquote{{[}Edge23d{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte3d"}}) 3d Nedelec finite element or Edge Element of degree \(2\).

\item {} 
\sphinxcode{\sphinxupquote{{[}P1nc{]}}} piecewise linear element continuous at the mid-point of the edge only in 2D (Crouzeix-Raviart Finite Element 2D).

\item {} 
\sphinxcode{\sphinxupquote{{[}P2pnc{]}}} piecewise quadratic plus a P3 bubble element with the continuity of the 2 moments on each edge (needs \sphinxcode{\sphinxupquote{load "Element\_P2pnc"}})

\item {} 
\sphinxcode{\sphinxupquote{{[}RT1{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT1}
\begin{split}RT1_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in\mathcal{T}_{h}, \ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_1^2,P_0, \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{x}{y} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}RT1Ortho{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT1Ortho}
\begin{split}RT1_{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in\mathcal{T}_{h},\ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_1^2,P_0, \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{-y}{x} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}RT2{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT2}
\begin{split}RT2_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in\mathcal{T}_{h},\ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_2^2, P_1, \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{x}{y} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}RT2Ortho{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT2Ortho}
\begin{split}RT2_{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in\mathcal{T}_{h} ,\ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_2^2, P_1,\ \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{-y}{x} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}BDM1{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}}) the Brezzi-Douglas-Marini finite element:
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:BDM1}
\begin{split}BDM1_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in\mathcal{T}_{h},\ \mathbf{v}_{|K} \in P_1^2\right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}BDM1Ortho{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}}) the Brezzi-Douglas-Marini Orthogonal also call Nedelec of type II , finite element
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:BDM1Ortho}
\begin{split}BDM1Ortho_{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in\mathcal{T}_{h},\ \mathbf{v}_{|K} \in P_1^2\right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}FEQF{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_QF"}}) the finite element to store functions at default quadrature points (so the quadrature is \sphinxcode{\sphinxupquote{qf5pT}} in 2D and is \sphinxcode{\sphinxupquote{qfV5}} in 3d).
\begin{quote}

For over quadrature you have the following corresponding finite element’s quadrature formula.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{FEQF1}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf1pT}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF2}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf2pT}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF5}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf5pT}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF7}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf7pT}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF9}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf9pT}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF13d}} \(\mapsto\) \sphinxcode{\sphinxupquote{qfV1}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF23d}} \(\mapsto\) \sphinxcode{\sphinxupquote{qfV2}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF53d}} \(\mapsto\) \sphinxcode{\sphinxupquote{qfV5}}

\end{itemize}
\end{quote}

\end{itemize}

You can use this element to optimize the storage and reuse of functions with a long formula inside an integral for non linear processes.


\subsection{Use of freefem fespace in 2D}
\label{\detokenize{documentation/finiteElement:use-of-freefem-fespace-in-2d}}
With the 2D finite element spaces
\begin{equation*}
\begin{split}X_{h} = \left\{ v \in H^{1}(]0,1[^2) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{1} \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}X_{ph} = \left\{ v \in X_{h} |\; v\left(\vecttwo{0}{.}\right) = v\left(\vecttwo{1}{.}\right) , v\left(\vecttwo{.}{0}\right) = v\left(\vecttwo{.}{1}\right) \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}M_{h} = \left\{ v \in H^{1}(]0,1[^2) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{2} \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}R_{h} = \left\{ \mathbf{v} \in H^{1}(]0,1[^2)^{2} |\; \forall K \in \mathcal{T}_{h}\quad \mathbf{v}_{|K}(x,y) = \vecttwo{\alpha_{K}}{\beta_{K}} + \gamma_{K}\vecttwo{x}{y} \right\}\end{split}
\end{equation*}
when \(\mathcal{T}_h\) is a mesh \(10\times 10\) of the unit square \(]0,1[^2\), we only write in \sphinxstylestrong{FreeFem++}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//bi\PYGZhy{}periodic FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Rh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//vectorial FE}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{Xh, Mh, Rh}} expresses finite element spaces (called FE spaces) \(X_h,\, M_h,\, R_h\), respectively.

To use FE-functions \(u_{h},v_{h} \in X_{h}\), \(p_{h},q_{h} \in M_{h}\) and \(U_{h},V_{h} \in R_{h}\), we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Xh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}
\PYG{n}{Xph} \PYG{n}{uph}\PYG{p}{,} \PYG{n}{vph}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{ph}\PYG{p}{,} \PYG{n}{qh}\PYG{p}{;}
\PYG{n}{Rh} \PYG{p}{[}\PYG{n}{Uxh}\PYG{p}{,} \PYG{n}{Uyh}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Vxh}\PYG{p}{,} \PYG{n}{Vyh}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Xh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uh}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}         \PYG{c+c1}{//array of 10 functions in Xh}
\PYG{n}{Rh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Wxh}\PYG{p}{,} \PYG{n}{Wyh}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//array of 10 functions in Rh}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{//the 6th function at point (0.5, 0.5)}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}               \PYG{c+c1}{//the array of the degree of freedom of the 6th function}
\end{sphinxVerbatim}

The functions \(U_{h}, V_{h}\) have two components so we have
\begin{equation*}
\begin{split}U_{h}=\vecttwo{Uxh}{Uyh} \quad \mbox{and}\quad V_{h}=\vecttwo{Vxh}{Vyh}\end{split}
\end{equation*}

\subsection{Use of fespace in 3D}
\label{\detokenize{documentation/finiteElement:use-of-fespace-in-3d}}
With the 3D finite element spaces
\begin{equation*}
\begin{split}X_{h} = \{ v \in H^{1}(]0,1[^3) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{1} \}\end{split}
\end{equation*}\begin{equation*}
\begin{split}X_{ph} = \left\{ v \in X_{h} |\; v\left(\vecttwo{0}{.}\right) = v\left(\vecttwo{1}{.}\right) , v\left(\vecttwo{.}{0}\right) = v\left(\vecttwo{.}{1}\right) \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}M_{h} = \{ v \in H^{1}(]0,1[^2) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{2} \}\end{split}
\end{equation*}\begin{equation*}
\begin{split}R_{h} = \left\{ \mathbf{v} \in H^{1}(]0,1[^2)^{2} |\; \forall K \in \mathcal{T}_{h}\quad \mathbf{v}_{|K}(x,y) = \vecttwo{\alpha_{K}}{\beta_{K}} + \gamma_{K}\vecttwo{x}{y} \right\}\end{split}
\end{equation*}
when \(\mathcal{T}_h\) is a mesh \(10\times 10\times 10\) of the unit cubic \(]0,1[^2\), we write in \sphinxstylestrong{FreeFem++}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//label: 0 up, 1 down, 2 front, 3 left, 4 back, 5 right}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//three\PYGZhy{}periodic FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Rh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT03d}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//vectorial FE}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{Xh, Mh, Rh}} expresses finite element spaces (called FE spaces) \(X_h,\, M_h,\, R_h\), respectively.

To define and use FE-functions \(u_{h},v_{h} \in X_{h}\), \(p_{h},q_{h} \in M_{h}\) and \(U_{h},V_{h} \in R_{h}\), we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Xh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}
\PYG{n}{Xph} \PYG{n}{uph}\PYG{p}{,} \PYG{n}{vph}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{ph}\PYG{p}{,} \PYG{n}{qh}\PYG{p}{;}
\PYG{n}{Rh} \PYG{p}{[}\PYG{n}{Uxh}\PYG{p}{,} \PYG{n}{Uyh}\PYG{p}{,} \PYG{n}{Uyzh}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Vxh}\PYG{p}{,} \PYG{n}{Vyh}\PYG{p}{,} \PYG{n}{Vyzh}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Xh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uh}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}             \PYG{c+c1}{//array of 10 functions in Xh}
\PYG{n}{Rh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Wxh}\PYG{p}{,}\PYG{n}{Wyh}\PYG{p}{,}\PYG{n}{Wzh}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// array of 10 functions in Rh}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{//the 6th function at point (0.5, 0.5, 0.5)}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}                   \PYG{c+c1}{//the array of the degree of freedom of the 6th function}
\end{sphinxVerbatim}

The functions \(U_{h}, V_{h}\) have three components, so we have:
\begin{equation*}
\begin{split}U_{h}=\vectthree{Uxh}{Uyh}{Uzh} \quad \mbox{and}\quad V_{h}=\vectthree{Vxh}{Vyh}{Vzh}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
One challenge of the periodic boundary condition is that the mesh must have equivalent faces.

The \sphinxcode{\sphinxupquote{buildlayers}} mesh generator splits each quadrilateral face with the diagonal passing through the vertex with maximum number, so to be sure to have the same mesh one both face periodic the 2D numbering in corresponding edges must be compatible (for example the same variation).

By Default, the numbering of square vertex is correct.

To change the mesh numbering you can use the \sphinxcode{\sphinxupquote{change}} function like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{old2new}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//array set on 0, 1, .., nv\PYGZhy{}1}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh2} \PYG{n}{sorder} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{;} \PYG{c+c1}{//choose an order increasing on 4 square borders with x or y}
    \PYG{n+nf}{sort}\PYG{p}{(}\PYG{n}{sorder}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{old2new}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//build the inverse permutation}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{new2old} \PYG{o}{=} \PYG{n}{old2new}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//inverse the permutation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{renumv}\PYG{o}{=}\PYG{n}{new2old}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The full example is in {\hyperref[\detokenize{example/finiteElement:exampleperiodic3d}]{\sphinxcrossref{\DUrole{std,std-ref}{examples}}}}.
\end{sphinxadmonition}


\subsection{Lagrangian Finite Elements}
\label{\detokenize{documentation/finiteElement:lagrangian-finite-elements}}

\subsubsection{P0-element}
\label{\detokenize{documentation/finiteElement:p0-element}}
For each triangle (d=2) or tetrahedron (d=3) \(T_k\), the basis function \(\phi_k\) in \sphinxcode{\sphinxupquote{Vh(Th, P0)}} is given by:
\begin{equation*}
\begin{split}\phi_k(\mathbf{x})=
\left\{
\begin{array}{cl}
    1 & \textrm{ if }(\mathbf{x})\in T_k\\
    0 & \textrm{ if }(\mathbf{x})\not\in T_k
\end{array}
\right.\end{split}
\end{equation*}
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then for vertices \(q^{k_i},\, i=1,2,.. d+1\) in \hyperref[\detokenize{documentation/finiteElement:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementp1p2}}}, \(f_h\) is built as \sphinxcode{\sphinxupquote{fh=}} \(\displaystyle f_h(x,y)=\sum_k f(\frac{\sum_i q^{k_i}}{d+1}) \phi_k\)

See \hyperref[\detokenize{documentation/finiteElement:finiteelementprojp0}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementprojp0}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) on \sphinxcode{\sphinxupquote{Vh(Th, P0)}} when the mesh \sphinxcode{\sphinxupquote{Th}} is a \(4\times 4\)-grid of \([-1,1]^2\) as in \hyperref[\detokenize{documentation/finiteElement:finiteelementp0p1p2p1nc}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementp0p1p2p1nc}}}.


\subsubsection{P1-element}
\label{\detokenize{documentation/finiteElement:p1-element}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{FiniteElement_P1P2}.png}
\caption{\(P_1\) and \(P_2\) degrees of freedom on triangle \(T_k\)}\label{\detokenize{documentation/finiteElement:finiteelementp1p2}}\end{figure}

For each vertex \(q^i\), the basis function \(\phi_i\) in \sphinxcode{\sphinxupquote{Vh(Th, P1)}} is given by:
\begin{equation*}
\begin{split}\phi_i(x,y)&=a^k_i+b^k_ix+c^k_iy \textrm{ for }(x,y)\in T_k,\\
\phi_i(q^i)&=1,\quad \phi_i(q^j)=0 \textrm{ if }i\neq j\end{split}
\end{equation*}
The basis function \(\phi_{k_1}(x,y)\) with the vertex \(q^{k_1}\) in \hyperref[\detokenize{documentation/finiteElement:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementp1p2}}} at point \(p=(x,y)\) in triangle \(T_k\) simply coincide with the \sphinxstyleemphasis{barycentric coordinates} \(\lambda^k_1\) \sphinxstyleemphasis{(area coordinates)}:
\begin{equation*}
\begin{split}\phi_{k_1}(x,y) = \lambda^k_{1}(x,y)=
\frac{\textrm{area of triangle} (p, q^{k_2},q^{k_3})}
{\textrm{area of triangle}(q^{k_1},q^{k_2},q^{k_3})}\end{split}
\end{equation*}
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{g}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then:

\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{n_v}f(q^i)\phi_i(x,y)\)

See \hyperref[\detokenize{documentation/finiteElement:finiteelementprojp1}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementprojp1}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P1)}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_P0P1P2P1nc}.png}
\caption{Test mesh \sphinxcode{\sphinxupquote{Th}} for projection}\label{\detokenize{documentation/finiteElement:id8}}\label{\detokenize{documentation/finiteElement:finiteelementp0p1p2p1nc}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP0}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P0)}}}\label{\detokenize{documentation/finiteElement:id9}}\label{\detokenize{documentation/finiteElement:finiteelementprojp0}}\end{subfigure}
\caption{Finite element \sphinxcode{\sphinxupquote{P0}}}

\end{figure}



\subsubsection{P2-element}
\label{\detokenize{documentation/finiteElement:p2-element}}\label{\detokenize{documentation/finiteElement:FiniteElement}}
For each vertex or mid-point \(q^i\).
The basis function \(\phi_i\) in \sphinxcode{\sphinxupquote{Vh(Th, P2)}} is given by:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \phi_i(x,y)&=&a^k_i+b^k_ix+c^k_iy+d^k_ix^2+e^k_ixy+f^f_jy^2\textrm{ for }(x,y)\in T_k,\\
    \phi_i(q^i)&=&1,\quad \phi_i(q^j)=0\textrm{ if }i\neq j
\end{array}\end{split}
\end{equation*}
The basis function \(\phi_{k_1}(x,y)\) with the vertex \(q^{k_1}\) in \hyperref[\detokenize{documentation/finiteElement:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementp1p2}}} is defined by the \sphinxstyleemphasis{barycentric coordinates}:
\begin{equation*}
\begin{split}\phi_{k_1}(x,y) = \lambda^k_{1}(x,y)(2\lambda^k_1(x,y)-1)\end{split}
\end{equation*}
and for the mid-point \(q^{k_2}\):
\begin{equation*}
\begin{split}\phi_{k_2}(x,y) = 4\lambda^k_1(x,y)\lambda^k_4(x,y)\end{split}
\end{equation*}
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then:

\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{M}f(q^i)\phi_i(x,y)\quad (\textrm{summation over all vertex or mid-point})\)

See {\hyperref[\detokenize{documentation/finiteElement:finiteelementprojp2}]{\sphinxcrossref{\DUrole{std,std-ref}{Projection to Vh(Th, P2)}}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P2)}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP1}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P1)}}}\label{\detokenize{documentation/finiteElement:id10}}\label{\detokenize{documentation/finiteElement:finiteelementprojp1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP2}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P2)}}}\label{\detokenize{documentation/finiteElement:id11}}\label{\detokenize{documentation/finiteElement:finiteelementprojp2}}\end{subfigure}
\caption{Finite elements \sphinxcode{\sphinxupquote{P1, P2}}}

\end{figure}



\subsection{P1 Nonconforming Element}
\label{\detokenize{documentation/finiteElement:p1-nonconforming-element}}\label{\detokenize{documentation/finiteElement:FiniteElement}}
Refer to \sphinxcite{reference:thomasset2012} for details; briefly, we now consider non-continuous approximations so we will lose the property:
\begin{equation*}
\begin{split}w_h\in V_h\subset H^1(\Omega)\end{split}
\end{equation*}
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1nc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then:

\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{n_v}f(m^i)\phi_i(x,y)\quad (\textrm{summation over all midpoint})\)

Here the basis function \(\phi_i\) associated with the mid-point \(m^i=(q^{k_i}+q^{k_{i+1}})/2\) where \(q^{k_i}\) is the \(i\)-th point in \(T_k\), and we assume that \(j+1=0\) if \(j=3\):
\begin{equation*}
\begin{split}\phi_i(x,y) &= a^k_i+b^k_ix+c^k_iy~\textrm{for }(x,y)\in T_k,\\
\phi_i(m^i) &= 1,\quad \phi_i(m^j)=0\textrm{ if }i\neq j\end{split}
\end{equation*}
Strictly speaking \(\p \phi_i/\p x,\, \p \phi_i/\p y\) contain Dirac distribution \(\rho \delta_{\p T_k}\).

The numerical calculations will automatically \sphinxstyleemphasis{ignore} them.
In \sphinxcite{reference:thomasset2012}, there is a proof of the estimation
\begin{equation*}
\begin{split}\left(\sum_{k=1}^{n_v}\int_{T_k}|\nabla w-\nabla w_h|^2\d x\d y\right)^{1/2} =O(h)\end{split}
\end{equation*}
The basis functions \(\phi_k\) have the following properties.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
For the bilinear form \(a\) defined in \hyperref[\detokenize{documentation/finiteElement:finiteelementprojp1nc}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementprojp1nc}}} satisfy:
\begin{quote}
\begin{equation*}
\begin{split}\begin{array}{rcl}
    a(\phi_i,\phi_i)>0,\qquad a(\phi_i,\phi_j)&\le& 0\quad\textrm{if }i\neq j\\
    \sum_{k=1}^{n_v}a(\phi_i,\phi_k)&\ge& 0
\end{array}\end{split}
\end{equation*}\end{quote}

\item {} 
\(f\ge 0 \Rightarrow u_h\ge 0\)

\item {} 
If \(i\neq j\), the basis function \(\phi_i\) and \(\phi_j\) are \(L^2\)-orthogonal:
\begin{quote}
\begin{equation*}
\begin{split}\int_{\Omega}\phi_i\phi_j\, \d x\d y=0\qquad \textrm{if }i\neq j\end{split}
\end{equation*}
which is false for \(P_1\)-element.
\end{quote}

\end{enumerate}

See \hyperref[\detokenize{documentation/finiteElement:finiteelementprojp1nc}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementprojp1nc}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P1nc)}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP1nc}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P1nc)}}}\label{\detokenize{documentation/finiteElement:id12}}\label{\detokenize{documentation/finiteElement:finiteelementprojp1nc}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP1b}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P1b)}}}\label{\detokenize{documentation/finiteElement:id13}}\label{\detokenize{documentation/finiteElement:finiteelementprojp1b}}\end{subfigure}
\caption{Finite elements \sphinxcode{\sphinxupquote{P1nc, P1b}}}

\end{figure}



\subsection{Other FE-space}
\label{\detokenize{documentation/finiteElement:other-fe-space}}\label{\detokenize{documentation/finiteElement:FiniteElement}}
For each triangle \(T_k\in \mathcal{T}_h\), let \(\lambda_{k_1}(x,y),\, \lambda_{k_2}(x,y),\, \lambda_{k_3}(x,y)\) be the area cordinate of the triangle (see \hyperref[\detokenize{documentation/finiteElement:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementp1p2}}}), and put:
\begin{equation*}
\begin{split}\beta_k(x,y)=27\lambda_{k_1}(x,y)\lambda_{k_2}(x,y)\lambda_{k_3}(x,y)\end{split}
\end{equation*}
called \sphinxstyleemphasis{bubble} function on \(T_k\).
The bubble function has the feature: 1. \(\beta_k(x,y)=0\quad \textrm{if }(x,y)\in \p T_k\).
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{1}
\item {} 
\(\beta_k(q^{k_b})=1\) where \(q^{k_b}\) is the barycenter \(\frac{q^{k_1}+q^{k_2}+q^{k_3}}{3}\).

\end{enumerate}

If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1b}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then:

\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{n_v}f(q^i)\phi_i(x,y)+\sum_{k=1}^{n_t}f(q^{k_b})\beta_k(x,y)\)

See \hyperref[\detokenize{documentation/finiteElement:finiteelementprojp1b}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementprojp1b}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P1b)}}.


\subsection{Vector Valued FE-function}
\label{\detokenize{documentation/finiteElement:vector-valued-fe-function}}
Functions from \(\R^{2}\) to \(\R^{N}\) with \(N=1\) are called scalar functions and called \sphinxstyleemphasis{vector valued} when \(N>1\).
When \(N=2\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P0}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}

makes the space
\begin{equation*}
\begin{split}V_h=\{\mathbf{w}=(w_1,w_2)|\; w_1\in V_h(\mathcal{T}_h,P_0),\,
w_2\in V_h(\mathcal{T}_h,P_1)\}\end{split}
\end{equation*}

\subsubsection{Raviart-Thomas Element}
\label{\detokenize{documentation/finiteElement:raviart-thomas-element}}
In the Raviart-Thomas finite element \(RT0_{h}\), the degrees of freedom are the fluxes across edges \(e\) of the mesh, where the flux of the function \(\mathbf{f} : \R^2 \longrightarrow \R^2\) is \(\int_{e} \mathbf{f}.n_{e}\), \(n_{e}\) is the unit normal of edge \(e\).

This implies an orientation of all the edges of the mesh, for example we can use the global numbering of the edge vertices and we just go from small to large numbers.

To compute the flux, we use a quadrature with one Gauss point, the mid-point of the edge.

Consider a triangle \(T_k\) with three vertices \((\mathbf{a},\mathbf{b},\mathbf{c})\).

Lets denote the vertices numbers by \(i_{a},i_{b},i_{c}\), and define the three edge vectors \(\mathbf{e}^{1},\mathbf{e}^{2},\mathbf{e}^{3}\) by \(sgn(i_{b}-i_{c})(\mathbf{b}-\mathbf{c})\), \(sgn(i_{c}-i_{a})(\mathbf{c}-\mathbf{a})\), \(sgn(i_{a}-i_{b})(\mathbf{a}-\mathbf{b})\).

We get three basis functions:
\begin{equation*}
\begin{split}\boldsymbol{\phi}^{k}_{1}= \frac{sgn(i_{b}-i_{c})}{2|T_k|}(\mathbf{x}-\mathbf{a}),\quad
\boldsymbol{\phi}^{k}_{2}= \frac{sgn(i_{c}-i_{a})}{2|T_k|}(\mathbf{x}-\mathbf{b}),\quad
\boldsymbol{\phi}^{k}_{3}= \frac{sgn(i_{a}-i_{b})}{2|T_k|}(\mathbf{x}-\mathbf{c}),\end{split}
\end{equation*}
where \(|T_k|\) is the area of the triangle \(T_k\).
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{f1h}\PYG{p}{,} \PYG{n}{f2h}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{f1}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

then:

\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle \mathbf{f}_h(x,y)=\sum_{k=1}^{n_t}\sum_{l=1}^6 n_{i_lj_l}|\mathbf{e^{i_l}}|f_{j_l}(m^{i_l})\phi_{i_lj_l}\)

where \(n_{i_lj_l}\) is the \(j_l\)-th component of the normal vector \(\mathbf{n}_{i_l}\),
\begin{equation*}
\begin{split}\{m_1,m_2,m_3\} = \left\{\frac{\mathbf{b}+\mathbf{c}}{2},
\frac{\mathbf{a}+\mathbf{c}}{2},
\frac{\mathbf{b}+\mathbf{a}}{2} \right\}\end{split}
\end{equation*}
and \(i_l=\{1,1,2,2,3,3\},\, j_l=\{1,2,1,2,1,2\}\) with the order of \(l\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{FiniteElement_RT0}.png}
\caption{Normal vectors of each edge}\label{\detokenize{documentation/finiteElement:finiteelementrt0}}\end{figure}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{uh} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{Uxh}\PYG{p}{,} \PYG{n}{Uyh}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//vectorial FE function}

\PYG{c+c1}{// Change the mesh}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//Xh is unchanged}
\PYG{c+c1}{//Uxh = x; //error: impossible to set only 1 component}
          \PYG{c+c1}{//of a vector FE function}
\PYG{n}{vh} \PYG{o}{=} \PYG{n}{Uxh}\PYG{p}{;}\PYG{c+c1}{//ok}
\PYG{c+c1}{//and now vh use the 5x5 mesh}
\PYG{c+c1}{//but the fespace of vh is always the 2x2 mesh}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{uh} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{//do a interpolation of uh (old) of 5x5 mesh}
        \PYG{c+c1}{//to get the new uh on 10x10 mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{vh}\PYG{p}{(}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//interpolate vh = ((x\PYGZhy{}1/2)\PYGZca{}2 + y\PYGZca{}2)}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_onoldmesh}.png}
\caption{\sphinxcode{\sphinxupquote{vh}} Iso on mesh \(2\times 2\)}\label{\detokenize{documentation/finiteElement:id14}}\label{\detokenize{documentation/finiteElement:finiteelementonoldmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_onnewmesh}.png}
\caption{\sphinxcode{\sphinxupquote{vh}} Iso on  mesh \(5\times 5\)}\label{\detokenize{documentation/finiteElement:id15}}\label{\detokenize{documentation/finiteElement:finiteelementonnewmesh}}\end{subfigure}
\phantomsection\label{\detokenize{documentation/finiteElement:FiniteElement}}

\end{figure}


To get the value at a point \(x=1,y=2\) of the FE function \sphinxcode{\sphinxupquote{uh}}, or \sphinxcode{\sphinxupquote{{[}Uxh, Uyh{]}}}, one writes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{value}\PYG{p}{;}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//get value = uh(2, 4)}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{Uxh}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//get value = Uxh(2, 4)}
\PYG{c+c1}{//OR}
\PYG{k+kr}{x} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{//get value = uh(1, 2)}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{Uxh}\PYG{p}{;} \PYG{c+c1}{//get value = Uxh(1, 2)}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{Uyh}\PYG{p}{;} \PYG{c+c1}{//get value = Uyh(1, 2)}
\end{sphinxVerbatim}

To get the value of the array associated to the FE function \sphinxcode{\sphinxupquote{uh}}, one writes

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//get the value of degree of freedom 0}
\PYG{k+kt}{real} \PYG{n}{maxdf} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;} \PYG{c+c1}{//maximum value of degree of freedom}
\PYG{k+kt}{int} \PYG{n}{size} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{c+c1}{//the number of degree of freedom}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{array}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//copy the array of the function uh}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
For a non-scalar finite element function \sphinxcode{\sphinxupquote{{[}Uxh, Uyh{]}}} the two arrays \sphinxcode{\sphinxupquote{Uxh{[}{]}}} and \sphinxcode{\sphinxupquote{Uyh{[}{]}}} are the same array, because the degree of freedom can touch more than one component.
\end{sphinxadmonition}


\subsection{A Fast Finite Element Interpolator}
\label{\detokenize{documentation/finiteElement:a-fast-finite-element-interpolator}}
In practice, one may discretize the variational equations by the Finite Element method.
Then there will be one mesh for \(\Omega_1\) and another one for \(\Omega_2\).
The computation of integrals of products of functions defined on different meshes is difficult.

Quadrature formula and interpolations from one mesh to another at quadrature points are needed.
We present below the interpolation operator which we have used and which is new, to the best of our knowledge.

Let \({\cal T}_{h}^0=\cup_k T^0_k,{\cal T}_{h}^1=\cup_k T^1_k\) be two triangulations of a domain \(\Omega\).
Let:
\begin{equation*}
\begin{split}V({\hbox{{\cal T}}_{h}^i}) =\{ C^0(\Omega_h^i)~:~f|_{T^i_k}\in P_0\},~~~i=0,1\end{split}
\end{equation*}
be the spaces of continuous piecewise affine functions on each triangulation.

Let \(f\in V({\cal T}_{h}^0)\).
The problem is to find \(g\in V({\cal T}_{h}^1)\) such that:
\begin{equation*}
\begin{split}g(q) = f(q) \quad \forall q\hbox{~vertex of ~} {\cal T}_{h}^1\end{split}
\end{equation*}
Although this is a seemingly simple problem, it is difficult to find an efficient algorithm in practice.

We propose an algorithm which is of complexity \(N^1\log N^0\), where \(N^i\) is the number of vertices of \(\cal T_{h}^i\), and which is very fast for most practical 2D applications.

\sphinxstylestrong{Algorithm}

The method has 5 steps.

First a quadtree is built containing all the vertices of the mesh \({\cal T}_{h}^0\) such that in each terminal cell there are at least one, and at most 4, vertices of \({\cal T}_{h}^0\).

For each \(q^1\), vertex of \({\cal T}_{h}^1\) do:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Find the terminal cell of the quadtree containing \(q^1\).

\item {} 
Find the the nearest vertex \(q^0_j\) to \(q^1\) in that cell.

\item {} 
Choose one triangle \(T_k^0\in{\cal T}_{h}^0\) which has \(q^0_j\) for vertex.

\item {} 
Compute the barycentric coordinates \(\{\lambda_j\}_{j=1,2,3}\) of \(q^1\) in \(T^0_k\).
\begin{itemize}
\item {} 
if all barycentric coordinates are positive, go to Step 5

\item {} 
otherwise, if one barycentric coordinate \(\lambda_i\) is negative, replace \(T^0_k\) by the adjacent triangle opposite \(q^0_i\) and go to Step 4.

\item {} 
otherwise, if two barycentric coordinates are negative, take one of the two randomly and replace \(T^0_k\) by the adjacent triangle as above.

\end{itemize}

\item {} 
Calculate \(g(q^1)\) on \(T^0_k\) by linear interpolation of \(f\):
\begin{quote}
\begin{equation*}
\begin{split}g(q^1) = \sum_{j=1,2,3} \lambda_j f(q^0_j)\end{split}
\end{equation*}\end{quote}

\end{enumerate}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{FiniteElement_fastInterpolate}.png}
\caption{To interpolate a function at \(q^0\), the knowledge of the triangle which contains \(q^0\) is needed. The algorithm may start at \(q^1\in T_k^0\) and stall on the boundary (thick line) because the line \(q^0q^1\) is not inside \(\Omega\).
But if the holes are triangulated too (doted line) then the problem does not arise.}\label{\detokenize{documentation/finiteElement:finiteelementfastinterpolate}}\end{figure}

Two problems need to be solved:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{What if :math:{}`q\textasciicircum{}1{}` is not in} \(\Omega^0_h\) \sphinxstyleemphasis{?} Then Step 5 will stop with a boundary triangle.
\begin{quote}

So we add a step which tests the distance of \(q^1\) with the two adjacent boundary edges and selects the nearest, and so on till the distance grows.
\end{quote}

\item {} 
\sphinxstyleemphasis{What if} \(\Omega^0_h\) \sphinxstyleemphasis{is not convex and the marching process of Step 4 locks on a boundary?} By construction Delaunay-Voronoï’s mesh generators always triangulate the convex hull of the vertices of the domain.
\begin{quote}

Therefore, we make sure that this information is not lost when \({\cal T}_{h}^0,{\cal T}_{h}^1\) are constructed and we keep the triangles which are outside the domain on a special list.

That way, in step 5 we can use that list to step over holes if needed.
\end{quote}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Sometimes, in rare cases, the interpolation process misses some points, we can change the search algorithm through a global variable \sphinxcode{\sphinxupquote{searchMethod}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// default value for fast search algorithm}
\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// safe search algorithm, uses brute force in case of missing point}
\PYG{c+c1}{// (warning: can be very expensive in cases where a lot of points are outside of the domain)}
\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{// always uses brute force. It is very computationally expensive.}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Step 3 requires an array of pointers such that each vertex points to one triangle of the triangulation.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
The operator \sphinxcode{\sphinxupquote{=}} is the interpolation operator of \sphinxstylestrong{FreeFem++}, the continuous finite functions are extended by continuity to the outside of the domain.

Try the following example :
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Ths} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thg} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{n}{Thg}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Ch}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ch} \PYG{n}{us} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Dh}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{n+nc}{P2dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Dh} \PYG{n}{vs} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Fh}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n+nc}{P2dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Fh} \PYG{n}{ug}\PYG{o}{=}\PYG{n}{us}\PYG{p}{,} \PYG{n}{vg}\PYG{o}{=}\PYG{n}{vs}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{us}\PYG{p}{,} \PYG{n}{ug}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{vs}\PYG{p}{,} \PYG{n}{vg}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_UsUg}.png}
\caption{Extension of a continuous FE-function}\label{\detokenize{documentation/finiteElement:id16}}\label{\detokenize{documentation/finiteElement:finiteelementusug}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_VsVg}.png}
\caption{Extension of discontinuous FE-function}\label{\detokenize{documentation/finiteElement:id17}}\label{\detokenize{documentation/finiteElement:finiteelementvsvg}}\end{subfigure}
\caption{Extension of FE-function}

\end{figure}

\end{quote}
\end{sphinxadmonition}


\subsection{Keywords: Problem and Solve}
\label{\detokenize{documentation/finiteElement:keywords-problem-and-solve}}\label{\detokenize{documentation/finiteElement:Extension}}
For \sphinxstylestrong{FreeFem++}, a problem must be given in variational form, so we need a bilinear form \(a(u,v)\), a linear form \(\ell(f,v)\), and possibly a boundary condition form must be added.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{k+kr}{P} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{l}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{+} \PYG{p}{(}\PYG{k+kp}{boundary} \PYG{n}{condition}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
When you want to formulate the problem and solve it in the same time, you can use the keyword \sphinxcode{\sphinxupquote{solve}}.
\end{sphinxadmonition}


\subsubsection{Weak Form and Boundary Condition}
\label{\detokenize{documentation/finiteElement:weak-form-and-boundary-condition}}
To present the principles of Variational Formulations, also called weak form, for the Partial Differential Equations, let’s take a model problem: a Poisson equation with Dirichlet and Robin Boundary condition.

The problem: Find \(u\) a real function defined on a domain \(\Omega\) of \(\R^d\) \((d=2,3)\) such that:
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\nabla\cdot(\kappa \nabla u) &=& f & \mbox{ in }\Omega\\
    a u + \kappa \frac{\p u}{\p n} &=& b & \mbox{ on }\Gamma_r\\
    u &=& g & \mbox{ on }\Gamma_d
\end{array}\end{split}
\end{equation*}
where:
\begin{itemize}
\item {} 
if \(d=2\) then \(\nabla.(\kappa \nabla u) = \p_x(\kappa \p_x u ) + \p_y(\kappa \p_y u )\) with \(\p_x u = \frac{\p u}{\p x}\) and \(\p_y u = \frac{\p u}{\p y}\)

\item {} 
if \(d=3\) then \(\nabla.(\kappa \nabla u) = \p_x(\kappa \p_x u) + \p_y(\kappa \p_y u) + \p_z(\kappa \p_z u)\) with \(\p_x u = \frac{\p u}{\p x}\), \(\p_y u = \frac{\p u}{\p y}\) and , \(\p_z u = \frac{\p u}{\p z}\)

\item {} 
The border \(\Gamma=\p \Omega\) is split in \(\Gamma_d\) and \(\Gamma_n\) such that \(\Gamma_d \cap \Gamma_n = \emptyset\) and \(\Gamma_d \cup \Gamma_n = \p \Omega\),

\item {} 
\(\kappa\) is a given positive function, such that \(\exists \kappa_0 \in \R ,\quad 0 < \kappa_0 \leq \kappa\).

\item {} 
\(a\) a given non negative function,

\item {} 
\(b\) a given function.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
This is the well known Neumann boundary condition if \(a=0\), and if \(\Gamma_d\) is empty.

In this case the function appears in the problem just by its derivatives, so it is defined only up to a constant (if \(u\) is a solution then \(u+c\) is also a solution).
\end{sphinxadmonition}

Let \({v}\), a regular test function, null on \(\Gamma_d\), by integration by parts we get:
\begin{equation*}
\begin{split}- \int_{\Omega} \nabla\cdot(\kappa \nabla u) \, {v} \,d\omega
= \int_{\Omega} \kappa \nabla{ v} \cdot \nabla u \,d\omega
- \int_{\Gamma} {v}\kappa \frac{ \p u}{\p \mathbf{n}} \,d\gamma,= \int_{\Omega} f {v} \,d\omega\end{split}
\end{equation*}
where if \(d=2\) the \(\nabla{ v} . \nabla u = (\frac{\p u}{\p x}\frac{\p { v}}{\p x}+\frac{\p u}{\p y}\frac{\p { v}}{\p y})\),

where if \(d=3\) the \(\nabla{ v} . \nabla u = (\frac{\p u}{\p x}\frac{\p { v}}{\p x}+\frac{\p u}{\p y}\frac{\p { v}}{\p y} + \frac{\p u}{\p z}\frac{\p { v}}{\p z})\),

and where \(\mathbf{n}\) is the unitary outer-pointing normal of the \(\Gamma\).

Now we note that \(\kappa \frac{ \p u}{\p n} = - a u + b\) on \(\Gamma_r\) and \(v=0\) on \(\Gamma_d\) and \(\Gamma = \Gamma_d \cup \Gamma_n\) thus:
\begin{equation*}
\begin{split}- \int_{\Gamma} {v}
\kappa \frac{ \p u}{\p n} = \int_{\Gamma_r} a u v - \int_{\Gamma_r} b v\end{split}
\end{equation*}
The problem becomes:

Find \(u \in V_g = \{w \in H^1(\Omega) / w = g \mbox{ on } \Gamma_d \}\) such that:
\begin{equation}\label{equation:documentation/finiteElement:eqn::v-poisson}
\begin{split}{\int_{\Omega} \kappa \nabla{ v} . \nabla u \,d\omega + \int_{\Gamma_r} a u v \,d\gamma = \int_{\Omega} f {v}} \,d\omega
+ \int_{\Gamma_r} b v \,d\gamma , \quad \forall v \in V_0\end{split}
\end{equation}
where \(V_0 = \{v \in H^1(\Omega) / v = 0 \mbox{ on } \Gamma_d \}\)

Except in the case of Neumann conditions everywhere, the problem \eqref{equation:documentation/finiteElement:eqn::v-poisson} is well posed when \(\kappa\geq \kappa_0>0\).

\begin{sphinxadmonition}{note}{Note:}
If we have only the Neumann boundary condition, linear algebra tells us that the right hand side must be orthogonal to the kernel of the operator for the solution to exist.
\begin{quote}

One way of writing the compatibility condition is:
\begin{equation*}
\begin{split}\int_{\Omega} f \,d\omega + \int_{\Gamma} b \,d\gamma=0\end{split}
\end{equation*}
and a way to fix the constant is to solve for \(u \in H^1(\Omega)\) such that:
\begin{equation*}
\begin{split}{\int_{\Omega} (\varepsilon u v \; + \; \kappa \nabla{ v} . \nabla u) \,d\omega
= \int_{\Omega} f {v}} \,d\omega + \int_{\Gamma_r} b v \,d\gamma , \quad \forall v \in H^1(\Omega)\end{split}
\end{equation*}
where \(\varepsilon\) is a small parameter (\(\sim \kappa\; 10^{-10} |\Omega|^{\frac2d}\)).
\end{quote}

Remark that if the solution is of order \(\frac{1}{\varepsilon}\) then the compatibility condition is unsatisfied, otherwise we get the solution such that \(\int_\Omega u = 0\), you can also add a Lagrange multiplier to solve the real mathematical problem like in the {\hyperref[\detokenize{example/finiteElement:examplelagrangemultipliers}]{\sphinxcrossref{\DUrole{std,std-ref}{Lagrange multipliers example}}}}.
\end{sphinxadmonition}

In \sphinxstylestrong{FreeFem++}, the bidimensional problem \eqref{equation:documentation/finiteElement:eqn::v-poisson} becomes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n+nf}{Pw} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{o}{/}\PYG{o}{/}\PYG{n}{int\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{Omega}\PYG{p}{\PYGZcb{}} \PYG{n}{kappa} \PYG{n}{nabla} \PYG{n}{v} \PYG{p}{.} \PYG{n}{nabla} \PYG{n}{u}
        \PYG{n}{kappa}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} a u v}
        \PYG{n}{a} \PYG{o}{*} \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Omega\PYGZcb{} f v}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} b v}
        \PYG{n}{b} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{gd}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)} \PYG{c+c1}{//u = g on Gamma\PYGZus{}d}
    \PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{Th}} is a mesh of the bi-dimensional domain \(\Omega\), and \sphinxcode{\sphinxupquote{gd}} and \sphinxcode{\sphinxupquote{gn}} are respectively the boundary labels of boundary \(\Gamma_d\) and \(\Gamma_n\).

And the three dimensional problem \eqref{equation:documentation/finiteElement:eqn::v-poisson} becomes

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{]}\PYG{c+c1}{//}
\PYG{k+kt}{problem} \PYG{n}{Pw} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{o}{/}\PYG{o}{/}\PYG{n}{int\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{Omega}\PYG{p}{\PYGZcb{}} \PYG{n}{kappa} \PYG{n}{nabla} \PYG{n}{v} \PYG{p}{.} \PYG{n}{nabla} \PYG{n}{u}
        \PYG{n}{kappa}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} a u v}
        \PYG{n}{a} \PYG{o}{*} \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Omega\PYGZcb{} f v}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} b v}
        \PYG{n}{b} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{gd}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)} \PYG{c+c1}{//u = g on Gamma\PYGZus{}d}
    \PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{Th}} is a mesh of the three dimensional domain \(\Omega\), and \sphinxcode{\sphinxupquote{gd}} and \sphinxcode{\sphinxupquote{gn}} are respectively the boundary labels of boundary \(\Gamma_d\) and \(\Gamma_n\).


\subsection{Parameters affecting solve and problem}
\label{\detokenize{documentation/finiteElement:parameters-affecting-solve-and-problem}}
The parameters are FE functions real or complex, the number \(n\) of parameters is even (\(n=2*k\)), the \(k\) first function parameters are unknown, and the \(k\) last are test functions.

\begin{sphinxadmonition}{note}{Note:}
If the functions are a part of vectorial FE then you must give all the functions of the vectorial FE in the same order (see {\hyperref[\detokenize{model/staticProblems:modelstaticpoissonwithmixedboundarycondition}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson problem with mixed finite element}}}} for example).
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Don’t mix complex and real parameters FE function.
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxstylestrong{Bug:}

The mixing of multiple \sphinxcode{\sphinxupquote{fespace}} with different periodic boundary conditions are not implemented.

So all the finite element spaces used for tests or unknown functions in a problem, must have the same type of periodic boundary conditions or no periodic boundary conditions.

No clean message is given and the result is unpredictable.
\end{sphinxadmonition}

The parameters are:
\begin{itemize}
\item {} 
\sphinxstylestrong{solver=} \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{CG}}, \sphinxcode{\sphinxupquote{Crout}},  \sphinxcode{\sphinxupquote{Cholesky}}, \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}}, \sphinxcode{\sphinxupquote{UMFPACK}} …
\begin{quote}

The default solver is \sphinxcode{\sphinxupquote{sparsesolver}} (it is equal to \sphinxcode{\sphinxupquote{UMFPACK}} if no other sparse solver is defined) or is set to \sphinxcode{\sphinxupquote{LU}} if no direct sparse solver is available.

The storage mode of the matrix of the underlying linear system depends on the type of solver chosen; for \sphinxcode{\sphinxupquote{LU}} the matrix is sky-line non symmetric, for \sphinxcode{\sphinxupquote{Crout}} the matrix is sky-line symmetric, for \sphinxcode{\sphinxupquote{Cholesky}} the matrix is sky-line symmetric positive definite, for \sphinxcode{\sphinxupquote{CG}} the matrix is sparse symmetric positive, and for \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}} or \sphinxcode{\sphinxupquote{UMFPACK}} the matrix is just sparse.
\end{quote}

\item {} 
\sphinxstylestrong{eps=} a real expression.
\begin{quote}

\(\varepsilon\) sets the stopping test for the iterative methods like \sphinxcode{\sphinxupquote{CG}}.

Note that if \(\varepsilon\) is negative then the stopping test is:
\begin{equation*}
\begin{split}|| A x - b || < |\varepsilon|\end{split}
\end{equation*}
if it is positive, then the stopping test is:
\begin{equation*}
\begin{split}|| A x - b || < \frac{|\varepsilon|}{|| A x_{0} - b ||}\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxstylestrong{init=} boolean expression, if it is false or 0 the matrix is reconstructed.
\begin{quote}

Note that if the mesh changes the matrix is reconstructed too.
\end{quote}

\item {} 
\sphinxstylestrong{precon=} name of a function (for example \sphinxcode{\sphinxupquote{P}}) to set the preconditioner.
\begin{quote}

The prototype for the function \sphinxcode{\sphinxupquote{P}} must be:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{P}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{xx}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxstylestrong{tgv=} Huge value (\(10^{30}\)) used to implement Dirichlet boundary conditions.

\item {} 
\sphinxstylestrong{tolpivot=} sets the tolerance of the pivot in \sphinxcode{\sphinxupquote{UMFPACK}} (\(10^{-1}\)) and, \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Crout}}, \sphinxcode{\sphinxupquote{Cholesky}} factorisation (\(10^{-20}\)).

\item {} 
\sphinxstylestrong{tolpivotsym=} sets the tolerance of the pivot sym in \sphinxcode{\sphinxupquote{UMFPACK}}

\item {} 
\sphinxstylestrong{strategy=} sets the integer \sphinxcode{\sphinxupquote{UMFPACK}} strategy (\(0\) by default).

\end{itemize}


\subsection{Problem definition}
\label{\detokenize{documentation/finiteElement:problem-definition}}\label{\detokenize{documentation/finiteElement:problemdefinition}}
Below \sphinxcode{\sphinxupquote{v}} is the unknown function and \sphinxcode{\sphinxupquote{w}} is the test function.

After the “=” sign, one may find sums of:
\begin{itemize}
\item {} 
Identifier(s); this is the name given earlier to the variational form(s) (type \sphinxcode{\sphinxupquote{varf}} ) for possible reuse.
\begin{quote}

Remark, that the name in the \sphinxcode{\sphinxupquote{varf}} of the unknown test function is forgotten, we use the order in the argument list to recall names as in a \sphinxcode{\sphinxupquote{C++}} function,
\end{quote}

\item {} 
The terms of the bilinear form itself: if \(K\) is a given function,

\item {} 
Bilinear part for 3D meshes \sphinxcode{\sphinxupquote{Th}}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int3d(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T } K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap (\Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intallfaces(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intallfaces(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{{T\in\mathtt{Th},T\subset \Omega_{1}}}\int_{\p T } K\,v\,w\)

\item {} 
They contribute to the sparse matrix of type \sphinxcode{\sphinxupquote{matrix}} which, whether declared explicitly or not, is constructed by \sphinxstylestrong{FreeFem++}.

\end{itemize}

\item {} 
Bilinear part for 2D meshes \sphinxcode{\sphinxupquote{Th}}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int2d(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T } K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intalledges(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intalledges(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{{T\in\mathtt{Th},T\subset \Omega_{1}}}\int_{\p T } K\,v\,w\)

\item {} 
They contribute to the sparse matrix of type \sphinxcode{\sphinxupquote{matrix}} which, whether declared explicitly or not, is constructed by \sphinxstylestrong{FreeFem++}.

\end{itemize}

\item {} 
The right hand-side of the Partial Differential Equation in 3D, the terms of the linear form: for given functions \(K,\, f\):
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int3d(Th)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, l)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\in\Omega_l}\int_{T} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset\Omega_{l}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, 2, 5)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5}) } K \,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intallfaces(Th)(f*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } f\,w\)

\item {} 
A vector of type \sphinxcode{\sphinxupquote{real{[}int{]}}}

\end{itemize}

\item {} 
The right hand-side of the Partial Differential Equation in 2D, the terms of the linear form: for given functions \(K,\, f\):
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int2d(Th)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, l)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\in\Omega_l}\int_{T} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset\Omega_{l}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, 2, 5)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5}) } K \,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset\Omega_{l}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intalledges(Th)(f*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } f\,w\)

\item {} 
a vector of type \sphinxcode{\sphinxupquote{real{[}int{]}}}

\end{itemize}

\item {} 
The boundary condition terms:
\begin{quote}
\begin{itemize}
\item {} 
An “on” scalar form (for Dirichlet) : \sphinxcode{\sphinxupquote{on(1, u=g)}}
\begin{quote}

Used for all degrees of freedom \(i\) of the boundary referred by “1”, the diagonal term of the matrix \(a_{ii}= tgv\) with the \sphinxstyleemphasis{terrible giant value} \sphinxcode{\sphinxupquote{tgv}} (= \(10^{30}\) by default), and the right hand side \(b[i] = "(\Pi_h g)[i]" \times tgv\), where the \("(\Pi_h g)g[i]"\) is the boundary node value given by the interpolation of \(g\).

\begin{sphinxadmonition}{note}{Note:}
if \(\mathrm{tgv} < 0\) then we put to \(0\) all term of the line \(i\) in the matrix, except diagonal term \(a_{ii}=1\), and \(b[i] = "(\Pi_h g)[i]"\).
\end{sphinxadmonition}
\end{quote}

\item {} 
An “on” vectorial form (for Dirichlet): \sphinxcode{\sphinxupquote{on(1, u1=g1, u2=g2)}}

\end{itemize}

If you have vectorial finite element like \sphinxcode{\sphinxupquote{RT0}}, the 2 components are coupled, and so you have : \(b[i] = "(\Pi_h (g1,g2))[i]" \times tgv\), where \(\Pi_h\) is the vectorial finite element interpolant.
\begin{itemize}
\item {} 
A linear form on \(\Gamma\) (for Neumann in 2d) \sphinxcode{\sphinxupquote{-int1d(Th)(f*w)}} or \sphinxcode{\sphinxupquote{-int1d(Th, 3)(f*w)}}

\item {} 
A bilinear form on \(\Gamma\) or \(\Gamma_{2}\) (for Robin in 2d) \sphinxcode{\sphinxupquote{int1d(Th)(K*v*w)}} or \sphinxcode{\sphinxupquote{int1d(Th,2)(K*v*w)}}

\item {} 
A linear form on \(\Gamma\) (for Neumann in 3d) \sphinxcode{\sphinxupquote{-int2d(Th)(f*w)}} or \sphinxcode{\sphinxupquote{-int2d(Th, 3)(f*w)}}

\item {} 
A bilinear form on \(\Gamma\) or \(\Gamma_{2}\) (for Robin in 3d) \sphinxcode{\sphinxupquote{int2d(Th)(K*v*w)}} or \sphinxcode{\sphinxupquote{int2d(Th,2)(K*v*w)}}

\end{itemize}
\end{quote}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
If needed, the different kind of terms in the sum can appear more than once.

\item {} 
The integral mesh and the mesh associated to test functions or unknown functions can be different in the case of linear form.

\item {} 
\sphinxcode{\sphinxupquote{N.x}}, \sphinxcode{\sphinxupquote{N.y}} and \sphinxcode{\sphinxupquote{N.z}} are the normal’s components.

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
It is not possible to write in the same integral the linear part and the bilinear part such as in \sphinxcode{\sphinxupquote{int1d(Th)(K*v*w - f*w)}}.
\end{sphinxadmonition}


\subsection{Numerical Integration}
\label{\detokenize{documentation/finiteElement:numerical-integration}}
Let \(D\) be a \(N\)-dimensional bounded domain.

For an arbitrary polynomial \(f\) of degree \(r\), if we can find particular (quadrature) points \(\mathbf{\xi}_j,\, j=1,\cdots,J\) in \(D\) and (quadrature) constants \(\omega_j\) such that
\begin{equation*}
\begin{split}\int_{D}f(\mathbf{x}) = \sum_{\ell =1}^L c_\ell f(\mathbf{\xi}_\ell)\end{split}
\end{equation*}
then we have an error estimate (see \sphinxcite{reference:crouzeix1984}), and then there exists a constant \(C>0\) such that
\begin{equation*}
\begin{split}\left|\int_{D}f(\mathbf{x}) - \sum_{\ell =1}^L \omega_\ell
f(\mathbf{\xi}_\ell )\right|
\le C|D|h^{r+1}\end{split}
\end{equation*}
for any function \(r + 1\) times continuously differentiable \(f\) in \(D\), where \(h\) is the diameter of \(D\) and \(|D|\) its measure (a point in the segment \([q^iq^j]\) is given as
\begin{equation*}
\begin{split}\{(x,y)|\; x=(1-t)q^i_x+tq^j_x,\, y=(1-t)q^i_y+tq^j_y,\, 0\le t\le 1\}\end{split}
\end{equation*}
For a domain \(\Omega_h=\sum_{k=1}^{n_t}T_k,\, \mathcal{T}_h=\{T_k\}\), we can calculate the integral over \(\Gamma_h=\p\Omega_h\) by:

\(\int_{\Gamma_h}f(\mathbf{x})ds\) =\sphinxcode{\sphinxupquote{int1d(Th)(f)}}
=\sphinxcode{\sphinxupquote{int1d(Th, qfe=*)(f)}}
=\sphinxcode{\sphinxupquote{int1d(Th, qforder=*)(f)}}

where * stands for the name of the quadrature formula or the precision (order) of the Gauss formula.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{6}%
\begin{varwidth}[t]{\sphinxcolwidth{6}{6}}
\sphinxstyletheadfamily Quadrature formula on an edge
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\(L\)
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qfe}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qforder}}
&\sphinxstyletheadfamily 
Point in \([q^i, q^j]\)
&\sphinxstyletheadfamily 
\(\omega_\ell\)
&\sphinxstyletheadfamily 
Exact on \(P_k,\ k=\)
\\
\hline
\(1\)
&
\sphinxcode{\sphinxupquote{qf1pE}}
&
\(2\)
&
\(1/2\)
&
\(||q^iq^j||\)
&
\(1\)
\\
\hline
\(2\)
&
\sphinxcode{\sphinxupquote{qf2pE}}
&
\(3\)
&
\((1\pm\sqrt{1/3})/2\)
&
\(||q^iq^j||/2\)
&
\(3\)
\\
\hline
\(3\)
&
\sphinxcode{\sphinxupquote{qf3pE}}
&
\(6\)
&
\((1\pm\sqrt{3/5})/2\)

\(1/2\)
&
\((5/18)||q^iq^j||\)

\((8/18)||q^iq^j||\)
&
\(5\)
\\
\hline
\(4\)
&
\sphinxcode{\sphinxupquote{qf4pE}}
&
\(8\)
&
\((1\pm\frac{525+70\sqrt{30}}{35})/2\)

\((1\pm\frac{525-70\sqrt{30}}{35})/2\)
&
\(\frac{18-\sqrt{30}}{72}||q^iq^j||\)

\(\frac{18+\sqrt{30}}{72}||q^iq^j||\)
&
\(7\)
\\
\hline
\(5\)
&
\sphinxcode{\sphinxupquote{qf5pE}}
&
\(10\)
&
\((1\pm\frac{245+14\sqrt{70}}{21})/2\)

\(1/2\)

\((1\pm\frac{245-14\sqrt{70}}{21})/2\)
&
\(\frac{322-13\sqrt{70}}{1800}||q^iq^j||\)

\(\frac{64}{225}||q^iq^j||\)

\(\frac{322+13\sqrt{70}}{1800}||q^iq^j||\)
&
\(9\)
\\
\hline
\(2\)
&
\sphinxcode{\sphinxupquote{qf1pElump}}
&
\(2\)
&
\(0\)

\(1\)
&
\(||q^iq^j||/2\)

\(||q^iq^j||/2\)
&
\(1\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

where \(|q^iq^j|\) is the length of segment \(\overline{q^iq^j}\).

For a part \(\Gamma_1\) of \(\Gamma_h\) with the label “1”, we can calculate the integral over \(\Gamma_1\) by:

\(\int_{\Gamma_1}f(x,y)ds\) =\sphinxcode{\sphinxupquote{int1d(Th, 1)(f)}}
=\sphinxcode{\sphinxupquote{int1d(Th, 1, qfe=qf2pE)(f)}}

The integrals over \(\Gamma_1,\, \Gamma_3\) are given by:

\(\int_{\Gamma_1\cup \Gamma_3}f(x,y)ds\)

For each triangle \(T_k=[q^{k_1}q^{k_2}q^{k_3}]\), the point \(P(x,y)\) in \(T_k\) is expressed by the \sphinxstyleemphasis{area coordinate} as \(P(\xi,\eta)\):
\begin{equation*}
\begin{split}&|T_k|=\frac12 \left|
\begin{array}{ccc}
    1&q^{k_1}_x&q^{k_1}_y\\
    1&q^{k_2}_x&q^{k_2}_y\\
    1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|\quad
D_1=\left|
\begin{array}{ccc}
    1&x&y\\
    1&q^{k_2}_x&q^{k_2}_y\\
    1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|
\quad
D_2=\left|
\begin{array}{ccc}
    1&q^{k_1}_x&q^{k_1}_y\\
    1&x&y\\
    1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|
\quad
D_3=\left|
\begin{array}{ccc}
    1&q^{k_1}_x&q^{k_1}_y\\
    1&q^{k_2}_x&q^{k_2}_y\\
    1&x&y
\end{array}
\right|\\
&\xi=\frac12 D_1/|T_k|\qquad
\eta=\frac12 D_2/|T_k|\qquad \textrm{then }
1-\xi-\eta=\frac12 D_3/|T_k|\end{split}
\end{equation*}
For a two dimensional domain or a border of three dimensional domain \(\Omega_h=\sum_{k=1}^{n_t}T_k,\, \mathcal{T}_h=\{T_k\}\), we can calculate the integral over \(\Omega_h\) by:

\(\int_{\Omega_h}f(x,y)\) =\sphinxcode{\sphinxupquote{int2d(Th)(f)}}
=\sphinxcode{\sphinxupquote{int2d(Th, qft=*)(f)}}
=\sphinxcode{\sphinxupquote{int2d(Th, qforder=*)(f)}}

where * stands for the name of quadrature formula or the order of the Gauss formula.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{6}%
\begin{varwidth}[t]{\sphinxcolwidth{6}{6}}
\sphinxstyletheadfamily Quadrature formula on a triangle
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\(L\)
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qft}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qforder}}
&\sphinxstyletheadfamily 
Point in \(T_k\)
&\sphinxstyletheadfamily 
\(\omega_\ell\)
&\sphinxstyletheadfamily 
Exact on \(P_k,\ k=\)
\\
\hline
1
&
\sphinxcode{\sphinxupquote{qf1pT}}
&
2
&
\(\left(\frac{1}{3},\frac{1}{3}\right)\)
&
\(|T_k|\)
&
\(1\)
\\
\hline
3
&
\sphinxcode{\sphinxupquote{qf2pT}}
&
3
&
\(\left(\frac{1}{2},\frac{1}{2}\right)\)

\(\left(\frac{1}{2},0\right)\)

\(\left(0,\frac{1}{2}\right)\)
&
\(|T_k|/3\)

\(|T_k|/3\)

\(|T_k|/3\)
&
\(2\)
\\
\hline
7
&
\sphinxcode{\sphinxupquote{qf5pT}}
&
6
&
\(\left(\frac{1}{3},\frac{1}{3}\right)\)

\(\left(\frac{6-\sqrt{15}}{21},\frac{6-\sqrt{15}}{21}\right)\)

\(\left(\frac{6-\sqrt{15}}{21},\frac{9+2\sqrt{15}}{21}\right)\)

\(\left(\frac{9+2\sqrt{15}}{21},\frac{6-\sqrt{15}}{21}\right)\)

\(\left(\frac{6+\sqrt{15}}{21},\frac{6+\sqrt{15}}{21}\right)\)

\(\left(\frac{6+\sqrt{15}}{21},\frac{9-2\sqrt{15}}{21}\right)\)

\(\left(\frac{9-2\sqrt{15}}{21},\frac{6+\sqrt{15}}{21}\right)\)
&
\(0.225|T_k|\)

\(\frac{(155-\sqrt{15})|T_k|}{1200}\)

\(\frac{(155-\sqrt{15})|T_k|}{1200}\)

\(\frac{(155-\sqrt{15})|T_k|}{1200}\)

\(\frac{(155+\sqrt{15})|T_k|}{1200}\)

\(\frac{(155+\sqrt{15})|T_k|}{1200}\)

\(\frac{(155+\sqrt{15})|T_k|}{1200}\)
&
\(5\)
\\
\hline
3
&
\sphinxcode{\sphinxupquote{qf1pTlump}}
&&
\(\left(0,0\right)\)

\(\left(1,0\right)\)

\(\left(0,1\right)\)
&
\(|T_k|/3\)

\(|T_k|/3\)

\(|T_k|/3\)
&
\(1\)
\\
\hline
9
&
\sphinxcode{\sphinxupquote{qf2pT4P1}}
&&
\(\left(\frac{1}{4},\frac{3}{4}\right)\)

\(\left(\frac{3}{4},\frac{1}{4}\right)\)

\(\left(0,\frac{1}{4}\right)\)

\(\left(0,\frac{3}{4}\right)\)

\(\left(\frac{1}{4},0\right)\)

\(\left(\frac{3}{4},0\right)\)

\(\left(\frac{1}{4},\frac{1}{4}\right)\)

\(\left(\frac{1}{4},\frac{1}{2}\right)\)

\(\left(\frac{1}{2},\frac{1}{4}\right)\)
&
\(|T_k|/12\)

\(|T_k|/12\)

\(|T_k|/12\)

\(|T_k|/12\)

\(|T_k|/12\)

\(|T_k|/12\)

\(|T_k|/6\)

\(|T_k|/6\)

\(|T_k|/6\)
&
\(1\)
\\
\hline
15
&
\sphinxcode{\sphinxupquote{qf7pT}}
&
8
&
See \sphinxcite{reference:taylor2005} for detail
&&
7
\\
\hline
21
&
\sphinxcode{\sphinxupquote{qf9pT}}
&
10
&
See \sphinxcite{reference:taylor2005} for detail
&&
9
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

For a three dimensional domain \(\Omega_h=\sum_{k=1}^{n_t}T_k,\, \mathcal{T}_h=\{T_k\}\), we can calculate the integral over \(\Omega_h\) by:

\(\int_{\Omega_h}f(x,y)\) =\sphinxcode{\sphinxupquote{int3d(Th)(f)}}
=\sphinxcode{\sphinxupquote{int3d(Th,qfV=*)(f)}}
=\sphinxcode{\sphinxupquote{int3D(Th,qforder=*)(f)}}

where * stands for the name of quadrature formula or the order of the Gauss formula.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{6}%
\begin{varwidth}[t]{\sphinxcolwidth{6}{6}}
\sphinxstyletheadfamily Quadrature formula on a tetrahedron
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\(L\)
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qfV}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qforder}}
&\sphinxstyletheadfamily 
Point in \(T_k\in\R^3\)
&\sphinxstyletheadfamily 
\(\omega_\ell\)
&\sphinxstyletheadfamily 
Exact on \(P_k,\ k=\)
\\
\hline
1
&
\sphinxcode{\sphinxupquote{qfV1}}
&
\(2\)
&
\(\left(\frac{1}{4},\frac{1}{4},\frac{1}{4}\right)\)
&
\(|T_k|\)
&
\(1\)
\\
\hline
4
&
\sphinxcode{\sphinxupquote{qfV2}}
&
\(3\)
&
\(G4(0.58\ldots,0.13\ldots,0.13\ldots)\)
&
\(|T_k|/4\)
&
\(2\)
\\
\hline
14
&
\sphinxcode{\sphinxupquote{qfV5}}
&
\(6\)
&
\(G4(0.72\ldots,0.092\ldots,0.092\ldots)\)

\(G4(0.067\ldots,0.31\ldots,0.31\ldots)\)

\(G6(0.45\ldots,0.045\ldots,0.45\ldots)\)
&
\(0.073\ldots|T_k|\)

\(0.11\ldots|T_k|\)

\(0.042\ldots|T_k|\)
&
\(5\)
\\
\hline
4
&
\sphinxcode{\sphinxupquote{qfV1lump}}
&&
\(G4(1,0,0)\)
&
\(|T_k|/4\)
&
\(1\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Where \(G4(a,b,b)\) such that \(a+3b=1\) is the set of the four point in barycentric coordinate:
\begin{equation*}
\begin{split}\{(a,b,b,b),(b,a,b,b),(b,b,a,b),(b,b,b,a)\}\end{split}
\end{equation*}
and where \(G6(a,b,b)\) such that \(2a+2b=1\) is the set of the six points in barycentric coordinate:
\begin{equation*}
\begin{split}\{(a,a,b,b),(a,b,a,b),(a,b,b,a),(b,b,a,a),(b,a,b,a),(b,a,a,b)\}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
These tetrahedral quadrature formulae come from \sphinxurl{http://nines.cs.kuleuven.be/research/ecf/mtables.html}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
By default, we use the formula which is exact for polynomials of degree \(5\) on triangles or edges (in bold in three tables).
\end{sphinxadmonition}

It is possible to add an own quadrature formulae with using plugin \sphinxcode{\sphinxupquote{qf11to25}} on segment, triangle or Tetrahedron.

The quadrature formulae in \(D\) dimension is a bidimentional array of size \(N_q\times (D+1)\) such that the \(D+1\) value of on row \(i=0,...,N_p-1\) are \(w^i,\hat{x}^i_1,...,\hat{x}^i_D\) where \(w^i\) is the weight of the quadrature point, and \(1-\sum_{k=1}^D \hat{x}^i_k ,\hat{x}^i_1,...,\hat{x}^i_D\) is the barycentric coordinate the quadrature point.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{qf11to25}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Quadrature on segment}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{qq1} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{;}

\PYG{n}{QF1} \PYG{n+nf}{qf1}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{qq1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def of quadrature formulae qf1 on segment}
\PYG{c+c1}{//remark:}
\PYG{c+c1}{//1 is the order of the quadrature exact for polynome of degree \PYGZlt{} 1}

\PYG{c+c1}{//Quadrature on triangle}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{qq2} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{;}

\PYG{n}{QF2} \PYG{n+nf}{qf2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{qq2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def of quadrature formulae qf2 on triangle}
\PYG{c+c1}{//remark:}
\PYG{c+c1}{//1 is the order of the quadrature exact for polynome of degree \PYGZlt{} 1}
\PYG{c+c1}{//so must have sum w\PYGZca{}i = 1}

\PYG{c+c1}{// Quadrature on tetrahedron}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{qq3} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{;}

\PYG{n}{QF3} \PYG{n+nf}{qf3}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{qq3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def of quadrature formulae qf3 on get}
\PYG{c+c1}{//remark:}
\PYG{c+c1}{//1 is the order of the quadrature exact for polynome of degree \PYGZlt{} 1)}

\PYG{c+c1}{// Verification in 1d and 2d}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{I1} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{n}{qf1}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{I1l} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf1pElump}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{I2} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{n}{qf2}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{I2l} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf1pTlump}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I1l} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I2l} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{I1}\PYG{o}{\PYGZhy{}}\PYG{n}{I1l}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{I2}\PYG{o}{\PYGZhy{}}\PYG{n}{I2l}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The output is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{1}.67 \PYG{o}{=}\PYG{o}{=} \PYG{l+m}{1}.67
\PYG{l+m}{0}.335 \PYG{o}{=}\PYG{o}{=} \PYG{l+m}{0}.335
\end{sphinxVerbatim}


\subsection{Variational Form, Sparse Matrix, PDE Data Vector}
\label{\detokenize{documentation/finiteElement:variational-form-sparse-matrix-pde-data-vector}}\label{\detokenize{documentation/finiteElement:variationalformsparsematrixpde}}
In \sphinxstylestrong{FreeFem++} it is possible to define variational forms, and use them to build matrices and vectors, and store them to speed-up the script (4 times faster here).

For example let us solve the {\hyperref[\detokenize{tutorial/thermalConduction:thermalconduction}]{\sphinxcrossref{\DUrole{std,std-ref}{Thermal Conduction problem}}}}.

The variational formulation is in \(L^2(0,T;H^1(\Omega))\); we shall seek \(u^n\) satisfying:
\begin{equation*}
\begin{split}\forall w \in V_{0}; \qquad \int_\Omega \frac{u^n-u^{n-1}}{\delta t} w + \kappa\n u^n\n w) +\int_\Gamma\alpha(u^n-u_{ue})w=0\end{split}
\end{equation*}
where \(V_0 = \{w\in H^1(\Omega)/ w_{|\Gamma_{24}}=0\}\).

So to code the method with the matrices \(A=(A_{ij})\), \(M=(M_{ij})\), and the vectors \(u^n, b^n, b',b", b_{cl}\) (notation if \(w\) is a vector then \(w_i\) is a component of the vector).
\begin{equation*}
\begin{split}u^n = A^{-1} b^n, \quad
\quad b' = b_0 + M u^{n-1},
\quad b"= \frac{1}{\varepsilon} \; b_{cl},
\quad b^n_i = \left\{
\begin{array}{cl} b"_i & \mbox{if }\ i \in \Gamma_{24} \\
b'_i & \mbox{else if } \not\in \Gamma_{24} \end{array}\right.\end{split}
\end{equation*}
Where with \(\frac{1}{\varepsilon} = \mathtt{tgv} = 10^{30}\):
\begin{equation*}
\begin{split}\begin{array}{rcl}
    A_{ij} &=& \left\{\begin{array}{cl} \frac{1}{\varepsilon} & \mbox{if } i \in \Gamma_{24}, \mbox{and} j=i \\
    \displaystyle
        \int_{\Omega} w_j w_i / dt + k (\nabla w_j. \nabla w_i ) + \int_{\Gamma_{13}} \alpha w_j w_i & \mbox{else if } i \not\in \Gamma_{24}, \mbox{or} j\ne i
        \end{array}\right.\\
        M_{ij} &=& \left\{\begin{array}{cl} \frac{1}{\varepsilon} & \mbox{if } i \in \Gamma_{24}, \mbox{and} j=i\\
    \displaystyle
        \int_{\Omega} w_j w_i / dt
        & \mbox{else if }i \not\in \Gamma_{24}, \mbox{or} j\ne i \end{array}\right. \\
        b_{0,i} &=& \int_{\Gamma_{13}} \alpha u_{ue} w_i \\
        b_{cl} &=& u^{0} \quad \mbox{the initial data}
\end{array}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{fu0} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{o}{+} \PYG{l+m+mi}{90}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mi}{6}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ue} \PYG{o}{=} \PYG{l+m+mf}{25.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1} \PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u0} \PYG{o}{=} \PYG{n}{fu0}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{n}{u0}\PYG{p}{;}
\end{sphinxVerbatim}

Create three variational formulation, and build the matrices \(A\),\(M\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{vthermic} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{k}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vthermic0} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{ue}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vMass} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{tgv} \PYG{o}{=} \PYG{l+m+mf}{1e30}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vthermic}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{k+kp}{tgv}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{M} \PYG{o}{=} \PYG{n}{vMass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now, to build the right hand size we need 4 vectors.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b0} \PYG{o}{=} \PYG{n}{vthermic0}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//constant part of the RHS}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bcn} \PYG{o}{=} \PYG{n}{vthermic}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//tgv on Dirichlet boundary node ( !=0 )}
\PYG{c+c1}{//we have for the node i : i in Gamma\PYGZus{}24 \PYGZhy{}\PYGZgt{} bcn[i] != 0}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bcl} \PYG{o}{=} \PYG{k+kp}{tgv}\PYG{o}{*}\PYG{n}{u0}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the Dirichlet boundary condition part}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The boundary condition is implemented by penalization and vector \sphinxcode{\sphinxupquote{bcn}} contains the contribution of the boundary condition \(u=1\), so to change the boundary condition, we have just to multiply the vector \sphinxcode{\sphinxupquote{bc{[}{]}}} by the current value \sphinxcode{\sphinxupquote{f}} of the new boundary condition term by term with the operator \sphinxcode{\sphinxupquote{.*}}.

{\hyperref[\detokenize{model/navierStokesEquations:navierstokesuzawaconjugategradients}]{\sphinxcrossref{\DUrole{std,std-ref}{Uzawa model}}}} gives a real example of using all this features.
\end{sphinxadmonition}

And the new version of the algorithm is now:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Time loop}
\PYG{k+kt}{ofstream} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{thermic.dat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b0}\PYG{p}{;} \PYG{c+c1}{//for the RHS}
    \PYG{n}{b} \PYG{o}{+}\PYG{o}{=} \PYG{n}{M}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//add the the time dependent part}
    \PYG{c+c1}{//lock boundary part:}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{bcn} \PYG{o}{?} \PYG{n+nl}{bcl} \PYG{o}{:} \PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//do forall i: b[i] = bcn[i] ? bcl[i] : b[i]}

    \PYG{c+c1}{// Solve}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}

    \PYG{c+c1}{// Save}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Display}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{6.0}\PYG{o}{*}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{20.0}\PYG{p}{,} \PYG{l+m+mf}{0.9}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The functions appearing in the variational form are formal and local to the \sphinxcode{\sphinxupquote{varf}} definition, the only important thing is the order in the parameter list, like in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{vb1}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vb2}\PYG{p}{(}\PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

To build matrix \(A\) from the bilinear part the variational form \(a\) of type \sphinxcode{\sphinxupquote{varf}} simply write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Wh} \PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// where}
\PYG{c+c1}{//Vh is \PYGZdq{}fespace\PYGZdq{} for the unknown fields with a correct number of component}
\PYG{c+c1}{//Wh is \PYGZdq{}fespace\PYGZdq{} for the test fields with a correct number of component}
\end{sphinxVerbatim}

Possible named parameters in \sphinxcode{\sphinxupquote{, {[}...{]}}} are
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{solver=}} \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{CG}}, \sphinxcode{\sphinxupquote{Crout}}, \sphinxcode{\sphinxupquote{Cholesky}}, \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}}, \sphinxcode{\sphinxupquote{UMFPACK}} …
\begin{quote}

The default solver is \sphinxcode{\sphinxupquote{GMRES}}.

The storage mode of the matrix of the underlying linear system depends on the type of solver chosen; for \sphinxcode{\sphinxupquote{LU}} the matrix is sky-line non symmetric, for \sphinxcode{\sphinxupquote{Crout}} the matrix is sky-line symmetric, for \sphinxcode{\sphinxupquote{Cholesky}} the matrix is sky-line symmetric positive definite, for \sphinxcode{\sphinxupquote{CG}} the matrix is sparse symmetric positive, and for \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}} or \sphinxcode{\sphinxupquote{UMFPACK}} the matrix is just sparse.
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{factorize =}} If true then do the matrix factorization for \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Cholesky}} or \sphinxcode{\sphinxupquote{Crout}}, the default value is \sphinxcode{\sphinxupquote{false}}.

\item {} 
\sphinxcode{\sphinxupquote{eps=}} A real expression.
\begin{quote}

\(\varepsilon\) sets the stopping test for the iterative methods like \sphinxcode{\sphinxupquote{CG}}.

Note that if \(\varepsilon\) is negative then the stopping test is:
\begin{equation*}
\begin{split}|| A x - b || < |\varepsilon|\end{split}
\end{equation*}
if it is positive then the stopping test is
\begin{equation*}
\begin{split}|| A x - b || < \frac{|\varepsilon|}{|| A x_{0} - b ||}\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{precon=}} Name of a function (for example \sphinxcode{\sphinxupquote{P}}) to set the preconditioner.

The prototype for the function \sphinxcode{\sphinxupquote{P}} must be:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{P}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{xx}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{tgv=}} Huge value (\(10^{30}\)) used to implement Dirichlet boundary conditions.

\item {} 
\sphinxcode{\sphinxupquote{tolpivot=}} Set the tolerance of the pivot in \sphinxcode{\sphinxupquote{UMFPACK}} (\(10^-1\)) and, \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Crout}}, \sphinxcode{\sphinxupquote{Cholesky}} factorization (\(10^{-20}\)).

\item {} 
\sphinxcode{\sphinxupquote{tolpivotsym=}} Set the tolerance of the pivot sym in \sphinxcode{\sphinxupquote{UMFPACK}}

\item {} 
\sphinxcode{\sphinxupquote{strategy=}} Set the integer UMFPACK strategy (\(0\) by default).

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
The line of the matrix corresponding to the space \sphinxcode{\sphinxupquote{Wh}} and the column of the matrix corresponding to the space \sphinxcode{\sphinxupquote{Vh}}.
\end{sphinxadmonition}

To build the dual vector \sphinxcode{\sphinxupquote{b}} (of type \sphinxcode{\sphinxupquote{real{[}int{]}}}) from the linear part of the variational form \sphinxcode{\sphinxupquote{a}} do simply:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n+nf}{b}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

A first example to compute the area of each triangle \(K\) of mesh \(Th\), just do:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Nh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the space function constant / triangle}
\PYG{n}{Nh} \PYG{n}{areaK}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{varea} \PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{chiK}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{chiK}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{etaK}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{varea}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Effectively, the basic functions of space \(Nh\), are the characteristic function of the element of Th, and the numbering is the numeration of the element, so by construction:
\begin{equation*}
\begin{split}\mathtt{etaK}[i] = \int {1}_{|K_i} = \int_{K_i} 1;\end{split}
\end{equation*}
Now, we can use this to compute error indicators like in example {\hyperref[\detokenize{model/staticProblems:modelstaticproblemadaptationusingresidualerrorindicator}]{\sphinxcrossref{\DUrole{std,std-ref}{Adaptation using residual error indicator}}}}.

First to compute a continuous approximation to the function \(h\) “density mesh size” of the mesh \(Th\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{h} \PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{count}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vmeshsizen} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{qfnbpE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vedgecount} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{qfnbpE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Computation of the mesh size}
\PYG{n}{count} \PYG{o}{=} \PYG{n}{vedgecount}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//number of edge / vertex}
\PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vmeshsizen}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//sum length edge / vertex}
\PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{/}\PYG{n}{count}\PYG{p}{;} \PYG{c+c1}{//mean length edge / vertex}
\end{sphinxVerbatim}

To compute error indicator for Poisson equation:
\begin{equation*}
\begin{split}{\eta_K = \int_K h_K^2 |( f + \Delta u_h)|^2 + \int_{\partial K} h_e |[ \frac{\partial u_h}{\partial n} ]|^2 }\end{split}
\end{equation*}
where \(h_K\) is size of the longest edge (\sphinxcode{\sphinxupquote{hTriangle}}), \(h_e\) is the size of the current edge (\sphinxcode{\sphinxupquote{lenEdge}}), \(n\) the normal.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Nh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// the space function constant / triangle}
\PYG{n}{Nh} \PYG{n}{etak}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vetaK} \PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{chiK}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{k+kr}{lenEdge}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{hTriangle}\PYG{o}{*}\PYG{p}{(}\PYG{n}{f} \PYG{o}{+} \PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{n}{etak}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vetaK}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We add automatic expression optimization by default, if this optimization creates problems, it can be removed with the keyword \sphinxcode{\sphinxupquote{optimize}} as in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{a} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{optimize}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

or you can also do optimization and remove the check by setting \sphinxcode{\sphinxupquote{optimize=2}}.

Remark, it is all possible to build interpolation matrix, like in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{VH}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{VH}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//build interpolation matrix Vh\PYGZhy{}\PYGZgt{}VH}
\PYG{k+kt}{matrix} \PYG{n}{BB} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//build interpolation matrix Vh\PYGZhy{}\PYGZgt{}Wh}
\end{sphinxVerbatim}

and after some operations on sparse matrices are available for example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//a full matrix}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{N}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{i}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{N}\PYG{p}{)} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{;}
    \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{sparseA} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sparseA} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{sparseA} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{sparseA} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{sparseB} \PYG{o}{=} \PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA}\PYG{p}{;} \PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sparseB = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sparseB}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Interpolation matrix}
\label{\detokenize{documentation/finiteElement:interpolation-matrix}}
It is also possible to store the matrix of a linear interpolation operator from a finite element space \(V_h\) to another \(W_h\) to \sphinxcode{\sphinxupquote{interpolate}}(\(W_h\),\(V_h\),…) a function.

Note that the continuous finite functions are extended by continuity outside of the domain.

The named parameters of function \sphinxcode{\sphinxupquote{interpolate}} are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{inside=}} set true to create zero-extension.

\item {} 
\sphinxcode{\sphinxupquote{t=}} set true to get the transposed matrix

\item {} 
\sphinxcode{\sphinxupquote{op=}} set an integer written below
\begin{itemize}
\item {} 
0 the default value and interpolate of the function

\item {} 
1 interpolate the \(\p_x\)

\item {} 
2 interpolate the \(\p_y\)

\item {} 
3 interpolate the \(\p_z\)

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{U2Vc=}} set the which is the component of \(W_h\) come in \(V_h\) in interpolate process in a int array so the size of the array is number of component of \(W_h\), if the put \(-1\) then component is set to \(0\), like in the following example: (by default the component number is unchanged).
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{V4h}\PYG{p}{(}\PYG{n}{Th4}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{V3h}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{u2vc} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//\PYGZhy{}1 \PYGZhy{}\PYGZgt{} put zero on the component}
\PYG{k+kt}{matrix} \PYG{n}{IV34} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{V3h}\PYG{p}{,} \PYG{n}{V4h}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{U2Vc}\PYG{o}{=}\PYG{n}{u2vc}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//V3h \PYGZlt{}\PYGZhy{} V4h}
\PYG{n}{V4h} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{,} \PYG{n}{a3}\PYG{p}{,} \PYG{n}{a4}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{V3h} \PYG{p}{[}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{b3}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{b1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{IV34}\PYG{o}{*}\PYG{n}{a1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

So here we have: \sphinxcode{\sphinxupquote{freefem   b1 == 2, b2 == 4, b3 == 0 ...}}
\end{quote}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
Matrix interpolation

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th4} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Th4}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh4}\PYG{p}{(}\PYG{n}{Th4}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh4} \PYG{n}{v4}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh4}\PYG{p}{(}\PYG{n}{Th4}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Interpolation}
\PYG{k+kt}{matrix} \PYG{n}{IV} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh4}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//here the function is exended by continuity}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh\PYGZlt{}\PYGZhy{}Vh4 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IV} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{v}\PYG{o}{=}\PYG{n}{v4}\PYG{p}{;}
\PYG{n}{vv}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=} \PYG{n}{IV}\PYG{o}{*}\PYG{n}{v4}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//here v == vv}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{diff}\PYG{o}{=} \PYG{n}{vv}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{} v \PYGZhy{} vv \textbar{}\textbar{} = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{diff}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n}{diff}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IV0} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh4}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//here the function is exended by zero}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh\PYGZlt{}\PYGZhy{}Vh4 (inside=1) }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IV0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IVt0} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh4}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh\PYGZlt{}\PYGZhy{}Vh4\PYGZca{}t (inside=1) }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IVt0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IV4t0} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh4}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh4\PYGZlt{}\PYGZhy{}Vh\PYGZca{}t }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IV4t0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IW4} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh4}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Wh4\PYGZlt{}\PYGZhy{}Wh }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IW4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IW4V} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh4}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Wh4\PYGZlt{}\PYGZhy{}Vh }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IW4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

Build interpolation matrix \(A\) at a array of points \((xx[j],yy[j]),\ i = 0,\ 2\) here:
\begin{equation*}
\begin{split}a_ij = dop(w^i_c (xx[j],yy[j]))\end{split}
\end{equation*}
where \(w_i\) is the basic finite element function, \(c\) the component number, \(dop\) the type of diff operator like in op def.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{.3}\PYG{p}{,} \PYG{l+m+mf}{.4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{yy} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{.1}\PYG{p}{,} \PYG{l+m+mf}{.4}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{dop} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Ixx} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{,} \PYG{k+kp}{op}\PYG{o}{=}\PYG{n}{dop}\PYG{p}{,} \PYG{k+kp}{composante}\PYG{o}{=}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ixx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ww}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n+nf}{dd} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{ww}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ixx}\PYG{o}{*}\PYG{n+nf}{dd}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Schwarz

The following shows how to implement with an interpolation matrix a domain decomposition algorithm based on Schwarz method with Robin conditions.

Given a non-overlapping partition \(\bar\Omega=\bar\Omega_0\cup\bar\Omega_1\) with \(\Omega_0\cap\Omega_1=\emptyset\), \(\Sigma:=\bar\Omega_0\cap\bar\Omega_1\) the algorithm is:
\begin{equation*}
\begin{split}-\Delta u_i &= f \hbox{ in }\Omega_i,~i=0,1,\\
\frac{\partial(u_1-u_0)}{\partial n} + \alpha (u_1-u_0) &=0\hbox{ on }\Sigma.\end{split}
\end{equation*}
The same in variational form is:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    &\int_{\Omega_i}\nabla u_i\cdot\nabla v &+ \int_\Sigma\alpha u_i v = \int_{\Omega_i}f v\\
    - \int_{\Omega_j}(\nabla u_j\cdot\nabla v-f v) + \int_\Sigma\alpha u_j v,~~
    \forall v\in H^1_0(\Omega), i,j=[0,1]\cup[1,0]
\end{array}\end{split}
\end{equation*}
To discretized with the \(P^1\) triangular Lagrangian finite element space \(V_h\) simply replace \(H^1_0(\Omega)\) by \(V_h(\Omega_0)\cup V_h(\Omega_1)\).

Then difficulty is to compute \(\int_{\Omega_j} \nabla u_j\cdot\nabla v\) when \(v\) is a basis function of \(V_h(\Omega_i)\), \(i\ne j\).

It is done as follows (with \(\Gamma=\partial\Omega\)):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{Gamma} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{Sigma} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{Niter} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{a0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Sigma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{n}{TH}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}
\PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{TH}\PYG{p}{(}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}

\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{reg}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh0}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh0} \PYG{n}{u0} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{u1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{a} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{b} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{du1dn} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{du0dn} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u0}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{I01} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh1}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{I10} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh0}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh0}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kp}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh1}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Solving loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}} \PYG{n}{Niter}\PYG{p}{;} \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve on Th[0]}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b0} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Du1dn} \PYG{o}{=} \PYG{n}{du1dn}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Tdu1dn}\PYG{p}{(}\PYG{n}{Vh0}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{Tdu1dn} \PYG{o}{=} \PYG{n}{I01}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Du1dn}\PYG{p}{;}
        \PYG{n}{b0} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Tdu1dn}\PYG{p}{;}
        \PYG{n}{u0}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Solve on Th[1]}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Du0dn} \PYG{o}{=} \PYG{n}{du0dn}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Tdu0dn}\PYG{p}{(}\PYG{n}{Vh1}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{Tdu0dn} \PYG{o}{=} \PYG{n}{I10}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Du0dn}\PYG{p}{;}
        \PYG{n}{b1} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Tdu0dn}\PYG{p}{;}
        \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iter=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Finite elements connectivity}
\label{\detokenize{documentation/finiteElement:finite-elements-connectivity}}
Here, we show how to get informations on a finite element space \(W_h({\cal T}_n,*)\), where “*” may be \sphinxcode{\sphinxupquote{P1, P2, P1nc}}, etc.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Wh.nt}} gives the number of element of \(W_h\)

\item {} 
\sphinxcode{\sphinxupquote{Wh.ndof}} gives the number of degrees of freedom or unknown

\item {} 
\sphinxcode{\sphinxupquote{Wh.ndofK}} gives the number of degrees of freedom on one element

\item {} 
\sphinxcode{\sphinxupquote{Wh(k,i)}} gives the number of \(i\)th degrees of freedom of element \(k\).

\end{itemize}

See the following example:

\begin{sphinxadmonition}{tip}{Tip:}
Finite element connectivity

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of degree of freedom = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Wh}\PYG{p}{.}\PYG{k+kr}{ndof} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of degree of freedom / ELEMENT = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Wh}\PYG{p}{.}\PYG{k+kr}{ndofK} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{kdf} \PYG{o}{=} \PYG{n}{Wh}\PYG{p}{.}\PYG{k+kr}{ndofK}\PYG{p}{;} \PYG{c+c1}{//element 2}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Degree of freedom of element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{o}{:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{kdf}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Wh}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Number of degree of \PYG{n+nv}{freedom} \PYG{o}{=} \PYG{l+m}{121}
Number of degree of freedom / \PYG{n+nv}{ELEMENT} \PYG{o}{=} \PYG{l+m}{6}
Degree of freedom of element \PYG{l+m}{2}:
\PYG{l+m}{78} \PYG{l+m}{95} \PYG{l+m}{83} \PYG{l+m}{87} \PYG{l+m}{79} \PYG{l+m}{92}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Visualization}
\label{\detokenize{documentation/visualization:visualization}}\label{\detokenize{documentation/visualization:id1}}\label{\detokenize{documentation/visualization::doc}}
Results created by the finite element method can be a huge set of data, so it is very important to render them easy to grasp.

There are two ways of visualization in FreeFem++:
\begin{itemize}
\item {} 
One, the default view, which supports the drawing of meshes, isovalues of real FE-functions, and of vector fields, all by the command \sphinxcode{\sphinxupquote{plot}} (see {\hyperref[\detokenize{documentation/visualization:plot}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot section}}}} below).
For publishing purpose, FreeFem++ can store these plots as postscript files.

\item {} 
Another method is to use external tools, for example, gnuplot (see {\hyperref[\detokenize{documentation/visualization:gnuplot}]{\sphinxcrossref{\DUrole{std,std-ref}{Gnuplot section}}}}, {\hyperref[\detokenize{documentation/visualization:medit}]{\sphinxcrossref{\DUrole{std,std-ref}{medit section}}}}, {\hyperref[\detokenize{documentation/visualization:paraview}]{\sphinxcrossref{\DUrole{std,std-ref}{Paraview section}}}}, {\hyperref[\detokenize{documentation/visualization:matlab}]{\sphinxcrossref{\DUrole{std,std-ref}{Matlab/Octave section}}}}) using the command \sphinxcode{\sphinxupquote{system}} to launch them and/or to save the data in text files.

\end{itemize}


\subsection{Plot}
\label{\detokenize{documentation/visualization:plot}}\label{\detokenize{documentation/visualization:id2}}
With the command \sphinxcode{\sphinxupquote{plot}}, meshes, isovalues of scalar functions, and vector fields can be displayed.

The parameters of the plot command can be meshes, real FE functions, arrays of 2 real FE functions, arrays of two double arrays, to plot respectively a mesh, a function, a vector field, or a curve defined by the two double arrays.

\begin{sphinxadmonition}{note}{Note:}
The length of an arrow is always bound to be in {[}5‰, 5\%{]} of the screen size in order to see something.
\end{sphinxadmonition}

The \sphinxcode{\sphinxupquote{plot}} command parameters are listed in the {\hyperref[\detokenize{reference/functions:referenceplot}]{\sphinxcrossref{\DUrole{std,std-ref}{Reference part}}}}.

The keyboard shortcuts are:
\begin{itemize}
\item {} 
\sphinxstylestrong{enter} tries to show plot

\item {} 
\sphinxstylestrong{p} previous plot (10 plots saved)

\item {} 
\sphinxstylestrong{?} shows this help

\item {} 
\sphinxstylestrong{+,-} zooms in/out around the cursor 3/2 times

\item {} 
\sphinxstylestrong{=} resets the view

\item {} 
\sphinxstylestrong{r} refreshes plot

\item {} 
\sphinxstylestrong{up, down, left, right} special keys to tanslate

\item {} 
\sphinxstylestrong{3} switches 3d/2d plot keys :
\begin{itemize}
\item {} 
\sphinxstylestrong{z,Z} focal zoom and zoom out

\item {} 
\sphinxstylestrong{H,h} increases or decreases the Z scale of the plot

\end{itemize}

\item {} 
\sphinxstylestrong{mouse motion}:
\begin{itemize}
\item {} 
\sphinxstylestrong{left button} rotates

\item {} 
\sphinxstylestrong{right button} zooms (ctrl+button on mac)

\item {} 
\sphinxstylestrong{right button +alt} tanslates (alt+ctrl+button on mac)

\end{itemize}

\item {} 
\sphinxstylestrong{a,A} increases or decreases the arrow size

\item {} 
\sphinxstylestrong{B} switches between showing the border meshes or not

\item {} 
\sphinxstylestrong{i,I} updates or not: the min/max bound of the functions to the window

\item {} 
\sphinxstylestrong{n,N} decreases or increases the number of iso value arrays

\item {} 
\sphinxstylestrong{b} switches between black and white or color plotting

\item {} 
\sphinxstylestrong{g} switches between grey or color plotting

\item {} 
\sphinxstylestrong{f} switches between filling iso or iso line

\item {} 
\sphinxstylestrong{l} switches between lighting or not

\item {} 
\sphinxstylestrong{v} switches between show or not showing the numerical value of colors

\item {} 
\sphinxstylestrong{m} switches between show or not showing the meshes

\item {} 
\sphinxstylestrong{w} window dump in file ffglutXXXX.ppm

\item {} 
\sphinxstylestrong{*} keep/drop viewpoint for next plot

\item {} 
\sphinxstylestrong{k} complex data / change view type

\item {} 
\sphinxstylestrong{ESC} closes the graphics process before version 3.22, after no way to close

\item {} 
\sphinxstylestrong{otherwise} does nothing

\end{itemize}

For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//plot scalar and vectorial FE function}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{vh}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{three.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//zoom on box defined by the two corner points [0.1,0.2] and [0.5,0.6]}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
   \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{grey}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{threeg.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//compute a cut}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{10.}\PYG{p}{;}
   \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{10.}\PYG{p}{;}
   \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
   \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{//value of uh at point (i/10., i/10.)}
\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{likegnu.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_Plot}.png}
\caption{Mesh, isovalue and vector}\label{\detokenize{documentation/visualization:id3}}\label{\detokenize{documentation/visualization:figvisumesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_Plot_Grey}.png}
\caption{Enlargement in grey of isovalue and vector}\label{\detokenize{documentation/visualization:id4}}\label{\detokenize{documentation/visualization:figvisugrey}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_Plot_Gnuplot}.png}
\caption{Plots a cut of \sphinxcode{\sphinxupquote{uh}}. Note that a refinement of the same can be obtained in combination with gnuplot}\label{\detokenize{documentation/visualization:id5}}\label{\detokenize{documentation/visualization:figvisucut}}\end{subfigure}
\caption{Plot}\phantomsection\label{\detokenize{documentation/visualization:Plot}}

\end{figure}


To change the color table and to choose the value of iso line you can do:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// from: \PYGZbs{}url\PYGZob{}http://en.wikipedia.org/wiki/HSV\PYGZus{}color\PYGZus{}space\PYGZcb{}}
\PYG{c+c1}{// The HSV (Hue, Saturation, Value) model defines a color space}
\PYG{c+c1}{// in terms of three constituent components:}
\PYG{c+c1}{// HSV color space as a color wheel}
\PYG{c+c1}{// Hue, the color type (such as red, blue, or yellow):}
\PYG{c+c1}{// Ranges from 0\PYGZhy{}360 (but normalized to 0\PYGZhy{}100\PYGZpc{} in some applications, like here)}
\PYG{c+c1}{// Saturation, the \PYGZdq{}vibrancy\PYGZdq{} of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}
\PYG{c+c1}{// The lower the saturation of a color, the more \PYGZdq{}grayness\PYGZdq{} is present}
\PYG{c+c1}{// and the more faded the color will appear.}
\PYG{c+c1}{// Value, the brightness of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{colorhsv}\PYG{o}{=}\PYG{p}{[} \PYG{c+c1}{// color hsv model}
   \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{c+c1}{// dark blue}
   \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// blue}
   \PYG{l+m+mf}{5.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// magenta}
   \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// red}
   \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.5} \PYG{p}{,} \PYG{l+m+mi}{1} \PYG{c+c1}{// light red}
   \PYG{p}{]}\PYG{p}{;}
 \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{31}\PYG{p}{)}\PYG{p}{;}

 \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
   \PYG{k+kp}{viso}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{o}{*}\PYG{l+m+mf}{0.1}\PYG{p}{;}

 \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{hsv}\PYG{o}{=}\PYG{n}{colorhsv}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_HSV_Space}.png}
\caption{HSV color cylinder}\label{\detokenize{documentation/visualization:id6}}\label{\detokenize{documentation/visualization:figvisuhsv}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_HSV}.png}
\caption{Isovalue with an other color table}\label{\detokenize{documentation/visualization:id7}}\label{\detokenize{documentation/visualization:figvisuisocolortable}}\end{subfigure}
\caption{HSV}\phantomsection\label{\detokenize{documentation/visualization:HSV}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
See {\hyperref[\detokenize{example/visualization:examplehsv}]{\sphinxcrossref{\DUrole{std,std-ref}{HSV example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with gnuplot}
\label{\detokenize{documentation/visualization:link-with-gnuplot}}\label{\detokenize{documentation/visualization:gnuplot}}
Example {\hyperref[\detokenize{tutorial/membrane:tutorialmembrane}]{\sphinxcrossref{\DUrole{std,std-ref}{Membrane}}}} shows how to generate a gnuplot from a FreeFem++ file.
Here is another technique which has the advantage of being online, i.e. one doesn’t need to quit FreeFem++ to generate a gnuplot.

However, this works only if \sphinxhref{http://www.gnuplot.info}{gnuplot} is installed, and only on an Unix-like computer.

Add to the previous example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}\PYG{c+c1}{// file for gnuplot}
   \PYG{k+kt}{ofstream} \PYG{n}{gnu}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{n}{gnu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// to call gnuplot command and wait 5 second (due to the Unix command)}
\PYG{c+c1}{// and make postscript plot}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{echo \PYGZsq{}plot }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ w l }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ pause 5 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set term postscript }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set output }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{gnuplot.eps}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ replot }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ quit\PYGZsq{} \textbar{} gnuplot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Gnuplot}.png}
\caption{Plots a cut of uh with gnuplot}\label{\detokenize{documentation/visualization:figvisugnuplot}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
See {\hyperref[\detokenize{example/visualization:exampleplot}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with medit}
\label{\detokenize{documentation/visualization:link-with-medit}}\label{\detokenize{documentation/visualization:medit}}
As said above, \sphinxcode{\sphinxupquote{medit}} is a freeware display package by Pascal Frey using OpenGL. Then you may run the following example.

Now \sphinxcode{\sphinxupquote{medit}} software is included in FreeFem++ under \sphinxcode{\sphinxupquote{ffmedit}} name.

The \sphinxcode{\sphinxupquote{medit}} command parameters are listed in the {\hyperref[\detokenize{reference/externalLibraries:referencemedit}]{\sphinxcrossref{\DUrole{std,std-ref}{Reference part}}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Medit}.png}
\caption{:freefem:medit{}` plot}\label{\detokenize{documentation/visualization:figvisumedit}}\end{figure}

With version 3.2 or later

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Before:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{u}\PYG{o}{*}\PYG{l+m+mf}{.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//save u.points and u.faces file}
\PYG{c+c1}{// build a u.bb file for medit}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.bb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2 1 1 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ 2 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//call medit command}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmedit u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//clean files on unix\PYGZhy{}like OS}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rm u.bb u.faces u.points}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
See {\hyperref[\detokenize{example/visualization:examplemedit}]{\sphinxcrossref{\DUrole{std,std-ref}{Medit example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with Paraview}
\label{\detokenize{documentation/visualization:link-with-paraview}}\label{\detokenize{documentation/visualization:paraview}}
One can also export mesh or results in the \sphinxcode{\sphinxupquote{.vtk}} format in order to post-process data using \sphinxhref{https://www.paraview.org/}{Paraview}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Order} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{DataName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n+nf}{savevtk}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.vtu}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{dataname}\PYG{o}{=}\PYG{n}{DataName}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{n}{Order}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Paraview}.png}
\caption{Paraview plot}\label{\detokenize{documentation/visualization:figvisuparaview}}\end{figure}

\begin{sphinxadmonition}{warning}{Warning:}
Finite element variables saved using paraview \sphinxstylestrong{must be in P0 or P1}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
See {\hyperref[\detokenize{example/visualization:exampleparaview}]{\sphinxcrossref{\DUrole{std,std-ref}{Paraview example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with Matlab© and Octave}
\label{\detokenize{documentation/visualization:link-with-matlab-and-octave}}\label{\detokenize{documentation/visualization:matlab}}
In order to create a plot from a FreeFem++ simulation in \sphinxhref{https://www.gnu.org/software/octave/}{Octave} and \sphinxhref{https://www.mathworks.com/}{Matlab} the mesh, the finite element space connectivity and the simulation data must be written to files:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmatlib.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{export\PYGZus{}mesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffSaveVh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{export\PYGZus{}vh.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffSaveData}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{export\PYGZus{}data.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Within Matlab or Octave the files can be plot with the \sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib library}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{addpath}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{path to ffmatlib\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{[}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{]}\PYG{p}{=}\PYG{n}{ffreadmesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{export\PYGZus{}mesh.msh\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{vh}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{export\PYGZus{}vh.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{export\PYGZus{}data.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VhSeq\PYGZsq{}}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XYData\PYGZsq{}}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ZStyle\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{continuous\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{grid}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Matlab_Octave}.png}
\caption{Matlab / Octave plot}\label{\detokenize{documentation/visualization:figvisumatlab}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
For more Matlab / Octave plot examples have a look at the tutorial section {\hyperref[\detokenize{tutorial/matlabOctavePlot:tutorialmatlaboctaveplot}]{\sphinxcrossref{\DUrole{std,std-ref}{Matlab / Octave Examples}}}} or visit the \sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib library} on github.
\end{sphinxadmonition}


\section{Algorithms \& Optimization}
\label{\detokenize{documentation/algorithmsOptimization:algorithms-optimization}}\label{\detokenize{documentation/algorithmsOptimization::doc}}

\subsection{Conjugate Gradient/GMRES}
\label{\detokenize{documentation/algorithmsOptimization:conjugate-gradient-gmres}}
Suppose we want to solve the Euler problem (here \(x\) has nothing to do with the reserved variable for the first coordinate in \sphinxstylestrong{FreeFem++}):

find \(x\in \mathbb{R}^n\) such that
\begin{equation}\label{equation:documentation/algorithmsOptimization:eqndJ}
\begin{split}\nabla J(x) = \left(\frac{\partial J}{\partial x_i} (\mathbf{x})\right) = 0\end{split}
\end{equation}
where \(J\) is a function (to minimize for example) from \(\mathbb{R}^n\) to \(\mathbb{R}\).

If the function is convex we can use the conjugate gradient algorithm to solve the problem, and we just need the function (named \sphinxcode{\sphinxupquote{dJ}} for example) which computes \(\nabla J\), so the parameters are the name of that function with prototype \sphinxcode{\sphinxupquote{func real{[}int{]} dJ(real{[}int{]} \&xx);}} which computes \(\nabla J\), and a vector \sphinxcode{\sphinxupquote{x}} of type (of course the number 20 can be changed) \sphinxcode{\sphinxupquote{real{[}int{]} x(20);}} to initialize the process and get the result.

Given an initial value \(\mathbf{x}^{(0)}\), a maximum number \(i_{\max}\) of iterations, and an error tolerance \(0<\epsilon<1\):

Put \(\mathbf{x}=\mathbf{x}^{(0)}\) and write

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{,} \PYG{k+kp}{stop}\PYG{o}{=}\PYG{n}{stopfunc}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

will give the solution of \(\mathbf{x}\) of \(\nabla J(\mathbf{x})=0\).
We can omit parameters \sphinxcode{\sphinxupquote{precon, nbiter, eps, stop}}.
Here \(M\) is the preconditioner whose default is the identity matrix.

The stopping test is
\begin{equation*}
\begin{split}\|\nabla J(\mathbf{x})\|_P\le \epsilon\| \nabla J(\mathbf{x}^{(0)})\|_P\end{split}
\end{equation*}
Writing the minus value in \sphinxcode{\sphinxupquote{eps=}}, i.e.,

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We can use the stopping test:
\begin{equation*}
\begin{split}\| \nabla J(\mathbf{x})\|_P^2\le \epsilon\end{split}
\end{equation*}
The parameters of these three functions are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nbiter=}} set the number of iteration (by default 100)

\item {} 
\sphinxcode{\sphinxupquote{precon=}} set the preconditioner function (\sphinxcode{\sphinxupquote{P}} for example) by default it is the identity, note the prototype is \sphinxcode{\sphinxupquote{func real{[}int{]} P(real{[}int{]} \&x)}}.

\item {} 
\sphinxcode{\sphinxupquote{eps=}} set the value of the stop test \(\varepsilon\) (\(=10^{-6}\) by default) if positive then relative test \(||\nabla J(x)||_P\leq \varepsilon||\nabla J(x_0)||_P\), otherwise the absolute test is \(||\nabla J(x)||_P^2\leq |\varepsilon|\).

\item {} 
\sphinxcode{\sphinxupquote{veps=}} set and return the value of the stop test, if positive, then relative test is \(||\nabla J(x)||_P\leq \varepsilon||\nabla J(x_0)||_P\), otherwise the absolute test is \(||\nabla J(x)||_P^2\leq |\varepsilon|\).
The return value is minus the real stop test (remark: it is useful in loop).

\item {} 
\sphinxcode{\sphinxupquote{stop=}} \sphinxcode{\sphinxupquote{stopfunc}} add your test function to stop before the \sphinxcode{\sphinxupquote{eps}} criterion. The prototype for the function \sphinxcode{\sphinxupquote{stopfunc}} is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n}{stopfunc}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{g}\PYG{p}{)}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{u}} is the current solution, and \sphinxcode{\sphinxupquote{g}}, the current gradient, is not preconditioned.

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
{\hyperref[\detokenize{example/algoOptimizations:examplealgorithms}]{\sphinxcrossref{\DUrole{std,std-ref}{Algorithms.edp}}}}

For a given function \(b\), let us find the minimizer \(u\) of the function
\begin{equation*}
\begin{split}\begin{array}{rcl}
   J(u) &=& \frac{1}{2}\int_{\Omega} f(|\nabla u|^2) - \int_{\Omega} u b \\
   f(x) &=& ax + x-\ln(1+x), \quad f'(x) = a+\frac{x}{1+x}, \quad f''(x) = \frac{1}{(1+x)^2}
\end{array}\end{split}
\end{equation*}
under the boundary condition \(u=0\) on \(\partial\Omega\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{alpha}\PYG{p}{;} \PYG{c+c1}{//store df(\textbar{}nabla u\textbar{}\PYGZca{}2)}

\PYG{c+c1}{// The functionn J}
\PYG{c+c1}{//J(u) = 1/2 int\PYGZus{}Omega f(\textbar{}nabla u\textbar{}\PYGZca{}2) \PYGZhy{} int\PYGZus{}Omega u b}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
   \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{f}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// The gradiant of J}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
   \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
   \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{au} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
      \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
         \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{vh}
      \PYG{p}{)}
      \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
      \PYG{p}{;}

   \PYG{n}{u} \PYG{o}{=} \PYG{n}{au}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

We also want to construct a preconditioner \(C\) with solving the problem:

find \(u_h \in V_{0h}\) such that:
\begin{equation*}
\begin{split}\forall v_h \in V_{0h}, \quad \int_\Omega \alpha \nabla u_h . \nabla v_h = \int_\Omega b v_h\end{split}
\end{equation*}
where \(\alpha=f'(|\nabla u|^2)\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{alap} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{amass}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{uh}\PYG{o}{*}\PYG{n}{vh}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{Amass} \PYG{o}{=} \PYG{n}{amass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Alap}\PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Preconditionner}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{w} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
   \PYG{n}{u} \PYG{o}{=} \PYG{n}{Alap}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array variable}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

To solve the problem, we make 10 iterations of the conjugate gradient, recompute the preconditioner and restart the conjugate gradient:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{conv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{conv} \PYG{o}{=} \PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{C}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{conv}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

   \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Alap} \PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Restart with new preconditionner }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{conv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, eps =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solution with NLCG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

For a given symmetric positive matrix \(A\), consider the quadratic form
\begin{equation*}
\begin{split}J(\mathbf{x})=\frac{1}{2}\mathbf{x}^TA\mathbf{x}-\mathbf{b}^T\mathbf{x}\end{split}
\end{equation*}
then \(J(\mathbf{x})\) is minimized by the solution \(\mathbf{x}\) of \(A\mathbf{x}=\mathbf{b}\).
In this case, we can use the function \sphinxcode{\sphinxupquote{AffineCG}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{AffineCG}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{,} \PYG{k+kp}{stop}\PYG{o}{=}\PYG{n}{stp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If \(A\) is not symmetric, we can use GMRES(Generalized Minimum Residual) algorithm by

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{AffineGMRES}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Also, we can use the non-linear version of GMRES algorithm (the function \(J\) is just convex)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{AffineGMRES}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For the details of these algorithms, refer to \sphinxcite{reference:pironneau1998}, Chapter IV, 1.3.


\subsection{Algorithms for Unconstrained Optimization}
\label{\detokenize{documentation/algorithmsOptimization:algorithms-for-unconstrained-optimization}}
Two algorithms of COOOL package are interfaced with the Newton Raphson method (called \sphinxcode{\sphinxupquote{Newton}}) and the \sphinxcode{\sphinxupquote{BFGS}} method.
These two are directly available in \sphinxstylestrong{FreeFem++} (no dynamical link to load).
Be careful with these algorithms, because their implementation uses full matrices.
We also provide several optimization algorithms from the \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt library} as well as an interface for Hansen’s implementation of CMAES (a MPI version of this one is also available).


\subsubsection{Example of usage for BFGS or CMAES}
\label{\detokenize{documentation/algorithmsOptimization:example-of-usage-for-bfgs-or-cmaes}}
\begin{sphinxadmonition}{tip}{Tip:}
BFGS

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//J}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.5} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugJ}\PYG{p}{)}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//the gradiant of J (this is a affine version (the RHS is in)}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{n}{u} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ\PYGZhy{}b: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//return of global variable ok}
\PYG{p}{\PYGZcb{}}

\PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nf}{BFGS}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{nbiterline}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BFGS: J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

It is almost the same a using the CMA evolution strategy except, that since it is a derivative free optimizer, the \sphinxcode{\sphinxupquote{dJ}} argument is omitted and there are some other named parameters to control the behavior of the algorithm.
With the same objective function as above, an example of utilization would be (see {\hyperref[\detokenize{example/algoOptimizations:examplecmaesvariationalinequality}]{\sphinxcrossref{\DUrole{std,std-ref}{CMAES Variational inequality}}}} for a complete example):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//define J, u, ...}
\PYG{k+kt}{real} \PYG{k+kr}{min} \PYG{o}{=} \PYG{n+nf}{cmaes}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{stopTolFun}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{stopMaxIter}\PYG{o}{=}\PYG{l+m+mi}{3000}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{minimum value is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ for u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

This algorithm works with a normal multivariate distribution in the parameters space and tries to adapt its covariance matrix using the information provided by the successive function evaluations (see \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt documentation} for more details).
Therefore, some specific parameters can be passed to control the starting distribution, size of the sample generations, etc…
Named parameters for this are the following:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{seed=}} Seed for random number generator (\sphinxcode{\sphinxupquote{val}} is an integer).
No specified value will lead to a clock based seed initialization.

\item {} 
\sphinxcode{\sphinxupquote{initialStdDev=}} Value for the standard deviations of the initial covariance matrix ( \sphinxcode{\sphinxupquote{val}} is a real).
If the value \(\sigma\) is passed, the initial covariance matrix will be set to \(\sigma I\).
The expected initial distance between initial \(X\) and the \(argmin\) should be roughly initialStdDev. Default is 0.3.

\item {} 
\sphinxcode{\sphinxupquote{initialStdDevs=}} Same as above except that the argument is an array allowing to set a value of the initial standard deviation for each parameter.
Entries differing by several orders of magnitude should be avoided (if it can’t be, try rescaling the problem).

\item {} 
\sphinxcode{\sphinxupquote{stopTolFun=}} Stops the algorithm if function value differences are smaller than the passed one, default is \(10^{-12}\).

\item {} 
\sphinxcode{\sphinxupquote{stopTolFunHist=}} Stops the algorithm if function value differences from the best values are smaller than the passed one, default is 0 (unused).

\item {} 
\sphinxcode{\sphinxupquote{stopTolX=}} Stopping criteria is triggered if step sizes in the parameters space are smaller than this real value, default is 0.

\item {} 
\sphinxcode{\sphinxupquote{stopTolXFactor=}} Stopping criteria is triggered when the standard deviation increases more than this value. The default value is \(10^{3}\).

\item {} 
\sphinxcode{\sphinxupquote{stopMaxFunEval=}} Stops the algorithm when \sphinxcode{\sphinxupquote{stopMaxFunEval}} function evaluations have been done.
Set to \(900(n+3)^{2}\) by default, where \(n\) is the parameters space dimension.

\item {} 
\sphinxcode{\sphinxupquote{stopMaxIter=}} Integer stopping the search when \sphinxcode{\sphinxupquote{stopMaxIter}} generations have been sampled.
Unused by default.

\item {} 
\sphinxcode{\sphinxupquote{popsize=}} Integer value used to change the sample size.
The default value is \(4+ \lfloor 3\ln (n) \rfloor\).
Increasing the population size usually improves the global search capabilities at the cost of, at most, a linear reduction of the convergence speed with respect to \sphinxcode{\sphinxupquote{popsize}}.

\item {} 
\sphinxcode{\sphinxupquote{paramFile=}} This \sphinxcode{\sphinxupquote{string}} type parameter allows the user to pass all the parameters using an extern file, as in Hansen’s original code.
More parameters related to the CMA-ES algorithm can be changed with this file.
Note that the parameters passed to the CMAES function in the \sphinxstylestrong{FreeFem++} script will be ignored if an input parameters file is given.

\end{itemize}


\subsection{IPOPT}
\label{\detokenize{documentation/algorithmsOptimization:ipopt}}
The \sphinxcode{\sphinxupquote{ff-Ipopt}} package is an interface for the \sphinxhref{https://projects.coin-or.org/Ipopt}{IPOPT} \sphinxcite{reference:wachter2006} optimizer.
IPOPT is a software library for large scale, non-linear, constrained optimization.
It implements a primal-dual interior point method along with filter method based line searches.

IPOPT needs a direct sparse symmetric linear solver.
If your version of \sphinxstylestrong{FreeFem++} has been compiled with the \sphinxcode{\sphinxupquote{-{-}enable-downlad}} tag, it will automatically be linked with a sequential version of MUMPS.
An alternative to MUMPS would be to download the HSL subroutines (see \sphinxhref{https://www.coin-or.org/Ipopt/documentation/node16.html}{Compiling and Installing the Java Interface JIPOPT}) and place them in the \sphinxcode{\sphinxupquote{/ipopt/Ipopt-3.10.2/ThirdParty/HSL}} directory of the \sphinxstylestrong{FreeFem++} downloads folder before compiling.


\subsubsection{Short description of the algorithm}
\label{\detokenize{documentation/algorithmsOptimization:short-description-of-the-algorithm}}
In this section, we give a very brief glimpse at the underlying mathematics of IPOPT.
For a deeper introduction on interior methods for nonlinear smooth optimization, one may consult \sphinxcite{reference:forsgren2002}, or \sphinxcite{reference:wachter2006} for more IPOPT specific elements.
IPOPT is designed to perform optimization for both equality and inequality constrained problems.
However, nonlinear inequalities are rearranged before the beginning of the optimization process in order to restrict the panel of nonlinear constraints to those of the equality kind.
Each nonlinear inequality is transformed into a pair of simple bound inequalities and nonlinear equality constraints by the introduction of as many slack variables as is needed : \(c_{i}(x)\leq 0\) becomes \(c_{i}(x) + s_{i} = 0\) and \(s_{i}\leq 0\), where \(s_{i}\) is added to the initial variables of the problems \(x_{i}\).
Thus, for convenience, we will assume that the minimization problem does not contain any nonlinear inequality constraint.
It means that, given a function \(f:\mathbb{R}^{n}\mapsto\mathbb{R}\), we want to find:
\begin{equation}\label{equation:documentation/algorithmsOptimization:minimproblem}
\begin{split}x_{0} = \underset{x\in V}{\operatorname{argmin}} f(x) \\
\mathrm{with}\ V = \left\lbrace x\in\mathbb{R}^{n}\ \vert\ c(x)= 0 \ \text{and}\ x_{l}\leq x\leq x_{u}\right\rbrace\end{split}
\end{equation}
Where \(c:\mathbb{R}^{n}\rightarrow\mathbb{R}^{m}\) and \(x_{l},x_{u}\in\mathbb{R}^{n}\) and inequalities hold componentwise.
The \(f\) function as well as the constraints \(c\) should be twice-continuously differentiable.

As a barrier method, interior points algorithms try to find a Karush-Kuhn-Tucker point for \eqref{equation:documentation/algorithmsOptimization:minimproblem} by solving a sequence of problems, unconstrained with respect to the inequality constraints, of the form:
\begin{equation}\label{equation:documentation/algorithmsOptimization:barrier}
\begin{split}\mathrm{for\ a\ given\ }\mu > 0,\ \mathrm{find}\ x_{\mu} = \underset{x\in\mathbb{R}^{n}\ \vert\ c(x)=0}{\operatorname{argmin}}\ B(x,\mu)\end{split}
\end{equation}
Where \(\mu\) is a positive real number and
\begin{equation*}
\begin{split}B(x,\mu) = f(x) - \displaystyle{\mu\sum_{i=1}^{n} \ln (x_{u,i}-x_{i})} - \displaystyle{\mu\sum_{i=1}^{m} \ln(x_{i}-x_{l,i})}\end{split}
\end{equation*}
The remaining equality constraints are handled with the usual Lagrange multipliers method.
If the sequence of barrier parameters \(\mu\) converge to 0, intuition suggests that the sequence of minimizers of \eqref{equation:documentation/algorithmsOptimization:barrier} converge to a local constrained minimizer of \eqref{equation:documentation/algorithmsOptimization:minimproblem}.
For a given \(\mu\), \eqref{equation:documentation/algorithmsOptimization:barrier} is solved by finding \((x_{\mu},\lambda_{\mu})\in\mathbb{R}^{n}\times\mathbb{R}^{m}\) such that:
\begin{equation}\label{equation:documentation/algorithmsOptimization:muproblem}
\begin{split}\nabla B(x_{\mu},\mu) + \displaystyle{\sum_{i=1}^{m}\lambda_{\mu,i}\nabla c_{i}(x_{\mu})}= \nabla B(x_{\mu},\mu) + J_{c}(x_{\mu})^{T}\lambda_{\mu}&= 0\\
c(x_{\mu}) &= 0\end{split}
\end{equation}
The derivations for \(\nabla B\) only holds for the \(x\) variables, so that:
\begin{equation*}
\begin{split}\nabla B(x,\mu) = \nabla f(x) + \left(\begin{matrix}\mu/(x_{u,1}-x_{1}) \\ \vdots \\ \mu/(x_{u,n}-x_{n})\end{matrix}\right) - \left(\begin{matrix}\mu/(x_{1}-x_{l,1}) \\ \vdots \\ \mu/(x_{n}-x_{l,n})\end{matrix}\right)\end{split}
\end{equation*}
If we respectively call \(z_{u}(x,\mu) = \left(\mu/(x_{u,1}-x_{1}),\dots, \mu/(x_{u,n}-x_{n})\right)\) and \(z_{l}(x,\mu)\) the other vector appearing in the above equation, then the optimum \((x_{\mu},\lambda_{\mu})\) satisfies:
\begin{equation}\label{equation:documentation/algorithmsOptimization:muproblemlambda}
\begin{split}\nabla f(x_{\mu}) + J_{c}(x_{\mu})^{T}\lambda_{\mu}+ z_{u}(x_{\mu},\mu) - z_{l}(x_{\mu},\mu) = 0 \quad \text{and} \quad c(x_{\mu}) = 0\end{split}
\end{equation}
In this equation, the \(z_l\) and \(z_u\) vectors seem to play the role of Lagrange multipliers for the simple bound inequalities, and indeed, when \(\mu\rightarrow 0\), they converge toward some suitable Lagrange multipliers for the KKT conditions, provided some technical assumptions are fulfilled (see \sphinxcite{reference:forsgren2002}).

Equation \eqref{equation:documentation/algorithmsOptimization:muproblemlambda} is solved by performing a Newton method in order to find a solution of \eqref{equation:documentation/algorithmsOptimization:muproblem} for each of the decreasing values of \(\mu\).
Some order 2 conditions are also taken into account to avoid convergence to local maximizers, see \sphinxcite{reference:forsgren2002} for details about them.
In the most classic IP algorithms, the Newton method is directly applied to \eqref{equation:documentation/algorithmsOptimization:muproblem}.
This is in most case inefficient due to frequent computation of infeasible points.
These difficulties are avoided in Primal-Dual interior point methods where \eqref{equation:documentation/algorithmsOptimization:muproblem} is transformed into an extended system where \(z_u\) and \(z_l\) are treated as unknowns and the barrier problems are finding \((x,\lambda,z_u,z_l)\in\mathbb{R}^n\times\mathbb{R}^m\times\mathbb{R}^n\times\mathbb{R}^n\) such that:
\begin{equation}\label{equation:documentation/algorithmsOptimization:PrimalDualIPBarrierProblem}
\begin{split}\left\lbrace
\begin{array}{rcl}
   \nabla f(x) + J_{c}(x)^{T}\lambda+ z_{u} - z_{l} & = & 0 \\
   c(x) & = & 0 \\
   (X_u - X) z_u - \mu e & = & 0 \\
   (X - X_l) z_l - \mu e & = & 0
\end{array}
\right.\end{split}
\end{equation}
Where if \(a\) is a vector of \(\mathbb{R}^n\), \(A\) denotes the diagonal matrix \(A=(a_i \delta_{ij})_{1\leq i,j\leq n}\) and \(e\in\mathbb{R}^{n} = (1,1,\dots,1)\).
Solving this nonlinear system by the Newton method is known as being the \sphinxstyleemphasis{primal-dual} interior point method.
Here again, more details are available in \sphinxcite{reference:forsgren2002}.
Most actual implementations introduce features in order to globalize the convergence capability of the method, essentially by adding some line-search steps to the Newton algorithm, or by using trust regions.
For the purpose of IPOPT, this is achieved by a \sphinxstyleemphasis{filter line search} methods, the details of which can be found in \sphinxcite{reference:wachter2006}.

More IPOPT specific features or implementation details can be found in \sphinxcite{reference:wachter2006}.
We will just retain that IPOPT is a smart Newton method for solving constrained optimization problems, with global convergence capabilities due to a robust line search method (in the sense that the algorithm will converge no matter the initializer).
Due to the underlying Newton method, the optimization process requires expressions of all derivatives up to the order 2 of the fitness function as well as those of the constraints.
For problems whose Hessian matrices are difficult to compute or lead to high dimensional dense matrices, it is possible to use a BFGS approximation of these objects at the cost of a much slower convergence rate.


\subsubsection{IPOPT in \sphinxstylestrong{FreeFem++}}
\label{\detokenize{documentation/algorithmsOptimization:ipopt-in-freefem}}
Calling the IPOPT optimizer in a \sphinxstylestrong{FreeFem++} script is done with the \sphinxcode{\sphinxupquote{IPOPT}} function included in the \sphinxcode{\sphinxupquote{ff-Ipopt}} dynamic library.
IPOPT is designed to solve constrained minimization problems in the form:
\begin{equation*}
\begin{split}\mathrm{find} & x_{0} = \underset{x\in\mathbb{R}^{n}}{\operatorname{argmin}} f(x) \\
\mathrm{s.t.} & \left\lbrace
\begin{array}{l r}
   \forall i\leq n,\ x_{i}^{\mathrm{lb}}\leq x_{i}\leq x_{i}^{\mathrm{ub}} & \mathrm{\ (simple\ bounds)} \\
   \forall i\leq m,\ c_{i}^{\mathrm{lb}}\leq c_{i}(x)\leq c_{i}^{\mathrm{ub}} & \mathrm{(constraints\ functions)}
\end{array}
\right.\end{split}
\end{equation*}
Where \(\mathrm{ub}\) and \(\mathrm{lb}\) stand for “upper bound” and “lower bound”.
If for some \(i, 1\leq i\leq m\) we have \(c_{i}^{\mathrm{lb}} = c_{i}^{\mathrm{ub}}\), it means that \(c_{i}\) is an equality constraint, and an inequality one if \(c_{i}^{\mathrm{lb}} < c_{i}^{\mathrm{ub}}\).

There are different ways to pass the fitness function and constraints.
The more general one is to define the functions using the keyword \sphinxcode{\sphinxupquote{func}}.
Any returned matrix must be a sparse one (type \sphinxcode{\sphinxupquote{matrix}}, not a \sphinxcode{\sphinxupquote{real{[}int,int{]}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Fitness Function, returns a scalar}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{gradJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Gradient is a vector}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Constraints}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n}{jacC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Constraints Jacobian}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
In the current version of \sphinxstylestrong{FreeFem++}, returning a \sphinxcode{\sphinxupquote{matrix}} object that is local to a function block leads to undefined results.
For each sparse matrix returning function you define, an extern matrix object has to be declared, whose associated function will overwrite and return on each call.
Here is an example for \sphinxcode{\sphinxupquote{jacC}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{jacCBuffer}\PYG{p}{;} \PYG{c+c1}{//just declare, no need to define yet}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{jacC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{c+c1}{//fill jacCBuffer}
   \PYG{k}{return} \PYG{n}{jacCBuffer}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
IPOPT requires the structure of each matrix at the initialization of the algorithm.
Some errors may occur if the matrices are not constant and are built with the \sphinxcode{\sphinxupquote{matrix A = {[}I,J,C{]}}} syntax, or with an intermediary full matrix (\sphinxcode{\sphinxupquote{real{[}int,int{]}}}), because any null coefficient is discarded during the construction of the sparse matrix.
It is also the case when making matrices linear combinations, for which any zero coefficient will result in the suppression of the matrix from the combination.
Some controls are available to avoid such problems.
Check the named parameter descriptions (\sphinxcode{\sphinxupquote{checkindex}}, \sphinxcode{\sphinxupquote{structhess}} and \sphinxcode{\sphinxupquote{structjac}} can help).
We strongly advice to use \sphinxcode{\sphinxupquote{varf}} as much as possible for the matrix forging.
\end{sphinxadmonition}

The Hessian returning function is somewhat different because it has to
be the Hessian of the Lagrangian function:
\begin{equation*}
\begin{split}(x,\sigma_{f},\lambda)\mapsto\sigma_{f}\nabla^{2}f(x)+\displaystyle{\sum_{i=1}^{m}\lambda_{i}\nabla^{2}c_{i}(x)}\ \mathrm{ where }\ \lambda\in\mathbb{R}^{m}\ \mathrm{ and }\ \sigma\in\mathbb{R}\end{split}
\end{equation*}
Your Hessian function should then have the following prototype:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{hessianLBuffer}\PYG{p}{;} \PYG{c+c1}{//Just to keep it in mind}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{hessianL} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{sigma}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{lambda}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If the constraints functions are all affine, or if there are only simple bound constraints, or no constraint at all, the Lagrangian Hessian is equal to the fitness function Hessian, one can then omit the \sphinxcode{\sphinxupquote{sigma}} and \sphinxcode{\sphinxupquote{lambda}} parameters:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{hessianJBuffer}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{hessianJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Hessian prototype when constraints are affine}
\end{sphinxVerbatim}

When these functions are defined, IPOPT is called this way:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Xi} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//starting point}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianL}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*some named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If the Hessian is omitted, the interface will tell IPOPT to use the (L)BFGS approximation (it can also be enabled with a named parameter, see further).
Simple bound or unconstrained problems do not require the constraints part, so the following expressions are valid:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//IPOPT with BFGS}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianJ}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Newton IPOPT without constraints}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//BFGS, no constraints}
\end{sphinxVerbatim}

Simple bounds are passed using the \sphinxcode{\sphinxupquote{lb}} and \sphinxcode{\sphinxupquote{ub}} named parameters, while constraint bounds are passed with the \sphinxcode{\sphinxupquote{clb}} and \sphinxcode{\sphinxupquote{cub}} ones.
Unboundedness in some directions can be achieved by using the \(1e^{19}\) and \(-1e^{19}\) values that IPOPT recognizes as \(+\infty\) and \(-\infty\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xlb}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xub}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{clb}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cub}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//fill the arrays...}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianL}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{xlb}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{xub}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{clb}\PYG{p}{,} \PYG{n}{cub}\PYG{o}{=}\PYG{n}{cub}\PYG{p}{,} \PYG{c+cm}{/*some other named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{P2 fitness function and affine constraints function :} In the case where the fitness function or constraints function can be expressed respectively in the following forms:
\begin{equation*}
\begin{split}\begin{array}{c c}
    \forall x\in\mathbb{R}^{n},\ f(x) = \frac{1}{2}\left\langle Ax,x \right\rangle + \left\langle b,x\right\rangle & (A,b)\in\mathcal{M}_{n,n}(\mathbb{R})\times\mathbb{R}^{n} \\
    \mathrm{or} ,\ C(x) = Ax + b & (A,b)\in\mathcal{M}_{n,m}(\mathbb{R})\times\mathbb{R}^{m}
\end{array}\end{split}
\end{equation*}
where \(A\) and \(b\) are constant, it is possible to directly pass the \((A,b)\) pair instead of defining 3 (or 2) functions.
It also indicates to IPOPT that some objects are constant and that they have to be evaluated only once, thus avoiding multiple copies of the same matrix.
The syntax is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Affine constraints with \PYGZdq{}standard\PYGZdq{} fitness function}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear part of the constraints}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//constant part of constraints}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianJ}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bounds and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//[b, A] would work as well.}
\end{sphinxVerbatim}

Note that if you define the constraints in this way, they don’t contribute to the Hessian, so the Hessian should only take one \sphinxcode{\sphinxupquote{real{[}int{]}}} as an argument.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Affine constraints and P2 fitness func}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//bilinear form matrix}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear contribution to f}
\PYG{k+kt}{matrix} \PYG{n}{Ac} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear part of the constraints}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bc} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//constant part of constraints}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Ac}\PYG{p}{,} \PYG{n}{bc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bounds and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If both objective and constraint functions are given this way, it automatically activates the IPOPT \sphinxcode{\sphinxupquote{mehrotra\_algorithm}} option (better for linear and quadratic programming according to the documentation).
Otherwise, this option can only be set through the option file (see the named parameters section).

A false case is the one of defining \(f\) in this manner while using standard functions for the constraints:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//bilinear form matrix}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear contribution to f}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//constraints}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n}{jacC}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//constraints Jacobian}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bounds and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Indeed, when passing \sphinxcode{\sphinxupquote{{[}A, b{]}}} in order to define \(f\), the Lagrangian Hessian is automatically built and has the constant \(x \mapsto A\) function, with no way to add possible constraint contributions, leading to incorrect second order derivatives.
So, a problem should be defined like that in only two cases:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
constraints are nonlinear but you want to use the BFGS mode (then add \sphinxcode{\sphinxupquote{bfgs=1}} to the named parameter),

\item {} 
constraints are affine, but in this case, compatible to pass in the same way

\end{enumerate}

Here are some other valid definitions of the problem (cases when \(f\) is a pure quadratic or linear form, or \(C\) a pure linear function, etc…):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Pure quadratic f \PYGZhy{} A is a matrix}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{c+cm}{/*constraints arguments*/}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bound and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Pure linear f \PYGZhy{} b is a real[int]}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{c+cm}{/*constraints arguments*/}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bound and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Linear constraints \PYGZhy{} Ac is a matrix}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{c+cm}{/*fitness function arguments*/}\PYG{p}{,} \PYG{n}{Ac}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bound and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{Returned Value :} The \sphinxcode{\sphinxupquote{IPOPT}} function returns an error code of type \sphinxcode{\sphinxupquote{int}}.
A zero value is obtained when the algorithm succeeds and positive values reflect the fact that IPOPT encounters minor troubles.
Negative values reveal more problematic cases.
The associated IPOPT return tags are listed in the table below.
The \sphinxhref{https://projects.coin-or.org/Ipopt/browser/stable/3.10/Ipopt/doc/documentation.pdf?format=raw}{IPOPT pdf documentation} provides a more accurate description of these return statuses:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Success
&\sphinxstyletheadfamily 
Failures
\\
\hline
0 \sphinxcode{\sphinxupquote{Solve\_Succeeded}}
&\\
\hline
1 \sphinxcode{\sphinxupquote{Solved\_To\_Acceptable\_Level}}
&
-1 \sphinxcode{\sphinxupquote{Maximum\_Iterations\_Exceeded}}
\\
\hline
2 \sphinxcode{\sphinxupquote{Infeasible\_Problem\_Detected}}
&
-2 \sphinxcode{\sphinxupquote{Restoration\_Failed}}
\\
\hline
3 \sphinxcode{\sphinxupquote{Search\_Direction\_Becomes\_Too\_Small}}
&
-3 \sphinxcode{\sphinxupquote{Error\_In\_Step\_Computation}}
\\
\hline
4 \sphinxcode{\sphinxupquote{Diverging\_Iterates}}
&
-4 \sphinxcode{\sphinxupquote{Maximum\_CpuTime\_Exceeded}}
\\
\hline
5 \sphinxcode{\sphinxupquote{User\_Requested\_Stop}}
&\\
\hline
6 \sphinxcode{\sphinxupquote{Feasible\_Point\_Found}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Problem definition issues
&\sphinxstyletheadfamily 
Critical errors
\\
\hline
-10 \sphinxcode{\sphinxupquote{Not\_Enough\_Degrees\_Of\_Freedom}}
&
-100 \sphinxcode{\sphinxupquote{Unrecoverable\_Exception}}
\\
\hline
-11 \sphinxcode{\sphinxupquote{Invalid\_Problem\_Definition}}
&
-101 \sphinxcode{\sphinxupquote{NonIpopt\_Exception\_Thrown}}
\\
\hline
-12 \sphinxcode{\sphinxupquote{Invalid\_Option}}
&
-102 \sphinxcode{\sphinxupquote{Insufficient\_Memory}}
\\
\hline
-13 \sphinxcode{\sphinxupquote{Invalid\_Number\_Detected}}
&
-199 \sphinxcode{\sphinxupquote{Internal\_Error}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstylestrong{Named Parameters :} The available named parameters in this interface are those we thought to be the most subject to variations from one optimization to another, plus a few that are interface specific.
Though, as one could see at \sphinxhref{https://www.coin-or.org/Ipopt/documentation/node59.html}{IPOPT Linear solver}, there are many parameters that can be changed within IPOPT, affecting the algorithm behavior.
These parameters can still be controlled by placing an option file in the execution directory.
Note that \sphinxhref{https://projects.coin-or.org/Ipopt/browser/stable/3.10/Ipopt/doc/documentation.pdf?format=raw}{IPOPT’s pdf documentation} may provides more information than the previously mentioned online version for certain parameters.
The in-script available parameters are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{lb}}, \sphinxcode{\sphinxupquote{ub}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} for lower and upper simple bounds upon the search variables must be of size \(n\) (search space dimension).
If two components of the same index in these arrays are equal then the corresponding search variable is fixed.
By default IPOPT will remove any fixed variable from the optimization process and always use the fixed value when calling functions.
It can be changed using the \sphinxcode{\sphinxupquote{fixedvar}} parameter.

\item {} 
\sphinxcode{\sphinxupquote{clb}}, \sphinxcode{\sphinxupquote{cub}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} of size \(m\) (number of constraints) for lower and upper constraints bounds.
Equality between two components of the same index \(i\) in \sphinxcode{\sphinxupquote{clb}} and \sphinxcode{\sphinxupquote{cub}} reflect an equality constraint.

\item {} 
\sphinxcode{\sphinxupquote{structjacc}} : To pass the greatest possible structure (indexes of non null coefficients) of the constraint Jacobians under the form \sphinxcode{\sphinxupquote{{[}I,J{]}}} where \sphinxcode{\sphinxupquote{I}} and \sphinxcode{\sphinxupquote{J}} are two integer arrays.
If not defined, the structure of the constraint Jacobians, evaluated in \sphinxcode{\sphinxupquote{Xi}}, is used (no issue if the Jacobian is constant or always defined with the same \sphinxcode{\sphinxupquote{varf}}, hazardous if it is with a triplet array or if a full matrix is involved).

\item {} 
\sphinxcode{\sphinxupquote{structhess}} : Same as above but for the Hessian function (unused if \(f\) is P2 or less and constraints are affine).
Here again, keep in mind that it is the Hessian of the Lagrangian function (which is equal to the Hessian of \(f\) only if constraints are affine).
If no structure is given with this parameter, the Lagrangian Hessian is evaluated on the starting point, with \(\sigma=1\) and \(\lambda = (1,1,\dots,1)\) (it is safe if all the constraints and fitness function Hessians are constant or build with \sphinxcode{\sphinxupquote{varf}}, and here again it is less reliable if built with a triplet array or a full matrix).

\item {} 
\sphinxcode{\sphinxupquote{checkindex}} : A \sphinxcode{\sphinxupquote{bool}} that triggers a dichotomic index search when matrices are copied from \sphinxstylestrong{FreeFem++} functions to IPOPT arrays.
It is used to avoid wrong index matching when some null coefficients are removed from the matrices by \sphinxstylestrong{FreeFem++}.
It will not solve the problems arising when a too small structure has been given at the initialization of the algorithm.
Enabled by default (except in cases where all matrices are obviously constant).

\item {} 
\sphinxcode{\sphinxupquote{warmstart}} : If set to \sphinxcode{\sphinxupquote{true}}, the constraints dual variables \(\lambda\), and simple bound dual variables are initialized with the values of the arrays passed to \sphinxcode{\sphinxupquote{lm}}, \sphinxcode{\sphinxupquote{lz}} and \sphinxcode{\sphinxupquote{uz}} named parameters (see below).

\item {} 
\sphinxcode{\sphinxupquote{lm}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} of size \(m\), which is used to get the final values of the constraints dual variables \(\lambda\) and/or initialize them in case of a warm start (the passed array is also updated to the last dual variables values at the end of the algorithm).

\item {} 
\sphinxcode{\sphinxupquote{lz}}, \sphinxcode{\sphinxupquote{uz}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} of size \(n\) to get the final values and/or initialize (in case of a warm start) the dual variables associated to simple bounds.

\item {} 
\sphinxcode{\sphinxupquote{tol}} : \sphinxcode{\sphinxupquote{real}}, convergence tolerance for the algorithm, the default value is \(10^{-8}\).

\item {} 
\sphinxcode{\sphinxupquote{maxiter}} : \sphinxcode{\sphinxupquote{int}}, maximum number of iterations with 3000 as default value.

\item {} 
\sphinxcode{\sphinxupquote{maxcputime}} : \sphinxcode{\sphinxupquote{real}} value, maximum runtime duration. Default is \(10^{6}\) (almost 11 and a halfdays).

\item {} 
\sphinxcode{\sphinxupquote{bfgs}} : \sphinxcode{\sphinxupquote{bool}} enabling or not the (low-storage) BFGS approximation of the Lagrangian Hessian.
It is set to false by default, unless there is no way to compute the Hessian with the functions that have been passed to IPOPT.

\item {} 
\sphinxcode{\sphinxupquote{derivativetest}} : Used to perform a comparison of the derivatives given to IPOPT with finite differences computation.
The possible \sphinxcode{\sphinxupquote{string}} values are : \sphinxcode{\sphinxupquote{"none"}} (default), \sphinxcode{\sphinxupquote{"first-order"}}, \sphinxcode{\sphinxupquote{"second-order"}} and \sphinxcode{\sphinxupquote{"only-second-order"}}.
The associated derivative error tolerance can be changed via the option file.
One should not care about any error given by it before having tried, and failed, to perform a first optimization.

\item {} 
\sphinxcode{\sphinxupquote{dth}} : Perturbation parameter for the derivative test computations with finite differences.
Set by default to \(10^{-8}\).

\item {} 
\sphinxcode{\sphinxupquote{dttol}} : Tolerance value for the derivative test error detection (default value unknown yet, maybe \(10^{-5}\)).

\item {} 
\sphinxcode{\sphinxupquote{optfile}} : \sphinxcode{\sphinxupquote{string}} parameter to specify the IPOPT option file name.
IPOPT will look for a \sphinxcode{\sphinxupquote{ipopt.opt}} file by default.
Options set in the file will overwrite those defined in the \sphinxstylestrong{FreeFem++} script.

\item {} 
\sphinxcode{\sphinxupquote{printlevel}} : An \sphinxcode{\sphinxupquote{int}} to control IPOPT output print level, set to 5 by default, the possible values are from 0 to 12.
A description of the output information is available in the \sphinxhref{https://projects.coin-or.org/Ipopt/browser/stable/3.10/Ipopt/doc/documentation.pdf?format=raw}{PDF documentation} of IPOPT.

\item {} 
\sphinxcode{\sphinxupquote{fixedvar}} : \sphinxcode{\sphinxupquote{string}} for the definition of simple bound equality constraints treatment : use \sphinxcode{\sphinxupquote{"make\_parameter"}} (default value) to simply remove them from the optimization process (the functions will always be evaluated with the fixed value for those variables), \sphinxcode{\sphinxupquote{"make\_constraint"}} to treat them as any other constraint or \sphinxcode{\sphinxupquote{"relax\_bounds"}} to relax fixing bound constraints.

\item {} 
\sphinxcode{\sphinxupquote{mustrategy}} : a \sphinxcode{\sphinxupquote{string}} to choose the update strategy for the barrier parameter \(\mu\).
The two possible tags are \sphinxcode{\sphinxupquote{"monotone"}}, to use the monotone (Fiacco-McCormick) strategy, or \sphinxcode{\sphinxupquote{"adaptive"}} (default setting).

\item {} 
\sphinxcode{\sphinxupquote{muinit}} : \sphinxcode{\sphinxupquote{real}} positive value for the barrier parameter initialization.
It is only relevant when \sphinxcode{\sphinxupquote{mustrategy}} has been set to \sphinxcode{\sphinxupquote{monotone}}.

\item {} 
\sphinxcode{\sphinxupquote{pivtol}} : \sphinxcode{\sphinxupquote{real}} value to set the pivot tolerance for the linear solver. A smaller number pivots for sparsity, a larger number pivots for stability.
The value has to be in the \([0,1]\) interval and is set to \(10^{-6}\) by default.

\item {} 
\sphinxcode{\sphinxupquote{brf}} : Bound relax factor: before starting the optimization, the bounds given by the user are relaxed.
This option sets the factor for this relaxation.
If it is set to zero, then the bound relaxation is disabled.
This \sphinxcode{\sphinxupquote{real}} has to be positive and its default value is \(10^{-8}\).

\item {} 
\sphinxcode{\sphinxupquote{objvalue}} : An identifier to a \sphinxcode{\sphinxupquote{real}} type variable to get the last value of the objective function (best value in case of success).

\item {} 
\sphinxcode{\sphinxupquote{mumin}} : minimum value for the barrier parameter \(\mu\), a \sphinxcode{\sphinxupquote{real}} with \(10^{-11}\) as default value.

\item {} 
\sphinxcode{\sphinxupquote{linesearch}} : A boolean which disables the line search when set to \sphinxcode{\sphinxupquote{false}}.
The line search is activated by default.
When disabled, the method becomes a standard Newton algorithm instead of a primal-dual system.
The global convergence is then no longer assured, meaning that many initializers could lead to diverging iterates.
But on the other hand, it can be useful when trying to catch a precise local minimum without having some out of control process making the iterate caught by some other near optimum.

\end{itemize}


\subsection{Some short examples using IPOPT}
\label{\detokenize{documentation/algorithmsOptimization:some-short-examples-using-ipopt}}
\begin{sphinxadmonition}{tip}{Tip:}
Ipopt variational inequality
A very simple example consisting of, given two functions \(f\) and \(g\) (defined on \(\Omega\subset\mathbb{R}^{2}\)), minimizing \(J(u) = \displaystyle{\frac{1}{2}\int_{\Omega} \vert\nabla u\vert^{2} - \int_{\Omega}fu}\ \), with \(u\leq g\) almost everywhere:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve}
\PYG{c+c1}{//\PYGZhy{} Delta u = f}
\PYG{c+c1}{//u \PYGZlt{} g}
\PYG{c+c1}{//u = 0 on Gamma}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//rhs function}
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{0.03}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{n}{r} \PYG{o}{\PYGZhy{}} \PYG{n}{r}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{lb} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.e19}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ub} \PYG{o}{=} \PYG{n}{g}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n}{vP} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
   \PYG{p}{)}
   \PYG{p}{;}
\end{sphinxVerbatim}

Here we build the matrix and second member associated to the function to fully and finally minimize it.
The \sphinxcode{\sphinxupquote{{[}A,b{]}}} syntax for the fitness function is then used to pass it to IPOPT.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We use simple bounds to impose the boundary condition \(u=0\) on \(\partial\Omega\), as well as the \(u\leq g\) condition.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{vGamma} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onGamma} \PYG{o}{=} \PYG{n}{vGamma}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//warning: the boundary conditions are given with lb and ub on border}
\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Ipopt variational inequality 2

Let \(\Omega\) be a domain of \(\mathbb{R}^{2}\).
\(f_{1}, f_{2}\in L^{2}(\Omega)\) and \(g_{1}, g_{2} \in L^{2}(\partial\Omega)\) four given functions with \(g_{1}\leq g_{2}\) almost everywhere.
We define the space:
\begin{equation*}
\begin{split}V = \left\lbrace (v_{1},v_{2})\in H^{1}(\Omega)^{2} ; v_{1}\vert_{\partial\Omega}=g_{1}, v_{2}\vert_{\partial\Omega}=g_{2}, v_{1}\leq v_{2}\ \mathrm{a.e.}\ \right\rbrace\end{split}
\end{equation*}
as well as the function \(J:H^{1}(\Omega)^{2}\longrightarrow \mathbb{R}\):
\begin{equation*}
\begin{split}J(v_{1},v_{2}) = \displaystyle{\frac{1}{2}\int_{\Omega}\vert\nabla v_{1}\vert^{2} - \int_{\Omega} f_{1}v_{1} + \frac{1}{2}\int_{\Omega}\vert\nabla v_{2}\vert^{2} - \int_{\Omega} f_{2}v_{2}}\end{split}
\end{equation*}
The problem entails finding (numerically) two functions \((u_{1},u_{2}) = \underset{(v_{1},v_{2})\in V}{\operatorname{argmin}} J(v_{1},v_{2})\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}\PYG{c+c1}{//right hand side}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{;}\PYG{c+c1}{//Boundary condition functions}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{uz}\PYG{p}{,} \PYG{n}{uz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{lz}\PYG{p}{,} \PYG{n}{lz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//starting point}

\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{lm}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Loop}
\PYG{k+kt}{int} \PYG{n}{iter}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Problem}
   \PYG{k+kt}{varf} \PYG{n}{vP} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{)}
      \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
         \PYG{o}{+} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
      \PYG{p}{)}
      \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{n}{f1}\PYG{o}{*}\PYG{n}{v1}
         \PYG{o}{+} \PYG{n}{f2}\PYG{o}{*}\PYG{n}{v2}
      \PYG{p}{)}
      \PYG{p}{;}

   \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//fitness function matrix}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//and linear form}

   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{II1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{II2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}\PYG{c+c1}{//Constraints matrix}
   \PYG{k+kt}{matrix} \PYG{n}{C1} \PYG{o}{=} \PYG{n+nf}{interpolate} \PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{U2Vc}\PYG{o}{=}\PYG{n}{II1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{n}{C2} \PYG{o}{=} \PYG{n+nf}{interpolate} \PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{U2Vc}\PYG{o}{=}\PYG{n}{II2}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{n}{CC} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{C1} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{;} \PYG{c+c1}{// u2 \PYGZhy{} u1 \PYGZgt{} 0}
   \PYG{n}{Wh} \PYG{n}{cl} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//constraints lower bounds (no upper bounds)}

   \PYG{c+c1}{//Boundary conditions}
   \PYG{k+kt}{varf} \PYG{n+nf}{vGamma} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onGamma} \PYG{o}{=} \PYG{n}{vGamma}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{ub1}\PYG{p}{,} \PYG{n}{ub2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{g2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{lb1}\PYG{p}{,} \PYG{n}{lb2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{g2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{ub1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{n}{ub1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{:} \PYG{l+m+mf}{1e19}\PYG{p}{;} \PYG{c+c1}{//Unbounded in interior}
   \PYG{n}{lb1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{n}{lb1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e19}\PYG{p}{;}

   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{uzi}\PYG{p}{,} \PYG{n}{uzi2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{uz}\PYG{p}{,} \PYG{n}{uz2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lzi}\PYG{p}{,} \PYG{n}{lzi2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{lz}\PYG{p}{,} \PYG{n}{lz2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{Wh} \PYG{n}{lmi} \PYG{o}{=} \PYG{n}{lm}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{;}

   \PYG{c+c1}{// Solve}
   \PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{n}{b}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{]}\PYG{p}{,} \PYG{n}{CC}\PYG{p}{,} \PYG{n}{ui1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{cl}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{warmstart}\PYG{o}{=}\PYG{n}{iter}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{uz}\PYG{o}{=}\PYG{n}{uzi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lz}\PYG{o}{=}\PYG{n}{lzi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lm}\PYG{o}{=}\PYG{n}{lmi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// Plot}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if}\PYG{p}{(}\PYG{n}{iter} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

   \PYG{c+c1}{// Mesh adpatation}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{l+m+mf}{0.004}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{[}\PYG{n}{uz}\PYG{p}{,} \PYG{n}{uz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{uzi}\PYG{p}{,} \PYG{n}{uzi2}\PYG{p}{]}\PYG{p}{;}
   \PYG{p}{[}\PYG{n}{lz}\PYG{p}{,} \PYG{n}{lz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{lzi}\PYG{p}{,} \PYG{n}{lzi2}\PYG{p}{]}\PYG{p}{;}
   \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{lm} \PYG{o}{=} \PYG{n}{lmi}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{VarIneqFill}.jpg}
\caption{Numerical Approximation of the Variational Inequality}\label{\detokenize{documentation/algorithmsOptimization:id10}}\label{\detokenize{documentation/algorithmsOptimization:figalgovarineqfill}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{VarIneqIso}.jpg}
\caption{Numerical Approximation of the Variational Inequality}\label{\detokenize{documentation/algorithmsOptimization:id11}}\label{\detokenize{documentation/algorithmsOptimization:figalgovarineqiso}}\end{subfigure}
\caption{Variational inequality}

\end{figure}

\end{sphinxadmonition}


\subsection{3D constrained minimum surface with IPOPT}
\label{\detokenize{documentation/algorithmsOptimization:d-constrained-minimum-surface-with-ipopt}}\label{\detokenize{documentation/algorithmsOptimization:VariationalInequality}}

\subsubsection{Area and volume expressions}
\label{\detokenize{documentation/algorithmsOptimization:area-and-volume-expressions}}
This example is aimed at numerically solving some constrained minimum surface problems with the IPOPT algorithm.
We restrain to \(C^{k}\) (\(k\geq 1\)), closed, spherically parametrizable surfaces, i.e. surfaces \(S\) such that:
\begin{equation*}
\begin{split}\exists \rho \in C^{k}([0,2\pi ]\times[0,\pi] ) \vert
S = \left\lbrace
X = \left(
\begin{array} {c}
 \rho(\theta,\phi) \\
 0 \\
 0
\end{array}
\right)
, (\theta,\phi) \in [0,2\pi ]\times[0,\pi]
 \right\rbrace\end{split}
\end{equation*}
Where the components are expressed in the spherical coordinate system.
Let’s call \(\Omega\) the \([0,2\pi ]\times[0,\pi]\) angular parameters set.
In order to exclude self crossing and opened shapes, the following assumptions upon \(\rho\) are made:
\begin{equation*}
\begin{split}\rho \geq 0\ \ \mathrm{and}\ \ \forall \phi, \rho(0,\phi) = \rho(2\pi,\phi)\end{split}
\end{equation*}
For a given function \(\rho\) the first fundamental form (the metric) of the defined surface has the following matrix representation:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msfff}
\begin{split}G =
\left(
\begin{array}{c c}
    \rho^{2}\sin^{2}(\phi) + (\partial_{\theta}\rho)^{2} &\partial_{\theta}\rho\partial_{\phi}\rho \\
    \partial_{\theta}\rho\partial_{\phi}\rho & \rho^{2} + (\partial_{\phi}\rho)^{2} \\
\end{array}
\right)\end{split}
\end{equation}
This metric is used to express the area of the surface.
Let \(g=\det(G)\), then we have:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msarea}
\begin{split}\begin{array}{ll}
    \mathcal{A}(\rho) &= \int{\Omega}{\left\| \partial_{\theta} X \wedge \partial_{\phi} X \right\|} =\int{\Omega}{\sqrt{g}}\\
        &=\int{\Omega}{\sqrt{ \rho^{2}(\partial_{\theta}\rho)^{2} + \rho^{4}\sin^{2}(\phi) + \rho^{2}(\partial_{\phi}\rho)^{2}\sin^{2}(\phi)}d\theta d\phi}
\end{array}\end{split}
\end{equation}
The volume of the space enclosed within the shape is easier to express:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msvolume}
\begin{split}\mathcal{V}(\rho)
= \int{\Omega}{\int_{0}^{\rho(\theta,\phi)} r^{2}\sin(\phi) dr d\theta d\phi}
= \frac{1}{3}\int{\Omega}{\rho^{3} \sin(\phi) d\theta d\phi}\end{split}
\end{equation}

\subsubsection{Derivatives}
\label{\detokenize{documentation/algorithmsOptimization:derivatives}}
In order to use a Newton based interior point optimization algorithm, one must be able to evaluate the derivatives of \(\mathcal{A}\) and \(\mathcal{V}\) with respect to \(rho\).
Concerning the area, we have the following result:
\begin{equation*}
\begin{split}\forall v\in C^{1}(\Omega) \ , \ \langle d\mathcal{A}(\rho),v\rangle
= \int{\Omega}{\frac{1}{2} \frac{ d\bar{g}(\rho)(v)}{\sqrt{g}}d\theta d\phi }\end{split}
\end{equation*}
Where \(\bar{g}\) is the application mapping the \((\theta,\phi) \mapsto g(\theta,\phi)\) scalar field to \(\rho\).
This leads to the following expression, easy to transpose in a freefem script using:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msdarea}
\begin{split}\begin{array}{r c l}
    \forall v\in C^{1}(\Omega)& &\\
    \langle d\mathcal{A}(\rho),v\rangle &=& \int{\Omega}{ \left(2\rho^{3}\sin^{2}(\phi) + \rho(\partial_{\theta}\rho)^{2} + \rho(\partial_{\phi}\rho)^{2}\sin^{2}(\phi) \right) v} \\
    & & +\int{\Omega}{\ \rho^{2}\partial_{\theta}\rho\partial_{\theta} v\ + \ \rho^{2}\partial_{\phi}\rho\sin^{2}(\phi)\partial_{\phi} v }
\end{array}\end{split}
\end{equation}
With a similar approach, one can derive an expression for second order derivatives.
However, comporting no specific difficulties, the detailed calculus are tedious, the result is that these derivatives can be written using a \(3\times 3\) matrix \(\mathbf{B}\) whose coefficients are expressed in term of \(\rho\) and its derivatives with respect to \(\theta\) and \(\phi\), such that:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msd2area}
\begin{split}\forall (w,v)\in C^{1}(\Omega)\ ,\ d^{2}\mathcal{A}(\rho)(w,v) = \int{\Omega}
{
   \left(\begin{array}{c c c} w & \partial_{\theta} w & \partial_{\phi} w \end{array}\right)
   \mathbf{B}
} \left( \begin{array}{c} v \\ \partial_{\theta} v \\ \partial_{\phi} v \end{array} \right) d\theta d\phi\end{split}
\end{equation}
Deriving the volume function derivatives is again an easier task.
We immediately get the following expressions:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msdvolume}
\begin{split}\begin{array}{r c l}
   \forall v\ ,\ \langle d\mathcal{V}(\rho),v\rangle & = & \int{\Omega}{\rho^{2}\sin(\phi)v\ d\theta d\phi} \\
   \forall w,v\ , d^{2}\mathcal{V}(\rho)(w,v) & = & \int{\Omega}{2\rho\sin(\phi)wv\ d\theta d\phi}
\end{array}\end{split}
\end{equation}

\subsubsection{The problem and its script}
\label{\detokenize{documentation/algorithmsOptimization:the-problem-and-its-script}}
The whole code is available in {\hyperref[\detokenize{example/algoOptimizations:exampleipoptminimalsurfacevolume}]{\sphinxcrossref{\DUrole{std,std-ref}{IPOPT minimal surface \& volume example}}}}.
We propose to solve the following problem:

\begin{sphinxadmonition}{tip}{Tip:}
Given a positive function \(\rho_{\mathrm{object}}\) piecewise continuous, and a scalar \(\mathcal{V}_{\mathrm{max}} > \mathcal{V}(\rho_{\mathrm{object}})\), find \(\rho_{0}\) such that:
\begin{equation*}
\begin{split}\rho_{0} = \underset{\rho\in C^{1}(\Omega)}{\operatorname{argmin}}\ \mathcal{A}(\rho)\ ,\ \mathrm{s.t.}\ \rho_{0}\geq\rho_{\mathrm{object}} \ \mathrm{and\ } \mathcal{V}(\rho_{0})\leq \mathcal{V}_{\mathrm{max}}\end{split}
\end{equation*}
If \(\rho_{\mathrm{object}}\) is the spherical parametrization of the surface of a 3-dimensional object (domain) \(\mathcal{O}\), it can be interpreted as finding the surface with minimum area enclosing the object with a given maximum volume. If \(\mathcal{V}_{\mathrm{max}}\) is close to \(\mathcal{V}(\rho_{\mathrm{object}})\), so should be \(\rho_{0}\) and \(\rho_{\mathrm{object}}\). With higher values of \(\mathcal{V}_{\mathrm{max}}\), \(\rho\) should be closer to the unconstrained minimum surface surrounding \(\mathcal{O}\) which is obtained as soon as \(\mathcal{V}_{\mathrm{max}} \geq \frac{4}{3}\pi \|\rho_{\mathrm{object}}\|_{\infty}^{3}\) (sufficient but not necessary).

It also could be interesting to solve the same problem with the constraint \(\mathcal{V}(\rho_{0})\geq \mathcal{V}_{\mathrm{min}}\) which leads to a sphere when \(\mathcal{V}_{\mathrm{min}} \geq \frac{1}{6}\pi \mathrm{diam}(\mathcal{O})^{3}\) and moves toward the solution of the unconstrained problem as \(\mathcal{V}_{\mathrm{min}}\) decreases.

We start by meshing the domain \([0,2\pi]\times\ [0,\pi]\), then a periodic P1 finite elements space is defined.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{np} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{regtest}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{shapeswitch} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{40.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{treshold} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r0} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{rr} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{r0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{e}\PYG{o}{*}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{RR} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{rr}\PYG{o}{*}\PYG{n}{rr}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{p}{,} \PYG{n}{np}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Initial shape definition}
\PYG{c+c1}{//outside of the mesh adaptation loop to initialize with the previous optimial shape found on further iterations}
\PYG{n}{Vh} \PYG{n}{startshape} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\end{sphinxVerbatim}

We create some finite element functions whose underlying arrays will be used to store the values of dual variables associated to all the constraints in order to reinitialize the algorithm with it in the case where we use mesh adaptation. Doing so, the algorithm will almost restart at the accuracy level it reached before mesh adaptation, thus saving many iterations.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh} \PYG{n}{uz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{lz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{n}{rreal}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{lm} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

Then, follows the mesh adaptation loop, and a rendering function, \sphinxcode{\sphinxupquote{Plot3D}}, using 3D mesh to display the shape it is passed with \sphinxcode{\sphinxupquote{medit}} (the \sphinxcode{\sphinxupquote{movemesh23}} procedure often crashes when called with ragged shapes).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{kkk} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{iter}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k+kt}{func} \PYG{n}{sin2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// A function which transform Th in 3d mesh (r=rho)}
   \PYG{c+c1}{//a point (theta,phi) of Th becomes ( r(theta,phi)*cos(theta)*sin(phi) , r(theta,phi)*sin(theta)*sin(phi) , r(theta,phi)*cos(phi) )}
   \PYG{c+c1}{//then displays the resulting mesh with medit}
   \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{Plot3D} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kt}{string} \PYG{k+kp}{cmm}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{ffplot}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{rhoo}\PYG{p}{;}
      \PYG{n}{rhoo}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rho}\PYG{p}{;}
      \PYG{c+c1}{//mesh sTh = square(np, np/2, [2*pi*x, pi*y]);}
      \PYG{c+c1}{//fespace sVh(sTh, P1);}
      \PYG{c+c1}{//Vh rhoplot = rhoo;}
      \PYG{k}{try}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{mesh3} \PYG{n}{Sphere} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{ffplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
         \PYG{k}{else}
            \PYG{n+nf}{medit}\PYG{p}{(}\PYG{k+kp}{cmm}\PYG{p}{,} \PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PLOT ERROR}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Here are the functions related to the area computation and its shape derivative, according to equations \eqref{equation:documentation/algorithmsOptimization:msarea} and \eqref{equation:documentation/algorithmsOptimization:msdarea}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Surface computation}
\PYG{c+c1}{//Maybe is it possible to use movemesh23 to have the surface function less complicated}
\PYG{c+c1}{//However, it would not simplify the gradient and the hessian}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Area} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{rho4} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho2}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho4}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{;}
   \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
      \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rho(theta,phi) on [0,2pi]x[0,pi] \PYGZhy{} S=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{res}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else}
      \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shape\PYGZus{}evolution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{rho2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{alpha}\PYG{p}{;}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{varf} \PYG{n}{dArea} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
      \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{alpha}\PYG{o}{*}\PYG{n}{v} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
      \PYG{p}{)}
      \PYG{p}{;}

   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dArea}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The function returning the hessian of the area for a given shape is a bit blurry, thus we won’t show here all of equation \eqref{equation:documentation/algorithmsOptimization:msd2area} coefficients definition, they can be found in the \sphinxcode{\sphinxupquote{edp}} file.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{hessianA}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{sqrtPsi3}\PYG{p}{,} \PYG{n}{C00}\PYG{p}{,} \PYG{n}{C01}\PYG{p}{,} \PYG{n}{C02}\PYG{p}{,} \PYG{n}{C11}\PYG{p}{,} \PYG{n}{C12}\PYG{p}{,} \PYG{n}{C22}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{;}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{C0}\PYG{p}{,} \PYG{n}{C1}\PYG{p}{,} \PYG{n}{C2}\PYG{p}{;}
      \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sqrtPsi3} \PYG{o}{=} \PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sqrtPsi}\PYG{p}{;}
      \PYG{n}{C0} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
      \PYG{n}{C1} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C2} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C00} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C01} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C1}\PYG{p}{;}
      \PYG{n}{C02} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
      \PYG{n}{C11} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C12} \PYG{o}{=} \PYG{n}{C1}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
      \PYG{n}{C22} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C2}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{varf} \PYG{n}{d2Area} \PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
      \PYG{o}{=}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}
              \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
         \PYG{p}{)}
         \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi3} \PYG{o}{*} \PYG{p}{(}
              \PYG{n}{C00}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C11}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C22}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
         \PYG{p}{)}
      \PYG{p}{)}
      \PYG{p}{;}
   \PYG{n}{hessianA} \PYG{o}{=} \PYG{n}{d2Area}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{hessianA}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

And the volume related functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Volume computation}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Volume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{rho3} \PYG{o}{=} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{dVolume}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dVolume}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{matrix} \PYG{n}{hessianV}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianVolume}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{hessianV} \PYG{o}{=} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{hessianV}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If we want to use the volume as a constraint function we must wrap it and its derivatives in some \sphinxstylestrong{FreeFem++} functions returning the appropriate types.
It is not done in the above functions in cases where one wants to use it as a fitness function.
The lagrangian hessian also has to be wrapped since the Volume is not linear with respect to \(\rho\), it has some non-null second order derivatives.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ipVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vol} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Volume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{k}{return} \PYG{n}{vol}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{matrix} \PYG{n}{mdV}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipGradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{:}\PYG{p}{)} \PYG{o}{=} \PYG{n}{GradVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mdV} \PYG{o}{=} \PYG{n}{dvol}\PYG{p}{;} \PYG{k}{return} \PYG{n}{mdV}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{matrix} \PYG{n}{HLagrangian}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipHessianLag} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{objfact}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{lambda}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{HLagrangian} \PYG{o}{=} \PYG{n}{objfact}\PYG{o}{*}\PYG{n}{HessianArea}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{HessianVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{HLagrangian}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{ipGradVolume}} function could pose some troubles during the optimization process because the gradient vector is transformed in a sparse matrix, so any null coefficient will be discarded.
Here we create the IPOPT structure manually and use the \sphinxcode{\sphinxupquote{checkindex}} named-parameter to avoid bad indexing during copies.
This gradient is actually dense, there is no reason for some components to be constantly zero:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{gvi}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{gvj}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{gvi} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

These two arrays will be passed to IPOPT with \sphinxcode{\sphinxupquote{structjacc={[}gvi,gvj{]}}}.
The last remaining things are the bound definitions.
The simple lower bound must be equal to the components of the P1 projection of \(\rho_{object}\).
And we choose \(\alpha\in [0,1]\) to set \(\mathcal{V}_{\mathrm{max}}\) to \((1-\alpha) \mathcal{V}(\rho_{object}) + \alpha\frac{4}{3}\pi \|\rho_{\mathrm{object}}\|_{\infty}^{3}\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{disc1} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{disc2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{lb} \PYG{o}{=} \PYG{n}{r0}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{q} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{q} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{o}{+}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{,} \PYG{n}{g}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{disc1}\PYG{p}{,} \PYG{n}{disc2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Vobj} \PYG{o}{=} \PYG{n}{Volume}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Vnvc} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
   \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{object\PYGZus{}inside}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{clb} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{cub} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{alpha}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Vobj} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{Vnvc}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

Calling IPOPT:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{Area}\PYG{p}{,} \PYG{n}{GradArea}\PYG{p}{,} \PYG{n}{ipHessianLag}\PYG{p}{,} \PYG{n}{ipVolume}\PYG{p}{,} \PYG{n}{ipGradVolume}\PYG{p}{,}
   \PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{clb}\PYG{p}{,} \PYG{n}{cub}\PYG{o}{=}\PYG{n}{cub}\PYG{p}{,} \PYG{n}{checkindex}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{maxiter}\PYG{o}{=}\PYG{n}{kkk}\PYG{o}{\PYGZlt{}}\PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{?} \PYG{l+m+mi}{40}\PYG{o}{:}\PYG{l+m+mi}{150}\PYG{p}{,}
   \PYG{n}{warmstart}\PYG{o}{=}\PYG{n}{kkk}\PYG{p}{,} \PYG{n}{lm}\PYG{o}{=}\PYG{n}{lm}\PYG{p}{,} \PYG{n}{uz}\PYG{o}{=}\PYG{n}{uz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lz}\PYG{o}{=}\PYG{n}{lz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{0.00001}\PYG{p}{,} \PYG{n}{structjacc}\PYG{o}{=}\PYG{p}{[}\PYG{n}{gvi}\PYG{p}{,}\PYG{n}{gvj}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IPOPT: res =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Shape\PYGZus{}at\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{GradArea}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ShapeGradient}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Finally, before closing the mesh adaptation loop, we have to perform the said adaptation.
The mesh is adaptated with respect to the \(X=(\rho, 0, 0)\) (in spherical coordinates) vector field, not directly with respect to \(\rho\), otherwise the true curvature of the 3D-shape would not be well taken into account.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,}
      \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{50000}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{startshape} \PYG{o}{=} \PYG{n}{rc}\PYG{p}{;}
   \PYG{n}{uz} \PYG{o}{=} \PYG{n}{uz}\PYG{p}{;}
   \PYG{n}{lz} \PYG{o}{=} \PYG{n}{lz}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Here are some pictures of the resulting surfaces obtained for decreasing values of \(\alpha\) (and a slightly more complicated object than two orthogonal discs).
We return to the enclosed object when \(\alpha=0\):

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{minsurf3D}.jpg}
\end{figure}
\end{sphinxadmonition}


\subsection{The nlOpt optimizers}
\label{\detokenize{documentation/algorithmsOptimization:the-nlopt-optimizers}}
The \sphinxcode{\sphinxupquote{ff-NLopt}} package provides a \sphinxstylestrong{FreeFem++} interface to the free/open-source library for nonlinear optimization, easing the use of several different free optimization (constrained or not) routines available online along with the PDE solver.
All the algorithms are well documented in \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt documentation}, therefore no exhaustive information concerning their mathematical specificities will be found here and we will focus on the way they are used in a \sphinxstylestrong{FreeFem++} script.
If needing detailed information about these algorithms, visit the website where a description of each of them is given, as well as many bibliographical links.

Most of the gradient based algorithms of NLopt uses a full matrix approximation of the Hessian, so if you’re planning to solve a large scale problem, use the IPOPT optimizer which definitely surpass them.

All the NLopt features are identified that way:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}NLopt}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//define J, u, and maybe grad(J), some constraints etc...}
\PYG{k+kt}{real} \PYG{k+kr}{min} \PYG{o}{=} \PYG{n}{nloptXXXXXX}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{c+c1}{//Unavoidable part}
   \PYG{n}{grad}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{name} \PYG{n}{of} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{J}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{c+c1}{//if needed}
   \PYG{n}{lb}\PYG{o}{=} \PYG{c+c1}{//Lower bounds array}
   \PYG{n}{ub}\PYG{o}{=} \PYG{c+c1}{//Upper bounds array}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{c+c1}{//Some optional arguments:}
   \PYG{c+c1}{//Constraints functions names,}
   \PYG{c+c1}{//Stopping criteria,}
   \PYG{c+c1}{//Algorithm specific parameters,}
   \PYG{c+c1}{//Etc...}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{XXXXXX}} refers to the algorithm tag (not necessarily 6 characters long).
\sphinxcode{\sphinxupquote{u}} is the starting position (a \sphinxcode{\sphinxupquote{real{[}int{]}}} type array) which will be overwritten by the algorithm, the value at the end being the found \(argmin\).
And as usual, \sphinxcode{\sphinxupquote{J}} is a function taking a \sphinxcode{\sphinxupquote{real{[}int{]}}} type array as argument and returning a \sphinxcode{\sphinxupquote{real}}.
\sphinxcode{\sphinxupquote{grad}}, \sphinxcode{\sphinxupquote{lb}} and \sphinxcode{\sphinxupquote{ub}} are “half-optional” arguments, in the sense that they are obligatory for some routines but not all.

The possible optionally named parameters are the following, note that they are not used by all algorithms (some do not support constraints, or a type of constraints, some are gradient-based and others are derivative free, etc…).
One can refer to the table after the parameters description to check which are the named parameters supported by a specific algorithm.
Using an unsupported parameter will not stop the compiler work, seldom breaks runtime, and will just be ignored.
When it is obvious you are missing a routine, you will get a warning message at runtime (for example if you pass a gradient to a derivative free algorithm, or set the population of a non-genetic one, etc…).
In the following description, \(n\) stands for the dimension of the search space.

\sphinxstylestrong{Half-optional parameters :}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{grad=}} The name of the function which computes the gradient of the cost function (prototype should be \sphinxcode{\sphinxupquote{real{[}int{]}}} \(\rightarrow\) \sphinxcode{\sphinxupquote{real{[}int{]}}}, both argument and result should have the size \(n\)).
This is needed as soon as a gradient-based method is involved, which is ignored if defined in a derivative free context.

\item {} 
\sphinxcode{\sphinxupquote{lb}}/\sphinxcode{\sphinxupquote{ub}} = Lower and upper bounds arrays ( \sphinxcode{\sphinxupquote{real{[}int{]}}} type) of size \(n\).
Used to define the bounds within which the search variable is allowed to move.
Needed for some algorithms, optional, or unsupported for others.

\item {} 
\sphinxcode{\sphinxupquote{subOpt}} : Only enabled for the Augmented Lagrangian and MLSL methods who need a sub-optimizer in order to work.
Just pass the tag of the desired local algorithm with a \sphinxcode{\sphinxupquote{string}}.

\end{itemize}

\sphinxstylestrong{Constraints related parameters (optional - unused if not specified):}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{IConst}}/\sphinxcode{\sphinxupquote{EConst}} : Allows to pass the name of a function implementing some inequality (resp. equality) constraints on the search space.
The function type must be \sphinxcode{\sphinxupquote{real{[}int{]}}} \(\rightarrow\) \sphinxcode{\sphinxupquote{real{[}int{]}}} where the size of the returned array is equal to the number of constraints (of the same type - it means that all of the constraints are computed in one vectorial function).
In order to mix inequality and equality constraints in a same minimization attempt, two vectorial functions have to be defined and passed.
See example \eqref{equation:documentation/algorithmsOptimization:varineqex} for more details about how these constraints have to be implemented.

\item {} 
\sphinxcode{\sphinxupquote{gradIConst}}/\sphinxcode{\sphinxupquote{gradEConst}} : Use to provide the inequality (resp. equality) constraints gradient.
These are \sphinxcode{\sphinxupquote{real{[}int{]}}} \(\rightarrow\) \sphinxcode{\sphinxupquote{real{[}int,int{]}}} type functions.
Assuming we have defined a constraint function (either inequality or equality) with \(p\) constraints, the size of the matrix returned by its associated gradient must be \(p\times n\) (the \(i\)-th line of the matrix is the gradient of the \(i\)-th constraint).
It is needed in a gradient-based context as soon as an inequality or equality constraint function is passed to the optimizer and ignored in all other cases.

\item {} 
\sphinxcode{\sphinxupquote{tolIConst}}/\sphinxcode{\sphinxupquote{tolEConst}} : Tolerance values for each constraint.
This is an array of size equal to the number of inequality (resp. equality) constraints.
Default value is set to \(10^{-12}\) for each constraint of any type.

\end{itemize}

\sphinxstylestrong{Stopping criteria :}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{stopFuncValue}} : Makes the algorithm end when the objective function reaches this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxcode{\sphinxupquote{stopRelXTol}} : Stops the algorithm when the relative moves in each direction of the search space is smaller than this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxcode{\sphinxupquote{stopAbsXTol}} : Stops the algorithm when the moves in each direction of the search space is smaller than the corresponding value in this \sphinxcode{\sphinxupquote{real{[}int{]}}} array.

\item {} 
\sphinxcode{\sphinxupquote{stopRelFTol}} : Stops the algorithm when the relative variation of the objective function is smaller than this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxcode{\sphinxupquote{stopAbsFTol}} : Stops the algorithm when the variation of the objective function is smaller than this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxcode{\sphinxupquote{stopMaxFEval}} : Stops the algorithm when the number of fitness evaluations reaches this \sphinxcode{\sphinxupquote{integer}} value.

\item {} 
\sphinxcode{\sphinxupquote{stopTime}} : Stops the algorithm when the optimization time in seconds exceeds this \sphinxcode{\sphinxupquote{real}} value.
This is not a strict maximum: the time may exceed it slightly, depending upon the algorithm and on how slow your function evaluation is.

Note that when an AUGLAG or MLSL method is used, the meta-algorithm and the sub-algorithm may have different termination criteria.
Thus, for algorithms of this kind, the following named parameters has been defined (just adding the SO prefix - for Sub-Optimizer) to set the ending condition of the sub-algorithm (the meta one uses the ones above): \sphinxcode{\sphinxupquote{SOStopFuncValue}}, \sphinxcode{\sphinxupquote{SOStopRelXTol}}, and so on… If these are not used, the sub-optimizer will use those of the master routine.

\end{itemize}

\sphinxstylestrong{Other named parameters :}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{popSize}} : \sphinxcode{\sphinxupquote{integer}} used to change the size of the sample for stochastic search methods.
Default value is a peculiar heuristic to the chosen algorithm.

\item {} 
\sphinxcode{\sphinxupquote{SOPopSize}} : Same as above, but when the stochastic search is passed to a meta-algorithm.

\item {} 
\sphinxcode{\sphinxupquote{nGradStored}} : The number (\sphinxcode{\sphinxupquote{integer}} type) of gradients to “remember” from previous optimization steps: increasing this increases the memory requirements but may speed convergence.
It is set to a heuristic value by default.
If used with AUGLAG or MLSL, it will only affect the given subsidiary algorithm.

\end{itemize}

The following table sums up the main characteristics of each algorithm, providing the more important information about which features are supported by which algorithm and what are the unavoidable arguments they need.
More details can be found in \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt documentation}.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[height=22cm]{{nlopttab}.png}
\end{figure}

\begin{sphinxadmonition}{tip}{Tip:}
Variational inequality

Let \(\Omega\) be a domain of \(\mathbb{R}^{2}\), \(f_{1}, f_{2}\in L^{2}(\Omega)\) and \(g_{1}, g_{2} \in L^{2}(\partial\Omega)\) four given functions with \(g_{1}\leq g_{2}\) almost everywhere.

We define the space:
\begin{equation*}
\begin{split}V = \left\lbrace (v_{1},v_{2})\in H^{1}(\Omega)^{2} ; v_{1}\vert_{\partial\Omega}=g_{1}, v_{2}\vert_{\partial\Omega}=g_{2}, v_{1}\leq v_{2}\ \mathrm{a.e.}\ \right\rbrace\end{split}
\end{equation*}
as well as the function \(J:H^{1}(\Omega)^{2}\longrightarrow \mathbb{R}\):
\begin{equation}\label{equation:documentation/algorithmsOptimization:varineqex}
\begin{split}J(v_{1},v_{2}) = \displaystyle{\frac{1}{2}\int_{\Omega}\vert\nabla v_{1}\vert^{2} - \int_{\Omega} f_{1}v_{1} + \frac{1}{2}\int_{\Omega}\vert\nabla v_{2}\vert^{2} - \int_{\Omega} f_{2}v_{2}}\end{split}
\end{equation}
The problem consists in finding (numerically) two functions \((u_{1},u_{2}) = \underset{(v_{1},v_{2})\in V}{\operatorname{argmin}} J(v_{1},v_{2})\).

This can be interpreted as finding \(u_{1}, u_{2}\) as close as possible (in a certain sense) to the solutions of the Laplace equation with respectively \(f_{1}, f_{2}\) second members and \(g_{1}, g_{2}\) Dirichlet boundary conditions with the \(u_{1}\leq u_{2}\) almost everywhere constraint.

Here is the corresponding script to treat this variational inequality problem with one of the NLOpt algorithms.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//A brief script to demonstrate how to use the freefemm interfaced nlopt routines}
\PYG{c+c1}{//The problem consist in solving a simple variational inequality using one of the}
\PYG{c+c1}{//optimization algorithm of nlopt. We restart the algorithlm a few times after}
\PYG{c+c1}{//performing some mesh adaptation to get a more precise output}

\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}NLopt}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{kas} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{c+c1}{//choose of the algorithm}
\PYG{k+kt}{int} \PYG{n}{NN} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{starttol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{bctol} \PYG{o}{=} \PYG{l+m+mf}{6.e\PYGZhy{}12}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{NN}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{oldu1}\PYG{p}{,} \PYG{n}{oldu2}\PYG{p}{;}

\PYG{c+c1}{// Adaptation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{al} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{al} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{al}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{varf} \PYG{n}{BVF} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{LVF1} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{LVF2} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f2}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{BVF}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{LVF1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{LVF2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kt}{varf} \PYG{n+nf}{Vbord} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{Vh} \PYG{n}{In}\PYG{p}{,} \PYG{n}{Bord}\PYG{p}{;}
   \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Vbord}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{In}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{gh1} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{gh2} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g2}\PYG{p}{;}

   \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
      \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Au2} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{Au1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
      \PYG{n}{Au2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
      \PYG{k+kt}{real} \PYG{n}{val} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au1} \PYG{o}{+} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au2}\PYG{p}{;}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{iter}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{9}\PYG{p}{)}
         \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{adapt level }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{al}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} iteration }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} J = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{val}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{val}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{varf} \PYG{n+nf}{dBFV} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{n}{dA} \PYG{o}{=} \PYG{n}{dBFV}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
      \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad1} \PYG{o}{=} \PYG{n}{dA}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{grad2} \PYG{o}{=} \PYG{n}{dA}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{grad1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
      \PYG{n}{grad2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{X}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Grad}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{grad1}\PYG{p}{;}
      \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{grad2}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{Grad}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{IneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{constraints}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{]}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{constraints}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dIneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dconst}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{dconst} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{dconst}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
         \PYG{n}{dconst}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{dconst}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{BordIndex}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Indexes of border d.f.}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Bord}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{k}{if} \PYG{p}{(}\PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{BordIndex}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{BC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{int} \PYG{n}{I} \PYG{o}{=} \PYG{n}{BordIndex}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
         \PYG{n}{bc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{I}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{I}\PYG{p}{]}\PYG{p}{;}
         \PYG{n}{bc}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{I}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{I}\PYG{p}{]}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{bc}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dBC}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dbc}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{dbc} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{int} \PYG{n}{I} \PYG{o}{=} \PYG{n}{BordIndex}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
         \PYG{n}{dbc}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{I}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
         \PYG{n}{dbc}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{,} \PYG{n}{I}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{dbc}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{up}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{al} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
      \PYG{n}{start}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{else}\PYG{p}{\PYGZob{}}
      \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{oldu1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{start}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{oldu2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{n}{up} \PYG{o}{=} \PYG{l+m+mi}{1000000}\PYG{p}{;}
   \PYG{n}{lo} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1000000}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{up}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{bctol}\PYG{p}{;}
         \PYG{n}{lo}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{bctol}\PYG{p}{;}
         \PYG{n}{up}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{bctol}\PYG{p}{;}
         \PYG{n}{lo}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{bctol}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{real} \PYG{n}{mini} \PYG{o}{=} \PYG{l+m+mf}{1e100}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptAUGLAG}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lo}\PYG{p}{,}
         \PYG{n}{ub}\PYG{o}{=}\PYG{n}{up}\PYG{p}{,} \PYG{n}{IConst}\PYG{o}{=}\PYG{n}{IneqC}\PYG{p}{,} \PYG{n}{gradIConst}\PYG{o}{=}\PYG{n}{dIneqC}\PYG{p}{,}
         \PYG{n}{subOpt}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LBFGS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{n}{stopAbsFTol}\PYG{o}{=}\PYG{n}{starttol}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptMMA}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lo}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{up}\PYG{p}{,} \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{n}{stopAbsFTol}\PYG{o}{=}\PYG{n}{starttol}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptAUGLAG}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{IConst}\PYG{o}{=}\PYG{n}{IneqC}\PYG{p}{,}
         \PYG{n}{gradIConst}\PYG{o}{=}\PYG{n}{dIneqC}\PYG{p}{,} \PYG{n}{EConst}\PYG{o}{=}\PYG{n}{BC}\PYG{p}{,} \PYG{n}{gradEConst}\PYG{o}{=}\PYG{n}{dBC}\PYG{p}{,}
         \PYG{n}{subOpt}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LBFGS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{stopRelXTol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}2}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptSLSQP}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{IConst}\PYG{o}{=}\PYG{n}{IneqC}\PYG{p}{,}
         \PYG{n}{gradIConst}\PYG{o}{=}\PYG{n}{dIneqC}\PYG{p}{,} \PYG{n}{EConst}\PYG{o}{=}\PYG{n}{BC}\PYG{p}{,} \PYG{n}{gradEConst}\PYG{o}{=}\PYG{n}{dBC}\PYG{p}{,}
         \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{n}{stopAbsFTol}\PYG{o}{=}\PYG{n}{starttol}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{;}
   \PYG{n}{best1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{best2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{start}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{oldu1} \PYG{o}{=} \PYG{n}{best1}\PYG{p}{;}
   \PYG{n}{oldu2} \PYG{o}{=} \PYG{n}{best2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Optimization with MPI}
\label{\detokenize{documentation/algorithmsOptimization:optimization-with-mpi}}
The only quick way to use the previously presented algorithms on a parallel architecture lies in parallelizing the used cost function (which is in most real life cases, the expensive part of the algorithm).
Somehow, we provide a parallel version of the CMA-ES algorithm.
The parallelization principle is the trivial one of evolving/genetic algorithms: at each iteration the cost function has to be evaluated \(N\) times without any dependence at all, these \(N\) calculus are then equally distributed to each process.
Calling the MPI version of CMA-ES is nearly the same as calling its sequential version (a complete example of use can be found in the {\hyperref[\detokenize{example/algoOptimizations:examplecmaesmpivariationalinequality}]{\sphinxcrossref{\DUrole{std,std-ref}{CMAES MPI variational inequality example}}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mpi\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{c+c1}{// Define J, u and all here}
\PYG{k+kt}{real} \PYG{k+kr}{min} \PYG{o}{=} \PYG{n}{cmaesMPI}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{stopTolFun}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{stopMaxIter}\PYG{o}{=}\PYG{l+m+mi}{3000}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{minimum value is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ for u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

If the population size is not changed using the \sphinxcode{\sphinxupquote{popsize}} parameter, it will use the heuristic value slightly changed to be equal to the closest greatest multiple of the size of the communicator used by the optimizer.
The \sphinxstylestrong{FreeFem++} \sphinxcode{\sphinxupquote{mpicommworld}} is used by default.
The user can specify his own MPI communicator with the named parameter \sphinxcode{\sphinxupquote{comm=}}, see the MPI section of this manual for more information about communicators in \sphinxstylestrong{FreeFem++}.


\section{Parallelization}
\label{\detokenize{documentation/parallelization:parallelization}}\label{\detokenize{documentation/parallelization::doc}}
A first attempt of parallelization of \sphinxstylestrong{FreeFem++} is made here with \sphinxstylestrong{MPI}.
An extended interface with MPI has been added to \sphinxstylestrong{FreeFem++} version 3.5, (see the \sphinxhref{https://www.mpi-forum.org/docs/}{MPI documentation} for the functionality of the language).


\subsection{MPI}
\label{\detokenize{documentation/parallelization:mpi}}

\subsubsection{MPI Keywords}
\label{\detokenize{documentation/parallelization:mpi-keywords}}
The following keywords and concepts are used:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{mpiComm}} to defined a \sphinxstyleemphasis{communication world}

\item {} 
\sphinxcode{\sphinxupquote{mpiGroup}} to defined a group of \sphinxstyleemphasis{processors} in the communication world

\item {} 
\sphinxcode{\sphinxupquote{mpiRequest}} to defined a request to wait for the end of the communication

\end{itemize}


\subsubsection{MPI Constants}
\label{\detokenize{documentation/parallelization:mpi-constants}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{mpisize}} The total number of \sphinxstyleemphasis{processes},

\item {} 
\sphinxcode{\sphinxupquote{mpirank}} the id-number of my current process in \sphinxcode{\sphinxupquote{\{0, ..., mpisize-1\}}},

\item {} 
\sphinxcode{\sphinxupquote{mpiUndefined}} The \sphinxcode{\sphinxupquote{MPI\_Undefined}} constant,

\item {} 
\sphinxcode{\sphinxupquote{mpiAnySource}} The \sphinxcode{\sphinxupquote{MPI\_ANY\_SOURCE}} constant,

\item {} 
\sphinxcode{\sphinxupquote{mpiCommWorld}} The \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}} constant,

\item {} 
{[} … {]} and all the keywords of \sphinxcode{\sphinxupquote{MPI\_Op}} for the \sphinxstyleemphasis{reduce} operator: \sphinxcode{\sphinxupquote{mpiMAX}}, \sphinxcode{\sphinxupquote{mpiMIN}}, \sphinxcode{\sphinxupquote{mpiSUM}}, \sphinxcode{\sphinxupquote{mpiPROD}}, \sphinxcode{\sphinxupquote{mpiLAND}}, \sphinxcode{\sphinxupquote{mpiLOR}}, \sphinxcode{\sphinxupquote{mpiLXOR}}, \sphinxcode{\sphinxupquote{mpiBAND}}, \sphinxcode{\sphinxupquote{mpiBXOR}}.

\end{itemize}


\subsubsection{MPI Constructor}
\label{\detokenize{documentation/parallelization:mpi-constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{proc1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{proc2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{color} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{key} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// MPI ranks}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPI rank = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// MPI}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set a MPI\PYGZus{}Comm to MPI\PYGZus{}COMM\PYGZus{}WORLD}

\PYG{k+kt}{mpiGroup} \PYG{n+nf}{grp}\PYG{p}{(}\PYG{n}{proc1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set MPI\PYGZus{}Group to proc 1,2 in MPI\PYGZus{}COMM\PYGZus{}WORLD}
\PYG{k+kt}{mpiGroup} \PYG{n+nf}{grp1}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{proc1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set MPI\PYGZus{}Group to proc 1,2 in comm}

\PYG{k+kt}{mpiComm} \PYG{n+nf}{ncomm1}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{n}{grp}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set the MPI\PYGZus{}Comm form grp}

\PYG{k+kt}{mpiComm} \PYG{n+nf}{ncomm2}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{color}\PYG{p}{,} \PYG{n}{key}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//MPI\PYGZus{}Comm\PYGZus{}split(MPI\PYGZus{}Comm comm, int color, int key, MPI\PYGZus{}Comm *ncomm)}

\PYG{k+kt}{mpiRequest} \PYG{n}{rq}\PYG{p}{;} \PYG{c+c1}{//defined an MPI\PYGZus{}Request}
\PYG{k+kt}{mpiRequest}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{arq}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//defined an array of 10 MPI\PYGZus{}Request}
\end{sphinxVerbatim}


\subsubsection{MPI Functions}
\label{\detokenize{documentation/parallelization:mpi-functions}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mpiComm} \PYG{n+nf}{Comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{MPICommSize} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MPIRank} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{MPIRank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPI Comm size = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{MPICommSize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPI rank in Comm = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{mpiRequest} \PYG{n}{Req}\PYG{p}{;}
\PYG{k+kt}{mpiRequest}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ReqArray}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{MPICommSize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
     \PYG{c+c1}{//return processor i with no Resquest in MPI\PYGZus{}COMM\PYGZus{}WORLD}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor any source with no Resquest in MPI\PYGZus{}COMM\PYGZus{}WORLD}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{k+kr}{mpiAnySource}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i with no Resquest in Comm}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i with no Resquest in Comm}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i with Resquest rq in Comm}
    \PYG{c+cm}{/* processor(i, Req, Comm);}
\PYG{c+cm}{    //return processor i with Resquest rq in MPI\PYGZus{}COMM\PYGZus{}WORLD}
\PYG{c+cm}{    processor(i, Req); */}
    \PYG{c+c1}{//return processor i in MPI\PYGZus{}COMM\PYGZus{}WORLD in block mode for synchronously communication}
    \PYG{n+nf}{processorblock}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor any source in MPI\PYGZus{}COMM\PYGZus{}WORLD in block mode for synchronously communication}
    \PYG{n+nf}{processorblock}\PYG{p}{(}\PYG{k+kr}{mpiAnySource}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i in in Comm in block mode}
    \PYG{n+nf}{processorblock}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{mpiBarrier}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//do a MPI\PYGZus{}Barrier on communicator Comm}
\PYG{n+nf}{mpiWaitAny}\PYG{p}{(}\PYG{n}{ReqArray}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait add of Request array,}
\PYG{n+nf}{mpiWait}\PYG{p}{(}\PYG{n}{Req}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait on a Request}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{n+nf}{mpiWtime}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//return MPIWtime in second}
\PYG{k+kt}{real} \PYG{n}{tick} \PYG{o}{=} \PYG{n+nf}{mpiWtick}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//return MPIWTick in second}
\end{sphinxVerbatim}

where a \sphinxcode{\sphinxupquote{processor}} is just a integer rank, pointer to a \sphinxcode{\sphinxupquote{MPI\_comm}} and pointer to a \sphinxcode{\sphinxupquote{MPI\_Request}}, and \sphinxcode{\sphinxupquote{processorblock}} with a special \sphinxcode{\sphinxupquote{MPI\_Request}}.


\subsubsection{MPI Communicator operator}
\label{\detokenize{documentation/parallelization:mpi-communicator-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{status}\PYG{p}{;} \PYG{c+c1}{//to get the MPI status of send / recv}
\PYG{k+kt}{real} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{;}

\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiRequest} \PYG{n}{req}\PYG{p}{;}

\PYG{c+c1}{//send a,b asynchronously to the process 1}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{;}
\PYG{c+c1}{//receive a,b synchronously from the process 10}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{;}

\PYG{c+c1}{//broadcast from processor of comm to other comm processor}
\PYG{c+c1}{// broadcast(processor(10, comm), a);}
\PYG{c+c1}{//send synchronously to the process 10 the data a}
\PYG{n}{status} \PYG{o}{=} \PYG{n}{Send}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//receive synchronously from the process 10 the data a}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Recv}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//send asynchronously to the process 10 the data a without request}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Isend}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//send asynchronously to the process 10 the data a with request}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Isend}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//receive asynchronously from the process 10 the data a}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Irecv}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Error asynchronously without request.}
\PYG{c+c1}{// status = Irecv(processor(10), a);}
\end{sphinxVerbatim}

where the data type of \sphinxcode{\sphinxupquote{a}} can be of type of \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{int{[}int,int{]}}}, \sphinxcode{\sphinxupquote{double{[}int,int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int,int{]}}}, \sphinxcode{\sphinxupquote{mesh}}, \sphinxcode{\sphinxupquote{mesh3}}, \sphinxcode{\sphinxupquote{mesh{[}int{]}}}, \sphinxcode{\sphinxupquote{mesh3{[}int{]}}}, \sphinxcode{\sphinxupquote{matrix}}, \sphinxcode{\sphinxupquote{matrix\textless{}complex\textgreater{}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//send asynchronously to the process 10 the data a with request}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{p}{;}
\PYG{c+c1}{//receive asynchronously from the process 10 the data a with request}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a} \PYG{p}{;}
\end{sphinxVerbatim}

If \sphinxcode{\sphinxupquote{a, b}} are arrays or full matrices of \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, or \sphinxcode{\sphinxupquote{complex}}, we can use the following MPI functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{mpiAlltoall}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{p}{[}\PYG{n}{comm}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiAllgather}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{p}{[}\PYG{n}{comm}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiGather}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiScatter}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiReduce}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiAllReduce}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Thank you to Guy-Antoine Atenekeng Kahou for his help to code this interface.


\subsubsection{Schwarz example in parallel}
\label{\detokenize{documentation/parallelization:schwarz-example-in-parallel}}
This example is a rewritting of example {\hyperref[\detokenize{model/domainDecomposition:domaindecompositionschwarzoverlapping}]{\sphinxcrossref{\DUrole{std,std-ref}{Schwarz overlapping}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{2} SchwarzParallel.edp
\PYG{c+c1}{\PYGZsh{} OR}
mpirun \PYGZhy{}np \PYG{l+m}{2} FreeFem++\PYGZhy{}mpi SchwarzParallel.edp
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpisize} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ sorry, number of processors !=2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{interior} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{exterior} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{interior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{interior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{e1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Th}\PYG{p}{(}\PYG{k+kr}{mpisize}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
    \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e1}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vhother}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vhother} \PYG{n}{U} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{//Problem}
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{pb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{interior}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{exterior}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} Loop }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{pb}\PYG{p}{;}
    \PYG{c+c1}{//send u to the other proc, receive in U}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{U}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{k+kt}{real} \PYG{n}{err0}\PYG{p}{,} \PYG{n}{err1}\PYG{p}{;}
    \PYG{n}{err0} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interior}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{U} \PYG{o}{\PYGZhy{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// send err0 to the other proc, receive in err1}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{err0}\PYG{p}{;}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{err1}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{err0} \PYG{o}{+} \PYG{n}{err1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} err0 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{err0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} err1 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{err1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{\label{documentation/parallelization:index-0}Todo:}
script freeze in the loop
\end{sphinxadmonition}


\paragraph{True parallel Schwarz example}
\label{\detokenize{documentation/parallelization:true-parallel-schwarz-example}}
\sphinxstyleemphasis{Thank you to F. Nataf}

This is a explanation of the two examples {\hyperref[\detokenize{example/parallelization:examplempigmres2d}]{\sphinxcrossref{\DUrole{std,std-ref}{MPI-GMRES 2D}}}} and {\hyperref[\detokenize{example/parallelization:examplempigmres3d}]{\sphinxcrossref{\DUrole{std,std-ref}{MPI-GMRES 3D}}}}, a Schwarz parallel with a complexity almost independent of the number of process (with a coarse grid preconditioner).

To solve the following Poisson problem on domain \(\Omega\) with boundary \(\Gamma\) in \(L^2(\Omega)\) :
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\Delta u &=& f & \mbox{ in } \Omega\\
    u &=& g & \mbox{ on } \Gamma
\end{array}\end{split}
\end{equation*}
where \(f\) and \(g\) are two given functions of \(L^2(\Omega)\) and of \(H^{\frac12}(\Gamma)\),

Lets introduce \((\pi_i)_{i=1,.., N_p}\) a regular partition of the unity of \(\Omega\), q-e-d:
\begin{equation*}
\begin{split}\pi_i \in \mathcal{C}^0(\Omega) : \quad \pi_i\ge 0 \mbox{ and } \sum_{i=1}^{N_p} \pi_i =1 .\end{split}
\end{equation*}
Denote \(\Omega_i\) the sub domain which is the support of \(\pi_i\) function and also denote \(\Gamma_i\) the boundary of \(\Omega_i\).

The parallel Schwarz method is:

Let \(\ell=0\) the iterator and a initial guest \(u^0\) respecting the boundary condition (i.e. \(u^0_{|\Gamma} = g\)).
\begin{equation}\label{equation:documentation/parallelization:eq:lapl}
\begin{split}\begin{array}{rcll}
    \forall i = 1 .., N_p:&\nonumber\\
    \displaystyle -\Delta u_i^\ell &=& f &\mbox{ in } \Omega_i\\
    u_i^\ell &=& u^\ell & \mbox{ on } \Gamma_i \setminus \Gamma\\
    u_i^\ell &=& g & \mbox{ on } \Gamma_i \cap \Gamma
\end{array}\end{split}
\end{equation}\begin{equation}\label{equation:documentation/parallelization:eq:pu1}
\begin{split}u^{\ell+1} = \sum_{i=1}^{N_p} \pi_i u_i^\ell\end{split}
\end{equation}
After discretization with the Lagrange finite element method, with a compatible mesh \({\mathcal{T}_h}_i\) of \(\Omega_i\), i. e., the exist a global mesh \({\mathcal{T}_h}\) such that \({\mathcal{T}_h}_i\) is include in \({\mathcal{T}_h}\).

Let us denote:
\begin{itemize}
\item {} 
\({V_h}_i\) the finite element space corresponding to domain \(\Omega_i\),

\item {} 
\({\mathcal{N}_h}_i\) is the set of the degree of freedom \(\sigma_i^k\),

\item {} 
\({\mathcal{N}^{\Gamma_i}_{hi}}\) is the set of the degree of freedom of \({V_h}_i\) on the boundary \(\Gamma_i\) of \(\Omega_i\),

\item {} 
\(\sigma_i^k({v_h})\) is the value the degree of freedom \(k\),

\item {} 
\({V_{0h}}_i= \{ {v_h} \in {V_h}_i :\forall k \in {\mathcal{N}^{\Gamma_i}_{hi}}, \quad \sigma_i^k({v_h})=0 \}\),

\item {} 
The conditional expression \(a\;?\;b:c\) is defined like in :c{}`C{}` of \sphinxcode{\sphinxupquote{C++}} language by
\begin{equation*}
\begin{split}a?b: c \equiv
\left\{
\begin{array}{l}
\mbox{if } a \mbox{ is true then return b}\\
\mbox{else return } c\\
\end{array}
\right..\end{split}
\end{equation*}
\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
We never use finite element space associated to the full domain \(\Omega\) because it is too expensive.
\end{sphinxadmonition}

We have to defined to operator to build the previous algorithm:

We denote \({u_h^{\ell}}_{|i}\) the restriction of \(u_h^\ell\) on \({V_h}_i\), so the discrete problem on \(\Omega_i\) of problem \eqref{equation:documentation/parallelization:eq:lapl} is find \({u_h^{\ell}}_{i}\in {V_h}_i\) such that:
\begin{equation*}
\begin{split}\forall {v_h}_i\in V_{0i}:
\int_{\Omega_i} \nabla {v_h}_i \cdot \nabla {u_h}^{\ell}_{i}
= \int_{\Omega_i} f {v_h}_i ,\quad \forall k \in {\mathcal{N}^{\Gamma_i}_{hi}}\;:\; \sigma_i^k({u_h}^\ell_i) = (k\in \Gamma) \; ? \; g_i^k : \sigma_i^k({u_h}^{\ell}_{|i})\end{split}
\end{equation*}
where \(g_i^k\) is the value of \(g\) associated to the degree of freedom \(k\in {\mathcal{N}^{\Gamma_i}_{hi}}\).

In \sphinxstylestrong{FreeFem++}, it can be written has with \sphinxcode{\sphinxupquote{U}} is the vector corresponding to \({u_h^{\ell}}_{|i}\) and the vector \sphinxcode{\sphinxupquote{U1}} is the vector corresponding to \({u_h^{\ell}}_{i}\) is the solution of:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{U1}\PYG{p}{(}\PYG{n}{Ui}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{U}\PYG{p}{;}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
\PYG{n}{U1} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
\end{sphinxVerbatim}

where \(\mathtt{onG}[i] =(i \in \Gamma_i\setminus\Gamma) ? 1 : 0\), and \(\mathtt{Bi}\) the right of side of the problem, are defined by

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whi}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{vPb} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{F}\PYG{o}{*}\PYG{n}{V}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{G}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vPbon} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{Ai} \PYG{o}{=} \PYG{n}{vPb} \PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onG} \PYG{o}{=} \PYG{n}{vPbon}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Bi}\PYG{o}{=}\PYG{n}{vPb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the \sphinxstylestrong{FreeFem++} label of \(\Gamma\) is 1 and the label of \(\Gamma_i\setminus \Gamma\) is \(10\).

To build the transfer/update part corresponding to \eqref{equation:documentation/parallelization:eq:pu1} equation on process \(i\), let us call \sphinxcode{\sphinxupquote{njpart}} the number the neighborhood of domain of \(\Omega_i\) (i.e: \(\pi_j\) is none \(0\) of \(\Omega_i\)), we store in an array \sphinxcode{\sphinxupquote{jpart}} of size \sphinxcode{\sphinxupquote{njpart}} all this neighborhood.

Let us introduce two array of matrix, \sphinxcode{\sphinxupquote{Smj{[}j{]}}} to defined the vector to send from \(i\) to \(j\) a neighborhood process, and the matrix \(rMj[j]\) to after to reduce owith neighborhood \(j\) domain.

So the tranfert and update part compute \(v_i= \pi_i u_i + \sum_{j\in J_i} \pi_j u_j\) and can be write the \sphinxstylestrong{FreeFem++} function Update:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{Update} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ui}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{vi}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n}{jpart}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n}{Usend}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;}
    \PYG{k+kt}{mpiRequest}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rq}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n+nf}{Irecv}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{jpart}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,}\PYG{n}{rq}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Ri}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n+nf}{Isend}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{jpart}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{rq}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{k+kr}{n}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Si}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{mpiWaitAny}\PYG{p}{(}\PYG{n}{rq}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// apply the unity local partition}
    \PYG{n}{vi} \PYG{o}{=} \PYG{n}{Pii}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;} \PYG{c+c1}{//set to pi\PYGZus{}i u\PYGZus{}i}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n}{vi} \PYG{o}{+}\PYG{o}{=} \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Vrecv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//add pi\PYGZus{}j u\PYGZus{}j}
    \PYG{k}{return} \PYG{k+kr}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

where the buffer are defined by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Usend}\PYG{p}{)} \PYG{c+c1}{//defined the send buffer}
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Vrecv}\PYG{p}{)} \PYG{c+c1}{//defined the revc buffer}
\end{sphinxVerbatim}

with the following macro definition:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{InitU}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{aTh}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)} \PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{U}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{n}{Th} \PYG{o}{=} \PYG{n}{aTh}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;} \PYG{n}{U}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstyleemphasis{First GMRES algorithm:} you can easily accelerate the fixed point algorithm by using a parallel GMRES algorithm after the introduction the following affine \(\mathcal{A}_i\) operator sub domain \(\Omega_i\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ0} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{U}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Where the parallel \sphinxcode{\sphinxupquote{MPIGMRES}} or \sphinxcode{\sphinxupquote{MPICG}} algorithm is just a simple way to solve in parallel the following \(A_i x_i = b_i, i = 1, .., N_p\) by just changing the dot product by reduce the local dot product of all process with the following MPI code:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{template}\PYG{p}{\PYGZlt{}}\PYG{n}{class} \PYG{n}{R}\PYG{p}{\PYGZgt{}} \PYG{n+nb}{R }\PYG{n}{ReduceSum1}\PYG{p}{(}\PYG{n+nb}{R }\PYG{n}{s}\PYG{p}{,} \PYG{n}{MPI\PYGZus{}Comm} \PYG{p}{*}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n+nb}{R }\PYG{n+nb}{r }\PYG{p}{=} \PYG{n}{0}\PYG{p}{;}
    \PYG{n}{MPI\PYGZus{}Allreduce}\PYG{p}{(}\PYG{p}{\PYGZam{}}\PYG{n}{s}\PYG{p}{,} \PYG{p}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{n}{1}\PYG{p}{,} \PYG{n}{MPI\PYGZus{}TYPE}\PYG{p}{\PYGZlt{}}\PYG{n}{R}\PYG{p}{\PYGZgt{}}\PYG{p}{::}\PYG{n}{TYPE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{MPI\PYGZus{}SUM}\PYG{p}{,} \PYG{p}{*}\PYG{n}{comm} \PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This is done in \sphinxcode{\sphinxupquote{MPIGC}} dynamics library tool.

\sphinxstyleemphasis{Second GMRES algorithm:} Use scharwz algorithm as a preconditioner of basic GMRES method to solving the parallel problem.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//the original problem}
    \PYG{o}{+}\PYG{o}{+}\PYG{n}{kiter}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{onGi} \PYG{o}{?} \PYG{l+m+mf}{0.}\PYG{o}{:} \PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//remove boundary term}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//the preconditioner}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Third GMRES algorithm:} Add a coarse solver to the previous algorithm

First build a coarse grid on processor 0, and the

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{AC}\PYG{p}{,} \PYG{n}{Rci}\PYG{p}{,} \PYG{n}{Pci}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{AC} \PYG{o}{=} \PYG{n}{vPbC}\PYG{p}{(}\PYG{n}{VhC}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the coarse problem}

\PYG{n}{Pci} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the projection on coarse grid}
\PYG{n}{Rci} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;} \PYG{c+c1}{//the restriction on Process i grid with the partition pi\PYGZus{}i}

\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{CoarseSolve} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{V}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{,} \PYG{k+kt}{mpiComm}\PYG{o}{\PYGZam{}} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// solving the coarse problem}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uc}\PYG{p}{(}\PYG{n}{Rci}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{Rci}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n+nf}{mpiReduce}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{mpiSUM}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{AC}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{Bc}\PYG{p}{;}
    \PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Uc}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{*}\PYG{n}{Uc}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The New preconditionner

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Idea: F. Nataf.}
    \PYG{c+c1}{// 0 \PYGZti{} (I C1A)(I\PYGZhy{}C2A) =\PYGZgt{} I \PYGZti{} \PYGZhy{} C1AC2A +C1A +C2A}
    \PYG{c+c1}{// New Prec P= C1+C2 \PYGZhy{} C1AC2 = C1(I\PYGZhy{} A C2) +C2}
    \PYG{c+c1}{// ( C1(I\PYGZhy{} A C2) +C2 ) Uo}
    \PYG{c+c1}{// V = \PYGZhy{} C2*Uo}
    \PYG{c+c1}{// ....}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{CoarseSolve}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//\PYGZhy{}C2*Uo}
    \PYG{n}{U} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//U = (I\PYGZhy{}A C2) Uo}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{U} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//C1( I \PYGZhy{}A C2) Uo}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{U} \PYG{o}{\PYGZhy{}} \PYG{n}{V}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The code of the 4 algorithms:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{epss} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rgmres} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPIAffineGMRES}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,}
        \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart}\PYG{o}{?}\PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
    \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,}
        \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart}\PYG{o}{?}\PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJC}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,}
        \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart}\PYG{o}{?}\PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{c+c1}{//algo Shwarz for demo}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

We have all ingredient to solve in parallel if we have et the partitions of the unity.
To build this partition we do:

The initial step on process \(1\) to build a coarse mesh, \({\mathcal{T}_h}^*\) of the full domain, and build the partition \(\pi\) function constant equal to \(i\) on each sub domain \(\mathcal{O}_i, i =1 ,.., N_p\), of the grid with the \sphinxcode{\sphinxupquote{metis}} graph partitioner \sphinxcite{reference:karypis1995} and on each process \(i\) in \(1..,N_p\) do
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Broadcast from process \(1\), the mesh \({\mathcal{T}_h}^*\) (call \sphinxcode{\sphinxupquote{Thii}} in FreeFem++ script), and \(\pi\) function,

\item {} 
remark that the characteristic function \(\mathrm{1\!\!I}_{\mathcal{O}_i}\) of domain \(\mathcal{O}_i\), is defined by \((\pi=i)?1:0\),

\item {} 
Let us call \(\Pi^2_P\) (resp. \(\Pi^2_V\)) the \(L^2\) on \(P_h^*\) the space of the constant finite element function per element on \({\mathcal{T}_h}^*\) (resp. \(V_h^*\) the space of the affine continuous finite element per element on \({\mathcal{T}_h}^*\)) and build in parallel the \(\pi_i\) and \(\Omega_i\), such that \(\mathcal{O}_i\ \subset \Omega_i\) where \(\mathcal{O}_i= supp ((\Pi^2_V \Pi^2_C)^m \mathrm{1\!\!I}_{O_i})\), and \(m\) is a the overlaps size on the coarse mesh (generally one), (this is done in function \sphinxcode{\sphinxupquote{AddLayers(Thii,suppii{[}{]},nlayer,phii{[}{]});}} We choose a function \(\pi^*_i = (\Pi^2_1 \Pi^2_0)^m \mathrm{1\!\!I}_{\mathcal{O}_i}\) so the partition of the unity is simply defined by
\begin{quote}
\begin{equation*}
\begin{split}\pi_i = \frac{\pi_i^*}{\sum_{j=1}^{N_p} \pi_j^*}\end{split}
\end{equation*}
The set \(J_i\) of neighborhood of the domain \(\Omega_i\), and the local version on \(V_{hi}\) can be defined the array \sphinxcode{\sphinxupquote{jpart}} and \sphinxcode{\sphinxupquote{njpart}} with:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vhi} \PYG{n}{pii} \PYG{o}{=} \PYG{n}{piistar}\PYG{p}{;}
\PYG{n}{Vhi}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pij}\PYG{p}{(}\PYG{n}{npij}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local partition of 1 = pii + sum\PYGZus{}j pij[j]}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{jpart}\PYG{p}{(}\PYG{n}{npart}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{njpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vhi} \PYG{n}{sumphi} \PYG{o}{=} \PYG{n}{piistar}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{npart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ipart}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{pijstar}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pijstar}\PYG{p}{;}
            \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{njpart}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
\PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{jpart}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
We call \({\mathcal{T}_h}^*_{ij}\) the sub mesh part of \({\mathcal{T}_h}_i\) where \(\pi_j\) are none zero.
And thanks to the function \sphinxcode{\sphinxupquote{trunc}} to build this array,
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}
    \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
At this step we have all on the coarse mesh, so we can build the fine final mesh by splitting all meshes: \sphinxcode{\sphinxupquote{Thi, Thij{[}j{]}, Thij{[}j{]}}} with FreeFem++ \sphinxcode{\sphinxupquote{trunc}} mesh function which do restriction and slipping.

\item {} 
The construction of the send/recv matrices \sphinxcode{\sphinxupquote{sMj}} and \sphinxtitleref{freefem:{}`rMj}: can done with this code:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{Thi}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whij}\PYG{p}{(}\PYG{n}{Thij}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Pii}\PYG{p}{;} \PYG{n}{Whi} \PYG{n}{wpii} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{;} \PYG{n}{Pii} \PYG{o}{=} \PYG{n}{wpii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//Diagonal matrix corresponding X pi\PYGZus{}i}
\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//M send/recive case}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//change mesh to change Whij, Whij}
    \PYG{k+kt}{matrix} \PYG{n}{I} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whij \PYGZlt{}\PYGZhy{} Whi}
    \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n}{I}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;} \PYG{c+c1}{//Whi \PYGZhy{}\PYGZgt{} s Whij}
    \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whij \PYGZhy{}\PYGZgt{} Whi}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

\end{enumerate}

To buil a not too bad application, all variables come from parameters value with the following code

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{getARGV.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}vv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{vdebug} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ksplit} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}k}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nloc} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{sff} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}p, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{gmres} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}gmres}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{dplot} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nC} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}N}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{nloc}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

And small include to make graphic in parallel of distribute solution of vector \(u\) on mesh \(T_h\) with the following interface:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPIplot.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{k+kt}{mesh} \PYG{o}{\PYGZam{}}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{cm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{PLOTMPIALL}\PYG{p}{(}\PYG{k+kt}{mesh}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{k+kp}{cmm}\PYG{o}{=}\PYG{n}{cm}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{cmm=cm, ...}} in the macro argument is a way to quote macro argument so the argument is \sphinxcode{\sphinxupquote{cmm=cm, ...}}.
\end{sphinxadmonition}


\subsection{Parallel sparse solvers}
\label{\detokenize{documentation/parallelization:parallel-sparse-solvers}}\label{\detokenize{documentation/parallelization:parallelsparsesolvers}}
Parallel sparse solvers use several processors to solve linear systems of equation. Like sequential, parallel linear solvers can be direct or iterative. In \sphinxstylestrong{FreeFem++} both are available.


\subsubsection{Using parallel sparse solvers in \sphinxstylestrong{FreeFem++}}
\label{\detokenize{documentation/parallelization:using-parallel-sparse-solvers-in-freefem}}
We recall that the \sphinxcode{\sphinxupquote{solver}} parameters are defined in the following commands: \sphinxcode{\sphinxupquote{solve}}, \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{set}} (setting parameter of a matrix) and in the construction of the matrix corresponding to a bilinear form.
In these commands, the parameter \sphinxcode{\sphinxupquote{solver}} must be set to \sphinxcode{\sphinxupquote{sparsesolver}} for parallel sparse solver.
We have added specify parameters to these command lines for parallel sparse solvers.
These are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{lparams}} : vector of integer parameters (\sphinxcode{\sphinxupquote{l}} is for the \sphinxcode{\sphinxupquote{C++}} type \sphinxcode{\sphinxupquote{long}})

\item {} 
\sphinxcode{\sphinxupquote{dparams}} : vector of real parameters

\item {} 
\sphinxcode{\sphinxupquote{sparams}} : string parameters

\item {} 
\sphinxcode{\sphinxupquote{datafilename}} : name of the file which contains solver parameters

\end{itemize}

The following four parameters are only for direct solvers and are vectors.
These parameters allow the user to preprocess the matrix (see the section on {\hyperref[\detokenize{documentation/parallelization:sparse-direct-solver}]{\emph{sparse direct solver}}} for more information).
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{permr}} : row permutation (integer vector)

\item {} 
\sphinxcode{\sphinxupquote{permc}} : column permutation or inverse row permutation (integer vector)

\item {} 
\sphinxcode{\sphinxupquote{scaler}} : row scaling (real vector)

\item {} 
\sphinxcode{\sphinxupquote{scalec}} : column scaling (real vector)

\end{itemize}

There are two possibilities to control solver parameters.
The first method defines parameters with \sphinxcode{\sphinxupquote{lparams}}, \sphinxcode{\sphinxupquote{dparams}} and \sphinxcode{\sphinxupquote{sparams}} in \sphinxcode{\sphinxupquote{.edp}} file.

The second one reads the solver parameters from a data file. The name of this file is specified by \sphinxcode{\sphinxupquote{datafilename}}.
If \sphinxcode{\sphinxupquote{lparams}}, \sphinxcode{\sphinxupquote{dparams}}, \sphinxcode{\sphinxupquote{sparams}} or \sphinxcode{\sphinxupquote{datafilename}} is not provided by the user, the solver’s default values are used.

To use parallel solver in \sphinxstylestrong{FreeFem++}, we need to load the dynamic library corresponding to this solver.
For example to use \sphinxhref{http://mumps.enseeiht.fr/}{MUMPS} solver as parallel solver in \sphinxstylestrong{FreeFem++}, write in the \sphinxcode{\sphinxupquote{.edp}} file \sphinxcode{\sphinxupquote{load "MUMPS\_FreeFem"}}.

If the libraries are not loaded, the default sparse solver will be loaded (default sparse solver is \sphinxcode{\sphinxupquote{UMFPACK}}). The \hyperref[\detokenize{documentation/parallelization:tabparallelizationsparsesolver}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationsparsesolver}}} gives this new value for the different libraries.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Default sparse solver for real and complex arithmetics when we load a parallel sparse solver library}\label{\detokenize{documentation/parallelization:tabparallelizationsparsesolver}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Libraries
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{3}}
\sphinxstyletheadfamily Default sparse solver
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
real
&\sphinxstyletheadfamily 
complex
\\
\hline
MUMPS\_FreeFem
&
mumps
&
mumps
\\
\hline
real\_SuperLU\_DIST\_FreeFem
&
SuperLU\_DIST
&
previous solver
\\
\hline
complex\_SuperLU\_DIST\_FreeFem
&
previous solver
&
SuperLU\_DIST
\\
\hline
real\_pastix\_FreeFem
&
PaStiX
&
previous solver
\\
\hline
complex\_pastix\_FreeFem
&
previous solver
&
PaStiX
\\
\hline
hips\_FreeFem
&
hips
&
previous solver
\\
\hline
hypre\_FreeFem
&
hypre
&
previous solver
\\
\hline
parms\_FreeFem
&
parms
&
previous solver
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

We also add functions (see \hyperref[\detokenize{documentation/parallelization:tabparallelizationfunction}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationfunction}}}) with no parameter to change the default sparse solver in the \sphinxcode{\sphinxupquote{.edp}} file.
To use these functions, we need to load the library corresponding to the solver.
An example of using different parallel sparse solvers for the same problem is given in {\hyperref[\detokenize{example/parallelization:exampledirectsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Direct solvers example}}}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Functions that allow to change the default sparse solver for real and complex arithmetics and the result of these functions}\label{\detokenize{documentation/parallelization:tabparallelizationfunction}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Function
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{3}}
\sphinxstyletheadfamily default sparse solver
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
real
&\sphinxstyletheadfamily 
complex
\\
\hline
defaulttoMUMPS()
&
mumps
&
mumps
\\
\hline
realdefaulttoSuperLUdist()
&
SuperLU\_DIST
&
previous solver
\\
\hline
complexdefaulttoSuperLUdist()
&
previous solver
&
SuperLU\_DIST
\\
\hline
realdefaultopastix()
&
pastix
&
previous solver
\\
\hline
complexdefaulttopastix()
&
previous solver
&
pastix
\\
\hline
defaulttohips()
&
hips
&
previous solver
\\
\hline
defaulttohypre()
&
hypre
&
previous solver
\\
\hline
defaulttoparms()
&
parms
&
previous solver
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{tip}{Tip:}
Test direct solvers

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MUMPS\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}SuperLU\PYGZus{}DIST\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} SuperLU\PYGZus{}DIST,}
\PYG{k+kt}{complex} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{MUMPS} \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}pastix\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} pastix, complex \PYGZhy{}\PYGZgt{} MUMPS}

\PYG{c+c1}{// Solving with pastix}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffpastix\PYGZus{}iparm\PYGZus{}dparm.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with SuperLU\PYGZus{}DIST}
\PYG{n}{realdefaulttoSuperLUdist}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} SuperLU\PYGZus{}DIST, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffsuperlu\PYGZus{}dist\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with MUMPS}
\PYG{n}{defaulttoMUMPS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solving solution}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Sparse direct solver}
\label{\detokenize{documentation/parallelization:sparse-direct-solver}}
In this section, we present the sparse direct solvers interfaced with \sphinxstylestrong{FreeFem++}.


\paragraph{MUMPS solver}
\label{\detokenize{documentation/parallelization:mumps-solver}}
MUltifrontal Massively Parallel Solver (\sphinxhref{http://mumps.enseeiht.fr/}{MUMPS}) is an open-source library.

This package solves linear system of the form \(A \: x = b\) where \(A\) is a square sparse matrix with a direct method.
The square matrix considered in MUMPS can be either unsymmetric, symmetric positive definite or general symmetric.

The method implemented in MUMPS is a direct method based on a multifrontal approach.
It constructs a direct factorization \(A \:= \: L\:U\), \(A\: = \: L^t \: D \: L\) depending of the symmetry of the matrix \(A\).
\begin{description}
\item[{MUMPS uses the following libraries :}] \leavevmode\begin{itemize}
\item {} 
\sphinxhref{http://www.netlib.org/blas/}{BLAS},

\item {} 
\sphinxhref{http://www.netlib.org/blacs/}{BLACS},

\item {} 
\sphinxhref{http://www.netlib.org/scalapack/}{ScaLAPACK}.

\end{itemize}

\end{description}

\begin{sphinxadmonition}{warning}{Warning:}
MUMPS does not solve linear system with a rectangular matrix.
\end{sphinxadmonition}

\sphinxstylestrong{MUMPS parameters:}

There are four input parameters in \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS}.
Two integers \sphinxcode{\sphinxupquote{SYM}} and \sphinxcode{\sphinxupquote{PAR}}, a vector of integer of size 40 \sphinxcode{\sphinxupquote{INCTL}} and a vector of real of size 15 \sphinxcode{\sphinxupquote{CNTL}}.

The first parameter gives the type of the matrix: 0 for unsymmetric matrix, 1 for symmetric positive matrix and 2 for general symmetric.

The second parameter defined if the host processor work during the factorization and solves steps : \sphinxcode{\sphinxupquote{PAR=1}} host processor working and \sphinxcode{\sphinxupquote{PAR=0}} host processor not working.

The parameter \sphinxcode{\sphinxupquote{INCTL}} and \sphinxcode{\sphinxupquote{CNTL}} is the control parameter of MUMPS.
The vectors \sphinxcode{\sphinxupquote{ICNTL}} and \sphinxcode{\sphinxupquote{CNTL}} in MUMPS becomes with index 1 like vector in \sphinxcode{\sphinxupquote{Fortran}}.
For more details see the \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS user’s guide}.

We describe now some elements of the main parameters of \sphinxcode{\sphinxupquote{ICNTL}} for MUMPS.
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxstylestrong{Input matrix parameter} The input matrix is controlled by parameters \sphinxcode{\sphinxupquote{ICNTL(5)}} and \sphinxcode{\sphinxupquote{ICNTL(18)}}.}] \leavevmode
The matrix format (resp. matrix pattern and matrix entries) are controlled by \sphinxcode{\sphinxupquote{INCTL(5)}} (resp. \sphinxcode{\sphinxupquote{INCTL(18)}}).

The different values of \sphinxcode{\sphinxupquote{ICNTL(5)}} are 0 for assembled format and 1 for element format.
In the current release of \sphinxstylestrong{FreeFem++}, we consider that FE matrix or matrix is storage in assembled format.
Therefore, \sphinxcode{\sphinxupquote{INCTL(5)}} is treated as 0 value.

The main option for \sphinxcode{\sphinxupquote{ICNTL(18)}}: \sphinxcode{\sphinxupquote{INCLTL(18)=0}} centrally on the host processor, \sphinxcode{\sphinxupquote{ICNTL(18)=3}} distributed the input matrix pattern and the entries (recommended option for distributed matrix by developer of MUMPS).
For other values of \sphinxcode{\sphinxupquote{ICNTL(18)}} see the \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS user’s guide}.
These values can be used also in \sphinxstylestrong{FreeFem++}.

The default option implemented in \sphinxstylestrong{FreeFem++} are \sphinxcode{\sphinxupquote{ICNTL(5)=0}} and \sphinxcode{\sphinxupquote{ICNTL(18)=0}}.

\end{description}

\item {} 
\sphinxstylestrong{Preprocessing parameter} The preprocessed matrix \(A_{p}\) that will be effectively factored is defined by
\begin{quote}
\begin{equation*}
\begin{split}A_{p} = P \: D_r \: A \: Q_c \ D_c P^t\end{split}
\end{equation*}
where \(P\) is the permutation matrix, \(Q_c\) is the column permutation, \(D_r\) and \(D_c\) are diagonal matrix for respectively row and column scaling.

The ordering strategy to obtain \(P\) is controlled by parameter \sphinxcode{\sphinxupquote{ICNTL(7)}}.
The permutation of zero free diagonal \(Q_c\) is controlled by parameter \sphinxcode{\sphinxupquote{ICNTL(6)}}.
The row and column scaling is controlled by parameter \sphinxcode{\sphinxupquote{ICNTL(18)}}.
These option are connected and also strongly related with \sphinxcode{\sphinxupquote{ICNTL(12)}} (see the \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS user’s guide} for more details).

The parameters \sphinxcode{\sphinxupquote{permr}}, \sphinxcode{\sphinxupquote{scaler}}, and \sphinxcode{\sphinxupquote{scalec}} in \sphinxstylestrong{FreeFem++} allow to give permutation matrix(\(P\)), row scaling (\(D_r\)) and column scaling (\(D_c\)) of the user respectively.
\end{quote}

\end{itemize}

\sphinxstylestrong{Calling MUMPS in FreeFem++}

To call MUMPS in \sphinxstylestrong{FreeFem++}, we need to load the dynamic library \sphinxcode{\sphinxupquote{MUMPS\_freefem.dylib}} (MacOSX), \sphinxcode{\sphinxupquote{MUMPS\_freefem.so}} (Unix) or \sphinxcode{\sphinxupquote{MUMPS\_freefem.dll}} (Windows).

This is done in typing \sphinxcode{\sphinxupquote{load "MUMPS\_FreeFem"}} in the \sphinxcode{\sphinxupquote{.edp}} file. We give now the two methods to give the option of MUMPS solver in \sphinxstylestrong{FreeFem++}.
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxstylestrong{Solver parameters is defined in .edp file:} In this method, we need to give the parameters \sphinxcode{\sphinxupquote{lparams}} and \sphinxcode{\sphinxupquote{dparams}}.}] \leavevmode
These parameters are defined for MUMPS by :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{lparams{[}0{]} = SYM}}, \sphinxcode{\sphinxupquote{lparams{[}1{]} = PAR}},

\item {} 
\(\forall i\) = 1,…,40, \sphinxcode{\sphinxupquote{lparams{[}i+1{]} = ICNTL(i)}}

\item {} 
\(\forall i\) = 1,…,15, \sphinxcode{\sphinxupquote{dparams{[}i-1{]} = CNTL(i)}}

\end{itemize}

\end{description}

\item {} 
\sphinxstylestrong{Reading solver parameters on a file:}
\begin{quote}

The structure of data file for MUMPS in \sphinxstylestrong{FreeFem++} is : first line parameter \sphinxcode{\sphinxupquote{SYM}} and second line parameter \sphinxcode{\sphinxupquote{PAR}} and in the following line the different value of vectors \sphinxcode{\sphinxupquote{ICNTL}} and \sphinxcode{\sphinxupquote{CNTL}}.
An example of this parameter file is given in \sphinxcode{\sphinxupquote{ffmumpsfileparam.txt}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mi}{0} \PYG{c+cm}{/* SYM :: 0 for non symmetric matrix, 1 for symmetric definite positive matrix and 2 general symmetric matrix*/}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* PAR :: 0 host not working during factorization and solves steps, 1 host working during factorization and solves steps*/}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(1) :: output stream for error message */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(2) :: output for diagnostic printing, statics and warning message */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(3) :: for global information */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(4) :: Level of printing for error, warning and diagnostic message */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(5) :: matrix format : 0 assembled format, 1 elemental format. */}
\PYG{l+m+mi}{7} \PYG{c+cm}{/* ICNTL(6) :: control option for permuting and/or scaling the matrix in analysis phase */}
\PYG{l+m+mi}{3} \PYG{c+cm}{/* ICNTL(7) :: pivot order strategy : AMD, AMF, metis, pord scotch*/}
\PYG{l+m+mi}{77} \PYG{c+cm}{/* ICNTL(8) :: Row and Column scaling strategy */}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(9) :: 0 solve Ax = b, 1 solve the transposed system A\PYGZca{}t x = b : parameter is not considered in the current release of freefem++*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(10) :: number of steps of iterative refinement */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(11) :: statics related to linear system depending on ICNTL(9) */}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(12) :: constrained ordering strategy for general symmetric matrix */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(13) :: method to control splitting of the root frontal matrix */}
\PYG{l+m+mi}{20} \PYG{c+cm}{/* ICNTL(14) :: percentage increase in the estimated working space (default 20\PYGZbs{}\PYGZpc{})*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(15) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(16) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(17) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{3} \PYG{c+cm}{/* ICNTL(18) :: method for given : matrix pattern and matrix entries : */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(19) :: method to return the Schur complement matrix */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(20) :: right hand side form ( 0 dense form, 1 sparse form) : parameter will be set to 0 for FreeFem++ */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(21) :: 0, 1 kept distributed solution : parameter is not considered in the current release of FreeFem++ */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(22) :: controls the in\PYGZhy{}core/out\PYGZhy{}of\PYGZhy{}core (OOC) facility */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(23) :: maximum size of the working memory in Megabyte than MUMPS can allocate per working processor */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(24) :: control the detection of null pivot */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(25) :: control the computation of a null space basis */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(26) :: This parameter is only significant with Schur option (ICNTL(19) not zero). : parameter is not considered in the current release of FreeFem++ */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8} \PYG{c+cm}{/* ICNTL(27) (Experimental parameter subject to change in next release of MUMPS) :: control the blocking factor for multiple righthand side during the solution phase : parameter is not considered in the current release of FreeFem++ */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(28) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(29) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(30) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(31) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(32) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(33) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(34) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(35) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(36) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(37) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(38) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(39) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(40) :: not used in this release of MUMPS*/}
\PYG{l+m+mf}{0.01} \PYG{c+cm}{/* CNTL(1) :: relative threshold for numerical pivoting */}
\PYG{l+m+mf}{1e\PYGZhy{}8} \PYG{c+cm}{/* CNTL(2) :: stopping criteria for iterative refinement */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* CNTL(3) :: threshold for null pivot detection */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* CNTL(4) :: determine the threshold for partial pivoting */}
\PYG{l+m+mf}{0.0} \PYG{c+cm}{/* CNTL(5) :: fixation for null pivots */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(6) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(7) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(8) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(9) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(10) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(11) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(12) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(13) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(14) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(15) :: not used in this release of MUMPS */}
\end{sphinxVerbatim}

If no solver parameter is given, we used default option of MUMPS solver.
\end{quote}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
MUMPS example

A simple example of calling MUMPS in \sphinxstylestrong{FreeFem++} with this two methods is given in the {\hyperref[\detokenize{example/parallelization:examplesolvermumps}]{\sphinxcrossref{\DUrole{std,std-ref}{Test solver MUMPS example}}}}.
\end{sphinxadmonition}


\paragraph{SuperLU distributed solver}
\label{\detokenize{documentation/parallelization:superlu-distributed-solver}}
The package \sphinxhref{http://crd-legacy.lbl.gov/~xiaoye/SuperLU/}{SuperLU\_DIST} solves linear systems using LU factorization.
It is a free scientific library

This library provides functions to handle square or rectangular matrix in real and complex arithmetics.
The method implemented in SuperLU\_DIST is a supernodal method.
New release of this package includes a parallel symbolic factorization.
This scientific library is written in C and MPI for communications.

\sphinxstylestrong{SuperLU\_DIST parameters:}

We describe now some parameters of SuperLU\_DIST.
The SuperLU\_DIST library use a 2D-logical process group.
This process grid is specified by \(nprow\) (process row) and \(npcol\) (process column) such that \(N_{p} = nprow \: npcol\) where \(N_{p}\) is the number of all process allocated for SuperLU\_DIST.

The input matrix parameters is controlled by “matrix=” in \sphinxcode{\sphinxupquote{sparams}} for internal parameter or in the third line of parameters file.
The different value are
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{matrix=assembled}} global matrix are available on all process

\item {} 
\sphinxcode{\sphinxupquote{matrix=distributedglobal}} The global matrix is distributed among all the process

\item {} 
\sphinxcode{\sphinxupquote{matrix=distributed}} The input matrix is distributed (not yet implemented)

\end{itemize}

The option arguments of SuperLU\_DIST are described in the section Users-callable routine of the \sphinxhref{http://crd-legacy.lbl.gov/~xiaoye/SuperLU/ug.pdf}{SuperLU users’ guide}.

The parameter \sphinxcode{\sphinxupquote{Fact}} and \sphinxcode{\sphinxupquote{TRANS}} are specified in \sphinxstylestrong{FreeFem++} interfaces to SuperLU\_DIST during the different steps.
For this reason, the value given by the user for this option is not considered.

The factorization LU is calculated in SuperLU\_DIST on the matrix \(A_p\).
\begin{equation*}
\begin{split}A_{p} = P_{c} \: P_r \: D_r \: A \: D_{c} \: P_{c}^{t}\end{split}
\end{equation*}
where \(P_c\) and \(P_r\) is the row and column permutation matrix respectively, \(D_r\) and \(D_c\) are diagonal matrix for respectively row and column scaling.

The option argument \sphinxcode{\sphinxupquote{RowPerm}} (resp. \sphinxcode{\sphinxupquote{ColPerm}}) control the row (resp. column) permutation matrix.
\(D_r\) and \(D_c\) is controlled by the parameter \sphinxcode{\sphinxupquote{DiagScale}}.

The parameter \sphinxcode{\sphinxupquote{permr}}, \sphinxcode{\sphinxupquote{permc}}, \sphinxcode{\sphinxupquote{scaler}}, and \sphinxcode{\sphinxupquote{scalec}} in \sphinxstylestrong{FreeFem++} is provided to give row permutation, column permutation, row scaling and column scaling of the user respectively.

The other parameters for LU factorization are \sphinxcode{\sphinxupquote{ParSymFact}} and \sphinxcode{\sphinxupquote{ReplaceTinyPivot}}.
The parallel symbolic factorization works only on a power of two processes and need the \sphinxcode{\sphinxupquote{ParMetis}} ordering.
The default option argument of SuperLU\_DIST are given in the file \sphinxcode{\sphinxupquote{ffsuperlu\_dist\_fileparam.txt}}.

\sphinxstylestrong{Calling SuperLU\_DIST in FreeFem++}

To call SuperLU\_DIST in \sphinxstylestrong{FreeFem++}, we need to load the library dynamic correspond to interface.
This done by the following line \sphinxcode{\sphinxupquote{load "real\_superlu \_DIST\_FreeFem"}} (resp. \sphinxcode{\sphinxupquote{load "complex\_superlu\_DIST\_FreeFem"}}) for real (resp. complex) arithmetics in the file \sphinxcode{\sphinxupquote{.edp}}.

\sphinxstylestrong{Solver parameters is defined in .edp file:}

To call SuperLU\_DIST with internal parameter, we used the parameters \sphinxcode{\sphinxupquote{sparams}}.
The value of parameters of SuperLU\_DIST in \sphinxcode{\sphinxupquote{sparams}} are defined by :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nprow=1}},

\item {} 
\sphinxcode{\sphinxupquote{npcol=1}},

\item {} 
\sphinxcode{\sphinxupquote{matrix= distributedgloba}},

\item {} 
\sphinxcode{\sphinxupquote{Fact= DOFACT}},

\item {} 
\sphinxcode{\sphinxupquote{Equil=NO}},

\item {} 
\sphinxcode{\sphinxupquote{ParSymbFact=NO}},

\item {} 
\sphinxcode{\sphinxupquote{ColPerm= MMD\_AT\_PLUS\_A}},

\item {} 
\sphinxcode{\sphinxupquote{RowPerm= LargeDiag}},

\item {} 
\sphinxcode{\sphinxupquote{DiagPivotThresh=1.0}},

\item {} 
\sphinxcode{\sphinxupquote{IterRefine=DOUBLE}},

\item {} 
\sphinxcode{\sphinxupquote{Trans=NOTRANS}},

\item {} 
\sphinxcode{\sphinxupquote{ReplaceTinyPivot=NO}},

\item {} 
\sphinxcode{\sphinxupquote{SolveInitialized=NO}},

\item {} 
\sphinxcode{\sphinxupquote{PrintStat=NO}},

\item {} 
\sphinxcode{\sphinxupquote{DiagScale=NOEQUIL}}

\end{itemize}

This value correspond to the parameter in the file \sphinxcode{\sphinxupquote{ffsuperlu\_dist\_fileparam.txt}}.
If one parameter is not specified by the user, we take the default value of SuperLU\_DIST.

\sphinxstylestrong{Reading solver parameters on a file:} The structure of data file for SuperLU\_DIST in \sphinxstylestrong{FreeFem++} is given in the file \sphinxcode{\sphinxupquote{ffsuperlu\_dist\_fileparam.txt}} (default value of the \sphinxstylestrong{FreeFem++} interface).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mi}{1} \PYG{c+cm}{/* nprow : integer value */}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* npcol : integer value */}
\PYG{n}{distributedglobal} \PYG{c+cm}{/* matrix input : assembled, distributedglobal, distributed */}
\PYG{n}{DOFACT} \PYG{c+cm}{/* Fact : DOFACT, SamePattern, SamePattern\PYGZus{}SameRowPerm, FACTORED */}
\PYG{n}{NO} \PYG{c+cm}{/* Equil : NO, YES */}
\PYG{n}{NO} \PYG{c+cm}{/* ParSymbFact : NO, YES */}
\PYG{n}{MMD\PYGZus{}AT\PYGZus{}PLUS\PYGZus{}A} \PYG{c+cm}{/* ColPerm : NATURAL, MMD\PYGZus{}AT\PYGZus{}PLUS\PYGZus{}A, MMD\PYGZus{}ATA, METIS\PYGZus{}AT\PYGZus{}PLUS\PYGZus{}A, PARMETIS, MY\PYGZus{}PERMC */}
\PYG{n}{LargeDiag} \PYG{c+cm}{/* RowPerm : NOROWPERM, LargeDiag, MY\PYGZus{}PERMR */}
\PYG{l+m+mf}{1.0} \PYG{c+cm}{/* DiagPivotThresh : real value */}
\PYG{n}{DOUBLE} \PYG{c+cm}{/* IterRefine : NOREFINE, SINGLE, DOUBLE, EXTRA */}
\PYG{n}{NOTRANS} \PYG{c+cm}{/* Trans : NOTRANS, TRANS, CONJ*/}
\PYG{n}{NO} \PYG{c+cm}{/* ReplaceTinyPivot : NO, YES*/}
\PYG{n}{NO} \PYG{c+cm}{/* SolveInitialized : NO, YES*/}
\PYG{n}{NO} \PYG{c+cm}{/* RefineInitialized : NO, YES*/}
\PYG{n}{NO} \PYG{c+cm}{/* PrintStat : NO, YES*/}
\PYG{n}{NOEQUIL} \PYG{c+cm}{/* DiagScale : NOEQUIL, ROW, COL, BOTH*/}
\end{sphinxVerbatim}

If no solver parameter is given, we used default option of SuperLU\_DIST solver.

\begin{sphinxadmonition}{tip}{Tip:}
A simple example of calling SuperLU\_DIST in \sphinxstylestrong{FreeFem++} with this two methods is given in the {\hyperref[\detokenize{example/parallelization:examplesolversuperludist}]{\sphinxcrossref{\DUrole{std,std-ref}{Solver superLU\_DIST example}}}}.
\end{sphinxadmonition}


\paragraph{PaStiX solver}
\label{\detokenize{documentation/parallelization:pastix-solver}}
\sphinxhref{http://pastix.gforge.inria.fr/files/README-txt.html}{PaStiX} (Parallel Sparse matrix package) is a free scientific library under CECILL-C license.
This package solves sparse linear system with a direct and block ILU(k) iterative methods.
his solver can be applied to a real or complex matrix with a symmetric pattern.

\sphinxstylestrong{PaStiX parameters:}

The input \sphinxcode{\sphinxupquote{matrix}} parameter of \sphinxstylestrong{FreeFem++} depend on PaStiX interface.
\sphinxcode{\sphinxupquote{matrix = assembled}} for non distributed matrix.
It is the same parameter for SuperLU\_DIST.

There are four parameters in PaStiX : \sphinxcode{\sphinxupquote{iparm}}, \sphinxcode{\sphinxupquote{dparm}}, \sphinxcode{\sphinxupquote{perm}} and \sphinxcode{\sphinxupquote{invp}}.
These parameters are respectively the integer parameters (vector of size 64), real parameters (vector of size 64), permutation matrix and inverse permutation matrix respectively.
\sphinxcode{\sphinxupquote{iparm}} and \sphinxcode{\sphinxupquote{dparm}} vectors are described in \sphinxhref{https://gforge.inria.fr/docman/?group\_id=186\&view=listfile\&dirid=246}{PaStiX RefCard}.

The parameters \sphinxcode{\sphinxupquote{permr}} and \sphinxcode{\sphinxupquote{permc}} in \sphinxstylestrong{FreeFem++} are provided to give permutation matrix and inverse permutation matrix of the user respectively.

\sphinxstylestrong{Solver parameters defined in .edp file:}

To call PaStiX in \sphinxstylestrong{FreeFem++} in this case, we need to specify the parameters \sphinxcode{\sphinxupquote{lparams}} and \sphinxcode{\sphinxupquote{dparams}}.
These parameters are defined by :

\(\forall i\) = 0,… ,63, \sphinxcode{\sphinxupquote{lparams{[}i{]} = iparm{[}i{]}}}.

\(\forall i\) = 0,… ,63, \sphinxcode{\sphinxupquote{dparams{[}i{]} = dparm{[}i{]}}}.

\sphinxstylestrong{Reading solver parameters on a file:}

The structure of data file for PaStiX parameters in \sphinxstylestrong{FreeFem++} is: first line structure parameters of the matrix and in the following line the value of vectors \sphinxcode{\sphinxupquote{iparm}} and \sphinxcode{\sphinxupquote{dparm}} in this order.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{assembled} \PYG{c+cm}{/* matrix input :: assembled, distributed global and distributed */}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{63}\PYG{p}{]}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{63}\PYG{p}{]}
\end{sphinxVerbatim}

An example of this file parameter is given in \sphinxcode{\sphinxupquote{ffpastix\_iparm\_dparm.txt}} with a description of these parameters.
This file is obtained with the example file \sphinxcode{\sphinxupquote{iparm.txt}} and \sphinxcode{\sphinxupquote{dparm.txt}} including in the PaStiX package.

If no solver parameter is given, we use the default option of PaStiX solver.

\begin{sphinxadmonition}{tip}{Tip:}
A simple example of calling PaStiX in \sphinxstylestrong{FreeFem++} with this two methods is given in the {\hyperref[\detokenize{example/parallelization:examplesolverpastix}]{\sphinxcrossref{\DUrole{std,std-ref}{Solver PaStiX example}}}}.
\end{sphinxadmonition}

In \hyperref[\detokenize{documentation/parallelization:tabparallelizationdirectsolver}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationdirectsolver}}}, we recall the different matrix considering in the different direct solvers.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Type of matrix used by the different direct sparse solver}\label{\detokenize{documentation/parallelization:tabparallelizationdirectsolver}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
direct solver
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{7}}
\sphinxstyletheadfamily square matrix
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{7}}
\sphinxstyletheadfamily rectangular matrix
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
sym
&\sphinxstyletheadfamily 
sym pattern
&\sphinxstyletheadfamily 
unsym
&\sphinxstyletheadfamily 
sym
&\sphinxstyletheadfamily 
sym pattern
&\sphinxstyletheadfamily 
unsym
\\
\hline
SuperLU\_DIST
&
yes
&
yes
&
yes
&
yes
&
yes
&
yes
\\
\hline
MUMPS
&
yes
&
yes
&
yes
&
no
&
no
&
no
\\
\hline
Pastix
&
yes
&
yes
&
no
&
no
&
no
&
no
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Parallel sparse iterative solver}
\label{\detokenize{documentation/parallelization:parallel-sparse-iterative-solver}}
Concerning iterative solvers, we have chosen \sphinxhref{https://www-users.cs.umn.edu/~saad/software/pARMS/}{pARMS}, \sphinxhref{http://hips.gforge.inria.fr/}{HIPS} and \sphinxhref{https://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods}{Hypre}.

Each software implements a different type of parallel preconditioner.

So, pARMS implements algebraic domain decomposition preconditioner type such as additive Schwartz \sphinxcite{reference:cai1989} and interface method; while HIPS implement hierarchical incomplete factorization and finally HYPRE implements multilevel preconditioner are AMG(Algebraic MultiGrid) and parallel approximated inverse.

To use one of these programs in \sphinxstylestrong{FreeFem++}, you have to install it independently of \sphinxstylestrong{FreeFem++}.
It is also necessary to install the MPI communication library which is essential for communication between the processors and, in some cases, software partitioning graphs like \sphinxhref{http://glaros.dtc.umn.edu/gkhome/metis/metis/overview}{METIS} or \sphinxhref{http://www.labri.fr/perso/pelegrin/scotch/}{Scotch}.

All this preconditioners are used with Krylov subspace methods accelerators.

Krylov subspace methods are iterative methods which consist in finding a solution \(x\) of linear system \(Ax=b\) inside the affine space \(x_0+K_m\) by imposing that \(b-Ax \bot \mathcal{L}_m\), where \(K_m\) is Krylov subspace of dimension \(m\) defined by \(K_m=\{r_0, Ar_0, A^2r_0,...,A^{m-1}r_0\}\) and \(\mathcal{L}_m\) is another subspace of dimension \(m\) which depends on type of Krylov subspace. For example in GMRES, \(\mathcal{L}_m=AK_m\).

We realized an interface which is easy to use, so that the call of these different softwares in \sphinxstylestrong{FreeFem++} is done in the same way.
You just have to load the solver and then specify the parameters to apply to the specific solvers.
In the rest of this chapter, when we talk about Krylov subspace methods we mean one among GMRES, CG and BICGSTAB.


\paragraph{pARMS solver}
\label{\detokenize{documentation/parallelization:parms-solver}}
\sphinxhref{https://www-users.cs.umn.edu/~saad/software/pARMS/}{pARMS} (parallel Algebraic Multilevel Solver) is a software developed by Youssef Saad and al at University of Minnesota.

This software is specialized in the resolution of large sparse non symmetric linear systems of equation.
Solvers developed in pARMS are of type “Krylov’s subspace”.

It consists of variants of GMRES like FGMRES (Flexible GMRES), DGMRES (Deflated GMRES) \sphinxcite{reference:saad2003} and BICGSTAB.
pARMS also implements parallel preconditioner like RAS (Restricted Additive Schwarz) \sphinxcite{reference:cai1989} and Schur Complement type preconditioner.

All these parallel preconditioners are based on the principle of domain decomposition.
Thus, the matrix \(A\) is partitioned into sub matrices \(A_i\)(\(i=1,...,p\)) where p represents the number of partitions one needs.
The union of \(A_i\) forms the original matrix.
The solution of the overall system is obtained by solving the local systems on \(A_i\) (see \sphinxcite{reference:smith1996}).
Therefore, a distinction is made between iterations on \(A\) and the local iterations on \(A_i\).

To solve the local problem on \(A_i\) there are several preconditioners as \sphinxstylestrong{ilut} (Incomplete LU with threshold), \sphinxstylestrong{iluk} (Incomplete LU with level of fill in) and \sphinxstylestrong{ARMS} (Algebraic Recursive Multilevel Solver).

\begin{sphinxadmonition}{tip}{Tip:}
Default parameters

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parms\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//Tell FreeFem that you will use pARMS}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh} \PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{f}\PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{real} \PYG{n}{cpu} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ CPU time = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In line 1, the pARMS dynamic library is loaded with interface \sphinxstylestrong{FreeFem++}.
After this, in line 15 we specify that the bilinear form will be solved by the last sparse linear solver load in memory which, in this case, is pARMS.

The parameters used in pARMS in this case are the default one since the user does not have to provide any parameter.

\begin{sphinxadmonition}{note}{Note:}
In order to see the plot of a parallel script, run the command \sphinxcode{\sphinxupquote{FreeFem++-mpi -glut ffglut script.edp}}
\end{sphinxadmonition}
\end{sphinxadmonition}

Here are some default parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{solver=FGMRES}},

\item {} 
\sphinxcode{\sphinxupquote{Krylov dimension=30}},

\item {} 
\sphinxcode{\sphinxupquote{Maximum of Krylov=1000}},

\item {} 
\sphinxcode{\sphinxupquote{Tolerance for convergence=1e-08}} (see book
\sphinxcite{reference:saad2003} to understand all this parameters),

\item {} 
\sphinxcode{\sphinxupquote{preconditionner=Restricted Additif Schwarz}}
\sphinxcite{reference:cai1989},

\item {} 
\sphinxcode{\sphinxupquote{Inner Krylov dimension=5}},

\item {} 
\sphinxcode{\sphinxupquote{Maximum of inner Krylov dimension=5}},

\item {} 
\sphinxcode{\sphinxupquote{Inner preconditionner=ILUK}}.

\end{itemize}

To specify the parameters to apply to the solver, the user can either give an integer vector for \sphinxstylestrong{integer parameters} and real vectors for \sphinxstylestrong{real parameters} or provide a \sphinxstylestrong{file} which contains those parameters.

\begin{sphinxadmonition}{tip}{Tip:}
User specifies parameters inside two vectors

Lets us consider Navier-Stokes example.
In this example we solve linear systems coming from discretization of Navier-Stokes equations with pARMS.
Parameters of solver is specified by user.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parms\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{iparm}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dparm}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{16}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{iparm}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{dparm}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{;} \PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{wall} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{inlet} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{uc} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{Stokes} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{ush}\PYG{p}{,} \PYG{n}{vsh}\PYG{p}{,} \PYG{n}{psh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}
            \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{ush}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{ush}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vsh}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vsh}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n}{psh}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{ush}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vsh}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{psh}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{wall}\PYG{p}{,} \PYG{n}{wall}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{inlet}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{uc}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{AA} \PYG{o}{=} \PYG{n}{Stokes}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{iparm}\PYG{p}{,} \PYG{k+kp}{dparams}\PYG{o}{=}\PYG{n}{dparm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set pARMS as linear solver}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb} \PYG{o}{=} \PYG{n}{Stokes}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sol}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sol} \PYG{o}{=} \PYG{n}{AA}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{k+kp}{bb}\PYG{p}{;}
\end{sphinxVerbatim}

We need two vectors to specify the parameters of the linear solver.
In line 5-6 of the example, we have declared these vectors(\sphinxcode{\sphinxupquote{int{[}int{]} iparm(16); real{[}int{]} dparm(6);}}).
In line 7-10 we have initialized these vectors by negative values.

We do this because all parameters values in pARMS are positive and if you do not change the negative values of one entry of this vector, the default value will be set.

In \hyperref[\detokenize{documentation/parallelization:tabparallelizationlparams}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationlparams}}} and \hyperref[\detokenize{documentation/parallelization:tabparallelizationdparams}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationdparams}}}, we have the meaning of different entries of these vectors.

We run this example on a cluster paradent of Grid5000 and report results in \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetime}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetime}}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Convergence and time for solving linear system}\label{\detokenize{documentation/parallelization:tabparallelizationconvergencetime}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{5}%
\begin{varwidth}[t]{\sphinxcolwidth{5}{5}}
\sphinxstyletheadfamily \(n=471281\)
\(nnz=13\times10^6\)
\(Te=571.29\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
np
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{5}}
\sphinxstyletheadfamily add(iluk)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{5}}
\sphinxstyletheadfamily shur(iluk)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
nit
&\sphinxstyletheadfamily 
time
&\sphinxstyletheadfamily 
nit
&\sphinxstyletheadfamily 
time
\\
\hline
4
&
230
&
637.57
&
21
&
557.8
\\
\hline
8
&
240
&
364.12
&
22
&
302.25
\\
\hline
16
&
247
&
212.07
&
24
&
167.5
\\
\hline
32
&
261
&
111.16
&
25
&
81.5
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Legend of \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetime}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetime}}}}\label{\detokenize{documentation/parallelization:tabparallelizationlegend}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{n}}
&\sphinxstyletheadfamily 
matrix size
\\
\hline
\sphinxcode{\sphinxupquote{nnz}}
&
number of non null entries inside matrix
\\
\hline
\sphinxcode{\sphinxupquote{nit}}
&
number of iteration for convergence
\\
\hline
\sphinxcode{\sphinxupquote{time}}
&
Time for convergence
\\
\hline
\sphinxcode{\sphinxupquote{Te}}
&
Time for constructing finite element matrix
\\
\hline
\sphinxcode{\sphinxupquote{np}}
&
number of processor
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

In this example, we fix the matrix size (in term of finite element, we fix the mesh) and increase the number of processors used to solve the linear system.
We saw that, when the number of processors increases, the time for solving the linear equation decreases, even if the number of iteration increases.
This proves that, using pARMS as solver of linear systems coming from discretization of partial differential equation in \sphinxstylestrong{FreeFem++} can decrease drastically the total time of simulation.
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Meaning of \sphinxstyleliteralintitle{\sphinxupquote{lparams}} corresponding variables}\label{\detokenize{documentation/parallelization:tabparallelizationlparams}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\sphinxstyletheadfamily 
Entries of \sphinxcode{\sphinxupquote{iparm}}
&\sphinxstyletheadfamily 
Significations of each entries
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}0{]}}}
&
Krylov subspace methods

Different values for this parameters are specify on \hyperref[\detokenize{documentation/parallelization:tabparallelizationparmskrylov}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationparmskrylov}}}
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}1{]}}}
&
Preconditionner

Different preconditionners for this parameters are  specify on \hyperref[\detokenize{documentation/parallelization:tabparallelizationparmsprecon}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationparmsprecon}}}
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}2{]}}}
&
Krylov subspace dimension in outer iteration: default value 30
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}3{]}}}
&
Maximum of iterations in outer iteration: default value 1000
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}4{]}}}
&
Number of level in arms when used
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}5{]}}}
&
Krylov subspace dimension in inner iteration: default value 3
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}6{]}}}
&
Maximum of iterations in inner iteration: default value 3
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}7{]}}}
&
Symmetric(=1 for symmetric) or unsymmetric matrix:

default value 0(unsymmetric matrix)
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}8{]}}}
&
Overlap size between different subdomain: default value 0(no overlap)
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}9{]}}}
&
Scale the input matrix or not: Default value 1 (Matrix should be scaled)
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}10{]}}}
&
Block size in arms when used: default value 20
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}11{]}}}
&
lfil0 (ilut, iluk, and arms) : default value 20
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}12{]}}}
&
lfil for Schur complement const : default value 20
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}13{]}}}
&
lfil for Schur complement const : default value 20
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}14{]}}}
&
Multicoloring or not in ILU when used : default value 1
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}15{]}}}
&
Inner iteration : default value 0
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}16{]}}}
&
Print message when solving: default 0 (no message print)
\begin{itemize}
\item {} 
0: no message is print,

\item {} 
1: Convergence informations like number of iteration and residual,

\item {} 
2: Timing for a different step like preconditioner,

\item {} 
3 : Print all informations

\end{itemize}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Significations of \sphinxstyleliteralintitle{\sphinxupquote{dparams}} corresponding variables}\label{\detokenize{documentation/parallelization:tabparallelizationdparams}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Entries of \sphinxcode{\sphinxupquote{dparm}}
&\sphinxstyletheadfamily 
Significations of each entries
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}0{]}}}
&
precision for outer iteration : default value 1e-08
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}1{]}}}
&
precision for inner iteration: default value 1e-2
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}2{]}}}
&
tolerance used for diagonal domain: : default value 0.1
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}3{]}}}
&
drop tolerance droptol0 (ilut, iluk, and arms) : default value 1e-2
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}4{]}}}
&
droptol for Schur complement const: default value 1e-2
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}5{]}}}
&
droptol for Schur complement const: default value 1e-2
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Krylov Solvers in pARMS}\label{\detokenize{documentation/parallelization:tabparallelizationparmskrylov}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Values of \sphinxcode{\sphinxupquote{iparm{[}0{]}}}
&\sphinxstyletheadfamily 
Krylov subspace methods
\\
\hline
0
&
FGMRES (Flexible GMRES)
\\
\hline
1
&
DGMRES (Deflated GMRES)
\\
\hline
2
&
BICGSTAB
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Preconditionners in pARMS}\label{\detokenize{documentation/parallelization:tabparallelizationparmsprecon}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Values of \sphinxcode{\sphinxupquote{iparm{[}1{]}}}
&\sphinxstyletheadfamily 
Preconditionners type
\\
\hline
0
&
additive Schwartz preconditioner with ilu0 as local preconditioner
\\
\hline
1
&
additive Schwartz preconditioner with iluk as local preconditioner
\\
\hline
2
&
additive Schwartz preconditioner with ilut as local preconditioner
\\
\hline
3
&
additive Schwartz preconditioner with arms as local preconditioner
\\
\hline
4
&
Left Schur complement preconditioner with ilu0 as local preconditioner
\\
\hline
5
&
Left Schur complement preconditioner with ilut as local preconditioner
\\
\hline
6
&
Left Schur complement preconditioner with iluk as local preconditioner
\\
\hline
7
&
Left Schur complement preconditioner with arms as local preconditioner
\\
\hline
8
&
Right Schur complement preconditioner with ilu0 as local preconditioner
\\
\hline
9
&
Right Schur complement preconditioner with ilut as local preconditioner
\\
\hline
10
&
Right Schur complement preconditioner with iluk as local preconditioner
\\
\hline
11
&
Right Schur complement preconditioner with arms as local preconditioner
\\
\hline
12
&
sch\_gilu0, Schur complement preconditioner with global ilu0
\\
\hline
13
&
SchurSymmetric GS preconditioner
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Interfacing with HIPS}
\label{\detokenize{documentation/parallelization:interfacing-with-hips}}
\sphinxhref{http://hips.gforge.inria.fr/}{HIPS} (\sphinxstyleemphasis{Hierarchical Iterative Parallel Solver}) is a scientific library that provides an efficient parallel iterative solver for very large sparse linear systems.
HIPS is available as free software under the CeCILL-C licence.

HIPS implements two solver classes which are the iteratives class (GMRES, PCG) and the Direct class.
Concerning preconditionners, HIPS implements a type of multilevel ILU.
For further informations on those preconditionners see the \sphinxhref{http://hips.gforge.inria.fr/doc/hips\_user.pdf}{HIPS documentation}.

\begin{sphinxadmonition}{tip}{Tip:}
Laplacian 3D solved with HIPS

Let us consider the 3D Laplacian example inside \sphinxstylestrong{FreeFem++} package where after discretization we want to solve the linear equation with HIPS.

The following example is a Laplacian 3D using Hips as linear solver.
We first load Hips solver at line 2.
From line 7 to 18 we specify the parameters for the Hips solver and in line 82 we set these parameters in the linear solver.

In \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetimehips}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehips}}} results of running on Cluster Paradent of Grid5000 are reported.
We can see in this running example the efficiency of parallelism.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hips\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//load Hips library}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{iparm}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dparm}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{14}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{iparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{dparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//use iterative solver}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//PCG as Krylov method}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//Matrix are symmetric}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//Pattern are also symmetric}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//Scale matrix}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}13}\PYG{p}{;} \PYG{c+c1}{//Tolerance to convergence}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Threshold in ILUT}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Threshold for Schur preconditionner}

\PYG{c+c1}{// Functions}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{z}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{uex} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{z}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{uey} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{uez} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{18.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rdown}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,}
    \PYG{k+kp}{reffaceup} \PYG{o}{=} \PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow} \PYG{o}{=} \PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uz}\PYG{p}{,} \PYG{n}{p2}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uhe} \PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uhe min =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, max =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{F}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n}{va} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{ue}\PYG{o}{*}\PYG{n}{v} \PYG{o}{+} \PYG{p}{(}\PYG{n}{uex}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n}{uey}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{+} \PYG{n}{uez}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{z}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{ue}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{l} \PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{cpu}\PYG{o}{=}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Aa} \PYG{o}{=} \PYG{n}{va}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{F}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{va}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Size of A =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Aa}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Non zero coefficients =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Aa}\PYG{p}{.}\PYG{n}{nbcoef} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CPU TIME FOR FORMING MATRIX =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{Aa}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{dparams}\PYG{o}{=}\PYG{n}{dparm}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{iparm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Set hips as linear solver}

\PYG{c+c1}{// Solve}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Aa}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{F}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Legend of this table are give in \hyperref[\detokenize{documentation/parallelization:tabparallelizationlegend}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationlegend}}}}\label{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehips}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
\sphinxstyletheadfamily \(n=4\times 10^6\)
\(nnz=118 \times 10^6\)
\(Te=221.34\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{np}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{nit}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{time}}
\\
\hline
8
&
190
&
120.34
\\
\hline
16
&
189
&
61.08
\\
\hline
32
&
186
&
31.70
\\
\hline
64
&
183
&
23.44
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Significations of \sphinxstyleliteralintitle{\sphinxupquote{lparams}} corresponding to HIPS interface}\label{\detokenize{documentation/parallelization:tabparallelizationhipsinterface}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Entries of \sphinxcode{\sphinxupquote{iparm}}
&\sphinxstyletheadfamily 
Significations of each entries
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}0{]}}}
&
Strategy use for solving (Iterative=0 or Hybrid=1 or Direct=2).

Defaults values are : Iterative
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}1{]}}}
&
Krylov methods.

If iparm{[}0{]}=0, give type of Krylov methods: 0 for GMRES, 1 for PCG
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}2{]}}}
&
Maximum of iterations in outer iteration: default value 1000
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}3{]}}}
&
Krylov subspace dimension in outer iteration: default value 40
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}4{]}}}
&
Symmetric(=0 for symmetric) and 1 for unsymmetricmatrix:

default value 1 (unsymmetric matrix)
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}5{]}}}
&
Pattern of matrix are symmetric or not: default value 0
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}6{]}}}
&
Partition type of input matrix: default value 0
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}7{]}}}
&
Number of level that use the HIPS locally consistentfill-in:

Default value 2
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}8{]}}}
&
Numbering in indices array will start at 0 or 1: Default value 0
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}9{]}}}
&
Scale matrix. Default value 1
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}10{]}}}
&
Reordering use inside subdomains for reducingfill-in:

Only use for iterative. Default value 1
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}11{]}}}
&
Number of unknowns per node in the matrix non-zeropattern graph:

Default value 1
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}12{]}}}
&
This value is used to set the number of time the

normalization is applied to the matrix: Default 2.
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}13{]}}}
&
Level of informations printed during solving: Default 5.
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}14{]}}}
&
HIPS\_DOMSIZE Subdomain size
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Significations of \sphinxstyleliteralintitle{\sphinxupquote{dparams}} corresponding to HIPS interface}\label{\detokenize{documentation/parallelization:tabparallelizationhipsdparms}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{dparm{[}0{]}}}
&
HIPS\_PREC: Relative residual norm: Default=1e-9
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}1{]}}}
&
HIPS\_DROPTOL0: Numerical threshold in ILUT for interior domain

(important : set 0.0 in HYBRID: Default=0.005)
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}2{]}}}
&
HIPS\_DROPTOL1 : Numerical threshold in ILUT for Schur preconditioner:

Default=0.005
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}3{]}}}
&
HIPS\_DROPTOLE : Numerical threshold for coupling between the interior

level and Schur: Default 0.005
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}4{]}}}
&
HIPS\_AMALG : Numerical threshold for coupling between the interior level

and Schur: Default=0.005
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}5{]}}}
&
HIPS\_DROPSCHUR : Numerical threshold for coupling between the interior

level and Schur: Default=0.005
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\paragraph{Interfacing with HYPRE}
\label{\detokenize{documentation/parallelization:interfacing-with-hypre}}
\sphinxhref{https://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods}{Hypre} (High Level Preconditioner) is a suite of parallel preconditioner developed at Lawrence Livermore National Lab.

There are two main classes of preconditioners developed in HYPRE: AMG (Algebraic MultiGrid) and Parasails (Parallel Sparse Approximate Inverse).

Now, suppose we want to solve \(Ax=b\).

At the heart of AMG there is a series of progressively coarser (smaller) representations of the matrix \(A\).
Given an approximation \(\hat{x}\) to the solution \(x\), consider solving the residual equation \(Ae=r\) to find the error \(e\), where \(r=b-A\hat{x}\).
A fundamental principle of AMG is that it is an algebraically smooth error.
To reduce the algebraically smooth errors further, they need to be represented by a smaller defect equation (coarse grid residual equation) \(A_ce_c=r_c\), which is cheaper to solve.
After solving this coarse equation, the solution is then interpolated in fine grid represented here by matrix \(A\).
The quality of AMG depends on the choice of coarsening and interpolating operators.

The \sphinxstyleemphasis{sparse approximate inverse} approximates the inverse of a matrix \(A\) by a sparse matrix \(M\).
A technical idea to construct matrix \(M\) is to minimize the Frobenuis norm of the residual matrix \(I-MA\).
For more details on this preconditioner technics see \sphinxcite{reference:chow1997}.

HYPRE implement three Krylov subspace solvers: GMRES, PCG and BiCGStab.

\begin{sphinxadmonition}{tip}{Tip:}
Laplacian 3D solved with HYPRE

Let us consider again the 3D Laplacian example inside FreeFem++ package where after discretization we want to solve the linear equation with Hypre.
The following example is a Laplacian 3D using Hypre as linear solver.
This is the same example as Hips one, so we just show here the lines where we set some Hypre parameters.

We first load the Hypre solver at line 2.
From line 6 to 18 we specifies the parameters to set to Hypre solver and in line 22 we set parameters to Hypre solver.

It should be noted that the meaning of the entries of these vectors is different from those of Hips.
In the case of HYPRE, the meaning of differents entries of vectors \sphinxcode{\sphinxupquote{iparm}} and \sphinxcode{\sphinxupquote{dparm}} are given in \hyperref[\detokenize{documentation/parallelization:tabparallelizationiparmsdparmshypre}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmshypre}}} to \hyperref[\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsschwartz}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsschwartz}}}.

In \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetimehypre}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehypre}}} the results of running on Cluster Paradent of Grid5000 are reported.
We can see in this running example the efficiency of parallelism, in particular when AMG are use as preconditioner.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hipre\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//Load Hipre librairy}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{iparm}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dparm}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{iparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{dparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//PCG as krylov method}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//AMG as preconditionner 2: if ParaSails}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;} \PYG{c+c1}{//Interpolation}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{c+c1}{//AMG Coarsen type}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//Measure type}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{16}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//Additive schwarz as smoother}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}13}\PYG{p}{;} \PYG{c+c1}{//Tolerance to convergence}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Threshold}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Truncation factor}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{Aa}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{dparams}\PYG{o}{=}\PYG{n}{dparm}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{iparm}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of common entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} vectors for every preconditioner in HYPRE}\label{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmshypre}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{iparms{[}0{]}}}
&
Solver identification:

0: BiCGStab, 1: GMRES, 2: PCG. Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}1{]}}}
&
Preconditioner identification:

0: BOOMER AMG, 1: PILUT, 2: Parasails, 3: Schwartz Default=0
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}2{]}}}
&
Maximum of iteration: Default=1000
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}3{]}}}
&
Krylov subspace dim: Default= 40
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}4{]}}}
&
Solver print info level: Default=2
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}5{]}}}
&
Solver log: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}6{]}}}
&
Solver stopping criteria only for BiCGStab : Default=1
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}0{]}}}
&
Tolerance for convergence: Default=:math:\sphinxtitleref{1.0e-11}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditioner is BOOMER AMG}\label{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsboomer}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
AMG interpolation type: Default=6
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
Specifies the use of GSMG - geometrically smooth coarsening and

interpolation: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}9{]}}}
&
AMG coarsen type: Default=6
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}10{]}}}
&
Defines whether local or global measures are used: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}11{]}}}
&
AMG cycle type: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}12{]}}}
&
AMG Smoother type: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}13{]}}}
&
AMG number of levels for smoothers: Default=3
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}14{]}}}
&
AMG number of sweeps for smoothers: Default=2
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}15{]}}}
&
Maximum number of multigrid levels: Default=25
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}16{]}}}
&
Defines which variant of the Schwartz method isused:

0: hybrid multiplicative Schwartz method (no overlap across processor boundaries)

1: hybrid additive Schwartz method (no overlap across processor boundaries)

2: additive Schwartz method

3: hybrid multiplicative Schwartz method (with overlap across processor boundaries)

Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}17{]}}}
&
Size of the system of PDEs: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}18{]}}}
&
Overlap for the Schwarz method: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}19{]}}}
&
Type of domain used for the Schwarz method

0: each point is a domain

1: each node is a domain (only of interest in “systems” AMG)

2: each domain is generated by agglomeration (default)
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}1{]}}}
&
AMG strength threshold: Default=0.25
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}2{]}}}
&
Truncation factor for the interpolation: Default=1e-2
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}3{]}}}
&
Sets a parameter to modify the definition of strength for

diagonal dominant portions of the matrix: Default=0.9
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}3{]}}}
&
Defines a smoothing parameter for the additive Schwartz method. Default=1
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditioner is PILUT}\label{\detokenize{documentation/parallelization:id9}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
Row size in Parallel ILUT: Default=1000
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
Set maximum number of iterations: Default=30
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}1{]}}}
&
Drop tolerance in Parallel ILUT: Default=1e-5
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditioner is ParaSails}\label{\detokenize{documentation/parallelization:id10}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
Number of levels in Parallel Sparse Approximate inverse: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
Symmetric parameter for the ParaSails preconditioner:

0: nonsymmetric and/or indefinite problem, and nonsymmetric preconditioner

1: SPD problem, and SPD (factored) preconditioner

2: nonsymmetric, definite problem, and SPD (factored) preconditioner

Default=0
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}1{]}}}
&
Filters parameters. The filter parameter is used to drop small nonzeros in the preconditioner,

to reduce the cost of applying the preconditioner: Default=0.1
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}2{]}}}
&
Threshold parameter: Default=0.1
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditionner is Schwartz}\label{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsschwartz}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
Defines which variant of the Schwartz method isused:

0: hybrid multiplicative Schwartz method (no overlap across processor boundaries)

1: hybrid additive Schwartz method (no overlap across processor boundaries)

2: additive Schwartz method

3: hybrid multiplicative Schwartz method (with overlap across processor boundaries)

Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
Overlap for the Schwartz method: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}9{]}}}
&
Type of domain used for the Schwartz method

0: each point is a domain

1: each node is a domain (only of interest in “systems” AMG)

2: each domain is generated by agglomeration (default)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Convergence and time for solving linear system}\label{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehypre}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\(n=4\times10^6\)
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
\sphinxstyletheadfamily \(nnz=13\times10^6\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstyletheadfamily 
\(Te = 571.29\)
\\
\hline\sphinxstyletheadfamily 
np
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{4}}
\sphinxstyletheadfamily AMG
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxtitleref{nit}
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
\sphinxstyletheadfamily \sphinxtitleref{time}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
8
&
6
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
1491.83
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
16
&
5
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
708.49
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
32
&
4
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
296.22
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
64
&
4
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
145.64
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Conclusion}
\label{\detokenize{documentation/parallelization:conclusion}}
With the different runs presented here, we wanted to illustrate the gain in time when we increase the number of processors used for the simulations.
We saw that in every case the time for the construction of the finite element matrix is constant.
This is normal because until now this phase is sequential in FreeFem++.
In contrast, phases for solving the linear system are parallel.
We saw on several examples presented here that when we increase the number of processors, in general we decrease the time used for solving the linear systems.
But this is not true in every case.
In several case, when we increase the number of processors the time to convergence also increases.
There are two main reasons for this.
First, the increase of processors can lead to the increase of volume of exchanged data across processors consequently increasing the time for solving the linear systems.

Furthermore, in decomposition domain type preconditioners, the number of processors generally corresponds to the number of sub domains.
In subdomain methods, generally when we increase the number of subdomains we decrease convergence quality of the preconditioner.
This can increase the time used for solving linear equations.

To end this, we should note that good use of the preconditioners interfaced in \sphinxstylestrong{FreeFem++} is empiric, because it is difficult to know what is a good preconditioner for some type of problems.
Although, the efficiency of preconditioners sometimes depends on how its parameters are set.
For this reason we advise the user to pay attention to the meaning of the parameters in the user guide of the iterative solvers interfaced in \sphinxstylestrong{FreeFem++}.


\subsubsection{Domain decomposition}
\label{\detokenize{documentation/parallelization:domain-decomposition}}
In the previous section, we saw that the phases to construct a matrix are sequential.
One strategy to construct the matrix in parallel is to divide geometrically the domain into subdomains.
In every subdomain we construct a local submatrix and after that we assemble every submatrix to form the global matrix.

We can use this technique to solve PDE directly in domain \(\Omega\).
In this case, in every subdomains you have to define artificial boundary conditions to form consistent equations in every subdomains.
After this, you solve equation in every subdomains and define a strategy to obtain the global solution.

In terms of parallel programming for \sphinxstylestrong{FreeFem++}, with MPI, this means that the user must be able to divide processors avaible for computation into subgroups of processors and also must be able to realize different type of communications in \sphinxstylestrong{FreeFem++} script.
Here is a wrapper of some MPI functions.


\paragraph{Communicators and groups}
\label{\detokenize{documentation/parallelization:communicators-and-groups}}
\sphinxstylestrong{Groups}

\sphinxcode{\sphinxupquote{mpiGroup grpe(mpiGroup gp, KN\_\textless{}long\textgreater{})}}: Create MPI\_Group from existing group \sphinxcode{\sphinxupquote{gp}} by given vector.

\sphinxstylestrong{Communicators}

Communicators is an abstract MPI object which allows MPI user to communicate across group of processors.
Communicators can be Intra-communicators(involves a single group) or Inter-communicators (involves two groups).
When we not specify type of communicator it will be Intra-communicators

\sphinxstylestrong{mpiComm cc(mpiComm comm, mpiGroup gp):} Creates a new communicator.

\sphinxcode{\sphinxupquote{comm}} communicator(handle), \sphinxcode{\sphinxupquote{gp}} group which is a subset of the group of \sphinxcode{\sphinxupquote{comm}} (handle).
Return new communicator

\sphinxstylestrong{mpiComm cc(mpiGroup gp)}: Same as previous constructor but default \sphinxcode{\sphinxupquote{comm}} here is \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.

\sphinxstylestrong{mpiComm cc(mpiComm comm, int color, int key):} Creates new communicators based on \sphinxcode{\sphinxupquote{colors}} and \sphinxcode{\sphinxupquote{key}}.
This constructor is based on MPI\_Comm\_split routine of MPI.

\sphinxstylestrong{mpiComm cc(MPIrank p, int key):} Same constructor than the last one.

Here \sphinxcode{\sphinxupquote{colors}} and \sphinxcode{\sphinxupquote{comm}} is defined in \sphinxcode{\sphinxupquote{MPIrank}}.
This constructor is based on \sphinxcode{\sphinxupquote{MPI\_Comm\_split}} routine of MPI.

\begin{sphinxadmonition}{tip}{Tip:}
Split communicator

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{color} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{ccc}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{color}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{qpp}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{cp}\PYG{p}{(}\PYG{n}{ccc}\PYG{p}{,} \PYG{n}{color}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxstylestrong{mpiComm cc(mpiComm comm, int high):} Creates an intracommunicator from an intercommunicator. \sphinxcode{\sphinxupquote{comm}} intercommunicator, \sphinxcode{\sphinxupquote{high}}.

Used to order the groups within \sphinxcode{\sphinxupquote{comm}} (logical) when creating the new communicator.
This constructor is based on \sphinxcode{\sphinxupquote{MPI\_Intercomm\_merge}} routine of MPI.

\sphinxstylestrong{mpiComm cc(MPIrank p1, MPIrank p2, int tag):} This constructor creates an intercommuncator from two intracommunicators.
\sphinxcode{\sphinxupquote{p1}} defined local (intra)communicator and rank in \sphinxcode{\sphinxupquote{local\_comm}} of leader (often 0) while \sphinxcode{\sphinxupquote{p2}} defined remote communicator and rank in \sphinxcode{\sphinxupquote{peer\_comm}} of remote leader (often 0).
\sphinxcode{\sphinxupquote{tag}} Message tag to use in constructing intercommunicator.
This constructor is based on \sphinxcode{\sphinxupquote{MPI\_Intercomm\_create}}.

\begin{sphinxadmonition}{tip}{Tip:}
Merge

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mpiComm} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{cc}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{color} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rk} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{size} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Color values: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{color} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{ccc}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rk}\PYG{o}{\PYGZlt{}}\PYG{n}{size}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rk}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{cp}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{n}{color}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rleader}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{rk} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{rleader} \PYG{o}{=} \PYG{n}{size}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{rk} \PYG{o}{=}\PYG{o}{=} \PYG{n}{size}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{rleader} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{p}{\PYGZob{}} \PYG{n}{rleader} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mpiComm} \PYG{n}{qqp}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ccc}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{rleader}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{12345}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{aaa} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{ccc}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of processor: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{aaa} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\paragraph{Process}
\label{\detokenize{documentation/parallelization:process}}
In \sphinxstylestrong{FreeFem++} we wrap MPI process by function call \sphinxcode{\sphinxupquote{processor}} which create internal \sphinxstylestrong{FreeFem++} object call \sphinxcode{\sphinxupquote{MPIrank}}.
This mean that do not use \sphinxcode{\sphinxupquote{MPIrank}} in \sphinxstylestrong{FreeFem++} script.

\sphinxcode{\sphinxupquote{processor(int rk)}}: Keep process rank inside object \sphinxcode{\sphinxupquote{MPIrank}}.
Rank is inside \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.

\sphinxcode{\sphinxupquote{processor(int rk, mpiComm cc)}} and \sphinxcode{\sphinxupquote{processor(mpiComm cc, int rk)}} process rank inside communicator cc.

\sphinxcode{\sphinxupquote{processor(int rk, mpiComm cc)}} and \sphinxcode{\sphinxupquote{processor(mpiComm cc, int rk)}} process rank inside communicator cc.

\sphinxcode{\sphinxupquote{processorblock(int rk)}}: This function is exactlly the same than \sphinxcode{\sphinxupquote{processor(int rk)}} but is use in case of blocking communication.

\sphinxcode{\sphinxupquote{processorblock(int rk, mpiComm cc)}}: This function is exactly the same as \sphinxcode{\sphinxupquote{processor(int rk, mpiComm cc)}} but uses a synchronization point.


\paragraph{Points to Points communicators}
\label{\detokenize{documentation/parallelization:points-to-points-communicators}}
In \sphinxstylestrong{FreeFem++} you can call MPI points to points communications functions.

\sphinxcode{\sphinxupquote{Send(processor(int rk, mpiComm cc), Data D)}} : Blocking send of \sphinxcode{\sphinxupquote{Data D}} to processor of \sphinxcode{\sphinxupquote{rank rk}} inside communicator \sphinxcode{\sphinxupquote{cc}}.
Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}}.

\sphinxcode{\sphinxupquote{Recv(processor(int rk, mpiComm cc), Data D)}}: Receive \sphinxcode{\sphinxupquote{Data D}} from process of rank \sphinxcode{\sphinxupquote{rk}} in communicator \sphinxcode{\sphinxupquote{cc}}.

Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}} and should be the same type than corresponding send.

\sphinxcode{\sphinxupquote{Isend(processor(int rk, mpiComm cc), Data D)}} : Non blocking send of \sphinxcode{\sphinxupquote{Data D}} to processor of \sphinxcode{\sphinxupquote{rank rk}} inside communicator \sphinxcode{\sphinxupquote{cc}}.

Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{mesh}}, \sphinxcode{\sphinxupquote{mesh3}}, \sphinxcode{\sphinxupquote{matrix}}.

\sphinxcode{\sphinxupquote{Recv(processor(int rk, mpiComm cc), Data D)}}: Receive corresponding to send.


\paragraph{Global operations}
\label{\detokenize{documentation/parallelization:global-operations}}
In \sphinxstylestrong{FreeFem++} you can call MPI global communication functions.

\sphinxcode{\sphinxupquote{broadcast(processor(int rk, mpiComm cc), Data D)}}: Process \sphinxcode{\sphinxupquote{rk}} Broadcast \sphinxcode{\sphinxupquote{Data D}} to all process inside \sphinxcode{\sphinxupquote{communicator cc}}.
Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}}.

\sphinxcode{\sphinxupquote{broadcast(processor(int rk), Data D)}}: Process \sphinxcode{\sphinxupquote{rk}} Broadcast \sphinxcode{\sphinxupquote{Data D}} to all process inside \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.
Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}}.

\sphinxcode{\sphinxupquote{mpiAlltoall(Data a, Data b)}}: Sends \sphinxcode{\sphinxupquote{data a}} from all to all processes.
Receive buffer is \sphinxcode{\sphinxupquote{Data b}}.
This is done inside communicator \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.

\sphinxcode{\sphinxupquote{mpiAlltoall(Data a, Data b, mpiComm cc)}}: Sends \sphinxcode{\sphinxupquote{data a}} from all to all processes. Receive buffer is \sphinxcode{\sphinxupquote{Data b}}.
This is done inside communicator \sphinxcode{\sphinxupquote{cc}}.

\sphinxcode{\sphinxupquote{mpiGather(Data a, Data b, processor(mpiComm, int rk)}}: Gathers together values \sphinxcode{\sphinxupquote{Data a}} from a group of processes.
Process of rank \sphinxcode{\sphinxupquote{rk}} get data on communicator \sphinxcode{\sphinxupquote{rk}}.
This function is like \sphinxcode{\sphinxupquote{MPI\_Gather}}.

\sphinxcode{\sphinxupquote{mpiAllgather(Data a, Data b)}}: Gathers \sphinxcode{\sphinxupquote{Data a}} from all processes and distribute it to all in \sphinxcode{\sphinxupquote{Data b}}.
This is done inside communicator \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.
This function is like \sphinxcode{\sphinxupquote{MPI\_Allgather}}.

\sphinxcode{\sphinxupquote{mpiAllgather(Data a, Data b, mpiComm cc)}}: Gathers \sphinxcode{\sphinxupquote{Data a}} from all processes and distribute it to all in \sphinxcode{\sphinxupquote{Data b}}.
This is done inside \sphinxcode{\sphinxupquote{communicator cc}}.
This function is like \sphinxcode{\sphinxupquote{MPI\_Allgather}}.

\sphinxcode{\sphinxupquote{mpiScatter(Data a,Data b,processor(int rk, mpiComm cc))}}: Sends \sphinxcode{\sphinxupquote{Data a}} from one process whith rank \sphinxcode{\sphinxupquote{rk}} to all other processes in group represented by communicator \sphinxcode{\sphinxupquote{mpiComm cc}}.

\sphinxcode{\sphinxupquote{mpiReduce(Data a, Data b, processor(int rk, mpiComm cc), MPI\_Op op)}} Reduces values \sphinxcode{\sphinxupquote{Data a}} on all processes to a single value \sphinxcode{\sphinxupquote{Data b}} on process of rank \sphinxcode{\sphinxupquote{rk}} and communicator \sphinxcode{\sphinxupquote{cc}}.

Operation use in reduce is: \sphinxcode{\sphinxupquote{MPI\_Op op}} which can be: \sphinxcode{\sphinxupquote{mpiMAX}}, \sphinxcode{\sphinxupquote{mpiMIN}}, \sphinxcode{\sphinxupquote{mpiSUM}}, \sphinxcode{\sphinxupquote{mpiPROD}}, \sphinxcode{\sphinxupquote{mpiLAND}}, \sphinxcode{\sphinxupquote{mpiLOR}}, \sphinxcode{\sphinxupquote{mpiLXOR}}, \sphinxcode{\sphinxupquote{mpiBAND}}, \sphinxcode{\sphinxupquote{mpiBXOR}}, \sphinxcode{\sphinxupquote{mpiMAXLOC}}, \sphinxcode{\sphinxupquote{mpiMINLOC}}.

Note that, for all global operations, only \sphinxcode{\sphinxupquote{int{[}int{]}}} and \sphinxcode{\sphinxupquote{real{[}int{]}}} are data type take in account in \sphinxstylestrong{FreeFem++}.


\subsubsection{HPDDM solvers}
\label{\detokenize{documentation/parallelization:hpddm-solvers}}
Real valued problems (diffusion, heat, elasticity and Stokes) and complex valued problems (Maxwell and Helmholtz) are given in both 2D and 3D.
We detail here the 3D elasticity problem and the 3D time-dependent heat problem.

\begin{sphinxadmonition}{tip}{Tip:}
Elasticity 3D

A three dimensional elasticity problem is defined.
The solver is a domain decomposition method.
Domain decomposition methods are a natural framework for parallel computers.
The scripts run on multicores computers (from 2 to tens of thousands of cores).
Recall that like in any MPI code the number of MPI processes, \sphinxcode{\sphinxupquote{mpisize}}, is given in the command line via the option \sphinxcode{\sphinxupquote{-np}}.
We focus on the script \sphinxcode{\sphinxupquote{Elasticity3D.edp}} but the other scripts have the same structure.
The command line to run the example on four processes with \sphinxcode{\sphinxupquote{ffglut}} visualization is: \sphinxcode{\sphinxupquote{ff-mpirun -np 4 Elasticity3D.edp -glut ffglut}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hpddm}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//load HPDDM plugin}
\PYG{k+kt}{macro} \PYG{n}{partitioner}\PYG{p}{(}\PYG{p}{)}\PYG{n}{metis}\PYG{c+c1}{//metis, scotch, or parmetis}
\PYG{k+kt}{macro} \PYG{n}{dimension}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{3}\PYG{c+c1}{//2D or 3D}
\PYG{k+kt}{macro} \PYG{n}{vectorialfe}\PYG{p}{(}\PYG{p}{)}\PYG{n+nc}{P1}\PYG{c+c1}{//}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{macro\PYGZus{}ddm.idp}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//additional DDM functions}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{i}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{]} \PYG{c+c1}{//vector field definition}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{]} \PYG{c+c1}{//vector field initialization}

\PYG{k+kt}{real} \PYG{n}{Sqrt} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n+nf}{epsilon}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{Sqrt}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{Sqrt}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{Sqrt}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9000.0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{strain} \PYG{o}{=} \PYG{l+m+mf}{100.0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Young} \PYG{o}{=} \PYG{l+m+mf}{2.0e11}\PYG{p}{;} \PYG{c+c1}{// steel}
\PYG{k+kt}{real} \PYG{n}{poisson} \PYG{o}{=} \PYG{l+m+mf}{0.35}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{Pk} \PYG{o}{=} \PYG{p}{[}\PYG{n}{vectorialfe}\PYG{p}{,} \PYG{n}{vectorialfe}\PYG{p}{,} \PYG{n}{vectorialfe}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{string} \PYG{n}{deflation} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}deflation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//coarse space construction}
\PYG{k+kt}{int} \PYG{n}{overlap} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}overlap}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//geometric overlap between subdomains}
\PYG{k+kt}{int} \PYG{n}{fakeInterface} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}interface}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//interface between subdomains}
\PYG{k+kt}{int} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}split}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//refinement factor}
\PYG{k+kt}{int} \PYG{n}{p} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mpiComm} \PYG{n}{comm}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{excluded} \PYG{o}{=} \PYG{n+nf}{splitComm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{topology} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}topology}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exclude} \PYG{o}{=} \PYG{p}{(}\PYG{n}{usedARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}exclude}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{}\PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{o}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpisize}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} Elasticity3D.edp \PYGZhy{} input parameters: refinement factor = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} overlap = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{overlap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{LL} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{meshN} \PYG{n}{ThBorder}\PYG{p}{,} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local finite element space}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{arrayIntersection}\PYG{p}{;} \PYG{c+c1}{//ranks of neighboring subdomains}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{restrictionIntersection}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local\PYGZhy{}to\PYGZhy{}neighbors renumbering}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{D}\PYG{p}{;} \PYG{c+c1}{//partition of unity}
\PYG{p}{\PYGZob{}}
    \PYG{n}{meshN} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{LL}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//global mesh}
    \PYG{n}{build}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ThBorder}\PYG{p}{,} \PYG{n}{ThGlobal}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{overlap}\PYG{p}{,} \PYG{n}{D}\PYG{p}{,} \PYG{n}{arrayIntersection}\PYG{p}{,} \PYG{n}{restrictionIntersection}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{excluded}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{tmp} \PYG{o}{=} \PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{n}{poisson}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{Young} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{Young} \PYG{o}{*} \PYG{n}{poisson} \PYG{o}{/} \PYG{p}{(}\PYG{n}{tmp} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{poisson}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhs}\PYG{p}{;} \PYG{c+c1}{//local right\PYGZhy{}hand side}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Mat}\PYG{p}{;} \PYG{c+c1}{//local operator}
\PYG{p}{\PYGZob{}} \PYG{c+c1}{//local weak form}
    \PYG{n}{meshN} \PYG{n}{ThAugmented} \PYG{o}{=} \PYG{n}{Th} \PYG{o}{+} \PYG{n}{ThBorder}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{vPb} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{lambda} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{f} \PYG{o}{*} \PYG{n}{vC}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uB}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uC}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{k+kt}{fespace} \PYG{n+nf}{WhAugmented}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Mat} \PYG{o}{=} \PYG{n}{vPb}\PYG{p}{(}\PYG{n}{WhAugmented}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhsFull} \PYG{o}{=} \PYG{n}{vPb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{R} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{renumbering}\PYG{p}{(}\PYG{n}{Mat}\PYG{p}{,} \PYG{n}{R}\PYG{p}{,} \PYG{n}{rhsFull}\PYG{p}{,} \PYG{n}{rhs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{ThBorder} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{dschwarz} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{Mat}\PYG{p}{,} \PYG{n}{arrayIntersection}\PYG{p}{,} \PYG{n}{restrictionIntersection}\PYG{p}{,} \PYG{n}{scaling} \PYG{o}{=} \PYG{n}{D}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{sparams} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}schwarz\PYGZus{}method ras \PYGZhy{}hpddm\PYGZus{}schwarz\PYGZus{}coarse\PYGZus{}correction balanced \PYGZhy{}hpddm\PYGZus{}variant right \PYGZhy{}hpddm\PYGZus{}verbosity 1 \PYGZhy{}hpddm\PYGZus{}geneo\PYGZus{}nu 10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Opt}\PYG{p}{;} \PYG{c+c1}{//local operator with optimized boundary conditions}
\PYG{n}{dpair} \PYG{n}{ret}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kp}{solver} \PYG{o}{=} \PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{schwarz\PYGZus{}method}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//optimized Schwarz methods}
        \PYG{k+kt}{fespace} \PYG{n}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{kZero} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}kZero}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Ph} \PYG{n}{transmission} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{kZero} \PYG{o}{*} \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{mu} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{lambda} \PYG{o}{+} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{mu}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n+nf}{vOptimized} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
            \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                  \PYG{n}{lambda} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                \PYG{o}{+} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n}{intN1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{)}\PYG{p}{(}
                  \PYG{n}{transmission} \PYG{o}{*} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uB}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uC}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
            \PYG{p}{;}
        \PYG{n}{Opt} \PYG{o}{=} \PYG{n}{vOptimized}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpisize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{isSetOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{schwarz\PYGZus{}coarse\PYGZus{}correction}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//two\PYGZhy{}level Schwarz methods}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{excluded}\PYG{p}{)}
            \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else} \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{varf} \PYG{n}{vPbNoPen} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                      \PYG{n}{lambda} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{)}
                \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uB}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uC}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
                \PYG{p}{;}
            \PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{noPen} \PYG{o}{=} \PYG{n}{vPbNoPen}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{//standard GenEO, no need for RHS \PYGZhy{}\PYGZgt{} deduced from LHS (Neumann matrix)}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{else} \PYG{n+nf}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dtn}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{k+kt}{varf} \PYG{n}{vMass} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=} \PYG{n}{intN1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u} \PYG{o}{*} \PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{massMatrix} \PYG{o}{=} \PYG{n}{vMass}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{massMatrix}\PYG{p}{,} \PYG{n}{pattern}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{n+nf}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo\PYGZhy{}2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{//GenEO\PYGZhy{}2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{pattern}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{// Solve}
\PYG{n}{Wh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local solution}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Opt}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//optimized Schwarz methods}
    \PYG{n}{DDM}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rhs}\PYG{p}{,} \PYG{n}{excluded}\PYG{o}{=}\PYG{n}{excluded}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{,} \PYG{n}{O}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{rhs}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{err}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kp}{err} \PYG{o}{=} \PYG{k+kp}{A} \PYG{o}{*} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//global matrix\PYGZhy{}vector product}
\PYG{k+kp}{err} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{rhs}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n}{plotMPI}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Global solution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plotMPI}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{err}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Global residual}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{2000.0}\PYG{p}{;}
\PYG{n}{meshN} \PYG{n}{ThMoved} \PYG{o}{=} \PYG{n}{movemesh3}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo} \PYG{o}{=} \PYG{p}{[}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{p}{,} \PYG{k+kr}{y} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{uB}\PYG{p}{,} \PYG{k+kr}{z} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{uC}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kr}{mpirank}\PYG{p}{;}
\PYG{n}{plotMPI}\PYG{p}{(}\PYG{n}{ThMoved}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Global moved solution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

The macro \sphinxcode{\sphinxupquote{build}} is of particular interest since it handles the data distribution among the \sphinxcode{\sphinxupquote{mpisize}} MPI processes with the following steps:
\begin{itemize}
\item {} 
The initial mesh \sphinxcode{\sphinxupquote{ThGlobal}} is partitioned by process 0 into \sphinxcode{\sphinxupquote{mpisize}} submeshes

\item {} \begin{description}
\item[{The partition is broadcasted to every process \(i\) for 0 \textless{} \(i\) \textless{} \sphinxcode{\sphinxupquote{mpisize}}.}] \leavevmode
From then on, all tasks are parallel.

\end{description}

\item {} \begin{description}
\item[{Each process creates the local submesh \sphinxcode{\sphinxupquote{Th}} (if the refinement factor \sphinxcode{\sphinxupquote{s}} defined via the option \sphinxcode{\sphinxupquote{-split}} is larger than 1, each local edge is splitted into \(s\) subedges, resulting in each element being split into \(s^2\) element in 2D and \(s^3\) elements in 3D) so that the collection of these submeshes is an overlapping domain decomposition of a refined mesh.}] \leavevmode
The number of extra layers added to the initial partition is monitored by the option \sphinxcode{\sphinxupquote{overlap}}.

\end{description}

\item {} 
Connectivity structures are created

\item {} 
\sphinxcode{\sphinxupquote{D}} is the diagonal of the local partition of unity (see {\hyperref[\detokenize{documentation/parallelization:paralleldistributedvectorshpddm}]{\sphinxcrossref{\DUrole{std,std-ref}{Distributed vectors in HPDDM}}}})

\item {} 
\sphinxcode{\sphinxupquote{arrayIntersection}} is the list of neighbors of the current subdomain

\item {} 
For \sphinxcode{\sphinxupquote{j}} in \sphinxcode{\sphinxupquote{arrayIntersection}}, \sphinxcode{\sphinxupquote{restrictionIntersection{[}j{]}}} is the list of the degrees of freedom that belong to the intersection of the current subdomain with its neighbor \sphinxcode{\sphinxupquote{j}}.

\end{itemize}

Then, the variational formulation \sphinxcode{\sphinxupquote{vPb}} of a three dimensional elasticity problem is used to assemble a local matrix \sphinxcode{\sphinxupquote{Mat}}.
This matrix along with \sphinxcode{\sphinxupquote{D}}, \sphinxcode{\sphinxupquote{arrayIntersection}} and \sphinxcode{\sphinxupquote{restrictionIntersection}} are arguments for the constructor of the distributed matrix \sphinxcode{\sphinxupquote{A}}.
This is enough to solve the problem with a one-level additive Schwarz method which can be either ASM or RAS.

For some problems it is interesting to use optimized interface conditions.
When there are many subdomains, it is usually profitable to add a second level to the solver.
Options are set in the sequel of the script:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{sparams}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}schwarz\PYGZus{}method ras \PYGZhy{}hpddm\PYGZus{}schwarz\PYGZus{}coarse\PYGZus{}correction balanced \PYGZhy{}hpddm\PYGZus{}variant right \PYGZhy{}hpddm\PYGZus{}verbosity 1 \PYGZhy{}hpddm\PYGZus{}geneo\PYGZus{}nu 10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In the above line, the first option selects the one-level preconditioner \sphinxcode{\sphinxupquote{ras}} (possible choices are \sphinxcode{\sphinxupquote{ras}}, \sphinxcode{\sphinxupquote{oras}}, \sphinxcode{\sphinxupquote{soras}}, \sphinxcode{\sphinxupquote{asm}}, \sphinxcode{\sphinxupquote{osm}} or \sphinxcode{\sphinxupquote{none}}), the second option selects the correction formula for the second level here \sphinxcode{\sphinxupquote{balanced}} (possible options are \sphinxcode{\sphinxupquote{deflated}}, \sphinxcode{\sphinxupquote{additive}} or \sphinxcode{\sphinxupquote{balanced}}), the third option selects right preconditioning, the fourth one is verbosity level of HPDDM (different from the one of \sphinxstylestrong{FreeFem++}), the fifth one prints all possible options of HPPDM and the last one specifies the number of coarse degrees of freedom per subdomain of the GENEO coarse space.
All other options of \sphinxhref{https://github.com/hpddm/hpddm/blob/master/doc/cheatsheet.pdf}{HPDDM library} can be selected via the \sphinxstylestrong{FreeFem++} function \sphinxcode{\sphinxupquote{set}}.

In the last part of the script, the global linear system is solved by the domain decomposition method defined above.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve}
\PYG{n}{Wh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local solution}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Opt}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//optimized Schwarz methods}
\PYG{n}{DDM}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rhs}\PYG{p}{,} \PYG{n}{excluded}\PYG{o}{=}\PYG{n}{excluded}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{,} \PYG{n}{O}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{rhs}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Time dependent problem}
\label{\detokenize{documentation/parallelization:time-dependent-problem}}
\begin{sphinxadmonition}{tip}{Tip:}
Heat 3D

A three dimensional heat problem
\begin{equation*}
\begin{split}\frac{\partial u}{\partial t} - \Delta u = 1,\ \ \ u(0,\cdot) := 0 \text{ in }\Omega\,.\end{split}
\end{equation*}
is discretized by an implicit Euler scheme. At each time step \(n\), we shall seek \(u^n(x,y,z)\) satisfying for all \(w\in H^1(\Omega)\):
\begin{equation*}
\begin{split}\int_\Omega \frac{u^n-u^{n-1}}{\delta t}\,w + \nabla u^n \nabla w = \int_\Omega w ,\ \ \ u^0 := 0 \text{ in }\Omega\,.\end{split}
\end{equation*}
so that at each time step a linear system:
\begin{equation*}
\begin{split}(M+dt*K) u^n[] = M*u^{n-1}[] + \delta t*F\end{split}
\end{equation*}
is solved by a domain decomposition method where \(M\) is the mass matrix and \(K\) is the rigidity matrix. In order to save computational efforts, the domain decomposition method preconditioner is built only once and then reused for all subsequent solves with matrix \(A:=M+dt*K\).
The distributed matrix vector product with matrix \(M\) is made through the call to the function \sphinxcode{\sphinxupquote{dmv}} using the partition of unity associated to matrix \(A\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hpddm}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//load HPDDM plugin}
\PYG{k+kt}{macro} \PYG{n}{partitioner}\PYG{p}{(}\PYG{p}{)}\PYG{n}{metis}\PYG{c+c1}{//metis, scotch, or parmetis}
\PYG{k+kt}{macro} \PYG{n}{dimension}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{3}\PYG{c+c1}{//2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{macro\PYGZus{}ddm.idp}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//additional DDM functions}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{n}{i} \PYG{c+c1}{//scalar field definition}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{n}{i} \PYG{c+c1}{//scalar field initialization}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//three\PYGZhy{}dimensional gradient}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{Pk} \PYG{o}{=} \PYG{n+nc}{P2}\PYG{p}{;} \PYG{c+c1}{//finite element space}

\PYG{k+kt}{string} \PYG{n}{deflation} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}deflation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//coarse space construction}
\PYG{k+kt}{int} \PYG{n}{overlap} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}overlap}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//geometric overlap between subdomains}
\PYG{k+kt}{int} \PYG{n}{fakeInterface} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}interface}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//interface between subdomains}
\PYG{k+kt}{int} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}split}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//refinement factor}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//time step}
\PYG{k+kt}{int} \PYG{n}{iMax} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}iMax}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//number of iterations}

\PYG{k+kt}{mpiComm} \PYG{n}{comm}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{p} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{excluded} \PYG{o}{=} \PYG{n+nf}{splitComm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{topology} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}topology}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exclude} \PYG{o}{=} \PYG{p}{(}\PYG{n}{usedARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}exclude}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{}\PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{o}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpisize}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} Heat3D.edp \PYGZhy{} input parameters: refinement factor = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} overlap = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{overlap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{LL} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{meshN} \PYG{n}{ThBorder}\PYG{p}{,} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local finite element space}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{arrayIntersection}\PYG{p}{;} \PYG{c+c1}{//ranks of neighboring subdomains}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{restrictionIntersection}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local\PYGZhy{}to\PYGZhy{}neighbors renumbering}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{D}\PYG{p}{;} \PYG{c+c1}{//partition of unity}
\PYG{p}{\PYGZob{}}
    \PYG{n}{meshN} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{LL}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//global mesh}
    \PYG{n}{build}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ThBorder}\PYG{p}{,} \PYG{n}{ThGlobal}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{overlap}\PYG{p}{,} \PYG{n}{D}\PYG{p}{,} \PYG{n}{arrayIntersection}\PYG{p}{,} \PYG{n}{restrictionIntersection}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{excluded}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhs}\PYG{p}{;} \PYG{c+c1}{// local right\PYGZhy{}hand side}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Mat}\PYG{p}{;} \PYG{c+c1}{//local operator}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{M}\PYG{p}{;} \PYG{c+c1}{//local mass matrix}
\PYG{p}{\PYGZob{}} \PYG{c+c1}{//local weak form}
    \PYG{n}{meshN} \PYG{n}{ThAugmented} \PYG{o}{=} \PYG{n}{Th} \PYG{o}{+} \PYG{n}{ThBorder}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{vPb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
        \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{u} \PYG{o}{*} \PYG{n}{v}
            \PYG{o}{+} \PYG{n}{dt} \PYG{o}{*} \PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{dt} \PYG{o}{*} \PYG{n}{v}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
        \PYG{p}{;}
    \PYG{k+kt}{fespace} \PYG{n+nf}{WhAugmented}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Mat} \PYG{o}{=} \PYG{n}{vPb}\PYG{p}{(}\PYG{n}{WhAugmented}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhsFull} \PYG{o}{=} \PYG{n}{vPb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{R} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{vPbM} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u} \PYG{o}{*} \PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{M} \PYG{o}{=} \PYG{n}{vPbM}\PYG{p}{(}\PYG{n}{WhAugmented}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{renumbering}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{R}\PYG{p}{,} \PYG{n}{rhsFull}\PYG{p}{,} \PYG{n}{rhs}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{renumbering}\PYG{p}{(}\PYG{n}{Mat}\PYG{p}{,} \PYG{n}{R}\PYG{p}{,} \PYG{n}{rhsFull}\PYG{p}{,} \PYG{n}{rhs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{ThBorder} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{dschwarz} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{Mat}\PYG{p}{,} \PYG{n}{arrayIntersection}\PYG{p}{,} \PYG{n}{restrictionIntersection}\PYG{p}{,} \PYG{n}{scaling}\PYG{o}{=}\PYG{n}{D}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Opt}\PYG{p}{;} \PYG{c+c1}{//local operator with optimized boundary conditions}
\PYG{n}{dpair} \PYG{n}{ret}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kp}{solver} \PYG{o}{=} \PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{schwarz\PYGZus{}method}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//optimized Schwarz methods}
        \PYG{k+kt}{fespace} \PYG{n}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{kZero} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}kZero}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Ph} \PYG{n}{transmission} \PYG{o}{=} \PYG{n}{kZero}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n+nf}{vOptimized} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
            \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                  \PYG{n}{u} \PYG{o}{*} \PYG{n}{v}
                \PYG{o}{+} \PYG{n}{dt} \PYG{o}{*} \PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n}{intN1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{)}\PYG{p}{(}
                  \PYG{n}{transmission} \PYG{o}{*} \PYG{p}{(}\PYG{n}{u} \PYG{o}{*} \PYG{n}{v}\PYG{p}{)}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
            \PYG{p}{;}
        \PYG{n}{Opt} \PYG{o}{=} \PYG{n}{vOptimized}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpisize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{isSetOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{schwarz\PYGZus{}coarse\PYGZus{}correction}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//two\PYGZhy{}level Schwarz methods}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{excluded}\PYG{p}{)}
            \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else} \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{varf} \PYG{n}{vPbNoPen} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
                \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                      \PYG{n}{u} \PYG{o}{*} \PYG{n}{v}
                    \PYG{o}{+} \PYG{n}{dt} \PYG{o}{*} \PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{)}
                \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
                \PYG{p}{;}
            \PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{noPen} \PYG{o}{=} \PYG{n}{vPbNoPen}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{//standard GenEO, no need for RHS \PYGZhy{}\PYGZgt{} deduced from LHS (Neumann matrix)}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{n}{ret} \PYG{o}{=} \PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{else} \PYG{n+nf}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dtn}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{varf} \PYG{n}{vMass} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=} \PYG{n}{intN1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u} \PYG{o}{*} \PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{massMatrix} \PYG{o}{=} \PYG{n}{vMass}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{massMatrix}\PYG{p}{,} \PYG{n}{pattern}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{n+nf}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo\PYGZhy{}2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{//GenEO\PYGZhy{}2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{pattern}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solve}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{sparams}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}reuse\PYGZus{}preconditioner=1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{=} \PYG{k+kp}{init}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local solution}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{iMax}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{newRhs}\PYG{p}{(}\PYG{n}{rhs}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dmv}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{newRhs}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//newRhs = M * u[]}
    \PYG{n}{newRhs} \PYG{o}{+}\PYG{o}{=} \PYG{n}{rhs}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{Opt}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//optimized Schwarz methods}
    \PYG{n}{DDM}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{newRhs}\PYG{p}{,} \PYG{n}{excluded}\PYG{o}{=}\PYG{n}{excluded}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{,} \PYG{n}{O}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{else}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{newRhs}\PYG{p}{;}

    \PYG{n}{plotMPI}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Global solution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Distributed vectors in HPDDM}
\label{\detokenize{documentation/parallelization:distributed-vectors-in-hpddm}}\label{\detokenize{documentation/parallelization:paralleldistributedvectorshpddm}}
We give here some hints on the way vectors are distributed among \(np\) processes when using \sphinxstylestrong{FreeFem++} interfaced with HPDDM.
The set of degrees of freedom \({\mathcal N}\) is decomposed into \(np\) overlapping sets \(({\mathcal N}_i)_{1\le i\le np}\).

A MPI-process is in charge of each subset.
Let \(n:=\#{\mathcal N}\) be the number of degrees of freedom of the global finite element space.
Let \(R_i\) denote the restriction operator from \(\R^n\) onto \(\R^{\#{\mathcal N}_i}\).
We have also defined local diagonal matrices \(D_i\in \R^{\#{\mathcal N}_i}\times \R^{\#{\mathcal N}_i}\) so that we have a partition of unity at the algebraic level:
\begin{equation}\label{equation:documentation/parallelization:eq:hpddm:14}
\begin{split}{\mathbf U} = \sum_{i=1}^{np} R_i^T\,D_i\,R_i\,{\mathbf U}\ \ \ \ \forall\ {\mathbf U}\in\R^n\,.\end{split}
\end{equation}
A global vector \({\mathbf U}\in\R^n\) is actually not stored.
Rather, it is stored in a distributed way.
Each process \(i\), \(1\le i\le N\), stores the local vector \({\mathbf U}_i:=R_i {\mathbf U}\in \R^{\#{\mathcal N}_i}\).

It is important to ensure that the result of all linear algebra operators applied to this representation are coherent.

As an example, consider the scalar product of two distributed vectors \({\mathbf U}, {\mathbf V} \in \mathbb{R}^{n}\).
Using the partition of unity \eqref{equation:documentation/parallelization:eq:hpddm:14}, we have:
\begin{equation*}
\begin{split}({\mathbf U}, {\mathbf V}) = \left({\mathbf U}, \sum_{i=1}^{np} R_i^T D_i R_i {\mathbf V}\right) &= \sum_{i=1}^{np} (R_i {\mathbf U}, D_i R_i {\mathbf V})\\
&=\sum_{i=1}^{np} \left({\mathbf U}_i, D_i {\mathbf V}_i\right)\,.\end{split}
\end{equation*}
Thus, the formula for the scalar product is:
\begin{equation*}
\begin{split}({\mathbf U}, {\mathbf V}) = \sum_{i = 1}^{np} (R_i {\mathbf U}, D_i R_i {\mathbf V})\,.\end{split}
\end{equation*}
Local scalar products are performed concurrently.
Thus, the implementation is parallel except for the sum which corresponds to a \sphinxcode{\sphinxupquote{MPI\_Reduce}} call across the \(np\) MPI processes.

Note also that the implementation relies on the knowledge of a partition of unity so that the FreeFem++ syntax is \sphinxcode{\sphinxupquote{dscalprod(D, u, v)}}.

A \sphinxcode{\sphinxupquote{axpy}} procedure \(y \leftarrow \alpha\,x+y\) for \(x,y\in \mathbb{R}^{n}\) and \(\alpha\in\R\) is easily implemented concurrently for distributed vectors in the form:
\begin{equation*}
\begin{split}y_i \leftarrow \alpha\,x_i+y_i\,, \forall\ 1\le i \le np\,.\end{split}
\end{equation*}
The matrix vector product is more involved and details are given in the SIAM book \sphinxhref{https://www.ljll.math.upmc.fr/nataf/OT144DoleanJolivetNataf\_full.pdf}{An Introduction to Domain Decomposition Methods: algorithms, theory and parallel implementation} and even more details are given in \sphinxhref{http://jolivet.perso.enseeiht.fr/thesis.pdf}{P. Jolivet’s PhD manuscrit}.


\section{Plugins}
\label{\detokenize{documentation/plugins:plugins}}\label{\detokenize{documentation/plugins::doc}}

\subsection{gsl}
\label{\detokenize{documentation/plugins:gsl}}
The interface with \sphinxcode{\sphinxupquote{gsl}} spline is available in \sphinxstylestrong{FreeFem++}, the seven kind of spline are
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{-1}
\item {} 
\sphinxcode{\sphinxupquote{gslinterpcspline}}: default type of spline

\item {} 
\sphinxcode{\sphinxupquote{gslinterpakima}}

\item {} 
\sphinxcode{\sphinxupquote{gslinterpsteffen}}

\item {} 
\sphinxcode{\sphinxupquote{gslinterplinear}}

\item {} 
\sphinxcode{\sphinxupquote{gslinterppolynomial}}

\item {} 
\sphinxcode{\sphinxupquote{gslinterpcsplineperiodic}}

\item {} 
\sphinxcode{\sphinxupquote{gslinterpakimaperiodic}}

\end{enumerate}

A brief wing example given all the syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gsl}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//data points to define the spline}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//set data points}
   \PYG{k+kt}{real} \PYG{n}{xx} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{/}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{yy} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{xx}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{n}{xx}\PYG{p}{;}
   \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{n}{yy}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// GSL splines}
\PYG{k+kt}{gslspline} \PYG{n}{spline1}\PYG{p}{(}\PYG{n+nf}{gslinterpcspline}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline1}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline11}\PYG{p}{(}\PYG{n}{dspline}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline11}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline2}\PYG{p}{(}\PYG{n+nf}{gslinterpsteffen}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline2}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline3}\PYG{p}{(}\PYG{n+nf}{gslinterpcspline}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline33}\PYG{p}{(}\PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline3}
\PYG{n}{spline1} \PYG{o}{=} \PYG{n}{spline2}\PYG{p}{;} \PYG{c+c1}{//copy spline2 in spline1}

\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{s1} \PYG{o}{=} \PYG{n}{spline1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//evaluate the function spline1 at t}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spline1(t) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ds1} \PYG{o}{=} \PYG{n}{spline1}\PYG{p}{.}\PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//evaluate the derivative of function spline1 at t}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spline1.d(t) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ds1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dds1} \PYG{o}{=} \PYG{n}{spline1}\PYG{p}{.}\PYG{n+nf}{dd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//evaluate the second derivative of function spline1 at t}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spline1.dd(t) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dds1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

This can be usefull to build function from data value.

The list of all \sphinxcode{\sphinxupquote{gsl}} functions and the \sphinxstylestrong{FreeFem++} equivalent is available in the {\hyperref[\detokenize{reference/externalLibraries:referenceffgslawk}]{\sphinxcrossref{\DUrole{std,std-ref}{Language references}}}} (same names without \sphinxcode{\sphinxupquote{\_}}).


\subsection{ffrandom}
\label{\detokenize{documentation/plugins:ffrandom}}
Plugin to linux \sphinxcode{\sphinxupquote{random}} functions.

The range of the random generator is from \(0\) to \((2^{31})-1\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffrandom}\PYG{l+s}{\PYGZdq{}}

\PYG{n+nf}{srandomdev}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set a true random seed}
\PYG{c+c1}{//warning: under window this command}
\PYG{c+c1}{//change the seed by randinit(random())) so all}
\PYG{c+c1}{//FreeFem++ random function are changed}

\PYG{k+kt}{int} \PYG{n}{maxrang} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{31} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ max range }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxrang} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n+nf}{srandom}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{mmap / semaphore}
\label{\detokenize{documentation/plugins:mmap-semaphore}}
The idea is just try to use Interprocess communication using POSIX Shared Memory in Linux.

We build a small library \sphinxcode{\sphinxupquote{libff-mmap-semaphore.c}} and \sphinxcode{\sphinxupquote{libff-mmap-semaphore.h}} to easily interface.
\begin{itemize}
\item {} 
mmap - allocate memory, or map files or devices into memory

\item {} 
semaphore - allow processes and threads to synchronize their actions

A semaphore is an integer whose value is never allowed to fall below zero.
Two operations can be performed on semaphores: increment the semaphore value by one (\sphinxcode{\sphinxupquote{sem\_post}}); and decrement the semaphore value by one (\sphinxcode{\sphinxupquote{sem\_wait}}).

If the value of a semaphore is currently zero, then a \sphinxcode{\sphinxupquote{sem\_wait}} operation will block until the value becomes greater than zero.

\end{itemize}

\sphinxstylestrong{The functions of library}

First the \sphinxcode{\sphinxupquote{semaphore}} interface to make synchronization:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{typedef struct FF\_P\_sem *ff\_Psem;}} the pointer to data structure

\item {} 
\sphinxcode{\sphinxupquote{ff\_Psem ffsem\_malloc();}} malloc an empty data structure

\item {} 
\sphinxcode{\sphinxupquote{void ffsem\_del(ff\_Psem sem);}} clean and free the pointer

\item {} 
\sphinxcode{\sphinxupquote{void ffsem\_destroy(ff\_Psem sem);}} clean, close the data structure

\item {} 
\sphinxcode{\sphinxupquote{void ffsem\_init0(ff\_Psem sem);}} make a correct empty of the data structure

\item {} 
\sphinxcode{\sphinxupquote{void ffsem\_init(ff\_Psem sem,const char *nmm, int crea);}} create or use a new semaphore

\item {} 
\sphinxcode{\sphinxupquote{long ffsem\_post(ff\_Psem sem);}} \sphinxcode{\sphinxupquote{nlocked}}, the value of the semaphore is incremented, and all threads which are waiting on the semaphore are awakened

\item {} 
\sphinxcode{\sphinxupquote{long ffsem\_wait(ff\_Psem sem);}} the semaphore referenced by \sphinxcode{\sphinxupquote{sem}} is locked.
When calling \sphinxcode{\sphinxupquote{sem\_wait()}}, if the semaphore’s value is zero, the calling thread will block until the lock is acquired or until the call is interrupted by a signal.

Alternatively, the \sphinxcode{\sphinxupquote{sem\_trywait()}} function will fail if the semaphore is already locked, rather than blocking on the semaphore

\item {} 
\sphinxcode{\sphinxupquote{long ffsem\_trywait(ff\_Psem p);}}

\end{itemize}

Secondly, the \sphinxcode{\sphinxupquote{mmap}} functions:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{typedef struct FF\_P\_mmap *ff\_Pmmap;}} the pointer to data structure

\item {} 
\sphinxcode{\sphinxupquote{ff\_Psem ffmmap\_malloc();}} malloc an empty data structure

\item {} 
\sphinxcode{\sphinxupquote{void ffmmap\_del(ff\_Pmmap p);}} clean and free the pointer

\item {} 
\sphinxcode{\sphinxupquote{void ffmmap\_destroy(ff\_Pmmap p);}} clean, close the data structure

\item {} 
\sphinxcode{\sphinxupquote{void ffmmap\_init0(ff\_Pmmap p);}} make a correct empty of the data structure

\item {} 
\sphinxcode{\sphinxupquote{long ffmmap\_msync(ff\_Pmmap p, long off, long ln);}} call writes modified whole pages back to the filesystem and updates the file modification time.
Only those pages containing \sphinxcode{\sphinxupquote{addr}} and \sphinxcode{\sphinxupquote{len-1}} succeeding locations will be examined.

\item {} 
\sphinxcode{\sphinxupquote{void ffmmap\_init(ff\_Pmmap p, const char *nmm, long len);}} allocate memory, or map files or devices into memory.

\item {} 
\sphinxcode{\sphinxupquote{long ffmmap\_read(ff\_Pmmap p, void *t, size\_t n, size\_t off);}} read \sphinxcode{\sphinxupquote{n}} bytes from the \sphinxcode{\sphinxupquote{mmap}} at memory \sphinxcode{\sphinxupquote{off}} in pointer \sphinxcode{\sphinxupquote{t}}.

\item {} 
\sphinxcode{\sphinxupquote{long ffmmap\_write(ff\_Pmmap p, void *t, size\_t n, size\_t off);}} write \sphinxcode{\sphinxupquote{n}} bytes to the \sphinxcode{\sphinxupquote{mmap}} at memory \sphinxcode{\sphinxupquote{off}} in pointer \sphinxcode{\sphinxupquote{t}}.

\end{itemize}

The \sphinxstylestrong{FreeFem++} corresponding functions:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Pmmap sharedata(filename, 1024);}} new type to store the \sphinxcode{\sphinxupquote{mmap}} informations of name store in string \sphinxcode{\sphinxupquote{filename}} with 1024 is the size the \sphinxcode{\sphinxupquote{sharedata}} zone and file.

\item {} 
\sphinxcode{\sphinxupquote{Psemaphore smff("ff-slave", creat);}} new type to store the semaphore of name \sphinxcode{\sphinxupquote{ff-slave}} where \sphinxcode{\sphinxupquote{creat}} is a boolean to create or use a existing semaphore.

\item {} 
\sphinxcode{\sphinxupquote{Wait(sem)}} the semaphore referenced by \sphinxcode{\sphinxupquote{sem}} is locked.
When calling \sphinxcode{\sphinxupquote{Wait(sem)}}, if the semaphore’s value is zero, the calling thread will block until the lock is acquired or until the call is interrupted by a signal.
Alternatively, the \sphinxcode{\sphinxupquote{trywait(sem)}} function will fail if the semaphore is already locked, rather than blocking on the semaphore.

\item {} 
\sphinxcode{\sphinxupquote{Post(sem)}} the semaphore referenced by \sphinxcode{\sphinxupquote{sem}} is unlocked, the value of the semaphore is incremented, and all threads which are waiting on the semaphore are awakened.

\item {} 
\sphinxcode{\sphinxupquote{Read(sharedata ,offset, data);}} read the variable \sphinxcode{\sphinxupquote{data}} from the place \sphinxcode{\sphinxupquote{offset}} in \sphinxcode{\sphinxupquote{sharedata}} mmap.

\item {} 
\sphinxcode{\sphinxupquote{Write(sharedata, offset, data);}} write the variable \sphinxcode{\sphinxupquote{data}} at the place \sphinxcode{\sphinxupquote{offset}} in \sphinxcode{\sphinxupquote{sharedata}} mmap.

\end{itemize}

The full example:

The \sphinxcode{\sphinxupquote{FFMaster.c}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}libff\PYGZhy{}mmap\PYGZhy{}semaphore.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{n}{ff\PYGZus{}Psem} \PYG{n}{sem\PYGZus{}ff}\PYG{p}{,} \PYG{n}{sem\PYGZus{}c}\PYG{p}{;} \PYG{c+c1}{//the semaphore for mutex}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{debug} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{ff\PYGZus{}Pmmap} \PYG{n}{shd}\PYG{p}{;}
   \PYG{k+kt}{double} \PYG{n}{cff}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{;}
   \PYG{k+kt}{long} \PYG{n}{status}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{argc} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{debug} \PYG{o}{=} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ff\PYGZus{}mmap\PYGZus{}sem\PYGZus{}verb} \PYG{o}{=} \PYG{n}{debug}\PYG{p}{;}

   \PYG{n}{sem\PYGZus{}ff} \PYG{o}{=} \PYG{n}{ffsem\PYGZus{}malloc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{sem\PYGZus{}c} \PYG{o}{=} \PYG{n}{ffsem\PYGZus{}malloc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{shd} \PYG{o}{=} \PYG{n}{ffmmap\PYGZus{}malloc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{ffsem\PYGZus{}init}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}slave1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}init}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}master1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}init}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shared\PYGZhy{}data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{status} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}write}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{status}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{status}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}msync}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kt}{char} \PYG{n}{ff}\PYG{p}{[}\PYG{l+m+mi}{1024}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FreeFem++ FFSlave.edp \PYGZhy{}nw \PYGZhy{}ns \PYGZhy{}v \PYGZpc{}d\PYGZam{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{debug}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{system}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//lauch FF++ in batch no graphics}
   \PYG{k}{if}\PYG{p}{(}\PYG{n}{debug}\PYG{p}{)} \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cc: before wait}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if}\PYG{p}{(}\PYG{n}{debug}\PYG{p}{)} \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cc: before wait 0 ff}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}wait}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ iter : \PYGZpc{}d }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{cff} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{o}{+}\PYG{n}{i}\PYG{p}{;}
      \PYG{n}{ffmmap\PYGZus{}write}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{cff}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{cff}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{ffsem\PYGZus{}post}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{)}\PYG{p}{;}

      \PYG{k}{if}\PYG{p}{(}\PYG{n}{debug}\PYG{p}{)} \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ cc: before wait 2}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{ffsem\PYGZus{}wait}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{ffmmap\PYGZus{}read}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{rff}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{rff}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ iter = \PYGZpc{}d rff= \PYGZpc{}f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{n}{status} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//end}
   \PYG{n}{ffmmap\PYGZus{}write}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{status}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{status}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}post}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End Master }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}wait}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}del}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}del}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}del}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{FFSlave.edp}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}mmap\PYGZhy{}semaphore}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{Psemaphore} \PYG{n}{smff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}slave1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{Psemaphore} \PYG{n+nf}{smc}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}master1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{Pmmap} \PYG{n+nf}{sharedata}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shared\PYGZhy{}data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Lab} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{k+kt}{int} \PYG{n}{status} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ FF status = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{status} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cff}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Pb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{cff}\PYG{o}{*}\PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Lab}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{9}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ FF: before FF post}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n+nf}{Post}\PYG{p}{(}\PYG{n}{smff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//unlock master end init}

\PYG{k}{while} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{9}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ FF: before FF wait }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
   \PYG{n+nf}{Wait}\PYG{p}{(}\PYG{n}{smc}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait from cint write ok}
   \PYG{n+nf}{Read}\PYG{p}{(}\PYG{n}{sharedata}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{Read}\PYG{p}{(}\PYG{n}{sharedata}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ After wait .. FF }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{status} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{if}\PYG{p}{(}\PYG{n}{status} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

   \PYG{c+c1}{// Solve}
   \PYG{n}{Pb}\PYG{p}{;}
   \PYG{n}{rff} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ** FF }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

   \PYG{c+c1}{// Write}
   \PYG{n+nf}{Write}\PYG{p}{(}\PYG{n}{sharedata}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{Post}\PYG{p}{(}\PYG{n}{smff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//unlock cc}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{Post}\PYG{p}{(}\PYG{n}{smff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait from cint}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ End FreeFem++ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

To test this example of coupling \sphinxcode{\sphinxupquote{C}} program and \sphinxstylestrong{FreeFem++} script:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
cc \PYGZhy{}c libff\PYGZhy{}mmap\PYGZhy{}semaphore.c
cc FFMaster.c \PYGZhy{}o FFMaster libff\PYGZhy{}mmap\PYGZhy{}semaphore.o \PYGZhy{}g \PYGZhy{}pthread
ff\PYGZhy{}c++ \PYGZhy{}auto ff\PYGZhy{}mmap\PYGZhy{}semaphore.cpp
./FFMaster
\end{sphinxVerbatim}

The output:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
len \PYG{l+m}{1024} size \PYG{l+m}{0}
len \PYG{l+m}{1024} size \PYG{l+m}{1024}
FF \PYG{n+nv}{status} \PYG{o}{=} \PYG{l+m}{1}
iter : \PYG{l+m}{0}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{10} \PYG{l+m}{1}
** FF \PYG{l+m}{10} \PYG{l+m}{0}.161797
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{0} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.161797
iter : \PYG{l+m}{1}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{11} \PYG{l+m}{1}
** FF \PYG{l+m}{11} \PYG{l+m}{0}.195774
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{1} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.195774
iter : \PYG{l+m}{2}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{12} \PYG{l+m}{1}
** FF \PYG{l+m}{12} \PYG{l+m}{0}.232987
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{2} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.232987
iter : \PYG{l+m}{3}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{13} \PYG{l+m}{1}
** FF \PYG{l+m}{13} \PYG{l+m}{0}.273436
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{3} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.273436
iter : \PYG{l+m}{4}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{14} \PYG{l+m}{1}
** FF \PYG{l+m}{14} \PYG{l+m}{0}.317121
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{4} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.317121
iter : \PYG{l+m}{5}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{15} \PYG{l+m}{1}
** FF \PYG{l+m}{15} \PYG{l+m}{0}.364042
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{5} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.364042
iter : \PYG{l+m}{6}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{16} \PYG{l+m}{1}
** FF \PYG{l+m}{16} \PYG{l+m}{0}.414199
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{6} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.414199
iter : \PYG{l+m}{7}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{17} \PYG{l+m}{1}
** FF \PYG{l+m}{17} \PYG{l+m}{0}.467592
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{7} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.467592
iter : \PYG{l+m}{8}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{18} \PYG{l+m}{1}
** FF \PYG{l+m}{18} \PYG{l+m}{0}.524221
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{8} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.524221
iter : \PYG{l+m}{9}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{19} \PYG{l+m}{1}
** FF \PYG{l+m}{19} \PYG{l+m}{0}.584086
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{9} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.584086
End Master
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{19} \PYG{l+m}{0}
\end{sphinxVerbatim}


\section{Developers}
\label{\detokenize{documentation/developers:developers}}\label{\detokenize{documentation/developers::doc}}

\subsection{File formats}
\label{\detokenize{documentation/developers:file-formats}}

\subsubsection{Mesh file data structure}
\label{\detokenize{documentation/developers:mesh-file-data-structure}}\label{\detokenize{documentation/developers:meshfiledatastructure}}
The mesh data structure, output of a mesh generation algorithm, refers to the geometric data structure and in some case to another mesh data structure.

In this case, the fields are

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{MeshVersionFormatted} \PYG{n}{0}

\PYG{n}{Dimension} \PYG{n+no}{[DIM]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{Vertices}
\PYG{n+no}{[Number of vertices]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n}{X\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{Y\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Z\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{X\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{Y\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Z\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}nv}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{Edges}
\PYG{n+no}{[Number of edges]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n}{Vertex1\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Vertex1\PYGZus{}ne}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}ne}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}ne}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{Triangles}
\PYG{n+no}{[Number of triangles]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n}{Vertex1\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Vertex1\PYGZus{}nt}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}nt}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}nt}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}nt}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{Quadrilaterals}
\PYG{n+no}{[Number of Quadrilaterals]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n}{Vertex1\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex4\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Vertex1\PYGZus{}nq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}nq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}nq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex4\PYGZus{}nq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}nq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{Geometry}
\PYG{n+no}{[File name of geometric support]}\PYG{p}{(}\PYG{n}{char}\PYG{p}{*}\PYG{p}{)}

   \PYG{n}{VertexOnGeometricVertex}
   \PYG{n+no}{[Number of vertex on geometric vertex]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{VertexGeometry\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvg}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{VertexGeometry\PYGZus{}nvg}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

   \PYG{n}{EdgeOnGeometricEdge}
   \PYG{n+no}{[Number of geometric edge]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{n}{Edge\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{EdgeGeometry\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Edge\PYGZus{}neg}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{EdgeGeometry\PYGZus{}neg}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{CrackedEdges}
\PYG{n+no}{[Number of cracked edges]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n}{Edge1\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Edge2\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Edge1\PYGZus{}nce}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Edge2\PYGZus{}nce}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\end{sphinxVerbatim}

When the current mesh refers to a previous mesh, we have in addition

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{MeshSupportOfVertices}
\PYG{n+no}{[File name of mesh support]}\PYG{p}{(}\PYG{n}{char}\PYG{p}{*}\PYG{p}{)}

   \PYG{n}{VertexOnSupportVertex}
   \PYG{n+no}{[Number of vertex on support vertex]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{VertexSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvsv}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{VertexSupport\PYGZus{}nvsv}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

   \PYG{n}{VertexOnSupportEdge}
   \PYG{n+no}{[Number of vertex on support edge]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{EdgeSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvse}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{EdgeSupport\PYGZus{}nvse}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}nvse}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}

   \PYG{n}{VertexOnSupportTriangle}
   \PYG{n+no}{[Number of vertex on support triangle]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvst}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}nvst}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}nvst}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}nvst}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}

   \PYG{n}{VertexOnSupportQuadrilaterals}
   \PYG{n+no}{[Number of vertex on support quadrilaterals]}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvsq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}nvsq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}nvsq}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}nvsq}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nv}} means the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{ne}} means the number of edges

\item {} 
\sphinxcode{\sphinxupquote{nt}} means the number of triangles

\item {} 
\sphinxcode{\sphinxupquote{nq}} means the number of quadrilaterals

\item {} 
\sphinxcode{\sphinxupquote{nvg}} means the number of vertex on geometric vertex

\item {} 
\sphinxcode{\sphinxupquote{neg}} means the number of edges on geometric edge

\item {} 
\sphinxcode{\sphinxupquote{nce}} means the number of cracked edges

\end{itemize}


\subsubsection{bb file type to Store Solutions}
\label{\detokenize{documentation/developers:bb-file-type-to-store-solutions}}
The file is formatted such that:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{2} \PYG{n+no}{[Number of solutions]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n+no}{[Number of vertices]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{2}

\PYG{n}{U\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}ns\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}ns\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ns}} means the number of solutions

\item {} 
\sphinxcode{\sphinxupquote{nv}} means the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{U\_i\_j}} is the solution component \sphinxcode{\sphinxupquote{i}} at the vertex \sphinxcode{\sphinxupquote{j}} on the associated mesh.

\end{itemize}


\subsubsection{BB file type to store solutions}
\label{\detokenize{documentation/developers:id1}}
The file is formatted such that:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{2} \PYG{n+no}{[Number of solutions]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n+no}{[Type 1]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n+no}{[Type ns]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n+no}{[Number of vertices]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{2}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}nbv\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}ns}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}1\PYGZus{}ns}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}nbv\PYGZus{}ns}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}nbv\PYGZus{}ns}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ns}} means the number of solutions

\item {} 
\sphinxcode{\sphinxupquote{type\_k}} mean the type of solution \sphinxcode{\sphinxupquote{k}}:
\begin{itemize}
\item {} 
1: the solution is scalar (1 value per vertex)

\item {} 
2: the solution is vectorial (2 values per vertex)

\item {} 
3: the solution is a \(2\times 2\) symmetric matrix (3 values per vertex)

\item {} 
4: the solution is a \(2\times 2\) matrix (4 values per vertex)

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nbv}} means the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{U\_i\_j\_k}} is the value of the component \sphinxcode{\sphinxupquote{i}} of the solution
\sphinxcode{\sphinxupquote{k}} at vertex \sphinxcode{\sphinxupquote{j}} on the associated mesh

\end{itemize}


\subsubsection{Metric file}
\label{\detokenize{documentation/developers:metric-file}}
A metric file can be of two types, isotropic or anisotropic.

The isotropic file is such that

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+no}{[Number of vertices]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{1}
\PYG{n}{h\PYGZus{}0}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{h\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nv}} is the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{h\_i}} is the wanted mesh size near the vertex \sphinxcode{\sphinxupquote{i}} on associated mesh.

\end{itemize}

The metric is \(\mathcal{M}_i = h_i^{-2}I\) where \(I\) is the identity matrix.

The anisotropic file is such that

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+no}{[Number of vertices]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{3}
\PYG{n}{a11\PYGZus{}0}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{a21\PYGZus{}0}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{a22\PYGZus{}0}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{a11\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{a21\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{a22\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nv}} is the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{a11\_i}}, \sphinxcode{\sphinxupquote{a21\_i}} and \sphinxcode{\sphinxupquote{a22\_i}} represent metric \(\mathcal{M}_i = \left(\begin{array}{cc}a_{11,i} & a_{12,i}\\a{12}_i & a_{22,i}\end{array}\right)\) which define the wanted size in a vicinity of the vertex \sphinxcode{\sphinxupquote{i}} such that \(h\) in direction \(u \in \mathbb{R}^2\) is equal to \(|u|/\sqrt{u\cdot\mathcal{M}_i\, u}\), where \(\cdot\) is the dot product in \(\mathbb{R}^2\), and \(|\cdot|\) is the classical norm.

\end{itemize}


\subsubsection{List of AM\_FMT, AMDBA Meshes}
\label{\detokenize{documentation/developers:list-of-am-fmt-amdba-meshes}}
The mesh is only composed of triangles and can be defined with the help of the following two integers and four arrays:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nbt}} the number of triangles

\item {} 
\sphinxcode{\sphinxupquote{nbv}} the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{nu(1:3, 1:nbt)}} an integer array giving the three vertex numbers counterclockwise for each triangle

\item {} 
\sphinxcode{\sphinxupquote{c(1:2, 1:nbv)}} a real array giving tje two coordinates of each vertex

\item {} 
\sphinxcode{\sphinxupquote{refs(1:nbv)}} an integer array giving the reference numbers of the vertices

\item {} 
\sphinxcode{\sphinxupquote{reft(1:nbt)}} an integer array giving the reference numbers of the triangles

\end{itemize}

\sphinxstylestrong{AM\_FMT Files}

In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{am\_fmt}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.am\PYGZus{}fmt\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(} \PYG{n}{reft}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(} \PYG{n}{refs}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{AM Files}

In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{am}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.am\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}unformatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZam{}} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZam{}} \PYG{p}{(}\PYG{n}{reft}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZam{}} \PYG{p}{(}\PYG{n}{refs}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{AMDBA Files}

In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{amdba}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.amdba\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{refs}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{reft}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{msh Files}

First, we add the notions of boundary edges
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nbbe}} the number of boundary edge

\item {} 
\sphinxcode{\sphinxupquote{nube(1:2, 1:nbbe)}} an integer array giving the two vertex numbers of boundary edges

\item {} 
\sphinxcode{\sphinxupquote{refbe(1:nbbe)}} an integer array giving the reference numbers of boundary edges

\end{itemize}

In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{msh}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.msh\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{,} \PYG{n}{nbbe}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{refs}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{reft}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{ne}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{refbe}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbbe}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{ftq Files}

In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{ftq}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.ftq\PYGZsq{}}\PYG{p}{,}\PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,}\PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,}\PYG{n}{nbe}\PYG{p}{,}\PYG{n}{nbt}\PYG{p}{,}\PYG{n}{nbq}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{n}{k}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{k}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{reft}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nbe}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{refs}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,}\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

where if \sphinxcode{\sphinxupquote{k(j) = 3}} when the element \sphinxcode{\sphinxupquote{j}} is a triangle and \sphinxcode{\sphinxupquote{k(j) = 4}} when the the element \sphinxcode{\sphinxupquote{j}} is a quadrilateral.


\subsubsection{sol and solb files}
\label{\detokenize{documentation/developers:sol-and-solb-files}}
With the keyword \sphinxcode{\sphinxupquote{savesol}}, we can store a scalar functions, a scalar finite element functions, a vector fields, a vector finite element fields, a symmetric tensor and a symmetric finite element tensor.

Such format is used in \sphinxcode{\sphinxupquote{medit}}.

\sphinxstylestrong{Extension file .sol}

The first two lines of the file are :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MeshVersionFormatted 0}}

\item {} 
\sphinxcode{\sphinxupquote{Dimension {[}DIM{]}(int)}}

\end{itemize}

The following fields begin with one of the following keyword:
\sphinxcode{\sphinxupquote{SolAtVertices}}, \sphinxcode{\sphinxupquote{SolAtEdges}},
\sphinxcode{\sphinxupquote{SolAtTriangles}}, \sphinxcode{\sphinxupquote{SolAtQuadrilaterals}},
\sphinxcode{\sphinxupquote{SolAtTetrahedra}}, \sphinxcode{\sphinxupquote{SolAtPentahedra}},
\sphinxcode{\sphinxupquote{SolAtHexahedra}}.

In each field, we give then in the next line the number of elements in the solutions (\sphinxcode{\sphinxupquote{SolAtVertices}}: number of vertices, \sphinxcode{\sphinxupquote{SolAtTriangles}}: number of triangles, …).
In other lines, we give the number of solutions, the type of solution (1: scalar, 2: vector, 3: symmetric tensor).
And finally, we give the values of the solutions on the elements.

The file must be ended with the keyword End.

The real element of symmetric tensor :
\begin{equation}\label{equation:documentation/developers:savesol.def.symtensor}
\begin{split}ST^{3d}=\left(
\begin{array}{ccc}
   ST_{xx}^{3d} & ST_{xy}^{3d} & ST_{xz}^{3d}\\
   ST_{yx}^{3d} & ST_{yy}^{3d} & ST_{yz}^{3d} \\
   ST_{zx}^{3d} & ST_{zy}^{3d} & ST_{zz}^{3d}
\end{array}
\right)
\quad
ST^{2d}= \left(
\begin{array}{cc}
   ST_{xx}^{2d} & ST_{xy}^{2d} \\
   ST_{yx}^{2d} & ST_{yy}^{2d}
\end{array}
\right)\end{split}
\end{equation}
stored in the extension \sphinxcode{\sphinxupquote{.sol}} are respectively \(ST_{xx}^{3d}, ST_{yx}^{3d}, ST_{yy}^{3d}, ST_{zx}^{3d}, ST_{zy}^{3d}, ST_{zz}^{3d}\) and \(ST_{xx}^{2d}, ST_{yx}^{2d}, ST_{yy}^{2d}\)

An example of field with the keyword \sphinxcode{\sphinxupquote{SolAtTetrahedra}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{SolAtTetrahedra}
\PYG{n+no}{[Number of tetrahedra]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n+no}{[Number of solutions]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n+no}{[Type of solution 1]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n+no}{[Type of soution nt]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}nrs\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}ns\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{nrs\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}ns\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}nt}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}nrs\PYGZus{}1\PYGZus{}nt}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}ns\PYGZus{}nt}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{nrs\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}ns\PYGZus{}nt}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ns}} is the number of solutions

\item {} 
\sphinxcode{\sphinxupquote{typesol\_k}}, type of the solution number \sphinxcode{\sphinxupquote{k}}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{typesol\_k = 1}} the solution \sphinxcode{\sphinxupquote{k}} is scalar

\item {} 
\sphinxcode{\sphinxupquote{typesol\_k = 2}} the solution \sphinxcode{\sphinxupquote{k}} is vectorial

\item {} 
\sphinxcode{\sphinxupquote{typesol\_k = 3}} the solution \sphinxcode{\sphinxupquote{k}} is a symmetric tensor or symmetric matrix

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nrs\_k}} is the number of real to describe solution \sphinxcode{\sphinxupquote{k}}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nrs\_k = 1}} if the solution \sphinxcode{\sphinxupquote{k}} is scalar

\item {} 
\sphinxcode{\sphinxupquote{nrs\_k = dim}} if the solution \sphinxcode{\sphinxupquote{k}} is vectorial (\sphinxcode{\sphinxupquote{dim}} is the dimension of the solution)

\item {} 
\sphinxcode{\sphinxupquote{nrs\_k = dim*(dim+1)/2}} if the solution k is a symmetric tensor or symmetric matrix

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{U\_i\_j\_\textasciicircum{}k}} is a real equal to the value of the component \sphinxcode{\sphinxupquote{i}} of the solution \sphinxcode{\sphinxupquote{k}} at tetrahedron \sphinxcode{\sphinxupquote{j}} on the associated mesh

\end{itemize}

The format \sphinxcode{\sphinxupquote{.solb}} is the same as format \sphinxcode{\sphinxupquote{.sol}} but in binary (read/write is faster, storage is less).

A real scalar functions \(f1\), a vector fields \(\mathbf{\Phi} = [\Phi1, \Phi2, \Phi3]\) and a symmetric tensor \(ST^{3d}\) \eqref{equation:documentation/developers:savesol.def.symtensor} at the vertices of the three dimensional mesh \sphinxcode{\sphinxupquote{Th3}} is stored in the file \sphinxcode{\sphinxupquote{f1PhiTh3.sol}} using :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savesol}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f1PhiST3dTh3.sol}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{VV3}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \(VV3 = [ST_{xx}^{3d}, ST_{yx}^{3d}, ST_{yy}^{3d}, ST_{zx}^{3d}, ST_{zy}^{3d}, ST_{zz}^{3d}]\).

For a two dimensional mesh \sphinxcode{\sphinxupquote{Th}}, A real scalar functions \(f2\), a vector fields \(\mathbf{\Psi} = [\Psi1, \Psi2]\) and a symmetric tensor \(ST^{2d}\) \eqref{equation:documentation/developers:savesol.def.symtensor} at triangles is stored in the file \sphinxcode{\sphinxupquote{f2PsiST2dTh3.solb}} using :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savesol}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f2PsiST2dTh3.solb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Psi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Psi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{VV2}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \(VV2 = [ST_{xx}^{2d}, ST_{yx}^{2d}, ST_{yy}^{2d}]\)

The arguments of \sphinxcode{\sphinxupquote{savesol}} functions are the name of a file, a mesh and solutions.
These arguments must be given in this order.

The parameters of this keyword are :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{order =}} 0 is the solution is given at the center of gravity of elements.
1 is the solution is given at the vertices of elements.

\end{itemize}

In the file, solutions are stored in this order : scalar solutions, vector solutions and finally symmetric tensor solutions.


\subsection{Adding a new finite element}
\label{\detokenize{documentation/developers:adding-a-new-finite-element}}\label{\detokenize{documentation/developers:developersaddingfiniteelement}}

\subsubsection{Some notations}
\label{\detokenize{documentation/developers:some-notations}}
For a function \(\boldsymbol{f}\) taking value in \(\mathbb{R}^{N},\, N=1,2,\cdots\), we define the finite element approximation \(\Pi_h\boldsymbol{f}\) of \(\boldsymbol{f}\).

Let us denote the number of the degrees of freedom of the finite element by \(NbDoF\).
Then the \(i\)-th base \(\boldsymbol{\omega}^{K}_{i}\) (\(i=0,\cdots,NbDoF-1\)) of the finite element space has the \(j\)-th component \(\mathbf{\omega}^{K}_{ij}\) for \(j=0,\cdots,N-1\).

The operator \(\Pi_{h}\) is called the interpolator of the finite element.

We have the identity \(\boldsymbol{\omega}^{K}_{i} = \Pi_{h} \boldsymbol{\omega}^{K}_{i}\).

Formally, the interpolator \(\Pi_{h}\) is constructed by the following formula:
\begin{equation}\label{equation:documentation/developers:eq-interpo}
\begin{split}\Pi_{h} \boldsymbol{f} = \sum_{k=0}^{\mathtt{kPi}-1} \alpha_k \boldsymbol{f}_{j_{k}}(P_{p_{k}}) \boldsymbol{\omega}^{K}_{i_{k}}\end{split}
\end{equation}
where \(P_{p}\) is a set of \(npPi\) points,

In the formula \eqref{equation:documentation/developers:eq-interpo}, the list \(p_{k},\, j_{k},\, i_{k}\) depend just on the type of finite element (not on the element), but the coefficient \(\alpha_{k}\) can be depending on the element.

\begin{sphinxadmonition}{tip}{Tip:}
Classical scalar Lagrange finite element

With the classical scalar Lagrange finite element, we have \(\mathtt{kPi}=\mathtt{npPi}=\mathtt{NbOfNode}\) and
\begin{itemize}
\item {} 
\(P_{p}\) is the point of the nodal points.

\item {} 
the \(\alpha_k=1\), because we take the value of the function at the point \(P_{k}\).

\item {} 
\(p_{k}=k\) , \(j_{k}=k\) because we have one node per function.

\item {} 
\(j_{k}=0\) because \(N=1\).

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
The Raviart-Thomas finite element
\begin{equation}\label{equation:documentation/developers:eq:RT0-fe}
\begin{split}RT0_{h} = \{ \mathbf{v} \in H(div) / \forall K \in
\mathcal{T}_{h} \quad \mathbf{v}_{|K}(x,y) =
\vecttwo{\alpha_{K}}{\beta_{K}} + \gamma_{K}\vecttwo{x}{y} \}\end{split}
\end{equation}
The degrees of freedom are the flux through an edge \(e\) of the mesh, where the flux of the function \(\mathbf{f} : \mathbb{R}^2 \longrightarrow \mathbb{R}^2\) is \(\int_{e} \mathbf{f}.n_{e}\), \(n_{e}\) is the unit normal of edge \(e\) (this implies a orientation of all the edges of the mesh, for example we can use the global numbering of the edge vertices and we just go to small to large number).

To compute this flux, we use a quadrature formula with one point, the middle point of the edge.
Consider a triangle \(T\) with three vertices \((\mathbf{a},\mathbf{b},\mathbf{c})\).

Let denote the vertices numbers by \(i_{a},i_{b},i_{c}\), and define the three edge vectors \(\mathbf{e}^{0},\mathbf{e}^{1},\mathbf{e}^{2}\) by \(sgn(i_{b}-i_{c})(\mathbf{b}-\mathbf{c})\), \(sgn(i_{c}-i_{a})(\mathbf{c}-\mathbf{a})\), \(sgn(i_{a}-i_{b})(\mathbf{a}-\mathbf{b})\).

The three basis functions are:
\begin{equation*}
\begin{split}\boldsymbol{\omega}^{K}_{0}= \frac{sgn(i_{b}-i_{c})}{2|T|}(x-a),\quad \boldsymbol{\omega}^{K}_{1}= \frac{sgn(i_{c}-i_{a})}{2|T|}(x-b),\quad \boldsymbol{\omega}^{K}_{2}= \frac{sgn(i_{a}-i_{b})}{2|T|}(x-c),\end{split}
\end{equation*}
where \(|T|\) is the area of the triangle \(T\).

So we have \(N=2\), \(\mathtt{kPi}=6; \mathtt{npPi}=3;\) and:
\begin{itemize}
\item {} 
\(P_{p} = \left\{\frac{\mathbf{b}+\mathbf{c}}{2}, \frac{\mathbf{a}+\mathbf{c}}{2}, \frac{\mathbf{b}+\mathbf{a}}{2} \right\}\)

\item {} \begin{description}
\item[{\(\alpha_{0}= - \mathbf{e}^{0}_{2}, \alpha_{1}= \mathbf{e}^{0}_{1}\),}] \leavevmode
\(\alpha_{2}= - \mathbf{e}^{1}_{2}, \alpha_{3}= \mathbf{e}^{1}_{1}\),
\(\alpha_{4}= - \mathbf{e}^{2}_{2}, \alpha_{5}= \mathbf{e}^{2}_{1}\) (effectively, the vector
\((-\mathbf{e}^{m}_{2}, \mathbf{e}^{m}_{1})\) is orthogonal to the edge \(\mathbf{e}^{m}= (e^m_{1},e^m_{2})\) with
a length equal to the side of the edge or equal to \(\int_{e^m} 1\)).

\end{description}

\item {} 
\(i_{k}=\{0,0,1,1,2,2\}\),

\item {} 
\(p_{k}=\{0,0,1,1,2,2\}\) , \(j_{k}=\{0,1,0,1,0,1,0,1\}\).

\end{itemize}
\end{sphinxadmonition}


\subsubsection{Which class to add?}
\label{\detokenize{documentation/developers:which-class-to-add}}
Add file \sphinxcode{\sphinxupquote{FE\_ADD.cpp}} in directory \sphinxcode{\sphinxupquote{FreeFem-sources/src/femlib}} for
example first to initialize :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{}include \PYGZdq{}error.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}rgraph.hpp\PYGZdq{}}
\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{c}{\PYGZsh{}include \PYGZdq{}RNM.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}fem.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}FESpace.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}AddNewFE.h\PYGZdq{}}

\PYG{n}{namespace} \PYG{n}{Fem2D} \PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Then add a class which derive for \sphinxcode{\sphinxupquote{public TypeOfFE}} like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
class TypeOfFE\PYGZus{}RTortho : public TypeOfFE \PYGZob{} public:
    static int Data[]; //some numbers
    TypeOfFE\PYGZus{}RTortho():
    TypeOfFE(
        0+3+0,  //nb degree of freedom on element
        2,      //dimension N of vectorial FE (1 if scalar FE)
        Data,   //the array data
        1,      //nb of subdivision for plotting
        1,      //nb of sub finite element (generaly 1)
        6,      //number kPi of coef to build the interpolator
        3,      //number npPi of integration point to build interpolator
        0       //an array to store the coef \PYGZbs{}alpha\PYGZus{}k to build interpolator
        //here this array is no constant so we have
        //to rebuilt for each element
    )
    \PYGZob{}
        const R2 Pt[] = \PYGZob{}R2(0.5, 0.5), R2(0.0, 0.5), R2(0.5, 0.0) \PYGZcb{};
        // the set of Point in hat\PYGZob{}K\PYGZcb{}
        for (int p = 0, kk = 0; p \PYGZlt{} 3; p++)\PYGZob{}
            P\PYGZus{}Pi\PYGZus{}h[p] = Pt[p];
            for (int j = 0; j \PYGZlt{} 2; j++)
                pij\PYGZus{}alpha[kk++] = IPJ(p, p, j);
        \PYGZcb{}
    \PYGZcb{} //definition of i\PYGZus{}k, p\PYGZus{}k, j\PYGZus{}k in interpolator

    void FB(const bool *watdd, const Mesh \PYGZam{}Th, const Triangle \PYGZam{}K,
        const R2 \PYGZam{}PHat, RNMK\PYGZus{} \PYGZam{}val) const;

    void Pi\PYGZus{}h\PYGZus{}alpha(const baseFElement \PYGZam{}K, KN\PYGZus{}\PYGZlt{}double\PYGZgt{} \PYGZam{}v) const;
\PYGZcb{} ;
\end{sphinxVerbatim}

where the array data is formed with the concatenation of five array of
size \sphinxcode{\sphinxupquote{NbDoF}} and one array of size \sphinxcode{\sphinxupquote{N}}.

This array is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
int TypeOfFE\PYGZus{}RTortho::Data[] = \PYGZob{}
    //for each df 0, 1, 3:
    3, 4, 5, //the support of the node of the df
    0, 0, 0, //the number of the df on the node
    0, 1, 2, //the node of the df
    0, 0, 0, //the df come from which FE (generally 0)
    0, 1, 2, //which are the df on sub FE
    0, 0
\PYGZcb{}; //for each component j=0, N\PYGZhy{}1 it give the sub FE associated
\end{sphinxVerbatim}

where the support is a number \(0,1,2\) for vertex support, \(3,4,5\) for edge support, and finally \(6\) for element support.

The function to defined the function
\(\boldsymbol{\omega}^{K}_{i}\), this function return the value of all the basics function or this derivatives in array \sphinxcode{\sphinxupquote{val}}, computed at point \sphinxcode{\sphinxupquote{Phat}} on the reference triangle corresponding to point \sphinxcode{\sphinxupquote{R2 P=K(Phat);}} on the current triangle \sphinxcode{\sphinxupquote{K}}.

The index \(i,j,k\) of the array \(val(i,j,k)\) correspond to:
\begin{itemize}
\item {} 
\(i\) is the basic function number on finite element
\(i \in [0,NoF[\)

\item {} 
\(j\) is the value of component \(j \in [0,N[\)

\item {} 
\(k\) is the type of computed value
\(f(P),dx(f)(P), dy(f)(P), ...\ i \in [0,\mathtt{last\_operatortype}[\).

\begin{sphinxadmonition}{note}{Note:}
For optimization, this value is computed only if \sphinxcode{\sphinxupquote{whatd{[}k{]}}} is true, and the numbering is defined with

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{enum} \PYG{n}{operatortype} \PYG{p}{\PYGZob{}}
\PYG{n}{op\PYGZus{}id} \PYG{p}{=} \PYG{n}{0}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dx} \PYG{p}{=} \PYG{n}{1}\PYG{p}{,} \PYG{n}{op\PYGZus{}dy} \PYG{p}{=} \PYG{n}{2}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dxx} \PYG{p}{=} \PYG{n}{3}\PYG{p}{,}\PYG{n}{op\PYGZus{}dyy} \PYG{p}{=} \PYG{n}{4}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dyx} \PYG{p}{=} \PYG{n}{5}\PYG{p}{,}\PYG{n}{op\PYGZus{}dxy} \PYG{p}{=} \PYG{n}{5}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dz} \PYG{p}{=} \PYG{n}{6}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dzz} \PYG{p}{=} \PYG{n}{7}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dzx} \PYG{p}{=} \PYG{n}{8}\PYG{p}{,} \PYG{n}{op\PYGZus{}dxz} \PYG{p}{=} \PYG{n}{8}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dzy} \PYG{p}{=} \PYG{n}{9}\PYG{p}{,} \PYG{n}{op\PYGZus{}dyz} \PYG{p}{=} \PYG{n}{9}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{int} \PYG{n}{last\PYGZus{}operatortype} \PYG{p}{=} \PYG{n}{10}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\end{itemize}

The shape function:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{void} \PYG{n}{TypeOfFE\PYGZus{}RTortho}\PYG{p}{::}\PYG{n}{FB}\PYG{p}{(}\PYG{n}{const} \PYG{n}{bool} \PYG{p}{*}\PYG{n}{whatd}\PYG{p}{,} \PYG{n}{const} \PYG{n}{Mesh} \PYG{p}{\PYGZam{}}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{const} \PYG{n}{Triangle} \PYG{p}{\PYGZam{}} \PYG{n}{K}\PYG{p}{,}
    \PYG{n}{const} \PYG{n}{R2} \PYG{p}{\PYGZam{}}\PYG{n}{PHat}\PYG{p}{,}\PYG{n}{RNMK\PYGZus{}} \PYG{p}{\PYGZam{}}\PYG{n}{val}\PYG{p}{)} \PYG{n}{const}
\PYG{p}{\PYGZob{}}
    \PYG{n}{R2} \PYG{n}{P}\PYG{p}{(}\PYG{n}{K}\PYG{p}{(}\PYG{n}{PHat}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{R2} \PYG{n}{A}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{n}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{B}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{n}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{C}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{n}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{l0} \PYG{p}{=} \PYG{n}{1} \PYG{p}{\PYGZhy{}} \PYG{n}{P}\PYG{p}{.}\PYG{n}{x}\PYG{n}{\PYGZhy{}P}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{l1} \PYG{p}{=} \PYG{n}{P}\PYG{p}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{l2} \PYG{p}{=} \PYG{n}{P}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;}
    \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{N}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZgt{}}\PYG{p}{=} \PYG{n}{3}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{M}\PYG{p}{(}\PYG{p}{)} \PYG{p}{=}\PYG{p}{=} \PYG{n}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{val} \PYG{p}{=} \PYG{n}{0}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{a} \PYG{p}{=} \PYG{n}{1}\PYG{p}{.}\PYG{p}{/}\PYG{p}{(}\PYG{n}{2}\PYG{p}{*}\PYG{n}{K}\PYG{p}{.}\PYG{n}{area}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{a0} \PYG{p}{=} \PYG{n}{K}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{n}{0}\PYG{p}{)} \PYG{p}{*} \PYG{n}{a}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{a1} \PYG{p}{=} \PYG{n}{K}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{n}{1}\PYG{p}{)} \PYG{p}{*} \PYG{n}{a}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{a2} \PYG{p}{=} \PYG{n}{K}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{n}{2}\PYG{p}{)} \PYG{p}{*} \PYG{n}{a}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{n+no}{[op\PYGZus{}id]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{p}{/}\PYG{p}{/}\PYG{n}{value} \PYG{n}{of} \PYG{n}{the} \PYG{k}{function}
        \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{K}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZgt{}} \PYG{n}{op\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{RN\PYGZus{}} \PYG{n}{f0}\PYG{p}{(}\PYG{n}{val}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}.\PYGZsq{}}\PYG{p}{,} \PYG{n}{0}\PYG{p}{,}\PYG{n}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{value} \PYG{n}{first} \PYG{n}{component}
        \PYG{n}{RN\PYGZus{}} \PYG{n}{f1}\PYG{p}{(}\PYG{n}{val}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}.\PYGZsq{}}\PYG{p}{,} \PYG{n}{1}\PYG{p}{,}\PYG{n}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{value} \PYG{n}{second} \PYG{n}{component}
        \PYG{n}{f1}\PYG{p}{[}\PYG{n}{0}\PYG{p}{]} \PYG{p}{=} \PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x} \PYG{p}{\PYGZhy{}} \PYG{n}{A}\PYG{p}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a0}\PYG{p}{;}
        \PYG{n}{f0}\PYG{p}{[}\PYG{n}{0}\PYG{p}{]} \PYG{p}{=} \PYG{p}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y} \PYG{p}{\PYGZhy{}} \PYG{n}{A}\PYG{p}{.}\PYG{n}{y}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a0}\PYG{p}{;}

        \PYG{n}{f1}\PYG{p}{[}\PYG{n}{1}\PYG{p}{]} \PYG{p}{=} \PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x} \PYG{p}{\PYGZhy{}} \PYG{n}{B}\PYG{p}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a1}\PYG{p}{;}
        \PYG{n}{f0}\PYG{p}{[}\PYG{n}{1}\PYG{p}{]} \PYG{p}{=} \PYG{p}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y} \PYG{p}{\PYGZhy{}} \PYG{n}{B}\PYG{p}{.}\PYG{n}{y}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a1}\PYG{p}{;}

        \PYG{n}{f1}\PYG{p}{[}\PYG{n}{2}\PYG{p}{]} \PYG{p}{=} \PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x} \PYG{p}{\PYGZhy{}} \PYG{n}{C}\PYG{p}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a2}\PYG{p}{;}
        \PYG{n}{f0}\PYG{p}{[}\PYG{n}{2}\PYG{p}{]} \PYG{p}{=} \PYG{p}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y} \PYG{p}{\PYGZhy{}} \PYG{n}{C}\PYG{p}{.}\PYG{n}{y}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{n+no}{[op\PYGZus{}dx]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{p}{/}\PYG{p}{/}\PYG{n}{value} \PYG{n}{of} \PYG{n}{the} \PYG{n}{dx} \PYG{n}{of} \PYG{k}{function}
        \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{K}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZgt{}} \PYG{n}{op\PYGZus{}dx}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{0}\PYG{p}{,}\PYG{n}{1}\PYG{p}{,}\PYG{n}{op\PYGZus{}dx}\PYG{p}{)} \PYG{p}{=} \PYG{n}{a0}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{1}\PYG{p}{,}\PYG{n}{1}\PYG{p}{,}\PYG{n}{op\PYGZus{}dx}\PYG{p}{)} \PYG{p}{=} \PYG{n}{a1}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{2}\PYG{p}{,}\PYG{n}{1}\PYG{p}{,}\PYG{n}{op\PYGZus{}dx}\PYG{p}{)} \PYG{p}{=} \PYG{n}{a2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{n+no}{[op\PYGZus{}dy]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{K}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZgt{}} \PYG{n}{op\PYGZus{}dy}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{0}\PYG{p}{,}\PYG{n}{0}\PYG{p}{,}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)} \PYG{p}{=} \PYG{n}{\PYGZhy{}a0}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{1}\PYG{p}{,}\PYG{n}{0}\PYG{p}{,}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)} \PYG{p}{=} \PYG{n}{\PYGZhy{}a1}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{2}\PYG{p}{,}\PYG{n}{0}\PYG{p}{,}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)} \PYG{p}{=} \PYG{n}{\PYGZhy{}a2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{for} \PYG{p}{(}\PYG{n}{int} \PYG{n}{i} \PYG{p}{=} \PYG{n}{op\PYGZus{}dy}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\PYGZlt{}} \PYG{n}{last\PYGZus{}operatortype}\PYG{p}{;} \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{n+no}{[op\PYGZus{}dx]}\PYG{p}{)}
            \PYG{n}{assert}\PYG{p}{(}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The function to defined the coefficient \(\alpha_{k}\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{void} \PYG{n}{TypeOfFE\PYGZus{}RT}\PYG{p}{::}\PYG{n}{Pi\PYGZus{}h\PYGZus{}alpha}\PYG{p}{(}\PYG{n}{const} \PYG{n}{baseFElement} \PYG{p}{\PYGZam{}}\PYG{n}{K}\PYG{p}{,} \PYG{n}{KN\PYGZus{}}\PYG{p}{\PYGZlt{}}\PYG{n}{double}\PYG{p}{\PYGZgt{}} \PYG{p}{\PYGZam{}}\PYG{n}{v}\PYG{p}{)} \PYG{n}{const}
\PYG{p}{\PYGZob{}}
    \PYG{n}{const} \PYG{n}{Triangle} \PYG{p}{\PYGZam{}}\PYG{n}{T}\PYG{p}{(}\PYG{n}{K}\PYG{p}{.}\PYG{n}{T}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{n}{int} \PYG{n}{i} \PYG{p}{=} \PYG{n}{0}\PYG{p}{,} \PYG{n}{k} \PYG{p}{=} \PYG{n}{0}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\PYGZlt{}} \PYG{n}{3}\PYG{p}{;} \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{R2} \PYG{n}{E}\PYG{p}{(}\PYG{n}{T}\PYG{p}{.}\PYG{n}{Edge}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nb}{R }\PYG{n}{signe} \PYG{p}{=} \PYG{n}{T}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{n}{k}\PYG{p}{+}\PYG{p}{+}\PYG{p}{]} \PYG{p}{=} \PYG{n}{signe}\PYG{p}{*}\PYG{n}{E}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{n}{k}\PYG{p}{+}\PYG{p}{+}\PYG{p}{]} \PYG{p}{=} \PYG{n}{\PYGZhy{}signe}\PYG{p}{*}\PYG{n}{E}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Now , we just need to add a new key work in \sphinxstylestrong{FreeFem++}.

Two way, with static or dynamic link so at the end of the file, we add:

\sphinxstylestrong{With dynamic link} it is very simple (see section {\hyperref[\detokenize{documentation/developers:developersdynamicallink}]{\sphinxcrossref{\DUrole{std,std-ref}{Dynamical link}}}}), just add before the end of \sphinxcode{\sphinxupquote{FEM2d namespace}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
   \PYG{n}{static} \PYG{n}{TypeOfFE\PYGZus{}RTortho} \PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{;}
   \PYG{n}{static} \PYG{n}{AddNewFE}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RT0Ortho}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{p}{/}\PYG{p}{/}\PYG{n}{FEM2d} \PYG{n}{namespace}
\end{sphinxVerbatim}

Try with \sphinxcode{\sphinxupquote{./load.link}} command in \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{examples++-load/} and see \sphinxcode{\sphinxupquote{BernardiRaugel.cpp}} or \sphinxcode{\sphinxupquote{Morley.cpp}} new finite element examples.

\sphinxstylestrong{Otherwise with static link} (for expert only), add

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{/}\PYG{p}{/}\PYG{n}{let} \PYG{n}{the} \PYG{n}{2} \PYG{n}{globals} \PYG{n}{variables}
\PYG{n}{static} \PYG{n}{TypeOfFE\PYGZus{}RTortho} \PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{;}
\PYG{p}{/}\PYG{p}{/}\PYG{n}{the} \PYG{n}{name} \PYG{k}{in} \PYG{n}{freefem}
\PYG{n}{static} \PYG{n}{ListOfTFE} \PYG{n}{typefemRTOrtho}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RT0Ortho}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{\PYGZam{}}\PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{/}\PYG{p}{/}\PYG{n}{link} \PYG{n}{with} \PYG{n}{FreeFem}\PYG{p}{+}\PYG{p}{+} \PYG{k}{do} \PYG{n}{not} \PYG{n}{work} \PYG{n}{with} \PYG{n}{static} \PYG{n}{library} \PYG{p}{.}\PYG{n}{a}
\PYG{p}{/}\PYG{p}{/}\PYG{n}{so} \PYG{n}{add} \PYG{n}{a} \PYG{n}{extern} \PYG{n}{name} \PYG{n}{to} \PYG{n}{call} \PYG{k}{in} \PYG{n}{init\PYGZus{}static\PYGZus{}FE}
\PYG{p}{/}\PYG{p}{/}\PYG{p}{(}\PYG{n}{see} \PYG{k}{end} \PYG{n}{of} \PYG{n}{FESpace}\PYG{p}{.}\PYG{n}{cpp}\PYG{p}{)}
\PYG{n}{void} \PYG{n}{init\PYGZus{}FE\PYGZus{}ADD}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{p}{/}\PYG{p}{/}\PYG{k}{end}
\PYG{p}{\PYGZcb{}} \PYG{p}{/}\PYG{p}{/}\PYG{n}{FEM2d} \PYG{n}{namespace}
\end{sphinxVerbatim}

To inforce in loading of this new finite element, we have to add the two new lines close to the end of files \sphinxcode{\sphinxupquote{src/femlib/FESpace.cpp}} like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{/}\PYG{p}{/}\PYG{n}{correct} \PYG{n}{problem} \PYG{n}{of} \PYG{n}{static} \PYG{n}{library} \PYG{n}{link} \PYG{n}{with} \PYG{n}{new} \PYG{n}{make} \PYG{n}{file}
\PYG{n}{void} \PYG{n}{init\PYGZus{}static\PYGZus{}FE}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}} \PYG{p}{/}\PYG{p}{/}\PYG{n}{list} \PYG{n}{of} \PYG{n}{other} \PYG{n}{FE} \PYG{n}{file}\PYG{p}{.}\PYG{n}{o}
    \PYG{n}{extern} \PYG{n}{void} \PYG{n}{init\PYGZus{}FE\PYGZus{}P2h}\PYG{p}{(}\PYG{p}{)} \PYG{p}{;}
    \PYG{n}{init\PYGZus{}FE\PYGZus{}P2h}\PYG{p}{(}\PYG{p}{)} \PYG{p}{;}
    \PYG{n}{extern} \PYG{n}{void} \PYG{n}{init\PYGZus{}FE\PYGZus{}ADD}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{new} \PYG{n}{line} \PYG{n}{1}
    \PYG{n}{init\PYGZus{}FE\PYGZus{}ADD}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{new} \PYG{n}{line} \PYG{n}{2}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

and now you have to change the makefile.

First, create a file \sphinxcode{\sphinxupquote{FE\_ADD.cpp}} contening all this code, like in file \sphinxcode{\sphinxupquote{src/femlib/Element\_P2h.cpp}}, after modify the \sphinxcode{\sphinxupquote{Makefile.am}} by adding the name of your file to the variable \sphinxcode{\sphinxupquote{EXTRA\_DIST}} like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{} Makefile using Automake + Autoconf}
\PYG{c}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c}{\PYGZsh{} Id}

\PYG{c}{\PYGZsh{} This is not compiled as a separate library because its}
\PYG{c}{\PYGZsh{} interconnections with other libraries have not been solved.}

\PYG{n}{EXTRA\PYGZus{}DIST}\PYG{p}{=}\PYG{n}{BamgFreeFem}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{BamgFreeFem}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{CGNL}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{CheckPtr}\PYG{p}{.}\PYG{n+nb}{cpp }       \PYG{p}{\PYGZbs{}}
\PYG{n}{ConjuguedGradrientNL}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{DOperator}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{Drawing}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{Element\PYGZus{}P2h}\PYG{p}{.}\PYG{n+nb}{cpp }     \PYG{p}{\PYGZbs{}}
\PYG{n}{Element\PYGZus{}P3}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{Element\PYGZus{}RT}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{fem3}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{fem}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{fem}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{FESpace}\PYG{p}{.}\PYG{n+nb}{cpp }     \PYG{p}{\PYGZbs{}}
\PYG{n}{FESpace}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{FESpace}\PYG{n}{\PYGZhy{}v0}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{FQuadTree}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{FQuadTree}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{gibbs}\PYG{p}{.}\PYG{n+nb}{cpp }       \PYG{p}{\PYGZbs{}}
\PYG{n}{glutdraw}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{gmres}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{MatriceCreuse}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{MatriceCreuse\PYGZus{}tpl}\PYG{p}{.}\PYG{n}{hpp}          \PYG{p}{\PYGZbs{}}
\PYG{n}{MeshPoint}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{mortar}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{mshptg}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{QuadratureFormular}\PYG{p}{.}\PYG{n+nb}{cpp }             \PYG{p}{\PYGZbs{}}
\PYG{n}{QuadratureFormular}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RefCounter}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RNM}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RNM\PYGZus{}opc}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RNM\PYGZus{}op}\PYG{p}{.}\PYG{n}{hpp}    \PYG{p}{\PYGZbs{}}
\PYG{n}{RNM\PYGZus{}tpl}\PYG{p}{.}\PYG{n}{hpp}     \PYG{n}{FE\PYGZus{}ADD}\PYG{p}{.}\PYG{n+nb}{cpp}
\end{sphinxVerbatim}

and do in the \sphinxstylestrong{FreeFem++} root directory

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
autoreconf
./reconfigure
make
\end{sphinxVerbatim}

For codewarrior compilation add the file in the project an remove the flag in panal PPC linker FreeFm++ Setting Dead-strip Static Initializition Code Flag.


\subsection{Dynamical link}
\label{\detokenize{documentation/developers:dynamical-link}}\label{\detokenize{documentation/developers:developersdynamicallink}}
Now, it’s possible to add built-in functionnalites in \sphinxstylestrong{FreeFem++} under the three environnents Linux, Windows and MacOS X 10.3 or newer.

It is agood idea to first try the example \sphinxcode{\sphinxupquote{load.edp}} in directory \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{example++-load}.

You will need to install a \sphinxcode{\sphinxupquote{compiler}} (generally \sphinxcode{\sphinxupquote{g++/gcc}} compiler) to compile your function.
\begin{itemize}
\item {} 
Windows Install the \sphinxcode{\sphinxupquote{cygwin}} environnent or the \sphinxcode{\sphinxupquote{mingw}} one

\item {} 
MacOs Install the developer tools \sphinxcode{\sphinxupquote{Xcode}} on the apple DVD

\item {} 
Linux/Unix Install the correct compiler (\sphinxcode{\sphinxupquote{gcc}} for instance)

\end{itemize}

Now, assume that you are in a shell window (a \sphinxcode{\sphinxupquote{cygwin}} window under Windows) in the directory \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{example++-load}.

\begin{sphinxadmonition}{note}{Note:}
In the sub directory \sphinxcode{\sphinxupquote{include}}, they are all the \sphinxstylestrong{FreeFem++} include file to make the link with \sphinxstylestrong{FreeFem++}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
If you try to load dynamically a file with command \sphinxcode{\sphinxupquote{load "xxx"}}
- Under Unix (Linux or MacOs), the file \sphinxcode{\sphinxupquote{xxx.so}} will be loaded so it must be either in the search directory of routine \sphinxcode{\sphinxupquote{dlopen}} (see the environment variable \sphinxtitleref{\$LD\_LIBRARY\_PATH}) or in the current directory, and the suffix \sphinxcode{\sphinxupquote{".so"}} or the prefix \sphinxcode{\sphinxupquote{"./"}} is automatically added.
\begin{itemize}
\item {} 
Under Windows, the file \sphinxtitleref{xxx.dll} will be loaded so it must be in the \sphinxtitleref{loadLibary} search directory which includes the directory of the application,

\end{itemize}
\end{sphinxadmonition}

\sphinxstylestrong{Compilation of your module:}

The script \sphinxcode{\sphinxupquote{ff-c++}} compiles and makes the link with \sphinxstylestrong{FreeFem++}, but be careful, the script has no way to known if you try to compile for a pure Windows environment or for a cygwin environment so to build the load module under cygwin you must add the \sphinxcode{\sphinxupquote{-cygwin}} parameter.


\subsubsection{A first example myfunction.cpp}
\label{\detokenize{documentation/developers:a-first-example-myfunction-cpp}}
The following defines a new function call \sphinxcode{\sphinxupquote{myfunction}} with no parameter, but using the \(x,y\) current value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{}include \PYGZlt{}iostream\PYGZgt{}}
\PYG{c}{\PYGZsh{}include \PYGZlt{}cfloat\PYGZgt{}}
\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{c}{\PYGZsh{}include \PYGZdq{}error.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}AFunction.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}rgraph.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}RNM.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}fem.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}FESpace.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}MeshPoint.hpp\PYGZdq{}}

\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{Fem2D}\PYG{p}{;}
\PYG{n}{double} \PYG{n}{myfunction}\PYG{p}{(}\PYG{n}{Stack} \PYG{n}{stack}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{/}\PYG{p}{/}\PYG{n}{to} \PYG{n}{get} \PYG{n}{FreeFem}\PYG{p}{+}\PYG{p}{+} \PYG{n}{data}
    \PYG{n}{MeshPoint} \PYG{p}{\PYGZam{}}\PYG{n+nb}{mp }\PYG{p}{=} \PYG{p}{*}\PYG{n}{MeshPointStack}\PYG{p}{(}\PYG{n}{stack}\PYG{p}{)}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{the} \PYG{n}{struct} \PYG{n}{to} \PYG{n}{get} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{normal}\PYG{p}{,} \PYG{n}{value}
    \PYG{n}{double} \PYG{n}{x} \PYG{p}{=} \PYG{n}{mp}\PYG{p}{.}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{get} \PYG{n}{the} \PYG{n}{current} \PYG{n}{x} \PYG{n}{value}
    \PYG{n}{double} \PYG{n}{y} \PYG{p}{=} \PYG{n}{mp}\PYG{p}{.}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{get} \PYG{n}{the} \PYG{n}{current} \PYG{n}{y} \PYG{n}{value}
    \PYG{p}{/}\PYG{p}{/}\PYG{n}{cout} \PYG{p}{\PYGZlt{}}\PYG{p}{\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x = }\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZlt{}}\PYG{p}{\PYGZlt{}} \PYG{n}{x} \PYG{p}{\PYGZlt{}}\PYG{p}{\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ y=}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZlt{}}\PYG{p}{\PYGZlt{}} \PYG{n}{y} \PYG{p}{\PYGZlt{}}\PYG{p}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{*}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Now the Problem is to build the link with \sphinxstylestrong{FreeFem++}, to do that we need two classes, one to call the function \sphinxcode{\sphinxupquote{myfunction}}.

All \sphinxstylestrong{FreeFem++} evaluable expression must be a \sphinxcode{\sphinxupquote{C++}} \sphinxcode{\sphinxupquote{struct}}/\sphinxcode{\sphinxupquote{class}} which derivate from \sphinxcode{\sphinxupquote{E\_F0}}.
By default this expression does not depend of the mesh position, but if they derivate from \sphinxcode{\sphinxupquote{E\_F0mps}} the expression depends of the mesh position, and for more details see \sphinxcite{reference:hecht2002}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
//A class build the link with FreeFem++
//generaly this class are already in AFunction.hpp
//but unfortunatly, I have no simple function with no parameter
//in FreeFem++ depending of the mesh
template\PYGZlt{}class R\PYGZgt{}
class OneOperator0s : public OneOperator \PYGZob{}
    //the class to define and evaluate a new function
    //It must devive from E\PYGZus{}F0 if it is mesh independent
    //or from E\PYGZus{}F0mps if it is mesh dependent
    class E\PYGZus{}F0\PYGZus{}F :public E\PYGZus{}F0mps \PYGZob{}
    public:
        typedef R (*func)(Stack stack);
        func f; //the pointeur to the fnction myfunction
        E\PYGZus{}F0\PYGZus{}F(func ff) : f(ff) \PYGZob{}\PYGZcb{}
        //the operator evaluation in FreeFem++
        AnyType operator()(Stack stack) const \PYGZob{}return SetAny\PYGZlt{}R\PYGZgt{}(f(stack));\PYGZcb{}
    \PYGZcb{};
    typedef R (*func)(Stack);
    func f;
    public:
        //the function which build the FreeFem++ byte code
        E\PYGZus{}F0 *code(const basicAC\PYGZus{}F0 \PYGZam{}) const \PYGZob{} return new E\PYGZus{}F0\PYGZus{}F(f); \PYGZcb{}
        //the constructor to say ff is a function without parameter
        //and returning a R
        OneOperator0s(func ff) : OneOperator(map\PYGZus{}type[typeid(R).name()]),f(ff)\PYGZob{}\PYGZcb{}
\PYGZcb{};
\end{sphinxVerbatim}

To finish we must add this new function in \sphinxstylestrong{FreeFem++} table, to do that include :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n}{void} \PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}
     \PYG{n}{Global}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myfunction}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{new} \PYG{n}{OneOperator0s}\PYG{p}{\PYGZlt{}}\PYG{n}{double}\PYG{p}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{myfunction}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
 \PYG{n}{LOADFUNC}\PYG{p}{(}\PYG{n}{init}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It will be called automatically at load module time.

To compile and link, use the \sphinxcode{\sphinxupquote{ff-c++}} script :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ff}\PYG{n}{\PYGZhy{}c}\PYG{p}{+}\PYG{p}{+} \PYG{n}{myfunction}\PYG{p}{.}\PYG{n+nb}{cpp}
\PYG{n}{g}\PYG{p}{+}\PYG{p}{+} \PYG{n}{\PYGZhy{}c} \PYG{n}{\PYGZhy{}g} \PYG{n}{\PYGZhy{}Iinclude} \PYG{n}{myfunction}\PYG{p}{.}\PYG{n+nb}{cpp}
\PYG{n}{g}\PYG{p}{+}\PYG{p}{+} \PYG{n}{\PYGZhy{}bundle} \PYG{n}{\PYGZhy{}undefined} \PYG{n}{dynamic\PYGZus{}lookup} \PYG{n}{\PYGZhy{}g} \PYG{n}{myfunction}\PYG{p}{.}\PYG{n}{o} \PYG{n}{\PYGZhy{}o} \PYG{p}{.}\PYG{p}{/}\PYG{n}{myfunction}\PYG{p}{.}\PYG{n}{dylib}
\end{sphinxVerbatim}

To try the simple example under Linux or MacOS, do \sphinxcode{\sphinxupquote{FreeFem++-nw load.edp}}

The output must be:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZhy{}\PYGZhy{} FreeFem++ v  *.****** \PYG{o}{(}date *** ** *** ****, **:**:** \PYG{o}{(}UTC+0*00\PYG{o}{)}\PYG{o}{)}
 Load: lg\PYGZus{}fem lg\PYGZus{}mesh lg\PYGZus{}mesh3 eigenvalue
    \PYG{l+m}{1} : // Example of dynamic \PYG{k}{function} load
    \PYG{l+m}{2} : // \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
    \PYG{l+m}{3} : // \PYG{n+nv}{\PYGZdl{}Id}\PYGZdl{}
    \PYG{l+m}{4} :
    \PYG{l+m}{5} :  load \PYG{l+s+s2}{\PYGZdq{}myfunction\PYGZdq{}}
    \PYG{l+m}{6} : // dumptable\PYG{o}{(}cout\PYG{o}{)}\PYG{p}{;}
    \PYG{l+m}{7} :  mesh \PYG{n+nv}{Th}\PYG{o}{=}square\PYG{o}{(}\PYG{l+m}{5},5\PYG{o}{)}\PYG{p}{;}
    \PYG{l+m}{8} :  fespace Vh\PYG{o}{(}Th,P1\PYG{o}{)}\PYG{p}{;}
    \PYG{l+m}{9} :  Vh \PYG{n+nv}{uh}\PYG{o}{=} myfunction\PYG{o}{(}\PYG{o}{)}\PYG{p}{;} // warning \PYG{k}{do} not forget \PYG{o}{(}\PYG{o}{)}
   \PYG{l+m}{10} :  cout \PYG{l+s}{\PYGZlt{}\PYGZlt{} uh[].min \PYGZlt{}\PYGZlt{} \PYGZdq{} \PYGZdq{} \PYGZlt{}\PYGZlt{} uh}\PYG{o}{[}\PYG{o}{]}.max \PYG{l+s}{\PYGZlt{}\PYGZlt{} endl;}
\PYG{l+s}{   11 :  cout \PYGZlt{}\PYGZlt{} \PYGZdq{} test io ( \PYGZdq{} \PYGZlt{}\PYGZlt{} endl}\PYG{p}{;}
   \PYG{l+m}{12} :  testio\PYG{o}{(}\PYG{o}{)}\PYG{p}{;}
   \PYG{l+m}{13} :  cout \PYGZlt{}\PYGZlt{} \PYG{l+s+s2}{\PYGZdq{} ) end test io .. \PYGZdq{}} \PYG{l+s}{\PYGZlt{}\PYGZlt{} endl; sizestack + 1024 =1416  ( 392 )}

\PYG{l+s}{  \PYGZhy{}\PYGZhy{} Square mesh : nb vertices  =36 ,  nb triangles = 50 ,  nb boundary edges 20}
\PYG{l+s}{0 0.841471}
\PYG{l+s}{ test io (}
\PYG{l+s}{ test cout 3.14159}
\PYG{l+s}{ test cout 512}
\PYG{l+s}{ test cerr 3.14159}
\PYG{l+s}{ test cerr 512}
\PYG{l+s}{ ) end} \PYG{n+nb}{test} io ..
times: compile \PYG{l+m}{0}.012854s, execution \PYG{l+m}{0}.000313s,  mpirank:0
 CodeAlloc : nb ptr  \PYG{l+m}{2715},  size :371104 mpirank: \PYG{l+m}{0}
Ok: Normal End
\end{sphinxVerbatim}

Under Windows, launch \sphinxstylestrong{FreeFem++} with the mouse (or ctrl O) on the example.


\subsubsection{Example: Discrete Fast Fourier Transform}
\label{\detokenize{documentation/developers:example-discrete-fast-fourier-transform}}
This will add FFT to \sphinxstylestrong{FreeFem++}, taken from \sphinxhref{http://www.fftw.org/}{FFTW}. To download and install under \sphinxcode{\sphinxupquote{download/include}} just go in \sphinxcode{\sphinxupquote{download/fftw}} and try \sphinxcode{\sphinxupquote{make}}.

The 1D dfft (fast discret fourier transform) for a simple array \(f\) of size \(n\) is defined by the following formula:
\begin{equation*}
\begin{split}\mathtt{dfft}(f,\varepsilon)_{k} = \sum_{j=0}^{n-1} f_i e^{\varepsilon 2\pi i kj/n}\end{split}
\end{equation*}
The 2D DFFT for an array of size \(N=n\times m\) is:
\begin{equation*}
\begin{split}\mathtt{dfft}(f,m,\varepsilon)_{k+nl} = \sum_{j'=0}^{m-1} \sum_{j=0}^{n-1} f_{i+nj} e^{\varepsilon 2\pi i (kj/n+lj'/m) }\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The value \(n\) is given by \(size(f)/m\), and the numbering is row-major order.
\end{sphinxadmonition}

So the classical discrete DFFT is \(\hat{f}=\mathtt{dfft}(f,-1)/\sqrt{n}\) and the reverse dFFT \(f=\mathtt{dfft}(\hat{f},1)/\sqrt{n}\)

\begin{sphinxadmonition}{note}{Note:}
The 2D Laplace operator is
\begin{quote}
\begin{equation*}
\begin{split}f(x,y) = 1/\sqrt{N} \sum_{j'=0}^{m-1} \sum_{j=0}^{n-1} \hat{f}_{i+nj} e^{\varepsilon 2\pi i (x j+ yj') }\end{split}
\end{equation*}
and we have
\begin{equation*}
\begin{split}f_{k+nl} = f(k/n,l/m)\end{split}
\end{equation*}
So
\begin{equation*}
\begin{split}\widehat{\Delta f_{kl}} = -( (2\pi)^2 ( (\tilde{k})^2+(\tilde{l})^2)) \widehat{ f_{kl}} \\\end{split}
\end{equation*}
where \(\tilde{k} = k\) if \(k \leq n/2\) else \(\tilde{k} = k-n\) and \(\tilde{l} = l\) if \(l \leq m/2\) else \(\tilde{l} = l-m\).
\end{quote}

And to have a real function we need all modes to be symmetric around zero, so \(n\) and \(m\) must be odd.
\end{sphinxadmonition}

\sphinxstylestrong{Compile to build a new library}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}c++ dfft.cpp ../download/install/lib/libfftw3.a \PYGZhy{}I../download/install/include
\PYG{n+nb}{export} \PYG{n+nv}{MACOSX\PYGZus{}DEPLOYMENT\PYGZus{}TARGET}\PYG{o}{=}\PYG{l+m}{10}.3
g++ \PYGZhy{}c \PYGZhy{}Iinclude \PYGZhy{}I../download/install/include dfft.cpp
g++ \PYGZhy{}bundle \PYGZhy{}undefined dynamic\PYGZus{}lookup dfft.o \PYGZhy{}o ./dfft.dylib ../download/install/lib/libfftw3.a
\end{sphinxVerbatim}

To test, try {\hyperref[\detokenize{example/developers:examplefft}]{\sphinxcrossref{\DUrole{std,std-ref}{FFT example}}}}.


\subsubsection{Load Module for Dervieux P0-P1 Finite Volume Method}
\label{\detokenize{documentation/developers:load-module-for-dervieux-p0-p1-finite-volume-method}}
The associed edp file is
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/convect\_dervieux.edp}{examples++-load/convect\_dervieux.edp}.

See
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/mat\_dervieux.cpp}{mat\_dervieux.cpp}.


\subsubsection{More on Adding a new finite element}
\label{\detokenize{documentation/developers:more-on-adding-a-new-finite-element}}
First read the {\hyperref[\detokenize{documentation/developers:developersaddingfiniteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Adding a new finite element section}}}}, we add two new finite elements examples in the directory \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{examples++-load}.


\paragraph{The Bernardi-Raugel Element}
\label{\detokenize{documentation/developers:the-bernardi-raugel-element}}
The Bernardi-Raugel finite element is meant to solve the Navier Stokes equations in \(u,p\) formulation; the velocity space \(P^{br}_K\) is minimal to prove the inf-sup condition with piecewise constant pressure by triangle.

The finite element space \(V_h\) is
\begin{equation*}
\begin{split}V_h= \{u\in H^1(\Omega)^2 ; \quad \forall K \in T_h, u_{|K} \in P^{br}_K \}\end{split}
\end{equation*}
where
\begin{equation*}
\begin{split}P^{br}_K = span \{ \lambda^K_i e_k \}_{i=1,2,3, k= 1,2} \cup \{ \lambda^K_i\lambda^K_{i+1} n^K_{i+2}\}_{i=1,2,3}\end{split}
\end{equation*}
with notation \(4=1, 5=2\) and where \(\lambda^K_i\) are the barycentric coordinates of the triangle \(K\), \((e_k)_{k=1,2}\) the canonical basis of \(\mathbb{R}^2\) and \(n^K_k\) the outer normal of triangle \(K\) opposite to vertex \(k\).

See
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/BernardiRaugel.cpp}{BernardiRaugel.cpp}.

A way to check the finite element

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BernardiRaugel}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Macro}
\PYG{c+c1}{//a macro the compute numerical derivative}
\PYG{k+kt}{macro} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{hx}\PYG{p}{,} \PYG{n}{hy}\PYG{p}{)} \PYG{p}{(} \PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{+}\PYG{n}{hx}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{o}{+}\PYG{n}{hy}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{hx}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n}{hy}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{n}{hx}\PYG{o}{+}\PYG{n}{hy}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{x1} \PYG{o}{=} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}7}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{it1} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{nuTriangle}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2BR}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{c1}\PYG{p}{,} \PYG{n}{c2}\PYG{p}{]}\PYG{p}{;}


\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndofK}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndofK}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{Vh}\PYG{p}{(}\PYG{n}{it1}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{[}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//do the interpolation}

    \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{b1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ a = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}9} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e\PYGZhy{}9}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//check if the interpolation is correct}

    \PYG{c+c1}{// check the derivative and numerical derivative}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ dx(a1)(x1, y1) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

A real example using this finite element, just a small modification of the Navier-Stokes P2-P1 example, just the begenning is change to

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BernardiRaugel}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{real} \PYG{n}{s0} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2BR}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{up1}\PYG{p}{,} \PYG{n}{up2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

And the plot instruction is also changed because the pressure is constant, and we cannot plot isovalues of peacewise constant functions.


\paragraph{The Morley Element}
\label{\detokenize{documentation/developers:the-morley-element}}
See the example
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/bilapMorley.edp}{bilapMorley.edp}.


\section{ffddm}
\label{\detokenize{documentation/ffddm/index:ffddm}}\label{\detokenize{documentation/ffddm/index::doc}}
In the acronym \sphinxcode{\sphinxupquote{ffddm}}, \sphinxcode{\sphinxupquote{ff}} stands for FreeFem++ and \sphinxcode{\sphinxupquote{ddm}} for domain decomposition methods.
The idea behind ffddm is to simplify the use of parallel solvers in FreeFem++: distributed direct methods and domain decomposition methods.

Parallelism is an important issue because, since about 2004, the clock speed of cores stagnates at 2-3 GHz.
The increase in performance is almost entirely due to the increase in the number of cores per processor.
All major processor vendors are producing multicore chips and now every machine is a parallel machine.
Waiting for the next generation machine does not guarantee anymore a better performance of a software.
To keep doubling performance parallelism must double.
It implies a huge effort in algorithmic development.

Thanks to \sphinxcode{\sphinxupquote{ffddm}}, FreeFem++ users have access to high-level functionalities for specifying and solving their finite element problems in parallel.
The first task handled by \sphinxcode{\sphinxupquote{ffddm}} is the data distribution among the processors.
This is done via an overlapping domain decomposition and a related distributed linear algebra.
Then, solving a linear system is possible either via an interface to the parallel \sphinxhref{http://mumps.enseeiht.fr/}{MUMPS} solver or by using domain decomposition methods as preconditioners to the GMRES Krylov method.
The \sphinxcode{\sphinxupquote{ffddm}} framework makes it easy to use scalable Schwarz methods enhanced by a coarse space correction built either from a coarse mesh or a \sphinxhref{https://link.springer.com/article/10.1007\%2Fs00211-013-0576-y}{GenEO} (Generalized Eigenvalue in the Overlap) coarse space, see also the book \sphinxhref{http://bookstore.siam.org/ot144/}{An Introduction to Domain Decomposition Methods: algorithms, theory, and parallel implementation}.
State-of-the-art three level methods are also implemented in \sphinxcode{\sphinxupquote{ffddm}}.

The \sphinxcode{\sphinxupquote{ffddm}} framework is entirely written in the FreeFem++ language and the ‘.idp’ scripts can be found \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples\%2B\%2B-ffddm}{here}.
It makes it also a very good tool for learning and prototyping domain decomposition methods without compromising efficiency.

\sphinxcode{\sphinxupquote{ffddm}} can also act as a wrapper for the \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM} library.
HPDDM is an efficient implementation of various domain decomposition methods and a variety of Krylov subspace algorithms, with advanced block and recycling methods for solving sequences of linear systems with multiple right-hand sides: GMRES and Block GMRES, CG, Block CG, and Breakdown-Free Block CG, GCRO-DR and Block GCRO-DR.
For more details on how to use HPDDM within \sphinxcode{\sphinxupquote{ffddm}}, see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}]{\sphinxcrossref{\DUrole{std,std-ref}{the ffddm documentation}}}}.

Getting Started

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{n}{Th} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{k+kr}{P} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{k+kr}{P} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{n}{PVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}
\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{c+c1}{// Step 5: Define the two\PYGZhy{}level GenEO Coarse Space}
\PYG{n}{ffddmgeneosetup}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{c+c1}{// Step 6: Solve the linear system with GMRES}
\PYG{n}{PVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{k+kr}{P}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{Pwritesummary}
\end{sphinxVerbatim}

This example solves a Laplace problem in 2D in parallel with a two-level GenEO domain decomposition method.
To try this example, just copy and paste the script above in a file ‘test.edp’ and run it on 2 cores with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ff}\PYG{o}{\PYGZhy{}}\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{2} \PYG{n}{test}\PYG{p}{.}\PYG{n}{edp} \PYG{o}{\PYGZhy{}}\PYG{n}{glut} \PYG{n}{ffglut}
\end{sphinxVerbatim}


\subsection{Domain Decomposition (DD)}
\label{\detokenize{documentation/ffddm/introddm:domain-decomposition-dd}}\label{\detokenize{documentation/ffddm/introddm:ffddmintroduction}}\label{\detokenize{documentation/ffddm/introddm::doc}}
When the size of a three dimensional problem is large (whatever it means), it is necessary to distribute data among several processors especially for solving linear systems.
A natural way is to do it via domain decomposition.


\subsubsection{Mesh Decomposition}
\label{\detokenize{documentation/ffddm/introddm:mesh-decomposition}}


The starting point is a collection of \(N\) sub-meshes \((Th_i)_{i=1}^N\) that together form a global mesh
\begin{equation*}
\begin{split}Th:= \cup_{i=1}^N Th_i\,.\end{split}
\end{equation*}
These meshes may be overlapping or not. This decomposition induces a natural decomposition of the global finite element space \(Vh\) on \(Th\) into \(N\) local finite element spaces \((Vh_i)_{i=1}^N\) each of them defined on \(Th_i\).

\sphinxstylestrong{Note} By global, we mean that the corresponding structure can be refered to in the code (most often only) by its local values.
In computer science term, it corresponds to a distributed data where each piece of data is stored by a MPI process.


\subsubsection{Distributed Linear Algebra}
\label{\detokenize{documentation/ffddm/introddm:distributed-linear-algebra}}
The domain decomposition induces a natural decomposition of the set of the global degrees of freedom (d.o.f.) \({\mathcal N}\) of the finite element space \(Vh\) into the \(N\) subsets of d.o.f.’s \(({\mathcal N}_i)_{i=1}^N\) each associated with the local finite element space \(Vh_i\).
We have thus
\begin{equation*}
\begin{split}{\mathcal N} = \cup_{i=1}^N {\mathcal N}_i\,,\end{split}
\end{equation*}
but with duplications of some of the d.o.f.’s.

Associated with this decomposition of the set of d.o.f.’s \({\mathcal N}\), a \sphinxstyleemphasis{distributed vector} is a collection of local vectors \(({\mathbf V_i})_{1\le i\le N}\) so that the values on the duplicated d.o.f.’s are the same.

\begin{sphinxadmonition}{note}{Note:}
In mathematical terms, it can be described as follows for a real valued problem.
Let \(R_i\) be the restriction operator from \(\R^{\#{\mathcal N}}\) to \(\R^{\#{\mathcal N}_i}\), where \(\#{\mathcal N}_i\) denotes the number of elements of \({\mathcal N}_i\).
A collection of local vectors \(({\mathbf V}_i)_{1\le i\le N}\in \Pi_{i=1}^N \R^{\#{\mathcal N}_i}\) is a distributed vector iff there exists a global vector \({\mathbf V}\in\R^{\#{\mathcal N}}\) such that for all subset \(1\le i\le N\), we have:
\begin{equation*}
\begin{split}{\mathbf V}_i = R_i\,{\mathbf V}\,.\end{split}
\end{equation*}
We will also say that the collection of local vectors \(({\mathbf V}_i)_{1\le i\le N}\) is consistent. For a complex valued problem, simply replace \(\R\) with \(\C\).
\end{sphinxadmonition}


\subsubsection{Partition of Unity Matrices (POUM)}
\label{\detokenize{documentation/ffddm/introddm:partition-of-unity-matrices-poum}}
Let \((D_i)_{1\le i \le N}\) be square diagonal matrices of size \(\#{\mathcal N}_i\) which form a partition of unity in the sense that:
\begin{equation*}
\begin{split}Id_{} = \sum_{i=1}^N R_i^T\,D_i\,R_i\text{ in }\R^{\#{\mathcal N}\times \#{\mathcal N}} \,.\end{split}
\end{equation*}
For instance if a degree of freedom is shared by \(k\) subdomains defining the corresponding entry of the diagonal matrix \(D\) to be \(1/k\) yields partition of unity matrices.
The matrices \(R_i\) and \(D_i\) are the heart of distributed linear algebra.


\paragraph{Distributed scalar product}
\label{\detokenize{documentation/ffddm/introddm:distributed-scalar-product}}
For two global vectors \({\mathbf U}\) and \({\mathbf V}\) of size \(\#{\mathcal N}\), the formula for the scalar product \({\mathbf V}^T\,{\mathbf U}=({\mathbf U},\,{\mathbf V})\) in terms of their distributed vector counterparts is:
\begin{equation*}
\begin{split}({\mathbf U}, {\mathbf V}) = \left({\mathbf U}, \sum_{i=1}^N R_i^T D_i R_i {\mathbf V}\right) = \sum_{i=1}^N(R_i {\mathbf U}, D_i R_i {\mathbf V})
=\sum_{i=1}^N\left({\mathbf U}_i, D_i {\mathbf V}_i\right)\,.\end{split}
\end{equation*}
Local scalar products are performed concurrently.
Thus, the implementation is parallel except for the sum which corresponds to a MPI\_Reduce call across the \(N\) MPI processes.
Note also that the implementation relies on the knowledge of a partition of unity so that the FreeFem++ syntax is \sphinxcode{\sphinxupquote{dscalprod(Di,u,v)}} or equivalently \sphinxcode{\sphinxupquote{pr\#scalprod(u,v)}} where \sphinxcode{\sphinxupquote{pr}} is a user defined prefix that refers to the domain decomposition and thus implicitely also to the partition of unity.


\paragraph{Update}
\label{\detokenize{documentation/ffddm/introddm:update}}\label{\detokenize{documentation/ffddm/introddm:ffddmdocumentationupdate}}
From a collection of local vectors \(({\mathbf U}_i)_{1\le i \le N}\), it is possible ensure consistency of the duplicated data and thus creating a distributed vector \(({\mathbf V}_i)_{1\le i \le N}\) by calling the function \sphinxcode{\sphinxupquote{pr\#update(Ui, TRUE)}} where \sphinxcode{\sphinxupquote{pr}} is a user defined prefix that refers to the domain decomposition.
This function performs the following operation for all \(1\le i \le N\):
\begin{equation*}
\begin{split}{\mathbf V}_i \leftarrow R_i\, \sum_{j=1}^N R_j^T D_j {\mathbf U}_j\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The implementation corresponds to
\begin{equation*}
\begin{split}{\mathbf V}_i := R_i \sum_{j=1}^N R_j^T D_j {\mathbf U}_j = D_i {\mathbf U}_i + \sum_{j\in \mathcal{O}(i)} R_i\,R_j^T\,D_j {\mathbf U}_j\end{split}
\end{equation*}
where \(\mathcal{O}(i)\) is the set of neighbors of subdomain \(i\).
Therefore, the matrix vector product is computed in three steps: - concurrent computing of \(D_j {\mathbf U}_j\) for all \(1\le j\le N\); - neighbor to neighbor MPI-communications (\(R_i\,R_j^T\)) ; - concurrent sum of neighbor contributions.
\end{sphinxadmonition}


\subsubsection{Distributed Matrix and Vector resulting from a variational formulation}
\label{\detokenize{documentation/ffddm/introddm:distributed-matrix-and-vector-resulting-from-a-variational-formulation}}
The discretization of a variational formulation on the global mesh \(Th\) yields a global matrix \(A\) and a global right hand side \(\mathbf{RHS}\).
Thanks to the sparsity of finite element matrices for partial differential equations and thanks to the overlap between subdomains, the knowledge of the local matrix \(R_i A R_i^T\) on each subdomain \(1\le i\le N\) is sufficient to perform the matrix-vector product \(A\times \mathbf{U}\) for any global vector \(\mathbf{U}\).
Once the problem has been set up by a call to \sphinxcode{\sphinxupquote{ffddmsetupOperator(myprefix, myFEprefix, myVarf)}}, the matrix-vector product is performed by calling the function \sphinxcode{\sphinxupquote{pr\#A(Ui)}} where \sphinxcode{\sphinxupquote{pr}} is a user defined prefix that refers to the problem at hand which itself implicitly refers to the triplet (domain decomposition, finite element, variational formulation).
See more on problem defintion in this {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}} and more on distributed linear algebra in chapter 8 of \sphinxhref{http://bookstore.siam.org/ot144/}{“An Introduction to Domain Decomposition Methods: algorithms, theory and parallel implementation” SIAM 2015}.


\subsubsection{Distributed Linear Solvers}
\label{\detokenize{documentation/ffddm/introddm:distributed-linear-solvers}}
In many cases, we are interested in the solution of the problem in terms of the vector of d.o.f.’s \(\mathbf{X}\) that satisfies:
\begin{equation*}
\begin{split}A\, \mathbf{X} = \mathbf{RHS}\,.\end{split}
\end{equation*}
\sphinxcode{\sphinxupquote{ffddm}} offers two parallel solvers: {\hyperref[\detokenize{documentation/ffddm/introddm:ffddmintroductiondisitributeddirectsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{direct factorization}}}} and {\hyperref[\detokenize{documentation/ffddm/introddm:ffddmintroductionschwarzmethods}]{\sphinxcrossref{\DUrole{std,std-ref}{Schwarz}}}} domain decomposition methods.


\paragraph{Distributed Direct Solvers}
\label{\detokenize{documentation/ffddm/introddm:distributed-direct-solvers}}\label{\detokenize{documentation/ffddm/introddm:ffddmintroductiondisitributeddirectsolvers}}
In order to benefit from the sparsity of the matrix arising from a finite element discretization of a partial differential equation, a variant of Gauss elimination, the frontal method, that automatically avoids a large number of operations involving zero terms was developed.
A frontal solver builds a \(LU\) or Cholesky decomposition of a sparse matrix given as the assembly of element matrices by eliminating equations only on a subset of elements at a time.
This subset is called the \sphinxstyleemphasis{front} and it is essentially the transition region between the part of the system already finished and the part not touched yet.
These methods are basically sequential since the unknowns are processed the one after another or one front after another.
In order to benefit from multicore processors, a \sphinxhref{https://en.wikipedia.org/wiki/Multifrontal\_method}{multifrontal solver} is an improvement of the frontal solver that uses several independent fronts at the same time.
The fronts can be worked on by different processors, which enables parallel computing. \sphinxcode{\sphinxupquote{ffddm}} provides an interface to the parallel sparse direct solver \sphinxhref{http://mumps.enseeiht.fr/}{MUMPS}.


\paragraph{Schwarz methods}
\label{\detokenize{documentation/ffddm/introddm:schwarz-methods}}\label{\detokenize{documentation/ffddm/introddm:ffddmintroductionschwarzmethods}}
We consider the solve of the equation \(A\, \mathbf{X} = \mathbf{RHS}\) by a flexible GMRES method preconditioned by domain decomposition methods.


\subparagraph{Restricted Additive Schwarz (RAS)}
\label{\detokenize{documentation/ffddm/introddm:restricted-additive-schwarz-ras}}
The RAS preconditioner reads:
\begin{equation*}
\begin{split}M^{-1}_{RAS} := \sum_{j=1}^N R_j^T D_j (R_j\, A\,R_j^T)^{-1} R_j\,.\end{split}
\end{equation*}
Let \(A_{i}\) denote the local matrix \((R_i\, A\,R_i^T)\).
The application of the operator \(M^{-1}_{RAS}\) to a distributed right hand side \((\mathbf{RHS}_i)_{i=1}^N\) consists in computing:
\begin{equation*}
\begin{split}R_i\, \sum_{j=1}^N R_j^T\,D_j\, A_{j}^{-1}\,\, \mathbf{ RHS}_j
= D_i\, A_{i}^{-1}\, \mathbf{ RHS}_i + \sum_{j\in \mathcal{O}(i)} (R_i\,R_j^T)\,D_j\, A_{j}^{-1}\, \mathbf{ RHS}_j\,.\end{split}
\end{equation*}
This task is performed by first solving concurrently on all subdomains a linear system for \({\mathbf Y}_j\) for all \(1\le j \le N\):
\begin{equation*}
\begin{split}A_{j}\, {\mathbf Y}_j = \mathbf{RHS}_j\,.\end{split}
\end{equation*}
Each local vector \({\mathbf Y}_j\) is weighted by the partition of unity matrix \(D_j\).
Then data transfers between neighboring subdomains implement the \(R_i\,R_j^T\,D_j\,{\mathbf Y}_j\) formula.
The contribution from neighboring subdomains are summed locally. This
pattern is very similar to that of the {\hyperref[\detokenize{documentation/ffddm/introddm:ffddmdocumentationupdate}]{\sphinxcrossref{\DUrole{std,std-ref}{update}}}} procedure.


\subparagraph{Optimized Restricted Additive Schwarz (ORAS)}
\label{\detokenize{documentation/ffddm/introddm:optimized-restricted-additive-schwarz-oras}}
The ORAS preconditioner may be seen as a variant of the RAS preconditioner.
It reads:
\begin{equation*}
\begin{split}M^{-1}_{RAS} := \sum_{j=1}^N R_j^T D_j\, B_j^{-1}\, R_j\,\end{split}
\end{equation*}
where \(B_j\) are local matrices of size \(\#{\mathcal N}_j \times \#{\mathcal N}_j\) for \(1\le j \le N\).
This variant is very useful when dealing with wave propagation phenomena such as Helmholtz problems in acoustics or Maxwell system in the frequency domain for electromagnetism.
Defining \(B_j\) as the discretization of the physical equation with impedance conditions on the boundary of the subdomain has been proved to be a good choice.


\subparagraph{Two level methods}
\label{\detokenize{documentation/ffddm/introddm:two-level-methods}}
The RAS and ORAS methods are called a one-level method in the sense that sub-domains only interact with their direct neighbors. For some problems such as Darcy problems or static elasticity problems and when the number of subdomains is large, such one-level methods may suffer from a slow convergence.
The fix is to add to the preconditioner an auxiliary coarse problem that couples all subdomains at each iteration and is inexpensive to calculate.

In mathematical terms, we first choose  a full rank rectangular matrix  \(Z\in\R^{\#{\mathcal N}\times NC}\) where \(NC \ll \#{\mathcal N}\) denotes the dimension of the coarse space spanned by the columns of \(Z\). We also pick a coarse matrix \(A_C\in \R^{N_C\times N_C}\). A generic one-level method preconditioner \(M_1^{-1}\) is enriched by a solve on the coarse space. The simplest correction formula is additive:
\begin{equation*}
\begin{split}M_2^{-1} := Z \,A_C^{-1}\,Z^T + M_1^{-1}\end{split}
\end{equation*}
Other correction formulas are given in {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}.

We consider two ways to build \(Z\) and thus the coarse space and the coarse problem \(A_C\), see below {\hyperref[\detokenize{documentation/ffddm/introddm:ffddmintroductioncoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{Coarse Mesh}}}} and {\hyperref[\detokenize{documentation/ffddm/introddm:ffddmintroductiongeneo}]{\sphinxcrossref{\DUrole{std,std-ref}{GenEO}}}}


\subparagraph{Coarse Mesh}
\label{\detokenize{documentation/ffddm/introddm:coarse-mesh}}\label{\detokenize{documentation/ffddm/introddm:ffddmintroductioncoarsemesh}}
A first possibility is to discretize the problem on a coarse mesh, following the same principle as multi-grid methods.
For 3-D problems, a coarsening of the mesh size by a factor 2, reduces by a factor \(2^3=8\) the size of the coarse problem which is then easier to solve by a direct method. Then, \(Z\) is the interpolation matrix from the coarse finite element space to the fine one.


\subparagraph{GenEO}
\label{\detokenize{documentation/ffddm/introddm:geneo}}\label{\detokenize{documentation/ffddm/introddm:ffddmintroductiongeneo}}
For highly heterogeneous or anisotropic problems, two level methods based on coarse meshes might fail and a more sophisticated construction must be used.
A provable robust coarse space called GenEO is built by first solving the following local generalized eigenvalue problem in parallel for each subdomain \(1\le i\le N\), where \(A_i^{\text{Neu}}\) denotes the local matrix resulting from the variational formulation:
\begin{equation*}
\begin{split}D_i A_i D_i\, V_{i,k} = \lambda_{i,k}\, A_i^{\text{Neu}} \,V_{i,k}\end{split}
\end{equation*}
The eigenvectors selected to enter the coarse space correspond to eigenvalues \(\lambda_{i,k} \ge \tau\), where the threshold parameter \(\tau\) is user-defined.
The precise formulas are given in this {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}.
From a mathematical point of view, it has been proved that for a symmetric positive definite matrix \(A\), the spectrum of the preconditioned by the two-level method with a GenEO coarse space lies in the interval \([\displaystyle \frac{1}{1+k_1\,\tau} , k_0 ]\).

\sphinxstylestrong{Note} A heuristic that justifies this construction is as follows.
We first introduce the Additive Schwarz method (ASM) which can be seen as a symmetrized variant of the RAS preconditioner:
\begin{equation*}
\begin{split}M_{ASM}^{-1} := \sum_{j=1}^N R_j^T A_j^{-1} R_j\,.\end{split}
\end{equation*}
It can be proved that the lower bound for the eigenvalue of \(M_{ASM}^{-1}\,A\) is close to zero (which is bad for convergence) whereas the upper bound depends only on the number of neigbors of a subdomain (which is good for convergence).

Second, we also introduce the following preconditioner \(M^{-1}_{NN}\):
\begin{equation*}
\begin{split}M^{-1}_{NN} := \sum_{1\le j\le N} D_i\,(A_j^{\text{Neu}})^{-1} D_j\,.\end{split}
\end{equation*}
We have a very good lower bound for the preconditioned operator \(M^{-1}_{NN}\,A\) that does not depend on the number of subdomains but only on the maximum multiplicity of intersections \(k_1\) (which is good for convergence).
But the upper bound for this preconditioner is very large (which is bad for convergence).

Now, if we compare formulas for \(M^{-1}_{NN}\) and \(M^{-1}_{ASM}\), we may suspect that vectors \(\mathbf{V}_{ik}\) for which \(D_i\, (A_i^{\text{Neu}})^{-1}\,D_i\,\mathbf{V}_{ik}\) and \(A_{i}^{-1}\,\mathbf{V}_{ik}\) have very different values are responsible for the slow convergence and should contribute to the coarse space.
This is a way to interpret the above generalized eigenvalue problem which controls the lower bound of the two-level preconditioned system.


\subsection{ffddm documentation}
\label{\detokenize{documentation/ffddm/documentation:ffddm-documentation}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentation}}\label{\detokenize{documentation/ffddm/documentation::doc}}

\subsubsection{Minimal example}
\label{\detokenize{documentation/ffddm/documentation:minimal-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{3}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{LL} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label} \PYG{o}{=} \PYG{n}{LL}\PYG{p}{)}\PYG{p}{;}      \PYG{c+c1}{// global mesh}

\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}\PYG{c+c1}{// EOM    // three\PYGZhy{}dimensional gradient}

\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// EOM}

\PYG{c+c1}{// Domain decomposition}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{Lap} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{n}{i}\PYG{c+c1}{// EOM                         // scalar field definition}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{n}{i}\PYG{c+c1}{// EOM                        // scalar field initialization}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{Lap} \PYG{p}{,} \PYG{n}{Lap} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P1} \PYG{p}{)}

\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{Lap} \PYG{p}{,}\PYG{n}{Lap} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhsi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{Lap} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{rhsi} \PYG{p}{)}

\PYG{n}{LapVhi} \PYG{n}{def}\PYG{p}{(}\PYG{n}{ui}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//Direct solve}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Lapdirectsolve}\PYG{p}{(}\PYG{n}{rhsi}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Lapwritesummary}

\PYG{n+nf}{ffddmplot}\PYG{p}{(}\PYG{n}{Lap}\PYG{p}{,}\PYG{n}{ui}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Overlapping mesh decomposition}
\label{\detokenize{documentation/ffddm/documentation:overlapping-mesh-decomposition}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{comm}\PYG{p}{)}
\end{sphinxVerbatim}

decomposes the mesh \sphinxstylestrong{Th} into overlapping submeshes.
The mesh will be distributed over the mpi ranks of communicator \sphinxstylestrong{comm}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below (\# is the concatenation operator).
The way the initial mesh \sphinxstylestrong{Th} is partitioned depends on the value of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpartitioner}}}}.

The size of the overlap between subdomains (its width in terms of number of mesh elements) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmoverlap}}}}.

The level of refinement of the resulting submeshes with respect to the input mesh \sphinxstylestrong{Th} is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsplit}}}}.

If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} \(\neq 0\), the first {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} mpi ranks of \sphinxstylestrong{comm} will be excluded from the spatial domain decomposition, in order to dedicate them later to the coarse problem (for two-level preconditioners).

The label of the new border of the submeshes (the interface between the subdomains) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddminterfacelabel}}}}.

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int pr\#npart}} number of subdomains for this decomposition; should be equal to mpiSize(\sphinxstylestrong{comm}) - {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} * {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}}

\item {} 
\sphinxcode{\sphinxupquote{meshN{[}int{]} pr\#aTh}} array (size \sphinxcode{\sphinxupquote{pr\#npart}}) of local meshes of the subdomains.
In the standard parallel case, only the local mesh for this mpi rank \sphinxcode{\sphinxupquote{pr\#aTh{[}mpiRank(pr\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i.e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1, see below).
In the sequential case, all local meshes are defined.

\item {} 
\sphinxcode{\sphinxupquote{meshN pr\#Thi}} the local mesh of the subdomain for this mpi rank, i. e. \sphinxcode{\sphinxupquote{pr\#aTh{[}mpiRank(pr\#commddm){]}}} in the parallel case -  \sphinxcode{\sphinxupquote{int pr\#numberIntersection}} the number of neighbors for this mpi rank

\item {} 
\sphinxcode{\sphinxupquote{int{[}int{]} pr\#arrayIntersection}} the list of neighbor ranks in \sphinxcode{\sphinxupquote{pr\#commddm}} for this mpi rank

\item {} 
\sphinxcode{\sphinxupquote{int pr\#pCS}} equal to {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}}

\item {} 
\sphinxcode{\sphinxupquote{int pr\#exclude}} equal to {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}}

\item {} 
\sphinxcode{\sphinxupquote{int pr\#excluded}} \sphinxstyleemphasis{true} if {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} is \sphinxstyleemphasis{true} (\(\neq 0\)) and mpiRank(\sphinxstylestrong{comm}) \textless{} \sphinxcode{\sphinxupquote{pr\#pCS}}.
In this case, this mpi rank will be excluded from the spatial domain decomposition and will only work on the coarse problem.

\item {} 
\sphinxcode{\sphinxupquote{mpiComm pr\#commddm}} mpi communicator for ranks participating in the spatial domain decomposition (ranks 0 to \sphinxcode{\sphinxupquote{pr\#npart}}-1 in \sphinxstylestrong{comm} if \sphinxcode{\sphinxupquote{pr\#exclude}} is \sphinxstyleemphasis{false}, ranks \sphinxcode{\sphinxupquote{pr\#pCS}} to \sphinxcode{\sphinxupquote{pr\#pCS}}+\sphinxcode{\sphinxupquote{pr\#npart}}-1 otherwise)

\item {} 
\sphinxcode{\sphinxupquote{mpiComm pr\#commCS}} mpi communicator for ranks participating in the assembly and resolution of the coarse problem for two-level preconditioners (ranks 0 to \sphinxcode{\sphinxupquote{pr\#pCS}} - 1 in \sphinxstylestrong{comm})

\item {} 
\sphinxcode{\sphinxupquote{mpiComm pr\#commself}} self mpi communicator (this mpi rank only), used for factorizing local matrices

\end{itemize}


\begin{description}
\item[{\sphinxstylestrong{Remark for sequential use} (see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}]{\sphinxcrossref{\DUrole{std,std-ref}{-seqddm}}}}):}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{meshN{[}int{]} pr\#aTh}} array (size \sphinxcode{\sphinxupquote{pr\#npart}}) of local meshes of the subdomains

\end{itemize}

\end{description}




\subsubsection{Local finite element spaces}
\label{\detokenize{documentation/ffddm/documentation:local-finite-element-spaces}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{prmesh}\PYG{p}{,}\PYG{n}{scalar}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{n}{Pk}\PYG{p}{)}
\end{sphinxVerbatim}

builds the local finite element spaces and associated distributed operators on top of the mesh decomposition \sphinxstylestrong{prmesh}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} has already been called with prefix \sphinxstylestrong{prmesh} in order to build the mesh decomposition.

The local finite element spaces of type \sphinxstylestrong{Pk} (where \sphinxstylestrong{Pk} is the type of finite element: P1, {[}P2,P2,P1{]}, …) are defined on the local meshes of the subdomains based on the mesh decomposition previously created with prefix \sphinxstylestrong{prmesh}.

\sphinxstylestrong{scalar} determines the type of data for this finite element: \sphinxstyleemphasis{real} or \sphinxstyleemphasis{complex}.

Two macros, \sphinxstylestrong{def} and \sphinxstylestrong{init}, are needed: \sphinxstylestrong{def} specifies how to define a finite element function in the finite element space \sphinxstylestrong{Pk}, and \sphinxstylestrong{init} specifies how to interpolate a scalar function onto the (possibly multiple) components of \sphinxstylestrong{Pk}. Two examples are given below:

For scalar P2 finite elements and complex-valued problems:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u}\PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u}\PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{myFEprefix}\PYG{p}{,}\PYG{n}{mymeshprefix}\PYG{p}{,}\PYG{k+kt}{complex}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{)}
\end{sphinxVerbatim}

For vectorial {[}P2,P2,P1{]} finite elements and real-valued problems:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{]}\PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{]}\PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{myFEprefix}\PYG{p}{,}\PYG{n}{mymeshprefix}\PYG{p}{,}\PYG{k+kt}{real}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

In practice, this builds the necessary distributed operators associated to the finite element space: the local partition of unity functions \((D_i)_{i=1,...,N}\) (see \sphinxcode{\sphinxupquote{pr\#Dk}} and \sphinxcode{\sphinxupquote{pr\#Dih}} below) as well as the function \sphinxcode{\sphinxupquote{pr\#update}} (see below) which synchronizes local vectors \((u_i)_{i=1,...,N}\) between neighboring subdomains, performing the equivalent of \(u_i = R_i (\sum_{j=1}^N R_j^T u_j)\) or \(u_i = R_i (\sum_{j=1}^N R_j^T D_j u_j)\) in a distributed parallel environment.

\sphinxcode{\sphinxupquote{pr\#scalprod}} (see below) performs the parallel scalar product for vectors defined on this finite element.

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{pr\#prmesh}} macro, saves the parent prefix \sphinxstylestrong{prmesh} of the mesh decomposition

\item {} 
\sphinxcode{\sphinxupquote{pr\#K}} macro, saves the type of data \sphinxstylestrong{scalar} for this finite element space (\sphinxstyleemphasis{real} or \sphinxstyleemphasis{complex})

\item {} 
\sphinxcode{\sphinxupquote{func pr\#fPk}} saves the type of finite element \sphinxstylestrong{Pk}, e.g. \sphinxstyleemphasis{P1, {[}P2,P2,P1{]}, …}

\item {} 
\sphinxcode{\sphinxupquote{fespace pr\#Vhi}} the local finite element space for this mpi rank, defined on the local mesh \sphinxcode{\sphinxupquote{prmesh\#Thi}}

\item {} 
\sphinxcode{\sphinxupquote{int pr\#Ndofglobal}} the total number of degrees of freedom \(n\) for this finite element discretization

\item {} 
\sphinxcode{\sphinxupquote{pr\#mdef}} macro, saves the macro \sphinxstylestrong{def} giving the definition of a finite element function in the finite element space \sphinxstylestrong{Pk}

\item {} 
\sphinxcode{\sphinxupquote{pr\#minit}} macro, saves the macro \sphinxstylestrong{init} specifying how to interpolate a scalar function onto the (possibly multiple) components of a finite element function of \sphinxstylestrong{Pk}.
This is used to create the local partition of unity function in \sphinxcode{\sphinxupquote{pr\#Vhi}}, by interpolating the local P1 partition of unity function onto the components of \sphinxcode{\sphinxupquote{pr\#Vhi}}.
For non Lagrange finite element spaces (e.g. \sphinxstyleemphasis{RT0}, \sphinxstyleemphasis{Edge03d}, …), see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDfespaceEdge}}}}.

\item {} 
\sphinxcode{\sphinxupquote{pr\#K{[}int{]}{[}int{]} pr\#Dk}} array (size \sphinxcode{\sphinxupquote{prmesh\#npart}}) of local partition of unity vectors in the subdomains, equivalent to \((D_i)_{i=1,...,N}\).
In the standard parallel case, only the local partition of unity vector for this mpi rank \sphinxcode{\sphinxupquote{pr\#Dk{[}mpiRank(prmesh\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1).
In the sequential case, all local partition of unity vectors are defined.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#K\textgreater{}{[}int{]} pr\#Dih}} array (size \sphinxcode{\sphinxupquote{prmesh\#npart}}) similar to \sphinxcode{\sphinxupquote{pr\#Dk}} but in \sphinxstyleemphasis{matrix} form, allowing for easier \sphinxstyleemphasis{matrix}-\sphinxstyleemphasis{matrix} multiplications.
\sphinxcode{\sphinxupquote{pr\#Dih{[}i{]}}} is a diagonal matrix, with the diagonal equal to \sphinxcode{\sphinxupquote{pr\#Dk{[}i{]}}}.

\item {} 
\sphinxcode{\sphinxupquote{fespace pr\#Vhglob}} the global finite element space defined on the global mesh \sphinxcode{\sphinxupquote{prmesh\#Thglob}}.
Defined only if {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}]{\sphinxcrossref{\DUrole{std,std-ref}{-noGlob}}}} is not used.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#K\textgreater{}{[}int{]} pr\#Rih}} array (size \sphinxcode{\sphinxupquote{prmesh\#npart}}) of restriction matrices from the global finite element space to the local finite element spaces on the local submeshes of the subdomains.
In the standard parallel case, only the restriction matrix for this mpi rank \sphinxcode{\sphinxupquote{pr\#Rih{[}mpiRank(prmesh\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1).
In the sequential case, all restriction matrices are defined. The restriction matrices \sphinxcode{\sphinxupquote{pr\#Rih}} are defined only if {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}]{\sphinxcrossref{\DUrole{std,std-ref}{-noGlob}}}} is not used.

\item {} 
\sphinxcode{\sphinxupquote{func int pr\#update(scalar{[}int{]} ui, bool scale)}} The function \sphinxcode{\sphinxupquote{pr\#update}} synchronizes the local vector \sphinxstyleemphasis{ui} between subdomains by exchanging the values of \sphinxstyleemphasis{ui} shared with neighboring subdomains (in the overlap region) using point-to-point MPI communications.
If \sphinxstyleemphasis{scale} is \sphinxstyleemphasis{true}, \sphinxstyleemphasis{ui} is multiplied by the local partition of unity beforehand.
This is equivalent to \(u_i = R_i (\sum_{j=1}^N R_j^T u_j)\) when \sphinxstyleemphasis{scale} is \sphinxstyleemphasis{false} and \(u_i = R_i (\sum_{j=1}^N R_j^T D_j u_j)\) when \sphinxstyleemphasis{scale} is \sphinxstyleemphasis{true}.

\item {} 
\sphinxcode{\sphinxupquote{func scalar pr\#scalprod(scalar{[}int{]} ai, scalar{[}int{]} bi)}} The function \sphinxcode{\sphinxupquote{pr\#scalprod}} computes the global scalar product of two vectors whose local restriction to the subdomain of this mpi rank are \sphinxstyleemphasis{ai} and \sphinxstyleemphasis{bi}.
The result is computed as \(\sum_{j=1}^N (D_j a_j, b_j)\).

\end{itemize}




\subsubsection{Define the problem to solve}
\label{\detokenize{documentation/ffddm/documentation:define-the-problem-to-solve}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ffddmsetupOperator}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{prfe}\PYG{p}{,}\PYG{n}{Varf}\PYG{p}{)}
\end{sphinxVerbatim}

builds the distributed operator associated to the variational problem given by \sphinxstylestrong{Varf}, on top of the distributed finite element space \sphinxstylestrong{prfe}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDfespace}}}} has already been called with prefix \sphinxstylestrong{prfe} in order to define the distributed finite element space.

In practice, this builds the so-called local ‘Dirichlet’ matrices \(A_i = R_i A R_i^T\), the restrictions of the global operator \(A\) to the subdomains (see \sphinxcode{\sphinxupquote{pr\#aRd}}below).
The matrices correspond to the discretization of the bilinear form given by the macro \sphinxstylestrong{Varf}, which represents the abstract variational form of the problem.
These matrices are then used to implement the action of the global operator \(A\) on a local vector (the parallel matrix-vector product with \(A\)), see \sphinxcode{\sphinxupquote{pr\#A}} below.

At this point, we already have the necessary data to be able to solve the problem with a parallel direct solver (\sphinxstyleemphasis{MUMPS}), which is the purpose of the function \sphinxcode{\sphinxupquote{pr\#directsolve}} (see below).
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildrhs}}}} for building the right-hand side.

The macro \sphinxstylestrong{Varf} is required to have three parameters: the name of the variational form, the mesh, and the finite element space.
The variational form given in this ‘abstract’ format will then be used by \sphinxstyleemphasis{ffddm} to assemble the discrete operators by setting the appropriate mesh and finite element space as parameters.
An example is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{myVarf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// EOM}

\PYG{n}{ffddmsetupOperator}\PYG{p}{(}\PYG{n}{myprefix}\PYG{p}{,}\PYG{n}{myFEprefix}\PYG{p}{,}\PYG{n}{myVarf}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Remark} In this simple example, the third parameter \sphinxstyleemphasis{VhName} is not used.
However, for more complex cases such as non-linear or time dependent problems where the problem depends on a solution computed at a previous step, it is useful to know for which discrete finite element space the variational form is being used.
See for example TODO

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{pr\#prfe}} macro, saves the parent prefix \sphinxstylestrong{prfe} of the finite element space

\item {} 
\sphinxcode{\sphinxupquote{int pr\#verbosity}} the level of verbosity for this problem, initialized with the value of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmverbosity}}}}

\item {} 
\sphinxcode{\sphinxupquote{pr\#writesummary}} macro, prints a summary of timings for this problem, such as the time spent to assemble local matrices or solve the linear system.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}prfe\#K\textgreater{} pr\#Aglobal}} the global matrix \(A\) corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{Varf} on the global finite element space \sphinxcode{\sphinxupquote{prfe\#Vhglob}}.
Defined only in the sequential case.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}prfe\#K\textgreater{}{[}int{]} pr\#aRd}} array (size \sphinxcode{\sphinxupquote{prfe\#prmesh\#npart}}) of so-called local ‘Dirichlet’ matrices in the subdomains; these are the restrictions of the global operator to the subdomains, equivalent to \(A_i = R_i A R_i^T\) with \(A\) the global matrix corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{Varf} on the global finite element space.
In the standard parallel case, only the local matrix for this mpi rank \sphinxcode{\sphinxupquote{pr\#aRd{[}mpiRank(prmesh\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1).
In the sequential case, all local matrices are defined.

\item {} 
\sphinxcode{\sphinxupquote{func prfe\#K{[}int{]} pr\#A(prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#A}} computes the parallel matrix-vector product, i.e. the action of the global operator \(A\) on the local vector \(u_i\).
The computation is equivalent to \(R_i (\sum_{j=1}^N R_j^T D_j A_j u_j)\) and is performed in parallel using local matrices \sphinxcode{\sphinxupquote{pr\#aRd}} and the function \sphinxcode{\sphinxupquote{prfe\#update}}.
In the sequential case, the global matrix \sphinxcode{\sphinxupquote{pr\#Aglobal}} is used instead.

\item {} 
\sphinxcode{\sphinxupquote{func prfe\#K{[}int{]} pr\#directsolve(prfe\#K{[}int{]}\& rhsi)}} The function \sphinxcode{\sphinxupquote{pr\#directsolve}} allows to solve the linear system \(A x = b\) in parallel using the parallel direct solver \sphinxstyleemphasis{MUMPS}.
The matrix is given to \sphinxstyleemphasis{MUMPS} in distributed form through the local matrices \sphinxcode{\sphinxupquote{pr\#aRd}}.
The input \sphinxstyleemphasis{rhsi} is given as a distributed vector (\sphinxstyleemphasis{rhsi} is the restriction of the global right-hand side \(b\) to the subdomain of this mpi rank, see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildrhs}}}}) and the returned vector is local as well.

\end{itemize}




\bigskip\hrule\bigskip


\def\sphinxLiteralBlockLabel{\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildrhs}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{Varfrhs}\PYG{p}{,}\PYG{n}{rhs}\PYG{p}{)}
\end{sphinxVerbatim}

builds the right-hand side associated to the variational form given by \sphinxstylestrong{Varfrhs} for the problem corresponding to prefix \sphinxstylestrong{pr}.
The resulting right-hand side vector \sphinxstylestrong{rhs} corresponds to the discretization of the abstract linear form given by the macro \sphinxstylestrong{Varfrhs} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).

The input vector \sphinxstylestrong{rhs} is resized and contains the resulting local right-hand side \(R_i b\), the restriction of the global right-hand side \(b\) to the subdomain of this mpi rank.
In the sequential case, the global right-hand side vector \(b\) is assembled instead.

An example is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{myVarfrhs}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// EOM}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhsi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(}\PYG{n}{myprefix}\PYG{p}{,}\PYG{n}{myVarfrhs}\PYG{p}{,}\PYG{n}{rhsi}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{One level preconditioners}
\label{\detokenize{documentation/ffddm/documentation:one-level-preconditioners}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{VarfPrec}\PYG{p}{)}
\end{sphinxVerbatim}

builds the one level preconditioner for problem \sphinxstylestrong{pr}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} has already been called with prefix \sphinxstylestrong{pr} in order to define the problem to solve.

In practice, this builds and performs the factorization of the local matrices used in the one level preconditioner.
The local matrices depend on the choice of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} and \sphinxstylestrong{VarfPrec}, see \sphinxcode{\sphinxupquote{pr\#aR}}below.

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{string pr\#prec}} equal to {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}}.
Sets the type of one level preconditioner \(M^{-1}_1\) to be used: “asm” (\sphinxstyleemphasis{Additive Schwarz}), “ras” (\sphinxstyleemphasis{Restricted Additive Schwarz}), “oras” (\sphinxstyleemphasis{Optimized Restricted Additive Schwarz}), “soras” (\sphinxstyleemphasis{Symmetric Optimized Restricted Additive Schwarz}) or “none” (no preconditioner).

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{}{[}int{]} pr\#aR}} array (size \sphinxcode{\sphinxupquote{prfe\#prmesh\#npart}}) of local matrices used for the one level preconditioner.
Each mpi rank of the spatial domain decomposition performs the \(LU\) (or \(LDL^T\)) factorization of the local matrix corresponding to its subdomain using the direct solver \sphinxstyleemphasis{MUMPS}.
\begin{itemize}
\item {} 
If \sphinxstylestrong{VarfPrec} is not a previously defined macro (just put \sphinxstyleemphasis{null} for example), the matrices \sphinxcode{\sphinxupquote{pr\#aR}} are set to be equal to the so-called local ‘Dirichlet’ matrices \sphinxcode{\sphinxupquote{pr\#aRd}} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}).
This is for the classical ASM preconditioner \(M^{-1}_1 = M^{-1}_{\text{ASM}} = \sum_{i=1}^N R_i^T A_i^{-1} R_i\) or classical RAS preconditioner \(M^{-1}_1 = M^{-1}_{\text{RAS}} = \sum_{i=1}^N R_i^T D_i A_i^{-1} R_i\) (it is assumed that {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} is equal to “asm” or “ras”).

\item {} 
If \sphinxstylestrong{VarfPrec} is a macro, it is assumed that \sphinxstylestrong{VarfPrec} defines an abstract bilinear form (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).
\begin{itemize}
\item {} 
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} is equal to “asm” or “ras”, the matrices \sphinxcode{\sphinxupquote{pr\#aR}} will be assembled as local ‘Dirichlet’ matrices in the same manner as \sphinxcode{\sphinxupquote{pr\#aRd}}, but using the bilinear form defined by \sphinxstylestrong{VarfPrec} instead.
This defines the ASM preconditioner as \(M^{-1}_1 = M^{-1}_{\text{ASM}} = \sum_{i=1}^N R_i^T {(A_i^{\text{Prec}})}^{-1} R_i\) and the RAS preconditioner as \(M^{-1}_1 = M^{-1}_{\text{RAS}} = \sum_{i=1}^N R_i^T D_i {(A_i^{\text{Prec}})}^{-1} R_i\), where \(A_i^{\text{Prec}} = R_i A^{\text{Prec}} R_i^T\).

\item {} 
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} is equal to “oras” or “soras”, the matrices \sphinxcode{\sphinxupquote{pr\#aR}} will correspond to the discretization of the variational form \sphinxstylestrong{VarfPrec} in the subdomains \(\Omega_i\).
In particular, various boundary conditions can be imposed at the interface between subdomains (corresponding to mesh boundary of label {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddminterfacelabel}}}} set by the parent call to {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}}), such as Optimized Robin boundary conditions.
We note the ORAS preconditioner as \(M^{-1}_1 = M^{-1}_{\text{ORAS}} = \sum_{i=1}^N R_i^T D_i {(B_i^{\text{Prec}})}^{-1} R_i\) and the SORAS preconditioner as \(M^{-1}_1 = M^{-1}_{\text{SORAS}} = \sum_{i=1}^N R_i^T D_i {(B_i^{\text{Prec}})}^{-1} D_i R_i\).

\end{itemize}

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#PREC1(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#PREC1}} computes the parallel application of the one level preconditioner \(M^{-1}_1\), i.e. the action of \(M^{-1}_1\) on the local vector \(u_i\).
In the sequential case, it computes the action of \(M^{-1}_1\) on a global vector.
The action of the inverse of local matrices \sphinxcode{\sphinxupquote{pr\#aRd}} is computed by forward-backward substitution using their \(LU\) (or \(LDL^T\)) decomposition.

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#PREC(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#PREC}} corresponds to the action of the preconditioner \(M^{-1}\) for problem \sphinxstylestrong{pr}.
It coincides with the one level preconditioner \sphinxcode{\sphinxupquote{pr\#PREC1}} after the call to {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}}.
If a second level is subsequently added (see the next section about {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{Two level preconditioners}}}}), it will then coincide with the two level preconditioner \(M^{-1}_2\) (see \sphinxcode{\sphinxupquote{pr\#PREC2level}}).

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#fGMRES(pr\#prfe\#K{[}int{]}\& x0i, pr\#prfe\#K{[}int{]}\& bi, real eps, int nbiter, string sprec)}} The function \sphinxcode{\sphinxupquote{pr\#fGMRES}} allows to solve the linear system \(A x = b\) in parallel using the flexible GMRES method preconditioned by \(M^{-1}\).
The action of the global operator \(A\) is given by \sphinxcode{\sphinxupquote{pr\#A}}, the action of the preconditioner \(M^{-1}\) is given by \sphinxcode{\sphinxupquote{pr\#PREC}} and the scalar products are computed by \sphinxcode{\sphinxupquote{pr\#scalprod}}.
More details are given in the section {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationsolvinglinearsystem}]{\sphinxcrossref{\DUrole{std,std-ref}{Solving the linear system}}}}.

\end{itemize}




\subsubsection{Two level preconditioners}
\label{\detokenize{documentation/ffddm/documentation:two-level-preconditioners}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}}
The main ingredient of a two level preconditioner is the so-called ‘coarse space’ matrix \(Z\).

\(Z\) is a rectangular matrix of size \(n \times n_c\), where usually \(n_c \ll n\).

\(Z\) is used to build the ‘coarse space operator’ \(E = Z^T A Z\), a square matrix of size \(n_c \times n_c\).
We can then define the ‘coarse space correction operator’ \(Q = Z E^{-1} Z^T = Z (Z^T A Z)^{-1} Z^T\), which can then be used to enrich the one level preconditioner through a correction formula.
The simplest one is the \sphinxstyleemphasis{additive} coarse correction: \(M^{-1}_2 = M^{-1}_1 + Q\).
See \sphinxcode{\sphinxupquote{pr\#corr}} below for all other available correction formulas.

There are multiple ways to define a relevant coarse space \(Z\) for different classes of problems.
{\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} defines a coarse space correction operator by building the GenEO coarse space, while {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcoarsemeshsetup}}}} builds the coarse space using a coarse mesh.

After a call to either {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} or {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcoarsemeshsetup}}}}, the following variables and functions are set up:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int pr\#ncoarsespace}} the size of the coarse space \(n_c\).

\item {} 
\sphinxcode{\sphinxupquote{string pr\#corr}} initialized with the value of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcorrection}}}}.
Specifies the type of coarse correction formula to use for the two level preconditioner.
The possible values are:

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{llllll}
\nonumber
    &&\text{"AD"}:&&\textit{Additive}, \quad &M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1\phantom{ (I - A Q)} + Q\\
    &&\text{"BNN"}:&&\textit{Balancing Neumann-Neumann}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1 (I - A Q) + Q\\
    &&\text{"ADEF1"}:&&\textit{Adapted Deflation Variant 1}, \quad &M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1 (I - A Q) + Q\\
    &&\text{"ADEF2"}:&&\textit{Adapted Deflation Variant 2}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1\phantom{ (I - A Q)} + Q\\
    &&\text{"RBNN1"}:&&\textit{Reduced Balancing Variant 1}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1 (I - A Q)\\
    &&\text{"RBNN2"}:&&\textit{Reduced Balancing Variant 2}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1\phantom{ (I - A Q)}\\
    &&\text{"none"}:&&\textit{no coarse correction}, \quad &M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1\phantom{ (I - A Q)}\\
\end{array}\end{split}
\end{equation*}\begin{itemize}
\item {} 
Note that \sphinxstyleemphasis{AD}, \sphinxstyleemphasis{ADEF1} and \sphinxstyleemphasis{RBNN2} only require one application of \(Q\), while \sphinxstyleemphasis{BNN}, \sphinxstyleemphasis{ADEF2} and \sphinxstyleemphasis{RBNN1} require two.
The default coarse correction is \sphinxstyleemphasis{ADEF1}, which is cheaper and generally as robust as \sphinxstyleemphasis{BNN} or \sphinxstyleemphasis{ADEF2}.

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#Q(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#Q}} computes the parallel application of the coarse correction operator \(Q\), i.e. the action of \(Q = Z E^{-1} Z^T\) on the local vector \(u_i\).
In the sequential case, it computes the action of \(Q\) on a global vector.
The implementation differs depending on the method used to build the coarse space (with GenEO or using a coarse mesh), but the idea is the same: the action of the transpose of the distributed operator \(Z\) on the distributed vector \(u_i\) is computed in parallel, with the contribution of all subdomains being gathered in a vector of size \(n_c\) in the mpi process of rank 0.
The action of the inverse of the coarse space operator \(E\) is then computed by forward-backward substitution using its \(LU\) (or \(LDL^T\)) decomposition previously computed by the first \sphinxcode{\sphinxupquote{pr\#prfe\#prmesh\#pCS}} ranks of the mpi communicator.
The result is then sent back to all subdomains to perform the last application of \(Z\) and obtain the resulting local vector in each subdomain.

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#PREC2level(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#PREC2level}} computes the parallel application of the two level preconditioner \(M^{-1}_2\), i.e. the action of \(M^{-1}_2\) on the local vector \(u_i\).
In the sequential case, it computes the action of \(M^{-1}_2\) on a global vector.
The two level preconditioner depends on the choice of the coarse correction formula which is determined by \sphinxcode{\sphinxupquote{pr\#corr}}, see above.

\end{itemize}




\paragraph{Building the GenEO coarse space}
\label{\detokenize{documentation/ffddm/documentation:building-the-geneo-coarse-space}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmgeneosetup}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{Varf}\PYG{p}{)}
\end{sphinxVerbatim}

This builds the GenEO coarse space for problem \sphinxstylestrong{pr}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}} has already been called for prefix \sphinxstylestrong{pr} in order to define the one level preconditioner for problem \sphinxstylestrong{pr}.
The GenEO coarse space is \(Z = (R_i^T D_i V_{i,k})^{i=1,...,N}_{\lambda_{i,k} \ge \tau}\), where \(V_{i,k}\) are eigenvectors corresponding to eigenvalues \(\lambda_{i,k}\) of the following local generalized eigenvalue problem in subdomain \(i\):

\(D_i A_i D_i V_{i,k} = \lambda_{i,k} A_i^{\text{Neu}} V_{i,k}\),

where \(A_i^{\text{Neu}}\) is the local Neumann matrix of subdomain \(i\) (with Neumann boundary conditions at the subdomain interface).

In practice, this builds and factorizes the local Neumann matrices \(A_i^{\text{Neu}}\) corresponding to the abstract bilinear form given by the macro \sphinxstylestrong{Varf} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).
In the GenEO method, the abstract bilinear form \sphinxstylestrong{Varf} is assumed to be the same as the one used to define the problem \sphinxstylestrong{pr} through the previous call to {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}.
The local generalized eigenvalue problem is then solved in each subdomain to find the eigenvectors \(V_{i,k}\) corresponding to the largest eigenvalues \(\lambda_{i,k}\) (see \sphinxcode{\sphinxupquote{pr\#Z}} below).
The number of computed eigenvectors \(\nu\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}}.
The eigenvectors selected to enter \(Z\) correspond to eigenvalues \(\lambda_{i,k}\) larger than \(\tau\), where the threshold parameter \(\tau\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}}.
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} \(= 0\), all {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}} eigenvectors are selected.
Finally, the coarse space operator \(E = Z^T A Z\) is assembled and factorized (see \sphinxcode{\sphinxupquote{pr\#E}} below).

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{pr\#prfe\#K{[}int{]}{[}int{]} pr\#Z}} array of local eigenvectors \(Z_{i,k} = D_i V_{i,k}\) obtained by solving the local generalized eigenvalue problem above in the subdomain of this mpi rank using \sphinxstyleemphasis{Arpack}.
The number of computed eigenvectors \(\nu\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}}.
The eigenvectors selected to enter \(Z\) correspond to eigenvalues \(\lambda_{i,k}\) larger than \(\tau\), where the threshold parameter \(\tau\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}}.
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} \(= 0\), all {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}} eigenvectors are selected.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#E}} the coarse space operator \(E = Z^T A Z\).
The matrix \sphinxcode{\sphinxupquote{pr\#E}} is assembled in parallel and is factorized by the parallel direct solver \sphinxstyleemphasis{MUMPS} using the first \sphinxcode{\sphinxupquote{pr\#prfe\#prmesh\#pCS}} ranks of the mpi communicator, with mpi rank 0 as the master process.
The number of mpi processes dedicated to the coarse problem is set by the underlying mesh decomposition of problem \sphinxstylestrong{pr}, which also specifies if these mpi ranks are excluded from the spatial decomposition or not.
These parameters are set by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} and {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} when calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} for more details).

\end{itemize}




\paragraph{Building the coarse space from a coarse mesh}
\label{\detokenize{documentation/ffddm/documentation:building-the-coarse-space-from-a-coarse-mesh}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmcoarsemeshsetup}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{Thc}\PYG{p}{,}\PYG{n}{VarfEprec}\PYG{p}{,}\PYG{n}{VarfAprec}\PYG{p}{)}
\end{sphinxVerbatim}

builds the coarse space for problem \sphinxstylestrong{pr} from a coarse problem which corresponds to the discretization of a variational form on a coarser mesh \sphinxstylestrong{Thc} of \(\Omega\).
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}} has already been called for prefix \sphinxstylestrong{pr} in order to define the one level preconditioner for problem \sphinxstylestrong{pr}.
The abstract variational form for the coarse problem can differ from the original problem \sphinxstylestrong{pr} and is given by macro \sphinxstylestrong{VarfEprec} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).
For example, absorption can be added in the preconditioner for wave propagation problems, see examples for Helmholtz and Maxwell equations in the {\hyperref[\detokenize{documentation/ffddm/examples:ffddmexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Examples}}}} section.

The coarse space \(Z\) corresponds to the interpolation operator from the coarse finite element space to the original finite element space of the problem.
Thus, the coarse space operator \(E = Z^T A^{\text{Eprec}} Z\) corresponds to the matrix of the problem given by \sphinxstylestrong{VarfEprec} discretized on the coarse mesh \sphinxstylestrong{Thc} and is assembled as such.

Similarly, \sphinxstylestrong{VarfAprec} specifies the global operator involved in multiplicative coarse correction formulas.
For example, \(M^{-1}_{2,\text{ADEF1}} = M^{-1}_1 (I - A^{\text{Aprec}} Q) + Q\) (where \(Q = Z E^{-1} Z^T\)).
\(A^{\text{Aprec}}\) defaults to \(A\) if \sphinxstylestrong{VarfAprec} is not a valid macro (you can put \sphinxstyleemphasis{null} for example).

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{meshN pr\#ThCoarse}} the coarse mesh \sphinxstylestrong{Thc}

\item {} 
\sphinxcode{\sphinxupquote{fespace pr\#VhCoarse}} the coarse finite element space of type \sphinxcode{\sphinxupquote{pr\#prfe\#fPk}} defined on the coarse mesh \sphinxcode{\sphinxupquote{pr\#ThCoarse}}

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#AglobEprec}} the global matrix \(A^{\text{Aprec}}\) corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{VarfAprec} on the global finite element space \sphinxcode{\sphinxupquote{pr\#prfe\#Vhglob}}.
Defined only in the sequential case.
\sphinxcode{\sphinxupquote{pr\#AglobEprec}} is equal to \sphinxcode{\sphinxupquote{pr\#Aglobal}} if \sphinxstylestrong{VarfAprec} is not a valid macro.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#aRdEprec}} the local ‘Dirichlet’ matrix corresponding to \sphinxstylestrong{VarfAprec}; it is the local restriction of the global operator \(A^{\text{Aprec}}\) to the subdomain, equivalent to \(A^{\text{Aprec}}_i = R_i A^{\text{Aprec}} R_i^T\) with \(A^{\text{Aprec}}\) the global matrix corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{VarfAprec} on the global finite element space.
Defined only if this mpi rank is not excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 0.
\sphinxcode{\sphinxupquote{pr\#aRdEprec}} is equal to \sphinxcode{\sphinxupquote{pr\#aRd{[}mpiRank(prmesh\#commddm){]}}} if \sphinxstylestrong{VarfAprec} is not a valid macro.

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#AEprec(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#AEprec}} computes the parallel matrix-vector product, i.e. the action of the global operator \(A^{\text{Aprec}}\) on the local vector \(u_i\).
The computation is equivalent to \(R_i (\sum_{j=1}^N R_j^T D_j A^{\text{Aprec}}_j u_j)\) and is performed in parallel using local matrices \sphinxcode{\sphinxupquote{pr\#aRdEprec}} and the function \sphinxcode{\sphinxupquote{pr\#prfe\#update}}.
In the sequential case, the global matrix \sphinxcode{\sphinxupquote{pr\#AglobEprec}} is used instead.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#ZCM}} the interpolation operator \(Z\) from the coarse finite element space \sphinxcode{\sphinxupquote{pr\#VhCoarse}} to the global finite element space \sphinxcode{\sphinxupquote{pr\#prfe\#Vhglob}}.
Defined only in the sequential case.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#ZCMi}} the local interpolation operator \(Z_i\) from the coarse finite element space \sphinxcode{\sphinxupquote{pr\#VhCoarse}} to the local finite element space \sphinxcode{\sphinxupquote{pr\#prfe\#Vhi}}.
Defined only if this mpi rank is not excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 0.
\sphinxcode{\sphinxupquote{pr\#ZCMi}} is used for the parallel application of \(Z\) and \(Z^T\).

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#ECM}} the coarse space operator \(E = Z^T A^{\text{Eprec}} Z\).
The matrix \sphinxcode{\sphinxupquote{pr\#ECM}} is assembled by discretizing the variational form given by \sphinxstylestrong{VarfEprec} on the coarse mesh and factorized by the parallel direct solver \sphinxstyleemphasis{MUMPS} using the first \sphinxcode{\sphinxupquote{pr\#prfe\#prmesh\#pCS}} ranks of the mpi communicator, with mpi rank 0 as the master process.
The number of mpi processes dedicated to the coarse problem is set by the underlying mesh decomposition of problem \sphinxstylestrong{pr}, which also specifies if these mpi ranks are excluded from the spatial decomposition or not.
These parameters are set by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} and {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} when calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} for more details).

\end{itemize}


\subsubsection{Solving the linear system}
\label{\detokenize{documentation/ffddm/documentation:solving-the-linear-system}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationsolvinglinearsystem}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{fGMRES}\PYG{p}{(}\PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{x0i}\PYG{p}{,} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{bi}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{itmax}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{sp}\PYG{p}{)}
\end{sphinxVerbatim}

solves the linear system for problem \sphinxstylestrong{pr} using the flexible GMRES algorithm with preconditioner \(M^{-1}\) (corresponding to \sphinxcode{\sphinxupquote{pr\#PREC}}).
Returns the local vector corresponding to the restriction of the solution to \sphinxcode{\sphinxupquote{pr\#prfe\#Vhi}}.
\sphinxstylestrong{x0i} and \sphinxstylestrong{bi} are local distributed vectors corresponding respectively to the initial guess and the right-hand side (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildrhs}}}}).
\sphinxstylestrong{eps} is the stopping criterion in terms of the relative decrease in residual norm.
If \sphinxstylestrong{eps} \(< 0\), the residual norm itself is used instead.
\sphinxstylestrong{itmax} sets the maximum number of iterations.
\sphinxstylestrong{sp} selects between the \sphinxcode{\sphinxupquote{"left"}} or \sphinxcode{\sphinxupquote{"right"}} preconditioning variants: \sphinxstyleemphasis{left} preconditioned GMRES solves \(M^{-1} A x = M^{-1} b\), while \sphinxstyleemphasis{right} preconditioned GMRES solves \(A M^{-1} y = b\) for \(y\), with \(x = M^{-1} y\).


\subsubsection{Using \sphinxstyleemphasis{HPDDM} within \sphinxstyleemphasis{ffddm}}
\label{\detokenize{documentation/ffddm/documentation:using-hpddm-within-ffddm}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}}
\sphinxstylestrong{ffddm} allows you to use \sphinxstylestrong{HPDDM} to solve your problem, effectively replacing the \sphinxstylestrong{ffddm} implementation of all parallel linear algebra computations.
\sphinxstylestrong{ffddm} can then be viewed as a finite element interface for \sphinxstylestrong{HPDDM}.

You can use \sphinxstylestrong{HPDDM} features unavailable in \sphinxstylestrong{ffddm} such as advanced Krylov subspace methods implementing block and recycling techniques.

To switch to \sphinxstylestrong{HPDDM}, simply define the macro \sphinxcode{\sphinxupquote{pr\#withhpddm}} before using {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}. You can then pass \sphinxstylestrong{HPDDM} options
with command-line arguments or directly to the underlying \sphinxstylestrong{HPDDM} operator \sphinxcode{\sphinxupquote{pr\#hpddmOP}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{PBwithhpddm}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{1} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{PBhpddmOP}\PYG{p}{,}\PYG{k+kp}{sparams}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}krylov\PYGZus{}method gcrodr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can also choose to replace only the Krylov solver, by defining the macro \sphinxcode{\sphinxupquote{pr\#withhpddmkrylov}} before using {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}.
Doing so, a call to \sphinxcode{\sphinxupquote{pr\#fGMRES}} will call the \sphinxstylestrong{HPDDM} Krylov solver, with \sphinxstylestrong{ffddm} providing the operator and preconditioner through \sphinxcode{\sphinxupquote{pr\#A}} and \sphinxcode{\sphinxupquote{pr\#PREC}}.

An example can be found in \sphinxstylestrong{Helmholtz-2d-HPDDM-BGMRES.edp}, see the {\hyperref[\detokenize{documentation/ffddm/examples:ffddmexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Examples}}}} section.


\subsection{Parameters}
\label{\detokenize{documentation/ffddm/parameters:parameters}}\label{\detokenize{documentation/ffddm/parameters::doc}}

\subsubsection{Command-line arguments}
\label{\detokenize{documentation/ffddm/parameters:command-line-arguments}}\label{\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_verbosity N}}, the level of verbosity of \sphinxstylestrong{ffddm}, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmverbosity}}}} (default 3).

\item {} 
\sphinxcode{\sphinxupquote{-seqddm N}} use \sphinxstylestrong{ffddm} in sequential mode, with N the number of subdomains.

\item {} 
\sphinxcode{\sphinxupquote{-noGlob}} if present, do not define any global quantity (such as saving the global mesh for plotting or building the global restriction matrices).
Cannot be used in sequential mode or with plotting.

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_partitioner N}} specifies how to partition the initial domain, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpartitioner}}}} (default 1, \sphinxstyleemphasis{metis}).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_overlap N}} specifies the width of the overlap region between subdomains, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmoverlap}}}} (default 1).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_master\_p N}}, number of master processes for the coarse problem (for two level preconditioners), see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} (default 1).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_master\_exclude 0\textbar{}1}} exclude master processes from the domain decomposition, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} (default 0).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_split N}}, level of refinement of the local submeshes with respect to the initial global mesh, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsplit}}}} (default 1).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_schwarz\_method S}}, specifies the type of one level preconditioner \(M^{-1}_1\): “asm” (\sphinxstyleemphasis{Additive Schwarz}), “ras” (\sphinxstyleemphasis{Restricted Additive Schwarz}), “oras” (\sphinxstyleemphasis{Optimized Restricted Additive Schwarz}), “soras” (\sphinxstyleemphasis{Symmetric Optimized Restricted Additive Schwarz}) or “none” (no preconditioner), see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} (default “ras”).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_geneo\_nu N}}, number of local eigenvectors to compute in each subdomain when solving the local generalized eigenvalue problem for the GenEO method, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}} (default 20).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_geneo\_threshold R}}, threshold parameter for selecting local eigenvectors when solving the local generalized eigenvalue problems for the GenEO method, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} (default 0.5).
If the command-line parameter \sphinxstylestrong{-ffddm\_geneo\_nu N} is used, then {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} is initialized to 0.

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_schwarz\_coarse\_correction S}}, specifies the coarse correction formula to use for the two level preconditioner: “AD” (\sphinxstyleemphasis{Additive}), “BNN” (\sphinxstyleemphasis{Balancing Neumann-Neumann}), “ADEF1” (\sphinxstyleemphasis{Adapted Deflation Variant 1}), “ADEF2” (\sphinxstyleemphasis{Adapted Deflation Variant 2}), “RBNN1” (\sphinxstyleemphasis{Reduced Balancing Variant 1}), “RBNN2” (\sphinxstyleemphasis{Reduced Balancing Variant 2}) or “none” (no coarse correction), see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcorrection}}}} (default “ADEF1”).

\end{itemize}


\subsubsection{Global parameters}
\label{\detokenize{documentation/ffddm/parameters:global-parameters}}\label{\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ffddmverbosity}} initialized by command-line argument \sphinxstylestrong{-ffddm\_verbosity N}, specifies the level of verbosity of \sphinxstylestrong{ffddm} (default 3).

\item {} 
\sphinxcode{\sphinxupquote{ffddmpartitioner}} initialized by command-line argument \sphinxstylestrong{-ffddm\_partitioner N}, specifies how to partition the initial domain:
\begin{itemize}
\item {} 
N=0: user-defined partition through the definition of a macro, see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}}

\item {} 
N=1: use the automatic graph partitioner \sphinxstyleemphasis{metis} (default)

\item {} 
N=2: use the automatic graph partitioner \sphinxstyleemphasis{scotch}

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{ffddmoverlap}} initialized by command-line argument \sphinxstylestrong{-ffddm\_overlap N}, specifies the number of layers of mesh elements in the overlap region between subdomains N \textgreater{}= 1 (default 1).
\sphinxstylestrong{Remark} The actual width of the overlap region between subdomains is 2N, since each subdomain is extended by N layers of elements in a symmetric way.

\item {} 
\sphinxcode{\sphinxupquote{ffddminterfacelabel}} the label of the new border of the subdomain meshes (the interface between the subdomains) (default 10).
Used for imposing problem-dependent boundary conditions at the interface between subdomains for the preconditioner, for example optimized Robin boundary conditions (see ORAS).

\item {} 
\sphinxcode{\sphinxupquote{ffddmpCS}} initialized by command-line argument \sphinxstylestrong{-ffddm\_master\_p N}, number of mpi processes used for the assembly and resolution of the coarse problem for two level preconditioners (default 1).

\item {} 
\sphinxcode{\sphinxupquote{ffddmexclude}} initialized by command-line argument \sphinxstylestrong{-ffddm\_master\_exclude}, 0 or 1 (default 0).
If true, mpi ranks participating in the assembly and resolution of the coarse problem for two level preconditioners will be excluded from the spatial domain decomposition and will only work on the coarse problem.

\item {} 
\sphinxcode{\sphinxupquote{ffddmsplit}} initialized by command-line argument \sphinxstylestrong{ffddm\_split N}, level of refinement of the local submeshes with respect to the initial global mesh (default 1).
This is useful for large problems, where we want to avoid working with a very large global mesh.
The idea is to start from a coarser global mesh, and generate finer local meshes in parallel during the mesh decomposition step in order to reach the desired level of refinement for the subdomains.
For example, calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} with {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsplit}}}} = 3 will generate local submeshes where each mesh element of the initial mesh is split into \(3^d\) elements.

\item {} 
\sphinxcode{\sphinxupquote{ffddmprecond}} initialized by command-line argument \sphinxstylestrong{-ffddm\_schwarz\_method S}, specifies the type of one level preconditioner \(M^{-1}_1\) to build when calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}}: “asm” (\sphinxstyleemphasis{Additive Schwarz}), “ras” (\sphinxstyleemphasis{Restricted Additive Schwarz}), “oras” (\sphinxstyleemphasis{Optimized Restricted Additive Schwarz}), “soras” (\sphinxstyleemphasis{Symmetric Optimized Restricted Additive Schwarz}) or “none” (no preconditioner).
Default is “ras”.
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}} for more details.

\item {} 
\sphinxcode{\sphinxupquote{ffddmnu}} initialized by command-line argument \sphinxstylestrong{-ffddm\_geneo\_nu N}, number of local eigenvectors to compute in each subdomain when solving the local generalized eigenvalue problem for the GenEO method (default 20).
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} for more details.

\item {} 
\sphinxcode{\sphinxupquote{ffddmtau}} initialized by command-line argument \sphinxstylestrong{-ffddm\_geneo\_threshold R}, threshold parameter for selecting local eigenvectors when solving the local generalized eigenvalue problems for the GenEO method (default 0.5).
If the command-line parameter \sphinxstylestrong{-ffddm\_geneo\_nu N} is used, then {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} is initialized to 0.
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} for more details.

\item {} 
\sphinxcode{\sphinxupquote{ffddmcorrection}} initialized by command-line argument \sphinxstylestrong{-ffddm\_schwarz\_coarse\_correction S}, specifies the coarse correction formula to use for the two level preconditioner: “AD” (\sphinxstyleemphasis{Additive}), “BNN” (\sphinxstyleemphasis{Balancing Neumann-Neumann}), “ADEF1” (\sphinxstyleemphasis{Adapted Deflation Variant 1}), “ADEF2” (\sphinxstyleemphasis{Adapted Deflation Variant 2}), “RBNN1” (\sphinxstyleemphasis{Reduced Balancing Variant 1}), “RBNN2” (\sphinxstyleemphasis{Reduced Balancing Variant 2}) or “none” (no coarse correction).
Default is “ADEF1”.
See the section about {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{Two level preconditioners}}}} for more details.

\end{itemize}


\subsection{Tutorial}
\label{\detokenize{documentation/ffddm/tutorial:tutorial}}\label{\detokenize{documentation/ffddm/tutorial:ffddmtutorial}}\label{\detokenize{documentation/ffddm/tutorial::doc}}
Authors: Pierre-Henri Tournier - Frédéric Nataf - Pierre Jolivet


\subsubsection{What is \sphinxstylestrong{ffddm} ?}
\label{\detokenize{documentation/ffddm/tutorial:what-is-ffddm}}\begin{itemize}
\item {} 
\sphinxstylestrong{ffddm} implements a class of parallel solvers in \sphinxstyleemphasis{FreeFem++}: \sphinxstyleemphasis{overlapping Schwarz domain decomposition methods}

\item {} \begin{description}
\item[{The entire \sphinxstylestrong{ffddm} framework is written in the \sphinxstyleemphasis{FreeFem++} language \sphinxstylestrong{ffddm} aims at simplifying the use of parallel solvers in \sphinxstyleemphasis{FreeFem++}}] \leavevmode
You can find the \sphinxstylestrong{ffddm} scripts and examples \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples\%2B\%2B-ffddm}{here}

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{ffddm} provides a set of high-level macros and functions to}] \leavevmode\begin{itemize}
\item {} 
handle data distribution: distributed meshes and linear algebra

\item {} 
build DD preconditioners for your variational problems

\item {} 
solve your problem using preconditioned Krylov methods

\end{itemize}

\end{description}

\item {} 
\sphinxstylestrong{ffddm} implements scalable two level Schwarz methods, with a coarse space correction built either from a coarse mesh or a \sphinxhref{https://link.springer.com/article/10.1007\%2Fs00211-013-0576-y}{GenEO} coarse space \sphinxstyleemphasis{Ongoing research}: approximate coarse solves and three level methods

\item {} \begin{description}
\item[{\sphinxstylestrong{ffddm} can also act as a wrapper for the \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM} library.}] \leavevmode
\sphinxstylestrong{HPDDM} is an efficient C++11 implementation of various domain decomposition methods and Krylov subspace algorithms with advanced block and recycling techniques More details on how to use \sphinxstylestrong{HPDDM} within \sphinxstylestrong{ffddm} {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}]{\sphinxcrossref{\DUrole{std,std-ref}{here}}}}

\end{description}

\end{itemize}


\subsubsection{Why Domain Decomposition Methods ?}
\label{\detokenize{documentation/ffddm/tutorial:why-domain-decomposition-methods}}
How can we solve a large sparse linear system \(A u = b \in \mathbb{R}^n\) ?

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{Methods_Solves_1}.png}


\paragraph{Step 1: Decompose the mesh}
\label{\detokenize{documentation/ffddm/tutorial:step-1-decompose-the-mesh}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

Build a collection of \(N\) overlapping sub-meshes \((Th_{i})_{i=1}^N\) from the global mesh \(Th\)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxincludegraphics[width=1.000\linewidth]{{domain1}.png}
&
\sphinxincludegraphics[width=1.000\linewidth]{{domain2}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{prmesh} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{n}{comm} \PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
mesh distributed over the MPI processes of communicator \sphinxstylestrong{comm}

\item {} 
initial mesh \sphinxstylestrong{ThGlobal} partitioned with \sphinxstyleemphasis{metis} by default

\item {} 
size of the overlap given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmoverlap}}}} (default 1)

\end{itemize}

\sphinxtitleref{prmesh\#Thi} is the local mesh of the subdomain for each mpi process

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}

\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{mpirank}\PYG{p}{,} \PYG{n}{MThi}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Copy and paste this to a file ‘test.edp’ and run it:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{2} test.edp \PYGZhy{}glut ffglut
\end{sphinxVerbatim}


\paragraph{Step 2: Define your finite element}
\label{\detokenize{documentation/ffddm/tutorial:step-2-define-your-finite-element}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{prfe} \PYG{p}{,} \PYG{n}{prmesh} \PYG{p}{,} \PYG{n}{scalar} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n}{Pk} \PYG{p}{)}
\end{sphinxVerbatim}

builds the local finite element spaces and associated distributed operators on top of the mesh decomposition \sphinxstylestrong{prmesh}
\begin{itemize}
\item {} 
\sphinxstylestrong{scalar}: type of data for this finite element: \sphinxstyleemphasis{real} or \sphinxstyleemphasis{complex}

\item {} 
\sphinxstylestrong{Pk}: your type of finite element: P1, {[}P2,P2,P1{]}, …

\item {} 
\sphinxstylestrong{def}, \sphinxstylestrong{init}: macros specifying how to define and initialize a \sphinxstylestrong{Pk} FE function

\end{itemize}

\sphinxtitleref{prfe\#Vhi} is the local FE space defined on \sphinxtitleref{prmesh\#Thi} for each mpi process

Example for P2 \sphinxstyleemphasis{complex}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{k+kt}{complex}\PYG{p}{,}
                    \PYG{n}{def}\PYG{p}{,} \PYG{k+kp}{init}\PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\end{sphinxVerbatim}

Example for {[}P2,P2,P1{]} \sphinxstyleemphasis{real}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{]}     \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,}
                    \PYG{k+kp}{init}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{]} \PYG{p}{)}
\end{sphinxVerbatim}


\subparagraph{Distributed vectors and restriction operators}
\label{\detokenize{documentation/ffddm/tutorial:distributed-vectors-and-restriction-operators}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{domain2}.png}\hspace*{\fill}}

Natural decomposition of the set of d.o.f.’s \({\mathcal N}\) of \(Vh\) into the \(N\) subsets of d.o.f.’s \(({\mathcal N}_i)_{i=1}^N\) each associated with the local FE space \(Vh_i\)
\begin{equation*}
\begin{split}{\mathcal N} = \cup_{i=1}^N {\mathcal N}_i\,,\end{split}
\end{equation*}
but with duplications of the d.o.f.’s in the overlap

\sphinxstylestrong{\_Definition\_} a \sphinxstyleemphasis{distributed vector} is a collection of local vectors \(({\mathbf V_i})_{1\le i\le N}\) so that the values on the duplicated d.o.f.’s are the same:
\begin{equation*}
\begin{split}{\mathbf V}_i = R_i\,{\mathbf V}, \quad i = 1, ..., N\end{split}
\end{equation*}
where \({\mathbf V}\) is the corresponding global vector
and \(R_i\) is the \sphinxstyleemphasis{restriction operator} from \({\mathcal N}\) into \({\mathcal N}_i\)

\sphinxstylestrong{Remark} \(R_i^T\) is the \sphinxstyleemphasis{extension operator}: extension by \(0\) from \({\mathcal N}_i\) into \({\mathcal N}\)


\subparagraph{Partition of unity}
\label{\detokenize{documentation/ffddm/tutorial:partition-of-unity}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.750\linewidth]{{domain3}.png}\hspace*{\fill}}

Duplicated unknowns coupled via a \sphinxstyleemphasis{partition of unity}:
\begin{equation*}
\begin{split}I = \sum_{i = 1}^N R_i^T D_i R_i\end{split}
\end{equation*}
\((D_i)_{1\le i \le N}\) are square diagonal matrices of size \(\#{\mathcal N}_i\)
\begin{equation*}
\begin{split}{\mathbf V} = \sum_{i = 1}^N R_i^T D_i R_i {\mathbf V} = \sum_{i = 1}^N R_i^T D_i {\mathbf V_i}\end{split}
\end{equation*}

\subparagraph{Data exchange between neighbors}
\label{\detokenize{documentation/ffddm/tutorial:data-exchange-between-neighbors}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{update}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vi}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{scale}\PYG{p}{)}
\end{sphinxVerbatim}

synchronizes local vectors \({\mathbf V}_i\) between subdomains \(\Rightarrow\) exchange the values of \(mathbf{V}_i\) shared with neighbors in the overlap region
\begin{equation*}
\begin{split}{\mathbf V}_i \leftarrow R_i \left( \sum_{j=1}^N R_j^T D_j {\mathbf V}_j \right) = D_i {\mathbf V}_i + \sum_{j\in \mathcal{O}(i)} R_i\,R_j^T\,D_j {\mathbf V}_j\end{split}
\end{equation*}
where \(\mathcal{O}(i)\) is the set of neighbors of subdomain \$i\$. Exchange operators \(R_i\,R_j^T\) correspond to neighbor-to-neighbor MPI communications

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{,} \PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}{\mathbf V}_i \leftarrow R_i \left( \sum_{j=1}^N R_j^T {\mathbf V}_j \right)\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{,} \PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}{\mathbf V}_i \leftarrow R_i \left( \sum_{j=1}^N R_j^T D_j {\mathbf V}_j  \right)\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}

\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{vi} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{v}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{mpirank}\PYG{p}{,} \PYG{n}{MThi}\PYG{p}{,} \PYG{n}{vi}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{vi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{FEDk}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{D}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{mpirank}\PYG{p}{,} \PYG{n}{MThi}\PYG{p}{,} \PYG{n}{vi}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{vi} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,}\PYG{n}{vi}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,}\PYG{n}{vi}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{multiplicity}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Step 3: Define your problem}
\label{\detokenize{documentation/ffddm/tutorial:step-3-define-your-problem}}\label{\detokenize{documentation/ffddm/tutorial:ffddmtutorialdefineyourproblem}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{prfe} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\end{sphinxVerbatim}

builds the distributed operator associated to your variational form on top of the distributed FE \sphinxstylestrong{prfe}

\sphinxstylestrong{Varf} is a macro defining your abstract variational form

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\end{sphinxVerbatim}

\(\Rightarrow\) assemble local ‘Dirichlet’ matrices \(A_i = R_i A R_i^T\)
\begin{equation*}
\begin{split}A = \sum_{i=1}^N R_i^T D_i A_i R_i\end{split}
\end{equation*}
\begin{sphinxadmonition}{warning}{Warning:}
only true because \(D_i R_i A = D_i A_i R_i\) due to the fact that \(D_i\) vanishes at the interface \sphinxstylestrong{!!}
\end{sphinxadmonition}

\sphinxtitleref{pr\#A} applies \(A\) to a distributed vector: \({\mathbf U}_i \leftarrow R_i \sum_{j=1}^N R_j^T D_j A_j {\mathbf V}_j\)

\(\Rightarrow\) multiply by \(A_i\) + \sphinxtitleref{prfe\#update}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}

\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}

\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBA}\PYG{p}{(}\PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A*b}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Summary so far: translating your sequential \sphinxstyleemphasis{FreeFem++} script}
\label{\detokenize{documentation/ffddm/tutorial:summary-so-far-translating-your-sequential-freefem-script}}

\paragraph{Step 1: Decompose the mesh}
\label{\detokenize{documentation/ffddm/tutorial:id1}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{mpiCommWorld}\PYG{p}{)}
\end{sphinxVerbatim}

Step 2: Define your finite element

See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kp}{init}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}
\end{sphinxVerbatim}

Step 3: Define your problem

See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{Pb}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{Pb}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{FE}\PYG{p}{,} \PYG{n}{Varf}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Solve the linear system}
\label{\detokenize{documentation/ffddm/tutorial:solve-the-linear-system}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{b}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBdirectsolve}\PYG{p}{(}\PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Solve the linear system with the parallel direct solver \sphinxstyleemphasis{MUMPS}}
\label{\detokenize{documentation/ffddm/tutorial:solve-the-linear-system-with-the-parallel-direct-solver-mumps}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{directsolve}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{bi}\PYG{p}{)}
\end{sphinxVerbatim}

We have \(A\) and \(b\) in distributed form, we can solve the linear system \(A u = b\) using the parallel direct solver \sphinxstyleemphasis{MUMPS}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve the problem using the direct parallel solver MUMPS}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBdirectsolve}\PYG{p}{(}\PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Step 4: Define the one level DD preconditioner}
\label{\detokenize{documentation/ffddm/tutorial:step-4-define-the-one-level-dd-preconditioner}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{VarfPrec} \PYG{p}{)}
\end{sphinxVerbatim}

builds the one level preconditioner for problem \sphinxstylestrong{pr}.

By default it is the \sphinxstyleemphasis{Restricted Additive Schwarz (RAS)} preconditioner:
\begin{equation*}
\begin{split}M^{-1}_1 = M^{-1}_{\text{RAS}} = \sum_{i=1}^N R_i^T D_i A_i^{-1} R_i \quad \text{with}\; A_i = R_i A R_i^T\end{split}
\end{equation*}
\sphinxstylestrong{\_Setup step\_}: compute the \(LU\) (or \(L D L^T\)) factorization of local matrices \(A_i\)

\sphinxtitleref{pr\#PREC1} applies \(M^{-1}_1\) to a distributed vector: \({\mathbf U}_i \leftarrow R_i \sum_{j=1}^N R_j^T D_j A_j^{-1} {\mathbf V}_i\)

\(\Rightarrow\) apply \(A_i^{-1}\) (forward/backward substitutions) + \sphinxtitleref{prfe\#update}


\paragraph{Step 5: Solve the linear system with preconditioned GMRES}
\label{\detokenize{documentation/ffddm/tutorial:step-5-solve-the-linear-system-with-preconditioned-gmres}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationsolvinglinearsystem}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{fGMRES}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{x0i}\PYG{p}{,} \PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{bi}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{itmax}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{sp}\PYG{p}{)}
\end{sphinxVerbatim}

solves the linear system with flexible GMRES with DD preconditioner \(M^{-1}\)
\begin{itemize}
\item {} 
\sphinxstylestrong{x0i}: initial guess

\item {} 
\sphinxstylestrong{bi}: right-hand side

\item {} 
\sphinxstylestrong{eps}: relative tolerance

\item {} 
\sphinxstylestrong{itmax}: maximum number of iterations

\item {} 
\sphinxstylestrong{sp}: \sphinxtitleref{“left”} or \sphinxtitleref{“right”} preconditioning

\end{itemize}

\sphinxstyleemphasis{left preconditioning}

solve \(M^{-1} A x = M^{-1} b\)

\sphinxstyleemphasis{right preconditioning}

solve \(A M^{-1} y = b\)

\(\Rightarrow x = M^{-1} y\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Step 5: Solve the linear system with GMRES}
\PYG{n}{FEVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{PBwritesummary}
\end{sphinxVerbatim}


\subsubsection{Define a two level DD preconditioner}
\label{\detokenize{documentation/ffddm/tutorial:define-a-two-level-dd-preconditioner}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\sphinxstylestrong{Goal} improve scalability of the one level method

\(\Rightarrow\) enrich the one level preconditioner with a \sphinxstyleemphasis{coarse problem} coupling all subdomains

Main ingredient is a rectangular matrix \(\color{red}{Z}\) of size \(n \times n_c,\,\) where \(n_c \ll n\)
\(\color{red}{Z}\) is the \sphinxstyleemphasis{coarse space} matrix

The \sphinxstyleemphasis{coarse space operator} \(E = \color{red}{Z}^T A \color{red}{Z}\) is a square matrix of size \(n_c \times n_c\)

The simplest way to enrich the one level preconditioner is through the \sphinxstyleemphasis{additive coarse correction} formula:
\begin{equation*}
\begin{split}M^{-1}_2 = M^{-1}_1 + \color{red}{Z} E^{-1} \color{red}{Z}^T\end{split}
\end{equation*}
\sphinxstyleemphasis{How to choose \$color\{red\}\{Z\}\$ ?}


\subsubsection{Build the GenEO coarse space}
\label{\detokenize{documentation/ffddm/tutorial:build-the-geneo-coarse-space}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmgeneosetup}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\end{sphinxVerbatim}

The \sphinxstyleemphasis{GenEO} method builds a robust coarse space for highly heterogeneous or anisotropic \sphinxstylestrong{SPD} problems

\(\Rightarrow\) solve a local generalized eigenvalue problem in each subdomain
\begin{equation*}
\begin{split}D_i A_i D_i\, V_{i,k} = \lambda_{i,k}\, A_i^{\text{Neu}} \,V_{i,k}\end{split}
\end{equation*}
with \(A_i^{\text{Neu}}\) the local Neumann matrices built from \sphinxstylestrong{Varf} (same \sphinxstylestrong{Varf} as {\hyperref[\detokenize{documentation/ffddm/tutorial:ffddmtutorialdefineyourproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{Step 3}}}}

The GenEO coarse space is \(\color{red}{Z} = (R_i^T D_i V_{i,k})^{i=1,...,N}_{\lambda_{i,k} \ge \color{blue}{\tau}}\)
The eigenvectors \(V_{i,k}\) selected to enter the coarse space correspond to eigenvalues \(\lambda_{i,k} \ge \color{blue}{\tau}\), where \(\color{blue}{\tau}\) is a threshold parameter
\begin{quote}

\sphinxstylestrong{Theorem}
the spectrum of the preconditioned operator lies in the interval \([\displaystyle \frac{1}{1+k_1 \color{blue}{\tau}} , k_0 ]\)
where \(k_0 - 1\) is the \# of neighbors and \(k_1\) is the multiplicity of intersections
\(\Rightarrow\) \(k_0\) and \(k_1\) do not depend on \(N\) nor on the PDE
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Build the GenEO coarse space}
\PYG{n}{ffddmgeneosetup}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Step 5: Solve the linear system with GMRES}
\PYG{n}{FEVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Build the coarse space from a coarse mesh}
\label{\detokenize{documentation/ffddm/tutorial:build-the-coarse-space-from-a-coarse-mesh}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmcoarsemeshsetup}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{Thc} \PYG{p}{,} \PYG{n}{VarfEprec} \PYG{p}{,} \PYG{n}{VarfAprec} \PYG{p}{)}
\end{sphinxVerbatim}

For \sphinxstylestrong{non SPD} problems, an alternative is to build the coarse space by discretizing the PDE on a coarser mesh \sphinxstylestrong{Thc}

\(Z\) will be the \sphinxstyleemphasis{interpolation matrix} from the coarse FE space \({Vh}_c\) to the original FE space \(Vh\)

\(\Rightarrow E=\color{red}{Z}^{T} A \color{red}{Z}\) is the matrix of the problem discretized on the coarse mesh

The variational problem to be discretized on \sphinxstylestrong{Thc} is given by macro \sphinxstylestrong{VarfEprec}

\sphinxstylestrong{VarfEprec} can differ from the original \sphinxstylestrong{Varf} of the problem

\sphinxstyleemphasis{Example}: added absorption for wave propagation problems

Similarly, \sphinxstylestrong{VarfAprec} specifies the global operator involved in multiplicative coarse correction formulas. It defaults to \(A\) if \sphinxstylestrong{VarfAprec} is not defined

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Build the coarse space from a coarse mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thc} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmcoarsemeshsetup}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Thc} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{null} \PYG{p}{)}

\PYG{c+c1}{// Step 5: Solve the linear system with GMRES}
\PYG{n}{FEVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Use \sphinxstylestrong{HPDDM} within \sphinxstylestrong{ffddm}}
\label{\detokenize{documentation/ffddm/tutorial:use-hpddm-within-ffddm}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\sphinxstylestrong{ffddm} allows you to use \sphinxstylestrong{HPDDM} to solve your problem, effectively replacing the \sphinxstylestrong{ffddm} implementation of all parallel linear algebra computations

\(\Rightarrow\) define your problem with \sphinxstylestrong{ffddm}, solve it with \sphinxstylestrong{HPDDM}

\(\Rightarrow\) \sphinxstylestrong{ffddm} acts as a finite element interface for \sphinxstylestrong{HPDDM}
\begin{itemize}
\item {} 
you can use \sphinxstylestrong{HPDDM} features unavailable in \sphinxstylestrong{ffddm} such as advanced Krylov subspace methods implementing block and recycling techniques

\item {} 
conversely, some features of \sphinxstylestrong{ffddm} such as two level methods built from a coarse mesh are not implemented in \sphinxstylestrong{HPDDM}

\end{itemize}

To switch to \sphinxstylestrong{HPDDM}, simply define the macro \sphinxtitleref{pr\#withhpddm} before using \sphinxtitleref{ffddmsetupOperator} ({\hyperref[\detokenize{documentation/ffddm/tutorial:ffddmtutorialdefineyourproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{Step 3}}}}). You can then pass \sphinxstylestrong{HPDDM} options
with command-line arguments or directly to the underlying \sphinxstylestrong{HPDDM} operator:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{PBwithhpddm}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{1} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{PBhpddmOP}\PYG{p}{,}\PYG{k+kp}{sparams}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}krylov\PYGZus{}method gcrodr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Or, define \sphinxtitleref{pr\#withhpddmkrylov} to use \sphinxstylestrong{HPDDM} only for the Krylov method

Example \sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/Helmholtz-2d-HPDDM-BGMRES.edp}{here}: Helmholtz problem with multiple rhs solved with Block GMRES


\subsubsection{Some results: Heterogeneous 3D elasticity with GenEO}
\label{\detokenize{documentation/ffddm/tutorial:some-results-heterogeneous-3d-elasticity-with-geneo}}
Heterogeneous 3D linear elasticity equation discretized with P2 FE solved on 4096 MPI processes \(n\approx\) 262 million

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{comparisonAMG}.png}


\subsubsection{Some results: 2-level DD for Maxwell equations, scattering from the COBRA cavity}
\label{\detokenize{documentation/ffddm/tutorial:some-results-2-level-dd-for-maxwell-equations-scattering-from-the-cobra-cavity}}
f = 10 GHz


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxincludegraphics[width=0.750\linewidth]{{10GHz_borders_new_v2}.png}
&
\sphinxincludegraphics[width=1.000\linewidth]{{10GHz_new}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

f = 16 GHz

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{16GHz_new}.png}\hspace*{\fill}}


\subsubsection{Some results: 2-level DD for Maxwell equations, scattering from the COBRA cavity}
\label{\detokenize{documentation/ffddm/tutorial:id2}}\begin{itemize}
\item {} 
order 2 Nedelec edge FE

\item {} 
fine mesh: 10 points per wavelength

\item {} 
coarse mesh: 3.33 points per wavelength

\item {} 
two level ORAS preconditioner with added absorption

\item {} 
f = 10 GHz: \(n\approx\) 107 million, \(n_c \approx\) 4 million
\begin{quote}

f = 16 GHz: \(n\approx\) 198 million, \(n_c \approx\) 7.4 million
\end{quote}

\end{itemize}

\(\rightarrow\) coarse problem too large for a direct solver
\(\Rightarrow\) inexact coarse solve: GMRES + one level ORAS preconditioner

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.750\linewidth]{{table}.png}\hspace*{\fill}}

speedup of 1.81 from 1536 to 3072 cores at 10GHz

1.51 from 3072 to 6144 cores at 16GHz

You can find the script \sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/Maxwell\_Cobracavity.edp}{here}


\subsection{Examples}
\label{\detokenize{documentation/ffddm/examples:examples}}\label{\detokenize{documentation/ffddm/examples:ffddmexamples}}\label{\detokenize{documentation/ffddm/examples::doc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
File name
&\sphinxstyletheadfamily 
\(M^{-1}_1\)
&\sphinxstyletheadfamily 
\(M^{-1}_2\)
&\sphinxstyletheadfamily 
inexact CS
&\sphinxstyletheadfamily 
comments
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/diffusion-3d-minimal-direct.edp}{diffusion-3d-minimal-direct.edp}
&&&&
direct solver MUMPS
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/diffusion-3d-minimal-ddm.edp}{diffusion-3d-minimal-ddm.edp}
&
RAS
&
GenEO
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/diffusion-3d-simple.edp}{diffusion-3d-simple.edp}
&
RAS
&
GenEO
&&
comparison with direct solver
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/diffusion-2d-thirdlevelgeneo.edp}{diffusion-2d-thirdlevelgeneo.edp}
&
RAS
&
GenEO
&
RAS + GenEO
&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/elasticity-3d-simple.edp}{elasticity-3d-simple.edp}
&
RAS
&
GenEO
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/elasticity-3d-thirdlevelgeneo.edp}{elasticity-3d-thirdlevelgeneo.edp}
&
RAS
&
GenEO
&
RAS + GenEO
&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/Helmholtz-2d-simple.edp}{Helmholtz-2d-simple.edp}
&
ORAS
&
Coarse Mesh
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/Helmholtz-2d-marmousi.edp}{Helmholtz-2d-marmousi.edp}
&
ORAS
&
Coarse Mesh
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/Helmholtz-3d-simple.edp}{Helmholtz-3d-simple.edp}
&
ORAS
&
Coarse Mesh
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/Helmholtz-3d-overthrust.edp}{Helmholtz-3d-overthrust.edp}
&
ORAS
&&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/Helmholtz-2d-HPDDM-BGMRES.edp}{Helmholtz-2d-HPDDM-BGMRES.edp}
&
ORAS
&&&
multi-rhs Block GMRES with HPDDM
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/Navier-2d-marmousi2.edp}{Navier-2d-marmousi2.edp}
&
ORAS
&
Coarse Mesh
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/Maxwell-3d-simple.edp}{Maxwell-3d-simple.edp}
&
ORAS
&
Coarse Mesh
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/Maxwell\_Cobracavity.edp}{Maxwell\_Cobracavity.edp}
&
ORAS
&
Coarse Mesh
&
ORAS
&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/natural\_convection.edp}{natural\_convection.edp}
&
ORAS
&
Coarse Mesh
&&
nonlinear
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/natural\_convection\_3D\_obstacle.edp}{natural\_convection\_3D\_obstacle.edp}
&
ORAS
&
Coarse Mesh
&&
nonlinear
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples\%2B\%2B-ffddm/Richards-2d.edp}{Richards-2d.edp}
&
RAS
&&&
nonlinear time dependent mesh adaptation
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{Language references}
\label{\detokenize{reference/index:language-references}}\label{\detokenize{reference/index::doc}}
In essence \sphinxstylestrong{FreeFem++} is a compiler: its language is typed, polymorphic, with exception and reentrant.
Every variable must be declared of a certain type, in a declarative statement; each statement are separated from the next by a semicolon \sphinxcode{\sphinxupquote{;}}.

The language allows the manipulation of basic types integers (\sphinxcode{\sphinxupquote{int}}), reals (\sphinxcode{\sphinxupquote{real}}), strings (\sphinxcode{\sphinxupquote{string}}), arrays (example: \sphinxcode{\sphinxupquote{real{[}int{]}}}), bi-dimensional (2D) finite element meshes (\sphinxcode{\sphinxupquote{mesh}}), 2D finite element spaces (\sphinxcode{\sphinxupquote{fespace}}), analytical functions (\sphinxcode{\sphinxupquote{func}}), arrays of finite element functions (\sphinxcode{\sphinxupquote{func{[}basic\_type{]}}}), linear and bilinear operators, sparse matrices, vectors , etc.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{c+c1}{//i, n are integer}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//two array of size n}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//which can be used in statements such as}
    \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The life of a variable is the current block \sphinxcode{\sphinxupquote{\{...\}}}, except the \sphinxcode{\sphinxupquote{fespace}} variable, and the variables local to a block are destroyed at the end of the block as follows.

\begin{sphinxadmonition}{tip}{Tip:}
Example

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//unit square mesh}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//P1 Lagrange finite element space}
\PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{k+kr}{x} \PYG{o}{+} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{z}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{log}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZob{}} \PYG{c+c1}{// new block}
    \PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//not the same r}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//error because Vh is a global name}
\PYG{p}{\PYGZcb{}}\PYG{c+c1}{// end of block}
\PYG{c+c1}{//here r back to 0.01}
\end{sphinxVerbatim}
\end{sphinxadmonition}

The type declarations are mandatory in \sphinxstylestrong{FreeFem++}; in the end this feature is an asset because it is easy to make bugs in a language with many implicit types.

The variable name is just an alphanumeric string, the underscore character \sphinxcode{\sphinxupquote{\_}} is not allowed, because it will be used as an operator in the future.


\section{Types}
\label{\detokenize{reference/types:types}}\label{\detokenize{reference/types:referencetypes}}\label{\detokenize{reference/types::doc}}

\subsection{Standard types}
\label{\detokenize{reference/types:standard-types}}

\subsubsection{int}
\label{\detokenize{reference/types:int}}
Integer value (equivalent to \sphinxcode{\sphinxupquote{long}} in \sphinxcode{\sphinxupquote{C++}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{bool}
\label{\detokenize{reference/types:bool}}
Boolean value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{b} \PYG{o}{=} \PYG{k+kr}{true}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
The result of a comparison is a boolean

\sphinxcode{\sphinxupquote{bool b = (1 \textless{} 2);}}
\end{sphinxadmonition}


\subsubsection{real}
\label{\detokenize{reference/types:real}}
Real value (equivalent to \sphinxcode{\sphinxupquote{double}} in \sphinxcode{\sphinxupquote{C++}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{complex}
\label{\detokenize{reference/types:complex}}
Complex value (equivalent to two \sphinxcode{\sphinxupquote{double}} or \sphinxcode{\sphinxupquote{complex\textless{}double\textgreater{}}} in \sphinxcode{\sphinxupquote{C++}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{complex} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{;}
\end{sphinxVerbatim}

The imaginary number \(i\) is defined as \sphinxcode{\sphinxupquote{1i}}

\begin{sphinxadmonition}{tip}{Tip:}
Example

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{complex} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{n}{i}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a + b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a \PYGZhy{} b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a*b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{o}{*}\PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a/b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{o}{/}\PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
a + \PYG{n+nv}{b} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{2},4\PYG{o}{)}
a \PYGZhy{} \PYG{n+nv}{b} \PYG{o}{=} \PYG{o}{(}\PYGZhy{}2,\PYGZhy{}2\PYG{o}{)}
a*b \PYG{o}{=} \PYG{o}{(}\PYGZhy{}3,2\PYG{o}{)}
a/b \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{0}.230769,0.153846\PYG{o}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
See {\hyperref[\detokenize{example/developers:examplecomplex}]{\sphinxcrossref{\DUrole{std,std-ref}{Complex example}}}} for a detailed example.
\end{sphinxadmonition}


\subsubsection{string}
\label{\detokenize{reference/types:string}}
String value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{string} \PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{this is a string}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{string}} value is enclosed within double quotes.
\end{sphinxadmonition}

Other types can be concatenate to a string, like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the int i = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{i} \PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, the real r = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{r} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, the complex z = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

To append a string in a string at position 4:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{s}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+++}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

To copy a substring in an other string:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{string} \PYG{n}{s2} \PYG{o}{=} \PYG{n}{s1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

See {\hyperref[\detokenize{example/developers:examplestring}]{\sphinxcrossref{\DUrole{std,std-ref}{String Example}}}} for a complete example.


\subsection{Mesh design}
\label{\detokenize{reference/types:mesh-design}}

\subsubsection{border}
\label{\detokenize{reference/types:border}}
Border type.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Define the 2D geometrical border in parametric coordinates.

\begin{sphinxadmonition}{note}{Note:}
Label

A label can be defined with the border:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Inner variable

An inner variable can be defined inside a border:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kt}{real} \PYG{n}{tt}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{tt}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{tt}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
From vector

A border can be defined from two vectors using :freefem{}`P.x{}` and \sphinxcode{\sphinxupquote{P.y}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vectorX}\PYG{p}{.}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{vectorX}\PYG{p}{[}\PYG{k+kp}{t}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{P}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{vectorY}\PYG{p}{[}\PYG{k+kp}{t}\PYG{p}{]}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{mesh}
\label{\detokenize{reference/types:mesh}}
2D Mesh type (see {\hyperref[\detokenize{documentation/meshGeneration:meshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{mesh3}
\label{\detokenize{reference/types:mesh3}}
3D mesh type (see {\hyperref[\detokenize{documentation/meshGeneration:meshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Finite element space design}
\label{\detokenize{reference/types:finite-element-space-design}}

\subsubsection{fespace}
\label{\detokenize{reference/types:fespace}}
Finite element space type (see {\hyperref[\detokenize{documentation/finiteElement:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Element}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Uh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{UPh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

A finite element space is based on a mesh (\sphinxcode{\sphinxupquote{Th}}) with an element definition, scalar (\sphinxcode{\sphinxupquote{P1}}) or vector (\sphinxcode{\sphinxupquote{{[}P2, P2, P1{]}}}).

\sphinxstylestrong{Available finite element space:}

Generic:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{P0 / P03d}}

\item {} 
\sphinxcode{\sphinxupquote{P0Edge}}

\item {} 
\sphinxcode{\sphinxupquote{P1 / P13d}}

\item {} 
\sphinxcode{\sphinxupquote{P1dc}}

\item {} 
\sphinxcode{\sphinxupquote{P1b / P1b3d}}

\item {} 
\sphinxcode{\sphinxupquote{P1bl / P1bl3d}}

\item {} 
\sphinxcode{\sphinxupquote{P1nc}}

\item {} 
\sphinxcode{\sphinxupquote{P2 / P23d}}

\item {} 
\sphinxcode{\sphinxupquote{P2b}}

\item {} 
\sphinxcode{\sphinxupquote{P2dc}}

\item {} 
\sphinxcode{\sphinxupquote{P2h}}

\item {} 
\sphinxcode{\sphinxupquote{RT0 / RT03d}}

\item {} 
\sphinxcode{\sphinxupquote{RT0Ortho}}

\item {} 
\sphinxcode{\sphinxupquote{Edge03d}}

\end{itemize}

Using \sphinxstyleemphasis{Element\_P3}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{P3}}

\end{itemize}

Using \sphinxstyleemphasis{Element\_P3dc}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{P3dc}}

\end{itemize}

Using \sphinxstyleemphasis{Element\_P4}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{P4}}

\end{itemize}

Using \sphinxstyleemphasis{Element\_P4dc}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{P4dc}}

\end{itemize}

Using \sphinxstyleemphasis{Element\_PkEdge}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{P1Edge}}

\item {} 
\sphinxcode{\sphinxupquote{P2Edge}}

\item {} 
\sphinxcode{\sphinxupquote{P3Edge}}

\item {} 
\sphinxcode{\sphinxupquote{P4Edge}}

\item {} 
\sphinxcode{\sphinxupquote{P5Edge}}

\end{itemize}

Using \sphinxstyleemphasis{Morlay}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{P2Morley}}

\end{itemize}

Using \sphinxstyleemphasis{HCT}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{HCT}}

\end{itemize}

Using \sphinxstyleemphasis{BernardiRaugel}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{P2BR}}

\end{itemize}

Using \sphinxstyleemphasis{Element\_Mixte}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RT1}}

\item {} 
\sphinxcode{\sphinxupquote{RT1Ortho}}

\item {} 
\sphinxcode{\sphinxupquote{RT2}}

\item {} 
\sphinxcode{\sphinxupquote{RT2Ortho}}

\item {} 
\sphinxcode{\sphinxupquote{BDM1}}

\item {} 
\sphinxcode{\sphinxupquote{BDM1Ortho}}

\end{itemize}

Using \sphinxstyleemphasis{Element\_Mixte3d}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Edge13d}}

\item {} 
\sphinxcode{\sphinxupquote{Edge23d}}

\end{itemize}

Using \sphinxstyleemphasis{Element\_QF}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{FEQF}}

\end{itemize}

A finite element function is defined as follow:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Uh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{u}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{UPh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{UPh} \PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Macro design}
\label{\detokenize{reference/types:macro-design}}\label{\detokenize{reference/types:typemacrodesign}}

\subsubsection{macro}
\label{\detokenize{reference/types:macro}}
Macro type.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{vU}\PYG{p}{(}\PYG{p}{)} \PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\end{sphinxVerbatim}

Macro ends with \sphinxcode{\sphinxupquote{//}}.

\begin{sphinxadmonition}{note}{Note:}
Macro concatenation

You can use the C concatenation operator \sphinxcode{\sphinxupquote{\#\#}} inside a macro using \sphinxcode{\sphinxupquote{\#}}.

If \sphinxtitleref{Ux} and \sphinxtitleref{Uy} are defined as finite element function, you can define:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)} \PYG{p}{[}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// End of macro}
\end{sphinxVerbatim}
\end{sphinxadmonition}

See {\hyperref[\detokenize{example/developers:examplemacro}]{\sphinxcrossref{\DUrole{std,std-ref}{Macro example}}}}


\subsubsection{NewMacro / EndMacro}
\label{\detokenize{reference/types:newmacro-endmacro}}
\begin{sphinxadmonition}{warning}{Warning:}
In developement - Not tested
\end{sphinxadmonition}

Set and end a macro

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{NewMacro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{k+kt}{EndMacro}
\end{sphinxVerbatim}


\subsubsection{IFMACRO}
\label{\detokenize{reference/types:ifmacro}}
Check if a macro exists and check its value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{)} \PYG{c+c1}{//check if macro AA exists}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+cp}{ENDIFMACRO}

\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{n}{tt}\PYG{p}{)} \PYG{c+c1}{//check if amcro exists and is equall to tt}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+cp}{ENDIFMACRO}
\end{sphinxVerbatim}


\subsubsection{ENDIFMACRO}
\label{\detokenize{reference/types:endifmacro}}

\subsection{Functions design}
\label{\detokenize{reference/types:functions-design}}

\subsubsection{func}
\label{\detokenize{reference/types:func}}
Function type.

Function without parameters (\(x\), \(y\) and \(z\) are implicitly considered):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Function’s type is defined by the expression’s type.
\end{sphinxadmonition}

Function with parameters:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{f} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{var}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{var}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Elementary functions}
\label{\detokenize{reference/types:elementary-functions}}\label{\detokenize{reference/types:typeelementaryfunctions}}
Class of basic functions (polynomials, exponential, logarithmic, trigonometric, circular) and the functions obtained from those by the four arithmetic operations
\begin{equation*}
\begin{split}f(x) + g(x),\, f(x) - g(x),\, f(x)g(x),\, f(x)/g(x)\end{split}
\end{equation*}
and by composition \(f(g(x))\), each applied a finite number of times.

In \sphinxstylestrong{FreeFem++}, all elementary functions can thus be created.
The derivative of an elementary function is also an elementary function; however, the indefinite integral of an elementary function cannot always be expressed in terms of elementary functions.

See {\hyperref[\detokenize{example/developers:exampleelementaryfunction}]{\sphinxcrossref{\DUrole{std,std-ref}{Elementary function example}}}} for a complete example.


\subsubsection{Random functions}
\label{\detokenize{reference/types:random-functions}}
\sphinxstylestrong{FreeFem++} includes the \sphinxhref{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html}{Mersenne Twister} random number generator.
It is a very fast and accurate random number generator of period \(2^{219937}-1\).

See {\hyperref[\detokenize{reference/functions:referencerandint32}]{\sphinxcrossref{\DUrole{std,std-ref}{randint32()}}}}, {\hyperref[\detokenize{reference/functions:referencerandint31}]{\sphinxcrossref{\DUrole{std,std-ref}{randint31()}}}}, {\hyperref[\detokenize{reference/functions:referencerandreal1}]{\sphinxcrossref{\DUrole{std,std-ref}{randreal1()}}}}, {\hyperref[\detokenize{reference/functions:referencerandreal2}]{\sphinxcrossref{\DUrole{std,std-ref}{randreal2()}}}}, {\hyperref[\detokenize{reference/functions:referencerandreal3}]{\sphinxcrossref{\DUrole{std,std-ref}{randreal3()}}}}, {\hyperref[\detokenize{reference/functions:referencerandres53}]{\sphinxcrossref{\DUrole{std,std-ref}{randres53()}}}}, {\hyperref[\detokenize{reference/functions:referencerandinit}]{\sphinxcrossref{\DUrole{std,std-ref}{randinit(seed)}}}}.

In addition, the \sphinxcode{\sphinxupquote{ffrandom}} plugin interface \sphinxcode{\sphinxupquote{random}}, \sphinxcode{\sphinxupquote{srandom}} and \sphinxcode{\sphinxupquote{srandomdev}} functions of the Unix \sphinxcode{\sphinxupquote{libc}} library.
The range is \(0 -- 2^{31}-1\).

\begin{sphinxadmonition}{note}{Note:}
If \sphinxcode{\sphinxupquote{srandomdev}} is not defined, a seed based on the current time is used.
\end{sphinxadmonition}

\sphinxcode{\sphinxupquote{gsl}} plugin equally allows usage of all random functions of the \sphinxcode{\sphinxupquote{gsllib}}, see {\hyperref[\detokenize{reference/externalLibraries:referenceffgslawk}]{\sphinxcrossref{\DUrole{std,std-ref}{gsl external library}}}}.


\subsubsection{FE-functions}
\label{\detokenize{reference/types:fe-functions}}
Finite element functions are also constructed like elementary functions by an arithmetic formula involving elementary functions.

The difference is that they are evaluated at declaration time and \sphinxstylestrong{FreeFem++} stores the array of its values at the places associated with he degree of freedom of the finite element type.
By opposition, elementary functions are evaluated only when needed.
Hence FE-functions are not defined only by their formula but also by the mesh and the finite element which enter in their definitions.

If the value of a FE-function is requested at a point which is not a degree of freedom, an interpolation is used, leading to an interpolation error, while by contrast, an elementary function can be evaluated at any point exactly.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ]\PYGZhy{}2, 2[\PYGZca{}2}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh}\PYG{o}{=}\PYG{n}{f}\PYG{p}{;} \PYG{c+c1}{//fh is the projection of f to Vh (real value)}
\PYG{k+kt}{func} \PYG{n}{zf} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{exp}\PYG{p}{(}\PYG{k+kr}{x} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{zh} \PYG{o}{=} \PYG{n}{zf}\PYG{p}{;} \PYG{c+c1}{//zh is the projection of zf to complex value Vh space}
\end{sphinxVerbatim}

The construction of \sphinxcode{\sphinxupquote{fh = f}} is explained in {\hyperref[\detokenize{documentation/finiteElement:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Element}}}}.

\begin{sphinxadmonition}{warning}{Warning:}
The \sphinxcode{\sphinxupquote{plot}} command only works for real or complex FE-functions, not for elementary functions.
\end{sphinxadmonition}


\subsection{Problem design}
\label{\detokenize{reference/types:problem-design}}\label{\detokenize{reference/types:typeproblemdesign}}

\subsubsection{problem}
\label{\detokenize{reference/types:problem}}\label{\detokenize{reference/types:typeproblem}}
Problem type.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxstylestrong{FreeFem++} needs the variational form in the problem definition.

In order to solve the problem, just call:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Laplacian}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Solver

A solver can be specified in the problem definition:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

The default solver is \sphinxcode{\sphinxupquote{sparsesolver}} or \sphinxcode{\sphinxupquote{LU}} if any direct sparse solver is available.

Solvers are listed in the {\hyperref[\detokenize{reference/globalVariables:globalvariables}]{\sphinxcrossref{\DUrole{std,std-ref}{Global variables}}}} section.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Stop test

A criterion \(\varepsilon\) can be defined for iterative methods, like CG for example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

If \(\varepsilon>0\), the stop test is:
\begin{equation*}
\begin{split}||Ax-b|| < \varepsilon\end{split}
\end{equation*}
Else, the stop test is:
\begin{equation*}
\begin{split}||Ax-b|| < \frac{|\varepsilon|}{||Ax_0-b||}\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Reconstruction

The keyword \sphinxcode{\sphinxupquote{init}} controls the reconstruction of the internal problem matrix.

If \sphinxcode{\sphinxupquote{init}} is set to \sphinxcode{\sphinxupquote{false}} or \sphinxcode{\sphinxupquote{0}}, the matrix is reconstructed et each problem calls (or after a mesh modification), else the previously constructed matrix is used.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Preconditioning

A preconditioner can be specified in the problem definition:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{k+kr}{P}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

The preconditioning function must have a prototype like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{P}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{xx}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
“\sphinxstyleemphasis{Très grande valeur}”

The “\sphinxstyleemphasis{Très grand valeur}” \sphinxcode{\sphinxupquote{tgv}} (or \sphinxstyleemphasis{Terrible giant value}) used to implement the Dirichlet conditions can be modified in the problem definition:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mf}{1e30}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

Refere to {\hyperref[\detokenize{documentation/finiteElement:problemdefinition}]{\sphinxcrossref{\DUrole{std,std-ref}{Problem definition}}}} for a description of the Dirichlet condition implementation.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Pivot tolerance

The tolerance of the pivot in \sphinxcode{\sphinxupquote{UMFPACK}}, \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Crout}}, \sphinxcode{\sphinxupquote{Cholesky}} factorization can be modified in the problem definition:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{,} \PYG{k+kp}{tolpivot}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}20}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{UMFPACK}}

Two specific parameters for the \sphinxcode{\sphinxupquote{UMFPACK}} can be modifed:
\begin{itemize}
\item {} 
Tolerance of the pivot sym

\item {} 
strategy

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{,} \PYG{k+kp}{tolpivotsym}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}1}\PYG{p}{,} \PYG{k+kp}{strategy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

Refer to the \sphinxhref{http://faculty.cse.tamu.edu/davis/research.html}{UMFPACK website} for more informations.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{dimKrylov}}

Dimension of the Krylov space
\end{sphinxadmonition}

Usage of \sphinxcode{\sphinxupquote{problem}} is detailled in the {\hyperref[\detokenize{tutorial/index:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{tutorials}}}}.


\subsubsection{solve}
\label{\detokenize{reference/types:solve}}\label{\detokenize{reference/types:typesolve}}
Solve type.

Identical to {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}} but automatically solved.

Usage of \sphinxcode{\sphinxupquote{solve}} is detailled in the {\hyperref[\detokenize{tutorial/index:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{tutorials}}}}.


\subsubsection{varf}
\label{\detokenize{reference/types:varf}}\label{\detokenize{reference/types:typevarf}}
Variational form type.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n}{vLaplacian} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

Directly define a variational form.

This is the other way to define a problem in order to directly manage matrix and right hang side.

Usage of \sphinxcode{\sphinxupquote{varf}} is detailed in the {\hyperref[\detokenize{tutorial/index:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{tutorial}}}}.


\subsection{Array}
\label{\detokenize{reference/types:array}}
An array stores multiple objects, and there are 2 kinds of arrays:
\begin{itemize}
\item {} 
the first is similar to vector, i.e. array with integer indices

\item {} 
the second is array with string indices

\end{itemize}

In the first case, the size of the array must be known at execution time, and implementation is done with the \sphinxcode{\sphinxupquote{KN\textless{}\textgreater{}}} class and all the vector operator of \sphinxcode{\sphinxupquote{KN\textless{}\textgreater{}}} are implemented.

Arrays can be set like in Matlab or Scilab with the operator \sphinxcode{\sphinxupquote{::}}, the array generator of \sphinxcode{\sphinxupquote{a:c}} is equivalent to \sphinxcode{\sphinxupquote{a:1:c}}, and the array set by \sphinxcode{\sphinxupquote{a:b:c}} is set to size \(\lfloor |(b-a)/c|+1 \rfloor\) and the value \(i\) is set by \(a + i (b-a)/c\).

There are \sphinxcode{\sphinxupquote{int,real, complex}} array with, in the third case, two operators (\sphinxcode{\sphinxupquote{.im}}, \sphinxcode{\sphinxupquote{.re}}) to generate the real and imaginary real array from the complex array (without copy).

\begin{sphinxadmonition}{note}{Note:}
Quantiles are points taken at regular intervals from the cumulative distribution function of a random variable.
Here the array values are random.

This statistical function \sphinxcode{\sphinxupquote{a.quantile(q)}} computes \(v\) from an array \(a\) of size \(n\) for a given number \(q\in ]0,1[\) such that:
\begin{equation*}
\begin{split}\#\{ i / a[i] < v \} \sim q*n\end{split}
\end{equation*}
it is equivalent to \(v = a[q*n]\) when the array \(a\) is sorted.
\end{sphinxadmonition}

For example, to declare, fill and display an array of \sphinxcode{\sphinxupquote{real}} of size \sphinxcode{\sphinxupquote{n}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Ai}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{Ai}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{5}
      \PYG{l+m}{0}   \PYG{l+m}{1}   \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}
\end{sphinxVerbatim}

See the {\hyperref[\detokenize{example/developers:examplearray}]{\sphinxcrossref{\DUrole{std,std-ref}{Array example}}}} for a complete example.


\subsubsection{Array index}
\label{\detokenize{reference/types:array-index}}
Array index can be int or string:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Ai} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{As} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Array size}
\label{\detokenize{reference/types:array-size}}
The size of an array is obtained using the keyword \sphinxcode{\sphinxupquote{n}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{ArraySize} \PYG{o}{=} \PYG{n}{Ai}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Array sort}
\label{\detokenize{reference/types:array-sort}}
To sort an array:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Ai}\PYG{p}{.}\PYG{n+nf}{sort}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Double array}
\label{\detokenize{reference/types:double-array}}
A double array (matrix) can be defined using two indexes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Aii} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

The two sizes are obtained using the keywords \sphinxcode{\sphinxupquote{n}} and \sphinxcode{\sphinxupquote{m}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{ArraySize1} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ArraySize2} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{m}\PYG{p}{;}
\end{sphinxVerbatim}

The minimum and maximum values of an array (simple or double) can be obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{ArrayMin} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ArrayMax} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}
\end{sphinxVerbatim}

Th minimum and maximum position of an array can be obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{mini} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{imin}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{minj} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{n}{jmin}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{maxi} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{imax}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{maxj} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{n}{jmax}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
An array can be obtained from a finite element function using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{aU} \PYG{o}{=} \PYG{n}{U}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{U}} is a finite element function.
\end{sphinxadmonition}


\subsubsection{Array of FE functions}
\label{\detokenize{reference/types:array-of-fe-functions}}
It is also possible to make an array of FE functions, with the same syntax, and we can treat them as vector valued function if we need them.

The syntax for space or vector finite function is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{c+c1}{//size of the array.}
\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{wh}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//real scalar case}
\PYG{n}{Wh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{]}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//real vectorial case}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{cwh}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//complex scalar case}
\PYG{n}{Wh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{cuh}\PYG{p}{,} \PYG{n}{cvh}\PYG{p}{]}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//complex vectorial case}
\PYG{p}{[}\PYG{n}{cuh}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cvh}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//set interpolation of index 2}

\PYG{c+c1}{// Array of Array}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
Example

In the following example, Poisson’s equation is solved for 3 different given functions \(f=1,\, \sin(\pi x)\cos(\pi y),\, |x-1||y-1|\), whose solutions are stored in an array of FE function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{f}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
      \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
      \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{uu}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//an array of FE function}
\PYG{c+c1}{// Solve problem 1}
\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{c+c1}{// Solve problem 2}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{c+c1}{// Solve problem 3}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

See {\hyperref[\detokenize{example/developers:examplefearray}]{\sphinxcrossref{\DUrole{std,std-ref}{FE array example}}}}.
\end{sphinxadmonition}


\subsubsection{Map arrays}
\label{\detokenize{reference/types:map-arrays}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{map}\PYG{p}{;} \PYG{c+c1}{//a dynamic array}

\PYG{n}{map}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{2.0}\PYG{p}{;}
\PYG{n}{map}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{3.0}\PYG{p}{;} \PYG{c+c1}{//2 is automatically cast to the string \PYGZdq{}2\PYGZdq{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{map[}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{map}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{map[2] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{map}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

It is just a map of the standard template library so no operations on vector are allowed, except the selection of an item.


\subsection{matrix}
\label{\detokenize{reference/types:matrix}}\label{\detokenize{reference/types:typematrix}}
Defines a sparse matrix.

Matrices can be defined like vectors:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

or using a variational form type (see {\hyperref[\detokenize{documentation/finiteElement:variationalformsparsematrixpde}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Element}}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{Laplacian} \PYG{o}{=} \PYG{n}{vLaplacian}\PYG{p}{(}\PYG{n}{Uh}\PYG{p}{,} \PYG{n}{Uh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or from block of matrices:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A1}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{n}{An}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{k+kp}{A1}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{p}{[}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{n}{An}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

or using sparse matrix set:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{[}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{,} \PYG{n}{C}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{I}} and \sphinxcode{\sphinxupquote{J}} are \sphinxcode{\sphinxupquote{int{[}int{]}}} and \sphinxcode{\sphinxupquote{C}} is \sphinxcode{\sphinxupquote{real{[}int{]}}}. The matrix is defined as:
\begin{equation*}
\begin{split}A = \sum_k{C[k]M_{I[k], J[k]}}\end{split}
\end{equation*}
where \(M_{a, b} = \left(\delta_{ia}\delta_{jb}\right)_{ij}\)

\sphinxtitleref{I}, \sphinxtitleref{J} and \sphinxtitleref{C} can be retrieved using \sphinxtitleref{{[}I, J, C{]} = A} (arrays are automatically resized).

The size of the matrix is \sphinxcode{\sphinxupquote{n = I.max;}}, \sphinxcode{\sphinxupquote{m = J.max;}}.
\end{sphinxadmonition}

Matrices are designed using templates, so they can be real or complex:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{Ai} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Solver

See {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.

The default solver is {\hyperref[\detokenize{reference/globalVariables:globalvariablesgmres}]{\sphinxcrossref{\DUrole{std,std-ref}{GMRES}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vLaplacian}\PYG{p}{(}\PYG{n}{Uh}\PYG{p}{,} \PYG{n}{Uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A} \PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Factorize

If \sphinxcode{\sphinxupquote{true}}, the factorization is done for \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Cholesky}} or \sphinxcode{\sphinxupquote{Crout}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vLaplacian}\PYG{p}{(}\PYG{n}{Uh}\PYG{p}{,} \PYG{n}{Uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A} \PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Stop test

See {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstyleemphasis{Très grande valeur}

See {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Preconditioning

See {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Pivot tolerance

See {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{UMFPACK}}

See {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{dimKrylov}}

See {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
datafilename

Name of the file containing solver parameters, see {\hyperref[\detokenize{documentation/parallelization:parallelsparsesolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Parallel sparse solvers}}}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{lparams}}

Vector of integer parameters for the solver, see {\hyperref[\detokenize{documentation/parallelization:parallelsparsesolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Parallel sparse solvers}}}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{dparams}}

Vector of real parameters for the solver, see {\hyperref[\detokenize{documentation/parallelization:parallelsparsesolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Parallel sparse solvers}}}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{sparams}}

String parameters for the solver, see {\hyperref[\detokenize{documentation/parallelization:parallelsparsesolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Parallel sparse solvers}}}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
To modify the \sphinxcode{\sphinxupquote{solver}}, the stop test,… after the matrix construction, use the {\hyperref[\detokenize{reference/functions:functionset}]{\sphinxcrossref{\DUrole{std,std-ref}{set keyword}}}}.
\end{sphinxadmonition}


\subsubsection{Matrix size}
\label{\detokenize{reference/types:matrix-size}}
The size of a matrix is obtain using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{NRows} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{NColumns} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{m}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Matrix resize}
\label{\detokenize{reference/types:matrix-resize}}
To resize a matrix, use:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kp}{A}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
When resizing, all new terms are set to zero.
\end{sphinxadmonition}


\subsubsection{Matrix diagonal}
\label{\detokenize{reference/types:matrix-diagonal}}
The diagonal of the matrix is obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Aii} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Matrix renumbering}
\label{\detokenize{reference/types:matrix-renumbering}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{I}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{n}{J}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{;}
\PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{I}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{J}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Complex matrix}
\label{\detokenize{reference/types:complex-matrix}}
Use \sphinxcode{\sphinxupquote{.im}} and \sphinxcode{\sphinxupquote{.re}} to get the imaginary and real part of a complex matrix, respectively:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{C} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{matrix} \PYG{n}{R} \PYG{o}{=} \PYG{n}{C}\PYG{p}{.}\PYG{k+kr}{re}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{I} \PYG{o}{=} \PYG{n}{C}\PYG{p}{.}\PYG{k+kr}{im}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Dot product / Outer product}
\label{\detokenize{reference/types:dot-product-outer-product}}
The dot product of two matrices is realized using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{k+kp}{B}\PYG{p}{;}
\end{sphinxVerbatim}

The outer product of two matrices is realized using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{C} \PYG{o}{=} \PYG{k+kp}{A} \PYG{o}{*} \PYG{k+kp}{B}\PYG{o}{\PYGZsq{}}
\end{sphinxVerbatim}

See {\hyperref[\detokenize{example/developers:examplematrixoperations}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix operations example}}}} for a complete example.


\subsubsection{Matrix inversion}
\label{\detokenize{reference/types:matrix-inversion}}
See {\hyperref[\detokenize{example/developers:examplematrixinversion}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix inversion example}}}}.


\section{Global variables}
\label{\detokenize{reference/globalVariables:global-variables}}\label{\detokenize{reference/globalVariables:globalvariables}}\label{\detokenize{reference/globalVariables::doc}}

\subsection{area}
\label{\detokenize{reference/globalVariables:area}}
Area of the current triangle.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh0}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh0} \PYG{k+kp}{A} \PYG{o}{=} \PYG{k+kr}{area}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{ARGV}
\label{\detokenize{reference/globalVariables:argv}}
Array that contains all the command line arguments.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

See {\hyperref[\detokenize{example/developers:examplecommandlinearguments}]{\sphinxcrossref{\DUrole{std,std-ref}{Command line arguments example}}}} for a complete example.


\subsection{BoundaryEdge}
\label{\detokenize{reference/globalVariables:boundaryedge}}
Return 1 if the current edge is on a boundary, 0 otherwise.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{BoundaryEdge}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{CG}
\label{\detokenize{reference/globalVariables:cg}}
Conjugate gradient solver.

Usable in {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}} and {\hyperref[\detokenize{reference/types:typesolve}]{\sphinxcrossref{\DUrole{std,std-ref}{solve}}}} definition

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

Or in {\hyperref[\detokenize{reference/types:typematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{matrix}}}} construction

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vLaplacian}\PYG{p}{(}\PYG{n}{Uh}\PYG{p}{,} \PYG{n}{Uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Or in {\hyperref[\detokenize{reference/functions:functionset}]{\sphinxcrossref{\DUrole{std,std-ref}{set function}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Cholesky}
\label{\detokenize{reference/globalVariables:cholesky}}
Cholesky solver.


\subsection{Crout}
\label{\detokenize{reference/globalVariables:crout}}
Crout solver.


\subsection{edgeOrientation}
\label{\detokenize{reference/globalVariables:edgeorientation}}
Sign of \(i-j\) if the current edge is \([q_i, q_j]\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{S} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{edgeOrientation}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{false}
\label{\detokenize{reference/globalVariables:false}}
False boolean value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{b} \PYG{o}{=} \PYG{k+kr}{false}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{GMRES}
\label{\detokenize{reference/globalVariables:gmres}}\label{\detokenize{reference/globalVariables:globalvariablesgmres}}
GMRES solver (Generalized minimal residual method).


\subsection{hTriangle}
\label{\detokenize{reference/globalVariables:htriangle}}
Size of the current triangle.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{h} \PYG{o}{=} \PYG{k+kr}{hTriangle}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{include}
\label{\detokenize{reference/globalVariables:include}}
Include an {\hyperref[\detokenize{reference/externalLibraries:externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{external library}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{InternalEdge}
\label{\detokenize{reference/globalVariables:internaledge}}
Return 0 if the current edge is on a boundary, 1 otherwise.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{I} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{InternalEdge}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{label}
\label{\detokenize{reference/globalVariables:label}}
Label number of a boundary if the current point is on a boundary, 0 otherwise.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{L} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{xB}\PYG{p}{,} \PYG{n}{yB}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{label}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{lenEdge}
\label{\detokenize{reference/globalVariables:lenedge}}
Length of the current edge.

For an edge \([q_i, g_j]\), return \(|q_i-q_j|\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{load}
\label{\detokenize{reference/globalVariables:load}}
Load a script.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Element\PYGZus{}P3}\PYG{l+s}{\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{LU}
\label{\detokenize{reference/globalVariables:lu}}
LU solver.


\subsection{N}
\label{\detokenize{reference/globalVariables:n}}
Outward unit normal at the current point if it is on a curve defined by a border.
\sphinxcode{\sphinxupquote{N.x, N.y, N.z}} are respectively the \(x\), \(y\) and \(z\) components of the normal.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{Nx} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{Ny} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{Nz} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{z}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{nTonEdge}
\label{\detokenize{reference/globalVariables:ntonedge}}
Number of adjacent triangles of the current edge.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{nTE} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{nTonEdge}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{nuEdge}
\label{\detokenize{reference/globalVariables:nuedge}}
Index of the current edge in the triangle.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{nE} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{nuEdge}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{nuTriangle}
\label{\detokenize{reference/globalVariables:nutriangle}}
Index of the current triangle.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{k+kr}{n} \PYG{o}{=} \PYG{k+kr}{nuTriangle}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{P}
\label{\detokenize{reference/globalVariables:p}}
Current point.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{cx} \PYG{o}{=} \PYG{k+kr}{P}\PYG{p}{.}\PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cy} \PYG{o}{=} \PYG{k+kr}{P}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cz} \PYG{o}{=} \PYG{k+kr}{P}\PYG{p}{.}\PYG{k+kr}{z}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{pi}
\label{\detokenize{reference/globalVariables:pi}}
Pi = 3.14159.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{Pi} \PYG{o}{=} \PYG{k+kr}{pi}\PYG{p}{;}
\end{sphinxVerbatim}

This is a real value.


\subsection{region}
\label{\detokenize{reference/globalVariables:region}}
Region number of the current point. If the point is outside, then \sphinxcode{\sphinxupquote{region == notaregion}} where \sphinxcode{\sphinxupquote{notaregion}} is a \sphinxstylestrong{FreeFem++} integer constant.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{R} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{xR}\PYG{p}{,} \PYG{n}{yR}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{sparsesolver}
\label{\detokenize{reference/globalVariables:sparsesolver}}
Sparse matrix solver.


\subsection{true}
\label{\detokenize{reference/globalVariables:true}}
True boolean value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{b} \PYG{o}{=} \PYG{k+kr}{true}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{verbosity}
\label{\detokenize{reference/globalVariables:verbosity}}
Verbosity level.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Verbosity} \PYG{o}{=} \PYG{k+kr}{verbosity}\PYG{p}{;}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

0 = nothing, 1 = little information, 10 = a lot of information, …

This is an integer value.


\subsection{version}
\label{\detokenize{reference/globalVariables:version}}
\sphinxstylestrong{FreeFem++} version.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{version} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{volume}
\label{\detokenize{reference/globalVariables:volume}}
Volume of the current tetrahedra.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh0}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh0} \PYG{n}{V} \PYG{o}{=} \PYG{k+kr}{volume}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{x}
\label{\detokenize{reference/globalVariables:x}}
The \(x\) coordinate at the current point.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{CurrentX} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\end{sphinxVerbatim}

This is a real value.


\subsection{y}
\label{\detokenize{reference/globalVariables:y}}
The \(y\) coordinate at the current point.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{CurrentY} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{;}
\end{sphinxVerbatim}

This is a real value.


\subsection{z}
\label{\detokenize{reference/globalVariables:z}}
The \(z\) coordinate at the current point.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{CurrentZ} \PYG{o}{=} \PYG{k+kr}{z}\PYG{p}{;}
\end{sphinxVerbatim}

This is a real value.


\section{Quadrature formulae}
\label{\detokenize{reference/quadratureFormulae:quadrature-formulae}}\label{\detokenize{reference/quadratureFormulae:quadratureformulae}}\label{\detokenize{reference/quadratureFormulae::doc}}
The quadrature formula is like the following:
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx \sum_{\ell=1}^{L}{\omega_\ell f(\boldxi_\ell)}\end{split}
\end{equation*}

\subsection{int1d}
\label{\detokenize{reference/quadratureFormulae:int1d}}\label{\detokenize{reference/quadratureFormulae:quadratureformulaeint1d}}
Quadrature formula on an edge.


\subsubsection{Notations}
\label{\detokenize{reference/quadratureFormulae:notations}}
\(|D|\) is the measure of the edge \(D\).

For a shake of simplicity, we denote:
\begin{equation*}
\begin{split}f(\boldx) = g(t)\end{split}
\end{equation*}
with \(0\leq t\leq 1\); \(\boldx=(1-t)\boldx_0+t\boldx_1\).


\subsubsection{qf1pE}
\label{\detokenize{reference/quadratureFormulae:qf1pe}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf1pE}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_1\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx |D|g\left(\frac{1}{2}\right)\end{split}
\end{equation*}

\subsubsection{qf2pE}
\label{\detokenize{reference/quadratureFormulae:qf2pe}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf2pE}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_3\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx \frac{|D|}{2}\left(
      g\left( \frac{1+\sqrt{1/3}}{2} \right)
    + g\left( \frac{1-\sqrt{1/3}}{2} \right)
\right)\end{split}
\end{equation*}

\subsubsection{qf3pE}
\label{\detokenize{reference/quadratureFormulae:qf3pe}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf3pE}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_5\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx \frac{|D|}{18}\left(
      5g\left( \frac{1+\sqrt{3/5}}{2} \right)
    + 8g\left( \frac{1}{2} \right)
    + 5g\left( \frac{1-\sqrt{3/5}}{2} \right)
\right)\end{split}
\end{equation*}

\subsubsection{qf4pE}
\label{\detokenize{reference/quadratureFormulae:qf4pe}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf4pE}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_7\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx \frac{|D|}{72}\left(
      (18-\sqrt{30})g\left( \frac{1-\frac{\sqrt{525+70\sqrt{30}}}{35}}{2} \right)
    + (18-\sqrt{30})g\left( \frac{1+\frac{\sqrt{525+70\sqrt{30}}}{35}}{2} \right)
    + (18+\sqrt{30})g\left( \frac{1-\frac{\sqrt{525-70\sqrt{30}}}{35}}{2} \right)
    + (18+\sqrt{30})g\left( \frac{1+\frac{\sqrt{525-70\sqrt{30}}}{35}}{2} \right)
\right)\end{split}
\end{equation*}

\subsubsection{qf5pE}
\label{\detokenize{reference/quadratureFormulae:qf5pe}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf5pE}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_9\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx |D|\left(
      \frac{(332-13\sqrt{70})}{1800}g\left( \frac{1-\frac{\sqrt{245+14\sqrt{70}}}{21}}{2} \right)
    + \frac{(332-13\sqrt{70})}{1800}g\left( \frac{1+\frac{\sqrt{245+14\sqrt{70}}}{21}}{2} \right)
    + \frac{64}{225}g\left( \frac{1}{2} \right)
    + \frac{(332+13\sqrt{70})}{1800}g\left( \frac{1-\frac{\sqrt{245-14\sqrt{70}}}{21}}{2} \right)
    + \frac{(332+13\sqrt{70})}{1800}g\left( \frac{1+\frac{\sqrt{245-14\sqrt{70}}}{21}}{2} \right)
\right)\end{split}
\end{equation*}

\subsubsection{qf1pElump}
\label{\detokenize{reference/quadratureFormulae:qf1pelump}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf1pElump}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_2\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx \frac{|D|}{2}\left(
      g\left( 0 \right)
    + g\left( 1 \right)
\right)\end{split}
\end{equation*}

\subsection{int2d}
\label{\detokenize{reference/quadratureFormulae:int2d}}\label{\detokenize{reference/quadratureFormulae:quadratureformulaeint2d}}
\begin{sphinxadmonition}{note}{Note:}
Complete formulas are no longer detailed
\end{sphinxadmonition}


\subsubsection{qf1pT}
\label{\detokenize{reference/quadratureFormulae:qf1pt}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf1pT}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_1\).


\subsubsection{qf2pT}
\label{\detokenize{reference/quadratureFormulae:qf2pt}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf2pT}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_2\).


\subsubsection{qf5pT}
\label{\detokenize{reference/quadratureFormulae:qf5pt}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf5pT}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_5\).


\subsubsection{qf1pTlump}
\label{\detokenize{reference/quadratureFormulae:qf1ptlump}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf1pTlump}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_1\).


\subsubsection{qf2pT4P1}
\label{\detokenize{reference/quadratureFormulae:qf2pt4p1}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf2pT4P1}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_1\).


\subsubsection{qf7pT}
\label{\detokenize{reference/quadratureFormulae:qf7pt}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf7pT}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_7\).


\subsubsection{qf9pT}
\label{\detokenize{reference/quadratureFormulae:qf9pt}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf9pT}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_9\).


\subsection{int3d}
\label{\detokenize{reference/quadratureFormulae:int3d}}\label{\detokenize{reference/quadratureFormulae:quadratureformulaeint3d}}

\subsubsection{qfV1}
\label{\detokenize{reference/quadratureFormulae:qfv1}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qfV1}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_1\).


\subsubsection{qfV2}
\label{\detokenize{reference/quadratureFormulae:qfv2}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qfV2}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_2\).


\subsubsection{qfV5}
\label{\detokenize{reference/quadratureFormulae:qfv5}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qfV5}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_5\).


\subsubsection{qfV1lump}
\label{\detokenize{reference/quadratureFormulae:qfv1lump}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qfV1lump}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

This quadrature formula is exact on \(\mathbb{P}_1\).


\section{Operators}
\label{\detokenize{reference/operators:operators}}\label{\detokenize{reference/operators::doc}}

\subsection{Addition operator +}
\label{\detokenize{reference/operators:addition-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{p}{;}
\end{sphinxVerbatim}

Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{string}}, \sphinxcode{\sphinxupquote{mesh}}, \sphinxcode{\sphinxupquote{mesh3}}, array.


\subsection{Substraction operator -}
\label{\detokenize{reference/operators:substraction-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{2.}\PYG{p}{;}
\end{sphinxVerbatim}

Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, array.


\subsection{Multiplication operator *}
\label{\detokenize{reference/operators:multiplication-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
\end{sphinxVerbatim}

Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, array, \sphinxcode{\sphinxupquote{matrix}}.


\subsection{Term by term multiplication .*}
\label{\detokenize{reference/operators:term-by-term-multiplication}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{k+kp}{B} \PYG{p}{.}\PYG{o}{*} \PYG{n}{C}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Division operator /}
\label{\detokenize{reference/operators:division-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{o}{/} \PYG{l+m+mf}{2.}\PYG{p}{;}
\end{sphinxVerbatim}

Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}.


\subsection{Term by term division ./}
\label{\detokenize{reference/operators:term-by-term-division}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{k+kp}{B} \PYG{p}{.}\PYG{o}{/} \PYG{n}{C}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Remainder from the division \%}
\label{\detokenize{reference/operators:remainder-from-the-division}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2}\PYG{p}{;}
\end{sphinxVerbatim}

Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}.


\subsection{Power operator \textasciicircum{}}
\label{\detokenize{reference/operators:power-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\end{sphinxVerbatim}

Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{matrix}}.


\subsection{Inverse of a matrix \textasciicircum{}-1}
\label{\detokenize{reference/operators:inverse-of-a-matrix-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Res} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
This operator can not be used to directly create a matrix, see {\hyperref[\detokenize{example/developers:examplematrixinversion}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix inversion}}}}.
\end{sphinxadmonition}


\subsection{Transpose operator ‘}
\label{\detokenize{reference/operators:transpose-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a} \PYG{o}{=} \PYG{n}{b}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

Works for array and \sphinxcode{\sphinxupquote{matrix}}.

\begin{sphinxadmonition}{note}{Note:}
For \sphinxcode{\sphinxupquote{matrix\textless{}complex\textgreater{}}}, the ::freefem{}`’{}` operator return the Hermitian tranpose.
\end{sphinxadmonition}


\subsection{Tensor scalar product :}
\label{\detokenize{reference/operators:tensor-scalar-product}}\begin{equation*}
\begin{split}A:B = \sum_{i,j}{A_{ij}B_{ij}}\end{split}
\end{equation*}

\subsection{C++ arithmetical if expression ? :}
\label{\detokenize{reference/operators:c-arithmetical-if-expression}}
\sphinxcode{\sphinxupquote{a ? b : c}} is equal to \sphinxcode{\sphinxupquote{b}} if the \sphinxcode{\sphinxupquote{a}} is true, \sphinxcode{\sphinxupquote{c}} otherwise.

\begin{sphinxadmonition}{tip}{Tip:}
Example with \sphinxcode{\sphinxupquote{int}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{12}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ + }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ * }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ / }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{/} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZpc{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZca{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZca{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{( }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZlt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ? }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{?} \PYG{n+nl}{a} \PYG{o}{:} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{12} + \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{17}
\PYG{l+m}{12} \PYGZhy{} \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{7}
\PYG{l+m}{12} * \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{60}
\PYG{l+m}{12} / \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{2}
\PYG{l+m}{12} \PYGZpc{} \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{2}
\PYG{l+m}{12} \PYGZca{} \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{248832}
\PYG{o}{(} \PYG{l+m}{12} \PYGZlt{} \PYG{l+m}{5} ? \PYG{l+m}{12} : \PYG{l+m}{5}\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{5}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Example with \sphinxcode{\sphinxupquote{real}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n}{qsrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{k+kr}{pi}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ + }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ * }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ / }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{/} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZpc{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZca{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZca{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{( }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZlt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ? }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{?} \PYG{n+nl}{a} \PYG{o}{:} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}.41421 + \PYG{l+m}{3}.14159 \PYG{o}{=} \PYG{l+m}{4}.55581
\PYG{l+m}{1}.41421 \PYGZhy{} \PYG{l+m}{3}.14159 \PYG{o}{=} \PYGZhy{}1.72738
\PYG{l+m}{1}.41421 * \PYG{l+m}{3}.14159 \PYG{o}{=} \PYG{l+m}{4}.44288
\PYG{l+m}{1}.41421 / \PYG{l+m}{3}.14159 \PYG{o}{=} \PYG{l+m}{0}.450158
\PYG{l+m}{1}.41421 \PYGZpc{} \PYG{l+m}{3}.14159 \PYG{o}{=} \PYG{l+m}{1}
\PYG{l+m}{1}.41421 \PYGZca{} \PYG{l+m}{3}.14159 \PYG{o}{=} \PYG{l+m}{2}.97069
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Loops}
\label{\detokenize{reference/loops:loops}}\label{\detokenize{reference/loops::doc}}
See {\hyperref[\detokenize{example/developers:exampleloop}]{\sphinxcrossref{\DUrole{std,std-ref}{Loop example}}}}.


\subsection{for}
\label{\detokenize{reference/loops:for}}\label{\detokenize{reference/loops:loopfor}}
For loop.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{N}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{if}
\label{\detokenize{reference/loops:if}}\label{\detokenize{reference/loops:loopif}}
If condition.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{else}
\label{\detokenize{reference/loops:else}}
See {\hyperref[\detokenize{reference/loops:loopif}]{\sphinxcrossref{\DUrole{std,std-ref}{if}}}}.


\subsection{while}
\label{\detokenize{reference/loops:while}}
While loop.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{while} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{continue}
\label{\detokenize{reference/loops:continue}}
Continue a loop.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{N}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)} \PYG{k}{continue}\PYG{p}{;}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{break}
\label{\detokenize{reference/loops:break}}
Break a loop.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{while} \PYG{p}{(}\PYG{n}{condition1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{try}
\label{\detokenize{reference/loops:try}}\label{\detokenize{reference/loops:looptry}}
Try a part of code.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{try}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

See {\hyperref[\detokenize{example/developers:examplebasicerrorhandling}]{\sphinxcrossref{\DUrole{std,std-ref}{Basic error handling example}}}} and {\hyperref[\detokenize{example/developers:exampleerrorhandling}]{\sphinxcrossref{\DUrole{std,std-ref}{Error handling example}}}}.


\subsection{catch}
\label{\detokenize{reference/loops:catch}}
Catch an error, see {\hyperref[\detokenize{reference/loops:looptry}]{\sphinxcrossref{\DUrole{std,std-ref}{try}}}}


\subsection{Implicit loop}
\label{\detokenize{reference/loops:implicit-loop}}
Array with one index:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n+nl}{ai} \PYG{o}{:} \PYG{n}{a}\PYG{p}{]}
\end{sphinxVerbatim}

If \sphinxcode{\sphinxupquote{real{[}int{]} a(10)}}, then \sphinxcode{\sphinxupquote{i=0:9}} and \sphinxcode{\sphinxupquote{ai}} is a reference to \sphinxcode{\sphinxupquote{a{[}i{]}}}.

Array with two indices or matrix:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n+nl}{aij} \PYG{o}{:} \PYG{n}{a}\PYG{p}{]}
\end{sphinxVerbatim}

If \sphinxcode{\sphinxupquote{real{[}int{]} a(10, 11)}}, then \sphinxcode{\sphinxupquote{i=0:9}}, \sphinxcode{\sphinxupquote{j=1:10}} and \sphinxcode{\sphinxupquote{aij}} is a reference to \sphinxcode{\sphinxupquote{a(i, j)}}.

See {\hyperref[\detokenize{example/developers:exampleimplicitloop}]{\sphinxcrossref{\DUrole{std,std-ref}{Implicit loop example}}}}.


\section{I/O}
\label{\detokenize{reference/IO:i-o}}\label{\detokenize{reference/IO::doc}}
See {\hyperref[\detokenize{example/developers:exampleio}]{\sphinxcrossref{\DUrole{std,std-ref}{I/O example}}}}

See {\hyperref[\detokenize{example/developers:examplefilestream}]{\sphinxcrossref{\DUrole{std,std-ref}{File stream example}}}}.


\subsection{cout}
\label{\detokenize{reference/IO:cout}}
Standard C++ output device (default: console).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Some text}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{cin}
\label{\detokenize{reference/IO:cin}}
Standard C++ input device (default: keyboard).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{var}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{endl}
\label{\detokenize{reference/IO:endl}}
End of line.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Some text}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{ifstream}
\label{\detokenize{reference/IO:ifstream}}
Open a file in read mode.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{ifstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
A file is closed at the end of a block.
\end{sphinxadmonition}


\subsection{ofstream}
\label{\detokenize{reference/IO:ofstream}}
Open a file in write mode.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
A file is closed at the end of a block.
\end{sphinxadmonition}


\subsection{append}
\label{\detokenize{reference/IO:append}}
Append data to an existing file.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{append}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{binary}
\label{\detokenize{reference/IO:binary}}
Write a file in binary.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.btxt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{binary}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{seekg}
\label{\detokenize{reference/IO:seekg}}
Set the file position.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{seekg}\PYG{p}{(}\PYG{n}{Pos}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{tellg}
\label{\detokenize{reference/IO:tellg}}
Get the file position.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Pos} \PYG{o}{=} \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{tellg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{flush}
\label{\detokenize{reference/IO:flush}}
Flush the buffer of the file.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{flush}
\end{sphinxVerbatim}


\subsection{getline}
\label{\detokenize{reference/IO:getline}}
Get the current line.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{;}
\PYG{n+nf}{getline}\PYG{p}{(}\PYG{k+kp}{file}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Output format}
\label{\detokenize{reference/IO:output-format}}
In the descriptions below, \sphinxcode{\sphinxupquote{f}} is an output stream, for example \sphinxcode{\sphinxupquote{cout}} or a \sphinxcode{\sphinxupquote{ofstream}}.

All this methods, excepted the first, return a stream, so they can be chained:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{cout}\PYG{p}{.}\PYG{k+kr}{scientific}\PYG{p}{.}\PYG{k+kr}{showpos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{precision}
\label{\detokenize{reference/IO:precision}}
Set the number of digits printed to the right of the decimal point.
This applies to all subsequent floating point numbers written to that output stream.
However, this won’t make floating-point “integers” print with a decimal point.
It’s necessary to use \sphinxcode{\sphinxupquote{fixed}} for that effect.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{np} \PYG{o}{=} \PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{precision}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{scientific}
\label{\detokenize{reference/IO:scientific}}
Formats floating-point numbers in scientific notation

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{scientific}
\end{sphinxVerbatim}


\subsubsection{fixed}
\label{\detokenize{reference/IO:fixed}}
Used fixed point notation for floating-point numbers.
Opposite of scientific.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{fixed}
\end{sphinxVerbatim}


\subsubsection{showbase}
\label{\detokenize{reference/IO:showbase}}
Converts insertions to an external form that can be read according to the \sphinxcode{\sphinxupquote{C++}} lexical conventions for integral constants.
By default, showbase is not set.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{showbase}
\end{sphinxVerbatim}


\subsubsection{noshowbase}
\label{\detokenize{reference/IO:noshowbase}}
Unset \sphinxcode{\sphinxupquote{showbase}} flags.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{noshowbase}
\end{sphinxVerbatim}


\subsubsection{showpos}
\label{\detokenize{reference/IO:showpos}}
Inserts a plus sign (+) into a decimal conversion of a positive integral value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{showpos}
\end{sphinxVerbatim}


\subsubsection{noshowpos}
\label{\detokenize{reference/IO:noshowpos}}
Unset \sphinxcode{\sphinxupquote{showpos}} flags.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{noshowpos}
\end{sphinxVerbatim}


\subsubsection{default}
\label{\detokenize{reference/IO:default}}
Reset all the previous flags to the default expect precision.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{default}
\end{sphinxVerbatim}


\subsubsection{setw}
\label{\detokenize{reference/IO:setw}}
Behaves as if member width were called with \sphinxcode{\sphinxupquote{n}} as argument on the stream on which it is inserted as a manipulator (it can be inserted on output streams).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{setw}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Functions}
\label{\detokenize{reference/functions:functions}}\label{\detokenize{reference/functions::doc}}

\subsection{abs}
\label{\detokenize{reference/functions:abs}}
Return the absolute value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{acos}
\label{\detokenize{reference/functions:acos}}
\(\arccos\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{acos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arccos}.png}
\caption{arccos function}\label{\detokenize{reference/functions:id1}}\end{figure}


\subsection{acosh}
\label{\detokenize{reference/functions:acosh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{acosh}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\arccosh(x) = \ln\left(x + \sqrt{x^2-1}\right)\end{split}
\end{equation*}
Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arccosh}.png}
\caption{arccosh function}\label{\detokenize{reference/functions:id2}}\end{figure}


\subsection{adaptmesh}
\label{\detokenize{reference/functions:adaptmesh}}\label{\detokenize{reference/functions:referenceadaptmesh}}
Mesh adaptation function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{fx}\PYG{p}{,} \PYG{n}{fy}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{hmin}\PYG{o}{=}\PYG{n}{HMin}\PYG{p}{,} \PYG{k+kp}{hmax}\PYG{o}{=}\PYG{n}{HMax}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{Err}\PYG{p}{,} \PYG{k+kp}{errg}\PYG{o}{=}\PYG{n}{ErrG}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{n}{NbVx}\PYG{p}{,} \PYG{k+kp}{nbsmooth}\PYG{o}{=}\PYG{n}{NbSmooth}\PYG{p}{,} \PYG{k+kp}{nbjacoby}\PYG{o}{=}\PYG{n}{NbJacoby}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{n}{Ratio}\PYG{p}{,} \PYG{k+kp}{omega}\PYG{o}{=}\PYG{n}{Omega}\PYG{p}{,} \PYG{k+kp}{iso}\PYG{o}{=}\PYG{n}{Iso}\PYG{p}{,} \PYG{k+kp}{abserror}\PYG{o}{=}\PYG{n}{AbsError}\PYG{p}{,} \PYG{k+kp}{cutoff}\PYG{o}{=}\PYG{n}{CutOff}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{Verbosity}\PYG{p}{,} \PYG{k+kp}{inquire}\PYG{o}{=}\PYG{n}{Inquire}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{n}{SplitPbEdge}\PYG{p}{,} \PYG{k+kp}{maxsubdiv}\PYG{o}{=}\PYG{n}{MaxSubdiv}\PYG{p}{,} \PYG{k+kp}{rescaling}\PYG{o}{=}\PYG{n}{Rescaling}\PYG{p}{,} \PYG{k+kp}{keepbackvertices}\PYG{o}{=}\PYG{n}{KeepBackVertices}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{n}{isMetric}\PYG{p}{,} \PYG{k+kp}{power}\PYG{o}{=}\PYG{n}{Power}\PYG{p}{,} \PYG{k+kp}{thetamax}\PYG{o}{=}\PYG{n}{ThetaMax}\PYG{p}{,} \PYG{k+kp}{splitin2}\PYG{o}{=}\PYG{n}{SplitIn2}\PYG{p}{,} \PYG{k+kp}{metric}\PYG{o}{=}\PYG{n}{Metric}\PYG{p}{,} \PYG{k+kp}{nomeshgeneration}\PYG{o}{=}\PYG{n}{NoMeshGeneration}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{Periodic}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Mesh to refine

\item {} 
\sphinxcode{\sphinxupquote{{[}fx, fy{]}}} (\sphinxcode{\sphinxupquote{func}} or \sphinxcode{\sphinxupquote{fespace}} function), scalar or vectorial Function to follow for the mesh adaptation

\item {} 
\sphinxcode{\sphinxupquote{hmin=}} (\sphinxcode{\sphinxupquote{real}}) Minimum edge size

\item {} 
\sphinxcode{\sphinxupquote{hmax=}} (\sphinxcode{\sphinxupquote{real}}) Maximum edge size

\item {} 
\sphinxcode{\sphinxupquote{err=}} (\sphinxcode{\sphinxupquote{real}}) Error level (P1 interpolation)

\item {} 
\sphinxcode{\sphinxupquote{errg=}} (\sphinxcode{\sphinxupquote{real}}) Relative geometrical error

\item {} 
\sphinxcode{\sphinxupquote{nbvx=}} (\sphinxcode{\sphinxupquote{int}}) Maximum number of vertices

\item {} 
\sphinxcode{\sphinxupquote{nbsmooth=}} (\sphinxcode{\sphinxupquote{int}}) Number of smoothing iterations

\item {} 
\sphinxcode{\sphinxupquote{nbjacoby=}} (\sphinxcode{\sphinxupquote{int}}) Number of iterations for the smoothing procedure

\item {} 
\sphinxcode{\sphinxupquote{ratio=}} (\sphinxcode{\sphinxupquote{real}}) Ratio of the triangles

\item {} 
\sphinxcode{\sphinxupquote{omega=}} (\sphinxcode{\sphinxupquote{real}}) Relaxation parameter for the smoothing procedure

\item {} 
\sphinxcode{\sphinxupquote{iso=}} (\sphinxcode{\sphinxupquote{bool}}) Isotropic adaptation (if true)

\item {} 
\sphinxcode{\sphinxupquote{abserror=}} (\sphinxcode{\sphinxupquote{bool}}) Error (if true) - Relative error (if false)

\item {} 
\sphinxcode{\sphinxupquote{cutoff=}} (\sphinxcode{\sphinxupquote{real}}) Lower limit of the relative error evaluation

\item {} 
\sphinxcode{\sphinxupquote{verbosity=}} (\sphinxcode{\sphinxupquote{real}}) Verbosity level

\item {} 
\sphinxcode{\sphinxupquote{inquire=}} (\sphinxcode{\sphinxupquote{bool}}) If true, inquire graphically

\item {} 
\sphinxcode{\sphinxupquote{splitpbedge=}} (\sphinxcode{\sphinxupquote{bool}}) If true, split all internal edges in half

\item {} 
\sphinxcode{\sphinxupquote{maxsubdiv=}} (\sphinxcode{\sphinxupquote{int}}) Bound the maximum subdivisions

\item {} 
\sphinxcode{\sphinxupquote{rescaling=}} (\sphinxcode{\sphinxupquote{bool}}) Rescale the function in {[}0, 1{]}

\item {} 
\sphinxcode{\sphinxupquote{keepbackvertices=}} (\sphinxcode{\sphinxupquote{bool}}) If true, try to keep vertices of the original mesh

\item {} 
\sphinxcode{\sphinxupquote{IsMetric=}} (\sphinxcode{\sphinxupquote{bool}}) If true, the metric is defined explicitly

\item {} 
\sphinxcode{\sphinxupquote{power=}} (\sphinxcode{\sphinxupquote{int}}) Exponent of the Hessian

\item {} 
\sphinxcode{\sphinxupquote{thetamax=}} (\sphinxcode{\sphinxupquote{int}}) Minimum corner angle (in degree)

\item {} 
\sphinxcode{\sphinxupquote{splitin2=}} (\sphinxcode{\sphinxupquote{bool}}) Split all triangles into 4 sub-triangles if true

\item {} 
\sphinxcode{\sphinxupquote{metric=}} (\sphinxcode{\sphinxupquote{{[}real{[}int{]}, real{[}int{]}, real{[}int{]}{]}}}) Array of 3 real arrays defining the metric

\item {} 
\sphinxcode{\sphinxupquote{nomeshgeneration=}} (\sphinxcode{\sphinxupquote{bool}}) If true, the mesh is not generated

\item {} 
\sphinxcode{\sphinxupquote{periodic=}} (\sphinxcode{\sphinxupquote{real{[}int, int{]}}}) Build an adapted periodic mesh

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Thnew}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}})

\end{itemize}


\subsection{adj}
\label{\detokenize{reference/functions:adj}}
Adjacent triangle of the triangle \(k\) by the edge \(e\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{T} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{adj}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{e}} (\sphinxcode{\sphinxupquote{int}}) Edge number

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{T}} (\sphinxcode{\sphinxupquote{int}}) Triangle number

\end{itemize}


\subsection{AffineCG}
\label{\detokenize{reference/functions:affinecg}}\label{\detokenize{reference/functions:functionaffinecg}}
Affine conjugate gradient solver

Used to solve a problem like \(Ax=b\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Conv} \PYG{o}{=} \PYG{n+nf}{AffineCG}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{Precon}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{n}{NbIter}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{Eps}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{VEps}\PYG{p}{,} \PYG{k+kp}{stop}\PYG{o}{=}\PYG{n}{Stop}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{A}} (\sphinxcode{\sphinxupquote{matrix}}) Matrix of the problem \(Ax=b\)

\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real{[}int{]}}}) Solution vector

\item {} 
\sphinxcode{\sphinxupquote{precon=}} (\sphinxcode{\sphinxupquote{real{[}int{]}}}) Preconditionning function

\item {} 
\sphinxcode{\sphinxupquote{nbiter=}} (\sphinxcode{\sphinxupquote{int}}) Maximum number of iterations

\item {} 
\sphinxcode{\sphinxupquote{eps=}} (\sphinxcode{\sphinxupquote{real}})

Convergence criterion

If \(\varepsilon>0\): test \(||A(x)||_p \leq \epsilon||A(x_0)||_p\)

If \(\varepsilon<0\): test \(||A(x)||_p^2 \leq |\epsilon|\)

\item {} 
\sphinxcode{\sphinxupquote{veps=}} (\sphinxcode{\sphinxupquote{real}}) Same as \sphinxcode{\sphinxupquote{eps}}, but return \sphinxcode{\sphinxupquote{-eps}}

\item {} 
\sphinxcode{\sphinxupquote{stop=}} (\sphinxcode{\sphinxupquote{func}}) Convergence criterion as a function

Prototype is \sphinxcode{\sphinxupquote{func bool StopFunc (int Iter, real{[}int{]} U, real{[}int{]} g)}}

\sphinxcode{\sphinxupquote{u}}: current solution, \sphinxcode{\sphinxupquote{g}}: current gradient (not preconditionned)

\end{itemize}

Output:
\begin{itemize}
\item {} 
Conv (int) 0: converged - !0: not converged

\end{itemize}


\subsection{AffineGMRES}
\label{\detokenize{reference/functions:affinegmres}}
Affine GMRES solver

Parameters and output are the same as {\hyperref[\detokenize{reference/functions:functionaffinecg}]{\sphinxcrossref{\DUrole{std,std-ref}{AffineCG}}}}


\subsection{arg}
\label{\detokenize{reference/functions:arg}}
Return the argument of a complex number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{arg}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{complex}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{asin}
\label{\detokenize{reference/functions:asin}}
\(\arcsin\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{asin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arcsin}.png}
\caption{arcsin function}\label{\detokenize{reference/functions:id3}}\end{figure}


\subsection{asinh}
\label{\detokenize{reference/functions:asinh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{asinh}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\arcsinh(x) = \ln\left(x + \sqrt{x^2+1}\right)\end{split}
\end{equation*}
Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arcsinh}.png}
\caption{arcsinh function}\label{\detokenize{reference/functions:id4}}\end{figure}


\subsection{assert}
\label{\detokenize{reference/functions:assert}}
Verify if a condition is true (same as C), if not the program stops.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
Boolean condition

\end{itemize}

Output:
\begin{itemize}
\item {} 
None

\end{itemize}


\subsection{atan}
\label{\detokenize{reference/functions:atan}}
\(\arctan\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{atan}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arctan}.png}
\caption{arctan function}\label{\detokenize{reference/functions:id5}}\end{figure}


\subsection{atan2}
\label{\detokenize{reference/functions:atan2}}
\(\displaystyle{\arctan\left(\frac{y}{x}\right)}\) function, returning the correct sign for \(\theta\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{atan2}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{atanh}
\label{\detokenize{reference/functions:atanh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{atanh}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arctanh}.png}
\caption{arctanh function}\label{\detokenize{reference/functions:id6}}\end{figure}


\subsection{atoi}
\label{\detokenize{reference/functions:atoi}}
Convert a string to an interger.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{atoi}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{s}} (\sphinxcode{\sphinxupquote{string}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{atof}
\label{\detokenize{reference/functions:atof}}
Convert a string to a real.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{atof}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{s}} (\sphinxcode{\sphinxupquote{string}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{BFGS}
\label{\detokenize{reference/functions:bfgs}}
\begin{sphinxadmonition}{note}{\label{reference/functions:index-0}Todo:}
todo
\end{sphinxadmonition}


\subsection{buildmesh}
\label{\detokenize{reference/functions:buildmesh}}\label{\detokenize{reference/functions:referencebuildmesh}}
Build a 2D mesh using border elements.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b4}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{n}{Nbvx}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{fixedborder}\PYG{o}{=}\PYG{n}{FixedBorder}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b1}}, \sphinxcode{\sphinxupquote{b2}}, \sphinxcode{\sphinxupquote{b3}}, \sphinxcode{\sphinxupquote{b4}} (\sphinxcode{\sphinxupquote{border}})

Geometry border, \sphinxcode{\sphinxupquote{b1(nn)}} means \sphinxcode{\sphinxupquote{b1}} border discretized by \sphinxcode{\sphinxupquote{nn}} vertices

\item {} 
\sphinxcode{\sphinxupquote{nbvx=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

Maximum number of vertices Default: 9000

\item {} 
\sphinxcode{\sphinxupquote{fixedborder=}} (\sphinxcode{\sphinxupquote{bool}}) \sphinxstyleemphasis{{[}Optional{]}}

If true, mesh generator cannot change the boundary mesh

Default: \sphinxcode{\sphinxupquote{false}}

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Resulting mesh

\end{itemize}


\subsection{ceil}
\label{\detokenize{reference/functions:ceil}}
Round fractions up of \(x\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{n+nf}{ceil}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{change}
\label{\detokenize{reference/functions:change}}
Change a property of a mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{L}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Original mesh

\item {} 
\sphinxcode{\sphinxupquote{label=}} L (\sphinxcode{\sphinxupquote{int{[}int{]}}}) Pair of old and new label

\item {} 
\sphinxcode{\sphinxupquote{region=}} R (\sphinxcode{\sphinxupquote{int{[}int{]}}}) Pair of old and new region

\item {} 
\sphinxcode{\sphinxupquote{flabel=}} l (\sphinxcode{\sphinxupquote{func int}}) Function of int given the new label

\item {} 
\sphinxcode{\sphinxupquote{fregion=}} r (\sphinxcode{\sphinxupquote{func int}}) Function of int given the new region

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Thnew}} (\sphinxcode{\sphinxupquote{mesh}}) Mesh with changed
parameters

\end{itemize}


\subsection{chi}
\label{\detokenize{reference/functions:chi}}
Characteristic function of a mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{IsInMesh} \PYG{o}{=} \PYG{n+nf}{chi}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}})

\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}}) Position \(x\)

\item {} 
\sphinxcode{\sphinxupquote{y}} (\sphinxcode{\sphinxupquote{real}}) Position \(y\)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{IsInMesh}} (\sphinxcode{\sphinxupquote{int}}) 1 if \((x,y)\in\) \sphinxcode{\sphinxupquote{Th}} 0 if
\((x,y)\not\in\) \sphinxcode{\sphinxupquote{Th}}

\end{itemize}


\subsection{checkmovemesh}
\label{\detokenize{reference/functions:checkmovemesh}}
Check a {\hyperref[\detokenize{reference/functions:functionmovemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{movemesh}}}} without mesh generation.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{minT} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Dx}\PYG{p}{,} \PYG{n}{Dy}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:

Same as {\hyperref[\detokenize{reference/functions:functionmovemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{movemesh}}}}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{minT}} (\sphinxcode{\sphinxupquote{real}}) Minimum triangle area

\end{itemize}


\subsection{clock}
\label{\detokenize{reference/functions:clock}}
Get the clock in second.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
None

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{t}} (\sphinxcode{\sphinxupquote{real}}) Current CPU time

\end{itemize}


\subsection{complexEigenValue}
\label{\detokenize{reference/functions:complexeigenvalue}}
Same as {\hyperref[\detokenize{reference/functions:functioneigenvalue}]{\sphinxcrossref{\DUrole{std,std-ref}{EigenValue}}}} for complex problems.


\subsection{conj}
\label{\detokenize{reference/functions:conj}}
Caculate the conjuguate of a complex number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{complex} \PYG{n}{C1} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{;}
\PYG{k+kt}{complex} \PYG{n}{C2} \PYG{o}{=} \PYG{n+nf}{conj}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{C1}} (\sphinxcode{\sphinxupquote{complex}}) Complex number

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{C2}} (\sphinxcode{\sphinxupquote{complex}}) Conjuguate of C1

\end{itemize}


\subsection{convect}
\label{\detokenize{reference/functions:convect}}
Characteristics Galerkin method.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{cgm} \PYG{o}{=} \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cgm} \PYG{o}{=} \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{,} \PYG{n}{Uz}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Compute \(c\circ \mathbf{X}\) with \(\mathbf{X}(\mathbf{x}) = \mathbf{x}_{\tau}\) and \(\mathbf{x}_{\tau}\) is the solution of:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \dot{\mathbf{x}}_{\tau} &=& \mathbf{u}(\mathbf{x}_{\tau})\\
    \mathbf{x}_{\tau} &=& \mathbf{x}
\end{array}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ux}} (\sphinxcode{\sphinxupquote{fespace}} function) Velocity: \(x\) component

\item {} 
\sphinxcode{\sphinxupquote{uy}} (\sphinxcode{\sphinxupquote{fespace}} function) Velocity: \(y\) component

\item {} 
\sphinxcode{\sphinxupquote{uz}} (\sphinxcode{\sphinxupquote{fespace}} function) \sphinxstylestrong{3D only}

Velocity: \(z\) component

\item {} 
\sphinxcode{\sphinxupquote{dt}} (\sphinxcode{\sphinxupquote{real}}) Time step

\item {} 
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{fespace}} function) Function to convect

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cgm}} (\sphinxcode{\sphinxupquote{real}}) Result

\end{itemize}


\subsection{copysign}
\label{\detokenize{reference/functions:copysign}}
C++ \sphinxcode{\sphinxupquote{copysign}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{copysign}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{cos}
\label{\detokenize{reference/functions:cos}}
\(\cos\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{cos}.png}
\caption{cos function}\label{\detokenize{reference/functions:id7}}\end{figure}


\subsection{cosh}
\label{\detokenize{reference/functions:cosh}}
\(\cosh\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{cosh}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\cosh(x) = \frac{e^x + e^{-x}}{2}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{diffnp}
\label{\detokenize{reference/functions:diffnp}}
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{diffnp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{\PYGZlt{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{?} \PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{:} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{diffpos}
\label{\detokenize{reference/functions:diffpos}}
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{diffpos}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{dist}
\label{\detokenize{reference/functions:dist}}
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{b}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{b}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{c}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{dumptable}
\label{\detokenize{reference/functions:dumptable}}
Show all types, operators and functions in \sphinxstylestrong{FreeFem++}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{dumptable}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{out}} (\sphinxcode{\sphinxupquote{ostream}}) \sphinxcode{\sphinxupquote{cout}} of \sphinxcode{\sphinxupquote{ofstream}} file.

\end{itemize}

Output:
\begin{itemize}
\item {} 
None

\end{itemize}


\subsection{dx}
\label{\detokenize{reference/functions:dx}}
\(x\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{up} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial u}{\partial x}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{up}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dxx}
\label{\detokenize{reference/functions:dxx}}
\(x\) double derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial x^2}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dxy}
\label{\detokenize{reference/functions:dxy}}
\(xy\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dxy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial x\partial y}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dxz}
\label{\detokenize{reference/functions:dxz}}
\(xz\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dxz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial x\partial z}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dy}
\label{\detokenize{reference/functions:dy}}
\(y\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{up} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial u}{\partial y}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dyx}
\label{\detokenize{reference/functions:dyx}}
\(yx\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dyx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial y\partial x}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dyy}
\label{\detokenize{reference/functions:dyy}}
\(y\) double derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial x^2}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dyz}
\label{\detokenize{reference/functions:dyz}}
\(yz\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dyz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial y\partial z}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dz}
\label{\detokenize{reference/functions:dz}}
\(z\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{up} \PYG{o}{=} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial u}{\partial z}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dzx}
\label{\detokenize{reference/functions:dzx}}
\(zx\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dzx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial z\partial x}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dzy}
\label{\detokenize{reference/functions:dzy}}
\(zy\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dzy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial z\partial y}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dzz}
\label{\detokenize{reference/functions:dzz}}
\(z\) double derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dzz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial z^2}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{EigenValue}
\label{\detokenize{reference/functions:eigenvalue}}\label{\detokenize{reference/functions:functioneigenvalue}}
Compute the generalized eigenvalue of \(Au=\lambda Bu\).
The shifted-inverse method is used by default with \sphinxcode{\sphinxupquote{sigma=}}\(\sigma\), the shift of the method.
The function \sphinxcode{\sphinxupquote{EigenValue}} can be used for either matrices or functions returning a matrix vector product.
The use of the matrix version is shown below.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,}\PYG{k+kp}{B}\PYG{p}{,}\PYG{k+kp}{nev}\PYG{o}{=} \PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{A}}, \sphinxcode{\sphinxupquote{B}}: matrices of same size

\item {} 
\sphinxcode{\sphinxupquote{nev=n}}: number of desired eigenvalues given by an integer \sphinxcode{\sphinxupquote{n}}

\item {} 
\sphinxcode{\sphinxupquote{sym=}}: the problem is symmetric or not

\item {} 
\sphinxcode{\sphinxupquote{tol=}}: the relative accuracy to which eigenvalues are to be determined

\item {} 
\sphinxcode{\sphinxupquote{value=}}: an array to store the real part of the eigenvalues

\item {} 
\sphinxcode{\sphinxupquote{ivalue=}}: an array to store the imaginary part of the eigenvalues

\item {} 
\sphinxcode{\sphinxupquote{vector=}}: a Finite Element function array to store the eigenvectors

\item {} 
\sphinxcode{\sphinxupquote{sigma=}}: the shift value

\item {} 
Other parameters are available for more advanced use: see the ARPACK documentation.

\end{itemize}

Output: The output is the number of converged eigenvalues, which can be different than the number of requested eigenvalues given by \sphinxcode{\sphinxupquote{nev=}}.
Note that the eigenvalues and the eigenvectors are stored for further purposes using the parameters \sphinxcode{\sphinxupquote{value=}} and \sphinxcode{\sphinxupquote{vector=}}.


\subsection{emptymesh}
\label{\detokenize{reference/functions:emptymesh}}
Build an empty mesh.

Useful to handle Lagrange multipliers in mixed and Mortar methods.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{eTh} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ssd}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Mesh to empty

\item {} 
\sphinxcode{\sphinxupquote{ssd}} (\sphinxcode{\sphinxupquote{int{[}int{]}}}) Pseudo subregion label

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{eTh}} (\sphinxcode{\sphinxupquote{mesh}}) Empty mesh

\end{itemize}


\subsection{erf}
\label{\detokenize{reference/functions:erf}}\label{\detokenize{reference/functions:functionerf}}
The error function:
\begin{equation*}
\begin{split}erf(x) = \frac{2}{\sqrt{pi}}\int_{0}^{x}{\exp(-t^2)dt}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{erf}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{err}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{erfc}
\label{\detokenize{reference/functions:erfc}}
Complementary of the {\hyperref[\detokenize{reference/functions:functionerf}]{\sphinxcrossref{\DUrole{std,std-ref}{error function}}}}:
\begin{equation*}
\begin{split}erfc(x) = 1-erf(x)\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{errc} \PYG{o}{=} \PYG{n+nf}{erfc}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{err}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{exec}
\label{\detokenize{reference/functions:exec}}
Execute an external command.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{v} \PYG{o}{=} \PYG{n+nf}{exec}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{command}} (\sphinxcode{\sphinxupquote{string}}) Command to execute

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{v}} (\sphinxcode{\sphinxupquote{int}}) Value returned by the command

\end{itemize}


\subsection{exit}
\label{\detokenize{reference/functions:exit}}
Exit function, equivalent to \sphinxcode{\sphinxupquote{return}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{exit}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{N}} (\sphinxcode{\sphinxupquote{int}}) Return value

\end{itemize}

Output:
\begin{itemize}
\item {} 
None

\end{itemize}


\subsection{exp}
\label{\detokenize{reference/functions:exp}}
Exponential function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}


\subsection{fdim}
\label{\detokenize{reference/functions:fdim}}
Positive difference (\sphinxcode{\sphinxupquote{cmath}} function).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{fd} \PYG{o}{=} \PYG{n+nf}{fdim}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{fd}} (\sphinxcode{\sphinxupquote{real}}) If \(x > y\), return \(x-y\)If \(x \leq y\), return \(0\)

\end{itemize}


\subsection{floor}
\label{\detokenize{reference/functions:floor}}
Floor function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{floor}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Return the largest integer value not greater than \sphinxcode{\sphinxupquote{b}}.

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{fmax}
\label{\detokenize{reference/functions:fmax}}
Maximum (\sphinxcode{\sphinxupquote{cmath}} function).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{Max} \PYG{o}{=} \PYG{n+nf}{fmax}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Max}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{fmin}
\label{\detokenize{reference/functions:fmin}}
Minimum (\sphinxcode{\sphinxupquote{cmath}} function).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{Min} \PYG{o}{=} \PYG{n+nf}{fmin}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Min}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{fmod}
\label{\detokenize{reference/functions:fmod}}
Remainder of \(a/b\) (\sphinxcode{\sphinxupquote{cmath}} function).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{Mod} \PYG{o}{=} \PYG{n+nf}{fmod}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Min}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Mod}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{imag}
\label{\detokenize{reference/functions:imag}}
Imaginary part of a complex number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{complex} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Im} \PYG{o}{=} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{int1d}
\label{\detokenize{reference/functions:int1d}}
1D integral.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qfe}\PYG{o}{=}\PYG{n}{Qfe}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qforder}\PYG{o}{=}\PYG{n}{Qforder}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

Used in {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}, {\hyperref[\detokenize{reference/types:typesolve}]{\sphinxcrossref{\DUrole{std,std-ref}{solve}}}} or {\hyperref[\detokenize{reference/types:typevarf}]{\sphinxcrossref{\DUrole{std,std-ref}{varf}}}} definition to impose a boundary condition only (FreeFem++ does not support 1D simulation), or outside to calculate a quantity.

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Mesh where the integral is calculated

\item {} 
\sphinxcode{\sphinxupquote{Label}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

Label of the 1D border Default: all borders of the mesh

\item {} 
\sphinxcode{\sphinxupquote{qfe=}} ({\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}

Quadrature formula, see {\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulaeint1d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\item {} 
\sphinxcode{\sphinxupquote{qforder=}} ({\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}

Quadrature order, see {\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulaeint1d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\end{itemize}

Output:
\begin{itemize}
\item {} 
Depending on the situation: In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition: Non relevant.

Outside: \sphinxcode{\sphinxupquote{real}} (example: \sphinxcode{\sphinxupquote{real l = int1d(Th, 1)(1.);}}).

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition, the content of \sphinxcode{\sphinxupquote{int1d}} must be a linear or bilinear form.
\end{sphinxadmonition}


\subsection{int2d}
\label{\detokenize{reference/functions:int2d}}
2D integral.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Region}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qfe}\PYG{o}{=}\PYG{n}{Qfe}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qforder}\PYG{o}{=}\PYG{n}{Qforder}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

Or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qfe}\PYG{o}{=}\PYG{n}{Qfe}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qforder}\PYG{o}{=}\PYG{n}{Qforder}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

Used in {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}, {\hyperref[\detokenize{reference/types:typesolve}]{\sphinxcrossref{\DUrole{std,std-ref}{solve}}}} or {\hyperref[\detokenize{reference/types:typevarf}]{\sphinxcrossref{\DUrole{std,std-ref}{varf}}}} definition to: - Calculate integral in 2D simulation - Impose a boundary condition in 3D simulation Or outside to calculate a quantity.

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}}) Mesh where the integral is calculated

\item {} 
\sphinxcode{\sphinxupquote{Region}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}} Label of the 2D region (2D simulation) Default: all regions of the mesh

\item {} 
\sphinxcode{\sphinxupquote{Label}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}} Label of the 2D border (3D simulation) Default: all borders of the mesh

\item {} 
\sphinxcode{\sphinxupquote{qfe=}} ({\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}

Quadrature formula, see {\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulaeint2d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\item {} 
\sphinxcode{\sphinxupquote{qforder=}} ({\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}

Quadrature order, see {\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulaeint2d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\end{itemize}

Output:
\begin{itemize}
\item {} 
Depending on the situation: In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition: Non relevant. Outside: \sphinxcode{\sphinxupquote{real}} (example: \sphinxcode{\sphinxupquote{real s = int2d(Th, 1)(1.);}}).

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition, the content of the \sphinxcode{\sphinxupquote{int2d}} must be a linear or bilinear form.
\end{sphinxadmonition}


\subsection{int3d}
\label{\detokenize{reference/functions:int3d}}
3D integral.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Region}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qfe}\PYG{o}{=}\PYG{n}{Qfe}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qforder}\PYG{o}{=}\PYG{n}{Qforder}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

Used in {\hyperref[\detokenize{reference/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}, {\hyperref[\detokenize{reference/types:typesolve}]{\sphinxcrossref{\DUrole{std,std-ref}{solve}}}} or {\hyperref[\detokenize{reference/types:typevarf}]{\sphinxcrossref{\DUrole{std,std-ref}{varf}}}} definition to calculate integral in 3D simulation, or outside to calculate a quantity.

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh3}}) Mesh where the integral is calculated

\item {} 
\sphinxcode{\sphinxupquote{Region}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

Label of the 3D region

Default: all regions of the mesh

\item {} 
\sphinxcode{\sphinxupquote{qfe=}} ({\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}

Quadrature formula, see {\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulaeint3d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\item {} 
\sphinxcode{\sphinxupquote{qforder=}} ({\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}

Quadrature order, see {\hyperref[\detokenize{reference/quadratureFormulae:quadratureformulaeint3d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\end{itemize}

Output:
\begin{itemize}
\item {} 
Depending on the situation: In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition: Non relevant. Outside: \sphinxcode{\sphinxupquote{real}} (example: \sphinxcode{\sphinxupquote{real v = int3d(Th, 1)(1.);}}).

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition, the content of the \sphinxcode{\sphinxupquote{int3d}} must be a linear or bilinear form.
\end{sphinxadmonition}


\subsection{intalledges}
\label{\detokenize{reference/functions:intalledges}}\label{\detokenize{reference/functions:functionintalledges}}
Integral on all edges.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Region}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Mesh where the integral is calculated

\item {} 
\sphinxcode{\sphinxupquote{Region}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

Label of the region

Default: all regions of the mesh

\end{itemize}

Output:
\begin{itemize}
\item {} 
Non relevant

\end{itemize}


\subsection{intallfaces}
\label{\detokenize{reference/functions:intallfaces}}
Intergal on all faces.

Same as {\hyperref[\detokenize{reference/functions:functionintalledges}]{\sphinxcrossref{\DUrole{std,std-ref}{intalledges}}}} for \sphinxcode{\sphinxupquote{mesh3}}.


\subsection{interpolate}
\label{\detokenize{reference/functions:interpolate}}
Interpolation operator from a finite element space to another.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{I} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{inside}\PYG{o}{=}\PYG{n}{Inside}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{T}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{op}\PYG{o}{=}\PYG{n}{Op}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{U2Vc}\PYG{o}{=}\PYG{n}{U2VC}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Wh}} (\sphinxcode{\sphinxupquote{fespace}}) Target finite element space

\item {} 
\sphinxcode{\sphinxupquote{Vh}} (\sphinxcode{\sphinxupquote{fespace}}) Original finite element space

\item {} 
\sphinxcode{\sphinxupquote{inside=}} (\sphinxcode{\sphinxupquote{bool}}) If true, create a zero extension outside the \sphinxcode{\sphinxupquote{Vh}} domain

\item {} 
\sphinxcode{\sphinxupquote{t=}} (\sphinxcode{\sphinxupquote{bool}}) If true, return the transposed matrix

\item {} 
\sphinxcode{\sphinxupquote{op=}} (\sphinxcode{\sphinxupquote{int}}) 0: interpolate the function (default value) 1: interpolate \(\partial_x\) 2: interpolate \(\partial_y\) 3: interpolate \(\partial_z\)

\item {} 
\sphinxcode{\sphinxupquote{U2Vc=}} (\sphinxcode{\sphinxupquote{int{[}int{]}}}) Array of the same size of \sphinxcode{\sphinxupquote{Wh}} describing which component of \sphinxcode{\sphinxupquote{Vh}}is interpolated in \sphinxcode{\sphinxupquote{Wh}}

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{I}} (\sphinxcode{\sphinxupquote{matrix}}) Interpolation matrix operator

\end{itemize}


\subsection{invdiff}
\label{\detokenize{reference/functions:invdiff}}
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{invdif}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)} \PYG{o}{?} \PYG{l+m+mi}{1}\PYG{p}{(}\PYG{o}{/}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{:} \PYG{l+m+mi}{0}
\PYG{n}{invdif}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{e}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{e}\PYG{p}{)} \PYG{o}{?} \PYG{l+m+mi}{1}\PYG{p}{(}\PYG{o}{/}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{:} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}


\subsection{invdiffnp}
\label{\detokenize{reference/functions:invdiffnp}}
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{invdiffnp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{\PYGZlt{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{?} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{:} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}


\subsection{invdiffpos}
\label{\detokenize{reference/functions:invdiffpos}}
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{invdiffpos}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{?} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{:} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}


\subsection{isInf}
\label{\detokenize{reference/functions:isinf}}
The C++ \sphinxcode{\sphinxupquote{isInf}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n+nf}{isInf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{isNaN}
\label{\detokenize{reference/functions:isnan}}
The C++ \sphinxcode{\sphinxupquote{isNan}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n+nf}{isNaN}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{j0}
\label{\detokenize{reference/functions:j0}}
Bessel function of first kind, order 0.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{n+nf}{j0}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{j1}
\label{\detokenize{reference/functions:j1}}
Bessel function of first kind, order 1.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{n+nf}{j1}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{jn}
\label{\detokenize{reference/functions:jn}}
Bessel function of first kind, order n.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{n+nf}{jn}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}J_n(x) = \sum_{p=0}^{\infty}\frac{(1)^p}{p!(n+p)!}\left(\frac{x}{2}\right)^{2p+n}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{n}} (\sphinxcode{\sphinxupquote{int}})

\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{jump}
\label{\detokenize{reference/functions:jump}}
Jump function across an edge.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{intalledges}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n+nf}{jump}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{fespace}} function) Discontinuous function

\end{itemize}

Output:
\begin{itemize}
\item {} 
Non relevant

\end{itemize}


\subsection{LinearCG}
\label{\detokenize{reference/functions:linearcg}}
Linear CG solver

Parameters and output are the same as {\hyperref[\detokenize{reference/functions:functionaffinecg}]{\sphinxcrossref{\DUrole{std,std-ref}{AffineCG}}}}


\subsection{LinearGMRES}
\label{\detokenize{reference/functions:lineargmres}}
Linear GMRES solver

Parameters and output are the same as {\hyperref[\detokenize{reference/functions:functionaffinecg}]{\sphinxcrossref{\DUrole{std,std-ref}{AffineCG}}}}


\subsection{lgamma}
\label{\detokenize{reference/functions:lgamma}}
Natural logarithm of the absolute value of the \(\Gamma\) function of \(x\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{lg} \PYG{o}{=} \PYG{n+nf}{lgamma}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{lg}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{log}
\label{\detokenize{reference/functions:log}}
Natural logarithm.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{n+nf}{log}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{l}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Complex value

For complex value, the \sphinxcode{\sphinxupquote{log}} function is defined as:
\begin{equation*}
\begin{split}\log(z) = \log(|z|) + i\arg(z)\end{split}
\end{equation*}\end{sphinxadmonition}


\subsection{log10}
\label{\detokenize{reference/functions:log10}}
Common logarithm.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{n+nf}{log10}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{l}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{lrint}
\label{\detokenize{reference/functions:lrint}}
Integer value nearest to \(x\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n+nf}{lrint}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{l}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{lround}
\label{\detokenize{reference/functions:lround}}
Round a value, and return an integer value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n+nf}{lround}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{l}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{max}
\label{\detokenize{reference/functions:max}}
Maximum value of two values.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}}

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{min}
\label{\detokenize{reference/functions:min}}
Minimum value of two values.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}}

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{movemesh}
\label{\detokenize{reference/functions:movemesh}}\label{\detokenize{reference/functions:functionmovemesh}}
Move a mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{MovedTh} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Dx}\PYG{p}{,} \PYG{n}{Dy}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{MovedTh} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Dx}\PYG{p}{,} \PYG{n}{Dy}\PYG{p}{,} \PYG{n}{Dz}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{Region}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{facemerge}\PYG{o}{=}\PYG{n}{FaceMerge}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{ptmerge}\PYG{o}{=}\PYG{n}{PtMerge}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{n}{Orientation}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} of \sphinxcode{\sphinxupquote{mesh3}}) Mesh to move

\item {} 
\sphinxcode{\sphinxupquote{Dx}} (\sphinxcode{\sphinxupquote{fespace}} function) Displacement along \(x\)

\item {} 
\sphinxcode{\sphinxupquote{Dy}} (\sphinxcode{\sphinxupquote{fespace}} function) Displacement along \(y\)

\item {} 
\sphinxcode{\sphinxupquote{Dz}} (\sphinxcode{\sphinxupquote{fespace}} function) \sphinxstylestrong{3D only}

Displacement along \(z\)

\item {} 
\sphinxcode{\sphinxupquote{region=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}} \sphinxstylestrong{3D only}

Set label to tetrahedra

\item {} 
\sphinxcode{\sphinxupquote{label=}} (\sphinxcode{\sphinxupquote{int{[}int{]}}}) \sphinxstyleemphasis{{[}Optional{]}} \sphinxstylestrong{3D only}

Set label of faces (see {\hyperref[\detokenize{reference/functions:change}]{\emph{change}}} for more information)

\item {} 
\sphinxcode{\sphinxupquote{facemerge=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}} \sphinxstylestrong{3D only}

If equal to 1, some faces can be merged during the mesh moving Default: 1

\item {} 
\sphinxcode{\sphinxupquote{ptmerge=}} (\sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}} \sphinxstylestrong{3D only}

Criteria to define when two points merge

\item {} 
\sphinxcode{\sphinxupquote{orientation=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}} \sphinxstylestrong{3D only}

If equal to 1, allow orientation reverse if tetrahedra is not positive Default: 1

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MovedTh}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}}) Moved mesh

\end{itemize}


\subsection{NaN}
\label{\detokenize{reference/functions:nan}}
C++ \sphinxcode{\sphinxupquote{nan}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n+nf}{NaN}\PYG{p}{(}\PYG{p}{[}\PYG{n}{String}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{String}} (\sphinxcode{\sphinxupquote{string}}) Default: \sphinxcode{\sphinxupquote{""}}

\end{itemize}


\subsection{NLCG}
\label{\detokenize{reference/functions:nlcg}}
Non-linear conjugate gradient.

Parameters and output are the same as {\hyperref[\detokenize{reference/functions:functionaffinecg}]{\sphinxcrossref{\DUrole{std,std-ref}{AffineCG}}}}


\subsection{on}
\label{\detokenize{reference/functions:on}}
Dirichlet condition function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Label}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{uD}\PYG{p}{)}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
Used only in problem, solve and varf
\end{sphinxadmonition}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Label}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{border}} in 2D)

Boundary reference where to impose the Dirichlet condition

\item {} 
\sphinxcode{\sphinxupquote{uD}} (\sphinxcode{\sphinxupquote{fespace}} function, \sphinxcode{\sphinxupquote{func}} or \sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{int}})

Dirichlet condition (\sphinxcode{\sphinxupquote{u}} is an unknown of the problem)

\end{itemize}

Output:
\begin{itemize}
\item {} 
Non relevant

\end{itemize}


\subsection{plot}
\label{\detokenize{reference/functions:plot}}\label{\detokenize{reference/functions:referenceplot}}
Plot meshes and results.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Th}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{,} \PYG{n}{Uz}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{n+nf}{Wait}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{ps}\PYG{o}{=}\PYG{n}{PS}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{coef}\PYG{o}{=}\PYG{n}{Coef}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{fill}\PYG{o}{=}\PYG{n}{Fill}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Cmm}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{value}\PYG{o}{=}\PYG{n}{Value}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{aspectratio}\PYG{o}{=}\PYG{n}{AspectRatio}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{bb}\PYG{o}{=}\PYG{n}{Bb}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{n}{NbIso}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{nbarrow}\PYG{o}{=}\PYG{n}{NbArrow}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{viso}\PYG{o}{=}\PYG{n}{VIso}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{varrow}\PYG{o}{=}\PYG{n}{VArrow}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{bw}\PYG{o}{=}\PYG{n}{Bw}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{grey}\PYG{o}{=}\PYG{n}{Grey}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{hsv}\PYG{o}{=}\PYG{n}{Hsv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{boundary}\PYG{o}{=}\PYG{n}{Boundary}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{dim}\PYG{o}{=}\PYG{n}{Dim}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{prev}\PYG{o}{=}\PYG{n}{Prev}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{WindowIndex}\PYG{o}{=}\PYG{n}{WI}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Only one of \sphinxcode{\sphinxupquote{Th}}, \sphinxcode{\sphinxupquote{u}} or \sphinxcode{\sphinxupquote{{[}Ux, Uy{]}}} / \sphinxcode{\sphinxupquote{{[}Ux, Uy, Uz{]}}} is needed for the \sphinxcode{\sphinxupquote{plot}} command.
\end{sphinxadmonition}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}}) Mesh to display

\item {} 
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function) Scalar \sphinxcode{\sphinxupquote{fespace}} function to display

\item {} 
\sphinxcode{\sphinxupquote{{[}Ux, Uy{]}}} / \sphinxcode{\sphinxupquote{{[}Ux, Uy, Uz{]}}} (\sphinxcode{\sphinxupquote{fespace}} function array) Vectorial \sphinxcode{\sphinxupquote{fespace}} function to display

\item {} 
\sphinxcode{\sphinxupquote{{[}Ux, Uy{]}}} (\sphinxcode{\sphinxupquote{{[}real{[}int{]}, real{[}int{]}{]}}}) Couple a real array to display a curve

\item {} 
\sphinxcode{\sphinxupquote{wait=}} (\sphinxcode{\sphinxupquote{bool}}) If true, wait before continue

\item {} 
\sphinxcode{\sphinxupquote{ps=}} (\sphinxcode{\sphinxupquote{string}}) Name of the file to save the plot (\sphinxcode{\sphinxupquote{.ps}} or \sphinxcode{\sphinxupquote{.eps format}})

\item {} 
\sphinxcode{\sphinxupquote{coef=}} (\sphinxcode{\sphinxupquote{real}}) Arrow size

\item {} 
\sphinxcode{\sphinxupquote{fill=}} (\sphinxcode{\sphinxupquote{bool}}) If true, fill color between isovalue (usable with scalar \sphinxcode{\sphinxupquote{fespace}} function only)

\item {} 
\sphinxcode{\sphinxupquote{cmm=}} (\sphinxcode{\sphinxupquote{string}}) Text comment in the graphic window

\item {} 
\sphinxcode{\sphinxupquote{value=}} (\sphinxcode{\sphinxupquote{bool}}) If true, show the value scale

\item {} 
\sphinxcode{\sphinxupquote{aspectratio=}} (\sphinxcode{\sphinxupquote{bool}}) If true, preserve the aspect ratio

\item {} 
\sphinxcode{\sphinxupquote{bb=}} (\sphinxcode{\sphinxupquote{{[}real{[}int{]}, real{[}int{]}{]}}}) Specify a bounding box using two corner points

\item {} 
\sphinxcode{\sphinxupquote{nbiso=}} (\sphinxcode{\sphinxupquote{int}}) Number of isovalues

\item {} 
\sphinxcode{\sphinxupquote{nbarrow=}} (\sphinxcode{\sphinxupquote{int}}) Number of colors of arrows values

\item {} 
\sphinxcode{\sphinxupquote{viso=}} (\sphinxcode{\sphinxupquote{real{[}int{]}}}) Specify an array of isovalues

\item {} 
\sphinxcode{\sphinxupquote{varrow=}} (\sphinxcode{\sphinxupquote{real{[}int{]}}}) Specify an array of arrows values color

\item {} 
\sphinxcode{\sphinxupquote{bw=}} (\sphinxcode{\sphinxupquote{bool}}) If true, the plot is in black and white

\item {} 
\sphinxcode{\sphinxupquote{grey=}} (\sphinxcode{\sphinxupquote{bool}}) If true, the plot is in grey scale

\item {} 
\sphinxcode{\sphinxupquote{hsv=}} (\sphinxcode{\sphinxupquote{real{[}int{]}}}) Array of \(3\times n\) values defining HSV color model \([h_1, s_1, v_1, ..., h_n, s_n, v_n]\)

\item {} 
\sphinxcode{\sphinxupquote{boundary=}} (\sphinxcode{\sphinxupquote{bool}}) If true, display the boundary of the domain

\item {} 
\sphinxcode{\sphinxupquote{dim=}} (\sphinxcode{\sphinxupquote{int}}) Set the dimension of the plot: 2 or 3

\item {} 
\sphinxcode{\sphinxupquote{prev=}} (\sphinxcode{\sphinxupquote{bool}}) Use the graphic state of the previous state

\item {} 
\sphinxcode{\sphinxupquote{WindowIndex=}} (\sphinxcode{\sphinxupquote{int}}) Specify window index for multiple windows graphics

\end{itemize}

Output:
\begin{itemize}
\item {} 
None

\end{itemize}

See the {\hyperref[\detokenize{documentation/visualization:plot}]{\sphinxcrossref{\DUrole{std,std-ref}{plot}}}} section for in-graphic commands.


\subsection{polar}
\label{\detokenize{reference/functions:polar}}
Polar coordinates.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{complex} \PYG{n}{p} \PYG{o}{=} \PYG{n+nf}{polar}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{p}} (\sphinxcode{\sphinxupquote{complex}})

\end{itemize}


\subsection{pow}
\label{\detokenize{reference/functions:pow}}
Power function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{p} \PYG{o}{=} \PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\(p=a^b\)

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{p}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{projection}
\label{\detokenize{reference/functions:projection}}
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{p} \PYG{o}{=} \PYG{n+nf}{projection}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Projection is equivalent to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{projection}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{min}\PYG{p}{(}\PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{p}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{randinit}
\label{\detokenize{reference/functions:randinit}}\label{\detokenize{reference/functions:referencerandinit}}
Initialize the state vector by using a seed.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{randinit}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{seed}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
None

\end{itemize}


\subsection{randint31}
\label{\detokenize{reference/functions:randint31}}\label{\detokenize{reference/functions:referencerandint31}}
Generate \sphinxcode{\sphinxupquote{unsigned int}} (31 bits) random number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randint31}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
None

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{randint32}
\label{\detokenize{reference/functions:randint32}}\label{\detokenize{reference/functions:referencerandint32}}
Generate \sphinxcode{\sphinxupquote{unsigned int}} (32 bits) random number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randint32}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
None

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{randreal1}
\label{\detokenize{reference/functions:randreal1}}\label{\detokenize{reference/functions:referencerandreal1}}
Generate uniform \sphinxcode{\sphinxupquote{real}} in \([0, 1]\) (32 bits).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randreal1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
None

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{randreal2}
\label{\detokenize{reference/functions:randreal2}}\label{\detokenize{reference/functions:referencerandreal2}}
Generate uniform \sphinxcode{\sphinxupquote{real}} in \([0, 1)\) (32 bits).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randreal2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
None

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{randreal3}
\label{\detokenize{reference/functions:randreal3}}\label{\detokenize{reference/functions:referencerandreal3}}
Generate uniform \sphinxcode{\sphinxupquote{real}} in \((0, 1)\) (32 bits).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randreal3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
None

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{randres53}
\label{\detokenize{reference/functions:randres53}}\label{\detokenize{reference/functions:referencerandres53}}
Generate uniform \sphinxcode{\sphinxupquote{real}} in \([0, 1)\) (53 bits).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randres53}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
None

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{readmesh}
\label{\detokenize{reference/functions:readmesh}}
Read a 2D mesh file at different formats (see {\hyperref[\detokenize{documentation/meshGeneration:meshdatastructurereadwrite}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{n}{MeshFileName}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MeshFileName}} (\sphinxcode{\sphinxupquote{string}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\end{itemize}


\subsection{readmesh3}
\label{\detokenize{reference/functions:readmesh3}}
Read a 3D mesh file at different formats (see {\hyperref[\detokenize{documentation/meshGeneration:meshreadwrite3d}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{readmesh3}\PYG{p}{(}\PYG{n}{MeshFileName}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MeshFileName}} (\sphinxcode{\sphinxupquote{string}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh3}})

\end{itemize}


\subsection{real}
\label{\detokenize{reference/functions:real}}
Return the real part of a complex number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{complex}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{rint}
\label{\detokenize{reference/functions:rint}}
Integer value nearest to \(x\) (real value).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{rint}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{round}
\label{\detokenize{reference/functions:round}}
Round a value (real value).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{round}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{savemesh}
\label{\detokenize{reference/functions:savemesh}}
Save a 2D or 3D mesh in different formats (see {\hyperref[\detokenize{documentation/meshGeneration:meshdatastructurereadwrite}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation 2D}}}} and {\hyperref[\detokenize{documentation/meshGeneration:meshreadwrite3d}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation 3D}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{MeshFileName}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}})

\item {} 
\sphinxcode{\sphinxupquote{MeshFileName}} (\sphinxcode{\sphinxupquote{string}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
None

\end{itemize}


\subsection{set}
\label{\detokenize{reference/functions:set}}\label{\detokenize{reference/functions:functionset}}
Set a property to a matrix. See {\hyperref[\detokenize{reference/types:typematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{matrix}}}}.


\subsection{sign}
\label{\detokenize{reference/functions:sign}}
Sign of a value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{sign}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{int}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{s}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{signbit}
\label{\detokenize{reference/functions:signbit}}
C++ \sphinxcode{\sphinxupquote{signbit}} function

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{signbit}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{sin}
\label{\detokenize{reference/functions:sin}}
\(\sin\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{sin}.png}
\caption{sin function}\label{\detokenize{reference/functions:id8}}\end{figure}


\subsection{sinh}
\label{\detokenize{reference/functions:sinh}}
\(\sinh\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{sinh}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\sinh(x) = \frac{e^{x} - e^{-x}}{2}\end{split}
\end{equation*}
Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{sinh}.png}
\caption{sinh function}\label{\detokenize{reference/functions:id9}}\end{figure}


\subsection{sort}
\label{\detokenize{reference/functions:sort}}
Sort two array in parallel

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{sort}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{A}} (\sphinxcode{\sphinxupquote{real{[}int{]}}})

\item {} 
\sphinxcode{\sphinxupquote{B}} (\sphinxcode{\sphinxupquote{int{[}int{]}}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
None

\end{itemize}

\sphinxcode{\sphinxupquote{A}} is sorted in ascending order, \sphinxcode{\sphinxupquote{B}} is sorted as \sphinxcode{\sphinxupquote{A}}.


\subsection{splitmesh}
\label{\detokenize{reference/functions:splitmesh}}
Split mesh triangles according to a function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{splitmesh}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th0}} (\sphinxcode{\sphinxupquote{mesh}})

\item {} 
\sphinxcode{\sphinxupquote{f}} (\sphinxcode{\sphinxupquote{func}} or \sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\end{itemize}


\subsection{sqrt}
\label{\detokenize{reference/functions:sqrt}}
Square root

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{s}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{square}
\label{\detokenize{reference/functions:square}}\label{\detokenize{reference/functions:functionsquare}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Square of a number.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{S} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{S}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{1}
\item {} 
Build a structured square mesh.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nnX}\PYG{p}{,} \PYG{n}{nnY}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{n}{L}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{H}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{Flags}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nnX}} (\sphinxcode{\sphinxupquote{int}}) Discretization along \(x\)

\item {} 
\sphinxcode{\sphinxupquote{nnY}} (\sphinxcode{\sphinxupquote{int}}) Discretization along \(y\)

\item {} 
\sphinxcode{\sphinxupquote{L}} (\sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}} Length along \(x\)

\item {} 
\sphinxcode{\sphinxupquote{H}} (\sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}} Height along \(y\)

\item {} 
\sphinxcode{\sphinxupquote{flags=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

Structured mesh type, see {\hyperref[\detokenize{documentation/meshGeneration:meshsquare}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation chapter}}}} for more information

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\end{itemize}


\subsection{swap}
\label{\detokenize{reference/functions:swap}}
Swap values.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{swap}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
None

\end{itemize}


\subsection{system}
\label{\detokenize{reference/functions:system}}
Execute a system command.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Res} \PYG{o}{=} \PYG{n+nf}{system}\PYG{p}{(}\PYG{n}{Command}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Command}} (\sphinxcode{\sphinxupquote{string}}) System command

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Res}} (\sphinxcode{\sphinxupquote{int}}) Value returned by the system command

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
On Windows, the full path of the command is needed. For example, to execute \sphinxcode{\sphinxupquote{ls.exe}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Res} \PYG{o}{=} \PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C:}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{cygwin}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{k+kp}{bin}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{ls.exe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{tan}
\label{\detokenize{reference/functions:tan}}
\(\tan\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{tan}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{tan}.png}
\caption{tan function}\label{\detokenize{reference/functions:id10}}\end{figure}


\subsection{tanh}
\label{\detokenize{reference/functions:tanh}}
\(\tanh\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{tanh}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{tanh}.png}
\caption{tanh function}\label{\detokenize{reference/functions:id11}}\end{figure}


\subsection{tgamma}
\label{\detokenize{reference/functions:tgamma}}
Calculate the \(\Gamma\) function of \(x\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{tg} \PYG{o}{=} \PYG{n+nf}{tgamma}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameter:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{tg}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{trunc}
\label{\detokenize{reference/functions:trunc}}
Split triangle of a mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n}{R}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{split}\PYG{o}{=}\PYG{n}{Split}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th0}} (\sphinxcode{\sphinxupquote{mesh}})

\item {} 
\sphinxcode{\sphinxupquote{R}} (\sphinxcode{\sphinxupquote{bool}} or \sphinxcode{\sphinxupquote{int}}) Split triangles where \sphinxcode{\sphinxupquote{R}} is true or different from 0

\item {} 
\sphinxcode{\sphinxupquote{split=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

Level of splitting Default: 1

\item {} 
\sphinxcode{\sphinxupquote{label=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

Label number of new boundary item Default: 1

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\end{itemize}


\subsection{y0}
\label{\detokenize{reference/functions:y0}}
Bessel function of second kind, order 0.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n+nf}{y0}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{y1}
\label{\detokenize{reference/functions:y1}}
Bessel function of second kind, order 1.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n+nf}{y1}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{yn}
\label{\detokenize{reference/functions:yn}}
Bessel function of second kind, order n.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n+nf}{yn}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}Y_n(x) = \lim_{\lambda\rightarrow n}{\frac{J_{\lambda}(x)\cos(\lambda\pi)-J_{-\lambda}(x)}{\sin(\lambda\pi)}}\end{split}
\end{equation*}
Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{n}} (\sphinxcode{\sphinxupquote{int}})

\item {} 
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\section{External libraries}
\label{\detokenize{reference/externalLibraries:external-libraries}}\label{\detokenize{reference/externalLibraries:externallibraries}}\label{\detokenize{reference/externalLibraries::doc}}

\subsection{aniso}
\label{\detokenize{reference/externalLibraries:aniso}}

\subsubsection{boundaniso}
\label{\detokenize{reference/externalLibraries:boundaniso}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-0}Todo:}
todo
\end{sphinxadmonition}


\subsection{BEC}
\label{\detokenize{reference/externalLibraries:bec}}

\subsubsection{BECtrap}
\label{\detokenize{reference/externalLibraries:bectrap}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-1}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{GPvortex}
\label{\detokenize{reference/externalLibraries:gpvortex}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-2}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dxGPVortex}
\label{\detokenize{reference/externalLibraries:dxgpvortex}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-3}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dyGPVortex}
\label{\detokenize{reference/externalLibraries:dygpvortex}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-4}Todo:}
todo
\end{sphinxadmonition}


\subsection{Binary I/O}
\label{\detokenize{reference/externalLibraries:binary-i-o}}

\subsubsection{LoadVec}
\label{\detokenize{reference/externalLibraries:loadvec}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-5}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{LoadFlag}
\label{\detokenize{reference/externalLibraries:loadflag}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-6}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{SaveVec}
\label{\detokenize{reference/externalLibraries:savevec}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-7}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{flag}
\label{\detokenize{reference/externalLibraries:flag}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-8}Todo:}
todo
\end{sphinxadmonition}


\subsection{buildlayer}
\label{\detokenize{reference/externalLibraries:buildlayer}}

\subsubsection{buildlayers}
\label{\detokenize{reference/externalLibraries:buildlayers}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-9}Todo:}
todo
\end{sphinxadmonition}


\subsection{ClosePoints}
\label{\detokenize{reference/externalLibraries:closepoints}}

\subsubsection{radiusSearch}
\label{\detokenize{reference/externalLibraries:radiussearch}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-10}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{Voisinage}
\label{\detokenize{reference/externalLibraries:voisinage}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-11}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{neighborhood}
\label{\detokenize{reference/externalLibraries:neighborhood}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-12}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{ClosePoints2}
\label{\detokenize{reference/externalLibraries:closepoints2}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-13}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{ClosePoint}
\label{\detokenize{reference/externalLibraries:closepoint}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-14}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{ClosePoints1}
\label{\detokenize{reference/externalLibraries:closepoints1}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-15}Todo:}
todo
\end{sphinxadmonition}


\subsection{Curvature}
\label{\detokenize{reference/externalLibraries:curvature}}

\subsubsection{extractborder}
\label{\detokenize{reference/externalLibraries:extractborder}}
Extract a border of a mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Res} \PYG{o}{=} \PYG{n}{extractborder}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Label}\PYG{p}{,} \PYG{n}{Points}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}})

\item {} 
\sphinxcode{\sphinxupquote{Label}} (\sphinxcode{\sphinxupquote{int}}) Label of the border to extract

\item {} 
\sphinxcode{\sphinxupquote{Points}} (\sphinxcode{\sphinxupquote{real{[}int, int{]}}}) Extracted points Must be allocated as \sphinxcode{\sphinxupquote{real{[}int, int{]} Points(3, 1);}}

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Res}} (\sphinxcode{\sphinxupquote{real}}) Length of the extracted border

\end{itemize}


\subsubsection{curvature}
\label{\detokenize{reference/externalLibraries:id1}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-16}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{raxicurvature}
\label{\detokenize{reference/externalLibraries:raxicurvature}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-17}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{curves}
\label{\detokenize{reference/externalLibraries:curves}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-18}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{setecurveabcisse}
\label{\detokenize{reference/externalLibraries:setecurveabcisse}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-19}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{equiparameter}
\label{\detokenize{reference/externalLibraries:equiparameter}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-20}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{Tresca}
\label{\detokenize{reference/externalLibraries:tresca}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-21}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{VonMises}
\label{\detokenize{reference/externalLibraries:vonmises}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-22}Todo:}
todo
\end{sphinxadmonition}


\subsection{dfft}
\label{\detokenize{reference/externalLibraries:dfft}}
Refer to the \sphinxhref{http://www.fftw.org/}{FFTW documentation} for more informations.


\subsubsection{plandfft}
\label{\detokenize{reference/externalLibraries:plandfft}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-23}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{execute}
\label{\detokenize{reference/externalLibraries:execute}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-24}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{delete}
\label{\detokenize{reference/externalLibraries:delete}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-25}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dfft}
\label{\detokenize{reference/externalLibraries:id2}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-26}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{map}
\label{\detokenize{reference/externalLibraries:map}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-27}Todo:}
todo
\end{sphinxadmonition}


\subsection{distance}
\label{\detokenize{reference/externalLibraries:distance}}
Need

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{distance}\PYG{l+s}{\PYGZdq{}}
\end{sphinxVerbatim}


\subsubsection{distance}
\label{\detokenize{reference/externalLibraries:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{distance}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nf}{d}\PYG{p}{,} \PYG{n+nf}{dist}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{distmax}\PYG{o}{=}\PYG{n}{DistMax}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\item {} 
\sphinxcode{\sphinxupquote{d}}

\item {} 
\sphinxcode{\sphinxupquote{dist}} (\sphinxcode{\sphinxupquote{real{[}int{]}}})

\end{itemize}

Output:
\begin{itemize}
\item {} 
\end{itemize}

\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-28}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{checkdist}
\label{\detokenize{reference/externalLibraries:checkdist}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-29}Todo:}
todo
\end{sphinxadmonition}


\subsection{DxWriter}
\label{\detokenize{reference/externalLibraries:dxwriter}}

\subsubsection{Dxaddmesh}
\label{\detokenize{reference/externalLibraries:dxaddmesh}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-30}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{Dxaddtimeseries}
\label{\detokenize{reference/externalLibraries:dxaddtimeseries}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-31}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{Dxaddsol2ts}
\label{\detokenize{reference/externalLibraries:dxaddsol2ts}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-32}Todo:}
todo
\end{sphinxadmonition}


\subsection{Element\_P1bl}
\label{\detokenize{reference/externalLibraries:element-p1bl}}

\subsubsection{expert}
\label{\detokenize{reference/externalLibraries:expert}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-33}Todo:}
todo
\end{sphinxadmonition}


\subsection{exactpartition}
\label{\detokenize{reference/externalLibraries:exactpartition}}

\subsubsection{exactpartition}
\label{\detokenize{reference/externalLibraries:id4}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-34}Todo:}
todo
\end{sphinxadmonition}


\subsection{ff-AiryBiry}
\label{\detokenize{reference/externalLibraries:ff-airybiry}}

\subsubsection{airy}
\label{\detokenize{reference/externalLibraries:airy}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-35}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{biry}
\label{\detokenize{reference/externalLibraries:biry}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-36}Todo:}
todo
\end{sphinxadmonition}


\subsection{ff-cmaes}
\label{\detokenize{reference/externalLibraries:ff-cmaes}}

\subsubsection{cmaes}
\label{\detokenize{reference/externalLibraries:cmaes}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-37}Todo:}
todo
\end{sphinxadmonition}


\subsection{ff\_gsl\_awk}
\label{\detokenize{reference/externalLibraries:ff-gsl-awk}}\label{\detokenize{reference/externalLibraries:referenceffgslawk}}
Refer to the \sphinxhref{https://www.gnu.org/software/gsl/doc/html/index.html}{GSL documentation} for more informations


\subsubsection{gslcdfugaussianP}
\label{\detokenize{reference/externalLibraries:gslcdfugaussianp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}ugaussian\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfugaussianQ}
\label{\detokenize{reference/externalLibraries:gslcdfugaussianq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}ugaussian\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfugaussianPinv}
\label{\detokenize{reference/externalLibraries:gslcdfugaussianpinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}ugaussian\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfugaussianQinv}
\label{\detokenize{reference/externalLibraries:gslcdfugaussianqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}ugaussian\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgaussianP}
\label{\detokenize{reference/externalLibraries:gslcdfgaussianp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gaussian\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgaussianQ}
\label{\detokenize{reference/externalLibraries:gslcdfgaussianq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gaussian\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgaussianPinv}
\label{\detokenize{reference/externalLibraries:gslcdfgaussianpinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gaussian\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgaussianQinv}
\label{\detokenize{reference/externalLibraries:gslcdfgaussianqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gaussian\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgammaP}
\label{\detokenize{reference/externalLibraries:gslcdfgammap}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gamma\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgammaQ}
\label{\detokenize{reference/externalLibraries:gslcdfgammaq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gamma\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgammaPinv}
\label{\detokenize{reference/externalLibraries:gslcdfgammapinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gamma\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgammaQinv}
\label{\detokenize{reference/externalLibraries:gslcdfgammaqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gamma\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfcauchyP}
\label{\detokenize{reference/externalLibraries:gslcdfcauchyp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}cauchy\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfcauchyQ}
\label{\detokenize{reference/externalLibraries:gslcdfcauchyq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}cauchy\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfcauchyPinv}
\label{\detokenize{reference/externalLibraries:gslcdfcauchypinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}cauchy\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfcauchyQinv}
\label{\detokenize{reference/externalLibraries:gslcdfcauchyqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}cauchy\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflaplaceP}
\label{\detokenize{reference/externalLibraries:gslcdflaplacep}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lapalce\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflaplaceQ}
\label{\detokenize{reference/externalLibraries:gslcdflaplaceq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lapalce\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflaplacePinv}
\label{\detokenize{reference/externalLibraries:gslcdflaplacepinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lapalce\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflaplaceQinv}
\label{\detokenize{reference/externalLibraries:gslcdflaplaceqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lapalce\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfrayleighP}
\label{\detokenize{reference/externalLibraries:gslcdfrayleighp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}rayleigh\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfrayleighQ}
\label{\detokenize{reference/externalLibraries:gslcdfrayleighq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}rayleigh\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfrayleighPinv}
\label{\detokenize{reference/externalLibraries:gslcdfrayleighpinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}rayleigh\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfrayleighQinv}
\label{\detokenize{reference/externalLibraries:gslcdfrayleighqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}rayleigh\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfchisqP}
\label{\detokenize{reference/externalLibraries:gslcdfchisqp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}chisq\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfchisqQ}
\label{\detokenize{reference/externalLibraries:gslcdfchisqq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}chisq\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfchisqPinv}
\label{\detokenize{reference/externalLibraries:gslcdfchisqpinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}chisq\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfchisqQinv}
\label{\detokenize{reference/externalLibraries:gslcdfchisqqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}chisq\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexponentialP}
\label{\detokenize{reference/externalLibraries:gslcdfexponentialp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exponential\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexponentialQ}
\label{\detokenize{reference/externalLibraries:gslcdfexponentialq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exponential\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexponentialPinv}
\label{\detokenize{reference/externalLibraries:gslcdfexponentialpinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exponential\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexponentialQinv}
\label{\detokenize{reference/externalLibraries:gslcdfexponentialqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exponential\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexppowP}
\label{\detokenize{reference/externalLibraries:gslcdfexppowp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exppow\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexppowQ}
\label{\detokenize{reference/externalLibraries:gslcdfexppowq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exppow\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdftdistP}
\label{\detokenize{reference/externalLibraries:gslcdftdistp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}t\PYGZus{}dist\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdftdistQ}
\label{\detokenize{reference/externalLibraries:gslcdftdistq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}t\PYGZus{}dist\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdftdistPinv}
\label{\detokenize{reference/externalLibraries:gslcdftdistpinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}t\PYGZus{}dist\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdftdistQinv}
\label{\detokenize{reference/externalLibraries:gslcdftdistqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}t\PYGZus{}dist\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdffdistP}
\label{\detokenize{reference/externalLibraries:gslcdffdistp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}fdist\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdffdistQ}
\label{\detokenize{reference/externalLibraries:gslcdffdistq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}fdist\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdffdistPinv}
\label{\detokenize{reference/externalLibraries:gslcdffdistpinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}fdist\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdffdistQinv}
\label{\detokenize{reference/externalLibraries:gslcdffdistqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}fdist\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbetaP}
\label{\detokenize{reference/externalLibraries:gslcdfbetap}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}beta\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbetaQ}
\label{\detokenize{reference/externalLibraries:gslcdfbetaq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}beta\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbetaPinv}
\label{\detokenize{reference/externalLibraries:gslcdfbetapinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}beta\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbetaQinv}
\label{\detokenize{reference/externalLibraries:gslcdfbetaqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}beta\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfflatP}
\label{\detokenize{reference/externalLibraries:gslcdfflatp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}flat\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfflatQ}
\label{\detokenize{reference/externalLibraries:gslcdfflatq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}flat\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfflatPinv}
\label{\detokenize{reference/externalLibraries:gslcdfflatpinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}flat\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfflatQinv}
\label{\detokenize{reference/externalLibraries:gslcdfflatqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}flat\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflognormalP}
\label{\detokenize{reference/externalLibraries:gslcdflognormalp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lognormal\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflognormalQ}
\label{\detokenize{reference/externalLibraries:gslcdflognormalq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lognormal\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflognormalPinv}
\label{\detokenize{reference/externalLibraries:gslcdflognormalpinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lognormal\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflognormalQinv}
\label{\detokenize{reference/externalLibraries:gslcdflognormalqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lognormal\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel1P}
\label{\detokenize{reference/externalLibraries:gslcdfgumbel1p}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel1\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel1Q}
\label{\detokenize{reference/externalLibraries:gslcdfgumbel1q}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel1\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel1Pinv}
\label{\detokenize{reference/externalLibraries:gslcdfgumbel1pinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel1\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel1Qinv}
\label{\detokenize{reference/externalLibraries:gslcdfgumbel1qinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel1\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel2P}
\label{\detokenize{reference/externalLibraries:gslcdfgumbel2p}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel2\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel2Q}
\label{\detokenize{reference/externalLibraries:gslcdfgumbel2q}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel2\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel2Pinv}
\label{\detokenize{reference/externalLibraries:gslcdfgumbel2pinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel2\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel2Qinv}
\label{\detokenize{reference/externalLibraries:gslcdfgumbel2qinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel2\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfweibullP}
\label{\detokenize{reference/externalLibraries:gslcdfweibullp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}weibull\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfweibullQ}
\label{\detokenize{reference/externalLibraries:gslcdfweibullq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}weibull\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfweibullPinv}
\label{\detokenize{reference/externalLibraries:gslcdfweibullpinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}weibull\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfweibullQinv}
\label{\detokenize{reference/externalLibraries:gslcdfweibullqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}weibull\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfparetoP}
\label{\detokenize{reference/externalLibraries:gslcdfparetop}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pareto\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfparetoQ}
\label{\detokenize{reference/externalLibraries:gslcdfparetoq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pareto\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfparetoPinv}
\label{\detokenize{reference/externalLibraries:gslcdfparetopinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pareto\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfparetoQinv}
\label{\detokenize{reference/externalLibraries:gslcdfparetoqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pareto\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflogisticP}
\label{\detokenize{reference/externalLibraries:gslcdflogisticp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}logistic\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflogisticQ}
\label{\detokenize{reference/externalLibraries:gslcdflogisticq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}logistic\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflogisticPinv}
\label{\detokenize{reference/externalLibraries:gslcdflogisticpinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}logistic\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflogisticQinv}
\label{\detokenize{reference/externalLibraries:gslcdflogisticqinv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}logistic\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbinomialP}
\label{\detokenize{reference/externalLibraries:gslcdfbinomialp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}binomial\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbinomialQ}
\label{\detokenize{reference/externalLibraries:gslcdfbinomialq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}binomial\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfpoissonP}
\label{\detokenize{reference/externalLibraries:gslcdfpoissonp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}poisson\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfpoissonQ}
\label{\detokenize{reference/externalLibraries:gslcdfpoissonq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}poisson\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgeometricP}
\label{\detokenize{reference/externalLibraries:gslcdfgeometricp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}geometric\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgeometricQ}
\label{\detokenize{reference/externalLibraries:gslcdfgeometricq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}geometric\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfnegativebinomialP}
\label{\detokenize{reference/externalLibraries:gslcdfnegativebinomialp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}negative\PYGZus{}binomial\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfnegativebinomialQ}
\label{\detokenize{reference/externalLibraries:gslcdfnegativebinomialq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}negative\PYGZus{}binomial\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfpascalP}
\label{\detokenize{reference/externalLibraries:gslcdfpascalp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pascal\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfpascalQ}
\label{\detokenize{reference/externalLibraries:gslcdfpascalq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pascal\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranbernoullipdf}
\label{\detokenize{reference/externalLibraries:gslranbernoullipdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}bernoulli\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranbeta}
\label{\detokenize{reference/externalLibraries:gslranbeta}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}beta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranbetapdf}
\label{\detokenize{reference/externalLibraries:gslranbetapdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}beta\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranbinomialpdf}
\label{\detokenize{reference/externalLibraries:gslranbinomialpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}binomial\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranexponential}
\label{\detokenize{reference/externalLibraries:gslranexponential}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}exponential}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranexponentialpdf}
\label{\detokenize{reference/externalLibraries:gslranexponentialpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}exponential\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranexppow}
\label{\detokenize{reference/externalLibraries:gslranexppow}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}exppow}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranexppowpdf}
\label{\detokenize{reference/externalLibraries:gslranexppowpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}exppow\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrancauchy}
\label{\detokenize{reference/externalLibraries:gslrancauchy}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}cauchy}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrancauchypdf}
\label{\detokenize{reference/externalLibraries:gslrancauchypdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}cauchy\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranchisq}
\label{\detokenize{reference/externalLibraries:gslranchisq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}chisq}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranchisqpdf}
\label{\detokenize{reference/externalLibraries:gslranchisqpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}chisq\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranerlang}
\label{\detokenize{reference/externalLibraries:gslranerlang}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}erlang}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranerlangpdf}
\label{\detokenize{reference/externalLibraries:gslranerlangpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}erlang\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranfdist}
\label{\detokenize{reference/externalLibraries:gslranfdist}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}fdist}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranfdistpdf}
\label{\detokenize{reference/externalLibraries:gslranfdistpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}fdist\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranflat}
\label{\detokenize{reference/externalLibraries:gslranflat}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}flat}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranflatpdf}
\label{\detokenize{reference/externalLibraries:gslranflatpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}flat\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangamma}
\label{\detokenize{reference/externalLibraries:gslrangamma}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gamma}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangammaint}
\label{\detokenize{reference/externalLibraries:gslrangammaint}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gamma\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangammapdf}
\label{\detokenize{reference/externalLibraries:gslrangammapdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gamma\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangammamt}
\label{\detokenize{reference/externalLibraries:gslrangammamt}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gamma\PYGZus{}mt}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangammaknuth}
\label{\detokenize{reference/externalLibraries:gslrangammaknuth}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gamma\PYGZus{}knuth}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussian}
\label{\detokenize{reference/externalLibraries:gslrangaussian}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussianratiomethod}
\label{\detokenize{reference/externalLibraries:gslrangaussianratiomethod}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian\PYGZus{}ratio\PYGZus{}method}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussianziggurat}
\label{\detokenize{reference/externalLibraries:gslrangaussianziggurat}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian\PYGZus{}ziggurat}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussianpdf}
\label{\detokenize{reference/externalLibraries:gslrangaussianpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranugaussian}
\label{\detokenize{reference/externalLibraries:gslranugaussian}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}ugaussian}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranugaussianratiomethod}
\label{\detokenize{reference/externalLibraries:gslranugaussianratiomethod}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}ugaussian\PYGZus{}ratio\PYGZus{}method}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranugaussianpdf}
\label{\detokenize{reference/externalLibraries:gslranugaussianpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}ugaussian\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussiantail}
\label{\detokenize{reference/externalLibraries:gslrangaussiantail}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian\PYGZus{}tail}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussiantailpdf}
\label{\detokenize{reference/externalLibraries:gslrangaussiantailpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian\PYGZus{}tail\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranugaussiantail}
\label{\detokenize{reference/externalLibraries:gslranugaussiantail}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}ugaussian\PYGZus{}tail}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranugaussiantailpdf}
\label{\detokenize{reference/externalLibraries:gslranugaussiantailpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}ugaussian\PYGZus{}tail\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlandau}
\label{\detokenize{reference/externalLibraries:gslranlandau}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}landau}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlandaupdf}
\label{\detokenize{reference/externalLibraries:gslranlandaupdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}landau\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangeometricpdf}
\label{\detokenize{reference/externalLibraries:gslrangeometricpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}geometric\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangumbel1}
\label{\detokenize{reference/externalLibraries:gslrangumbel1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gumbel1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangumbel1pdf}
\label{\detokenize{reference/externalLibraries:gslrangumbel1pdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gumbel1\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangumbel2}
\label{\detokenize{reference/externalLibraries:gslrangumbel2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gumbel2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangumbel2pdf}
\label{\detokenize{reference/externalLibraries:gslrangumbel2pdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gumbel2\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlogistic}
\label{\detokenize{reference/externalLibraries:gslranlogistic}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}logistic}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlogisticpdf}
\label{\detokenize{reference/externalLibraries:gslranlogisticpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}logistic\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlognormal}
\label{\detokenize{reference/externalLibraries:gslranlognormal}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}lognormal}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlognormalpdf}
\label{\detokenize{reference/externalLibraries:gslranlognormalpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}lognormal\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlogarithmicpdf}
\label{\detokenize{reference/externalLibraries:gslranlogarithmicpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}logarithmic\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrannegativebinomialpdf}
\label{\detokenize{reference/externalLibraries:gslrannegativebinomialpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}negative\PYGZus{}binomial\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranpascalpdf}
\label{\detokenize{reference/externalLibraries:gslranpascalpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}pascal\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranpareto}
\label{\detokenize{reference/externalLibraries:gslranpareto}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}pareto}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranparetopdf}
\label{\detokenize{reference/externalLibraries:gslranparetopdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}pareto\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranpoissonpdf}
\label{\detokenize{reference/externalLibraries:gslranpoissonpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}poisson\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranrayleigh}
\label{\detokenize{reference/externalLibraries:gslranrayleigh}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}rayleigh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranrayleighpdf}
\label{\detokenize{reference/externalLibraries:gslranrayleighpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}rayleigh\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranrayleightail}
\label{\detokenize{reference/externalLibraries:gslranrayleightail}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}rayleigh\PYGZus{}tail}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranrayleightailpdf}
\label{\detokenize{reference/externalLibraries:gslranrayleightailpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}rayleigh\PYGZus{}tail\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrantdist}
\label{\detokenize{reference/externalLibraries:gslrantdist}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}tdsit}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrantdistpdf}
\label{\detokenize{reference/externalLibraries:gslrantdistpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}tdsit\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlaplace}
\label{\detokenize{reference/externalLibraries:gslranlaplace}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}laplace}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlaplacepdf}
\label{\detokenize{reference/externalLibraries:gslranlaplacepdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}laplace\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlevy}
\label{\detokenize{reference/externalLibraries:gslranlevy}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}levy}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranweibull}
\label{\detokenize{reference/externalLibraries:gslranweibull}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}weibull}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranweibullpdf}
\label{\detokenize{reference/externalLibraries:gslranweibullpdf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}weibull\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyAi}
\label{\detokenize{reference/externalLibraries:gslsfairyai}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Ai}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyBi}
\label{\detokenize{reference/externalLibraries:gslsfairybi}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Bi}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyAiscaled}
\label{\detokenize{reference/externalLibraries:gslsfairyaiscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Ai\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyBiscaled}
\label{\detokenize{reference/externalLibraries:gslsfairybiscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Bi\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyAideriv}
\label{\detokenize{reference/externalLibraries:gslsfairyaideriv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Ai\PYGZus{}deriv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyBideriv}
\label{\detokenize{reference/externalLibraries:gslsfairybideriv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Bi\PYGZus{}deriv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyAiderivscaled}
\label{\detokenize{reference/externalLibraries:gslsfairyaiderivscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Ai\PYGZus{}deriv\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyBiderivscaled}
\label{\detokenize{reference/externalLibraries:gslsfairybiderivscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Bi\PYGZus{}deriv\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyzeroAi}
\label{\detokenize{reference/externalLibraries:gslsfairyzeroai}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Ai}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyzeroBi}
\label{\detokenize{reference/externalLibraries:gslsfairyzerobi}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}aero\PYGZus{}Bi}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyzeroAideriv}
\label{\detokenize{reference/externalLibraries:gslsfairyzeroaideriv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}aero\PYGZus{}Ai\PYGZus{}deriv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyzeroBideriv}
\label{\detokenize{reference/externalLibraries:gslsfairyzerobideriv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}aero\PYGZus{}Bi\PYGZus{}deriv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselJ0}
\label{\detokenize{reference/externalLibraries:gslsfbesselj0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}J0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselJ1}
\label{\detokenize{reference/externalLibraries:gslsfbesselj1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}J1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselJn}
\label{\detokenize{reference/externalLibraries:gslsfbesseljn}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Jn}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselY0}
\label{\detokenize{reference/externalLibraries:gslsfbessely0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Y0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselY1}
\label{\detokenize{reference/externalLibraries:gslsfbessely1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Y1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselYn}
\label{\detokenize{reference/externalLibraries:gslsfbesselyn}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Yn}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselI0}
\label{\detokenize{reference/externalLibraries:gslsfbesseli0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}I0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselI1}
\label{\detokenize{reference/externalLibraries:gslsfbesseli1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}I1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselIn}
\label{\detokenize{reference/externalLibraries:gslsfbesselin}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}In}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselI0scaled}
\label{\detokenize{reference/externalLibraries:gslsfbesseli0scaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}I0\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselI1scaled}
\label{\detokenize{reference/externalLibraries:gslsfbesseli1scaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}I1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselInscaled}
\label{\detokenize{reference/externalLibraries:gslsfbesselinscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}In\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselK0}
\label{\detokenize{reference/externalLibraries:gslsfbesselk0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}K0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselK1}
\label{\detokenize{reference/externalLibraries:gslsfbesselk1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}K1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselKn}
\label{\detokenize{reference/externalLibraries:gslsfbesselkn}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Kn}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselK0scaled}
\label{\detokenize{reference/externalLibraries:gslsfbesselk0scaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}K0\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselK1scaled}
\label{\detokenize{reference/externalLibraries:gslsfbesselk1scaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}K1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselKnscaled}
\label{\detokenize{reference/externalLibraries:gslsfbesselknscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Kn\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselj0}
\label{\detokenize{reference/externalLibraries:id5}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}j0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselj1}
\label{\detokenize{reference/externalLibraries:id6}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}j1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselj2}
\label{\detokenize{reference/externalLibraries:gslsfbesselj2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}j2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesseljl}
\label{\detokenize{reference/externalLibraries:gslsfbesseljl}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}jl}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbessely0}
\label{\detokenize{reference/externalLibraries:id7}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}y0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbessely1}
\label{\detokenize{reference/externalLibraries:id8}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}y0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbessely2}
\label{\detokenize{reference/externalLibraries:gslsfbessely2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}y0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselyl}
\label{\detokenize{reference/externalLibraries:gslsfbesselyl}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}jl}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesseli0scaled}
\label{\detokenize{reference/externalLibraries:id9}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}i0\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesseli1scaled}
\label{\detokenize{reference/externalLibraries:id10}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}i1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesseli2scaled}
\label{\detokenize{reference/externalLibraries:gslsfbesseli2scaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}i2\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselilscaled}
\label{\detokenize{reference/externalLibraries:gslsfbesselilscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}il\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselk0scaled}
\label{\detokenize{reference/externalLibraries:id11}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}k0\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselk1scaled}
\label{\detokenize{reference/externalLibraries:id12}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}k1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselk2scaled}
\label{\detokenize{reference/externalLibraries:gslsfbesselk2scaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}k2\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselklscaled}
\label{\detokenize{reference/externalLibraries:gslsfbesselklscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}kl\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselJnu}
\label{\detokenize{reference/externalLibraries:gslsfbesseljnu}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Jnu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselYnu}
\label{\detokenize{reference/externalLibraries:gslsfbesselynu}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Ynu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselInuscaled}
\label{\detokenize{reference/externalLibraries:gslsfbesselinuscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Inu\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselInu}
\label{\detokenize{reference/externalLibraries:gslsfbesselinu}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Inu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselKnuscaled}
\label{\detokenize{reference/externalLibraries:gslsfbesselknuscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Knu\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselKnu}
\label{\detokenize{reference/externalLibraries:gslsfbesselknu}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Knu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbessellnKnu}
\label{\detokenize{reference/externalLibraries:gslsfbessellnknu}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}lnKnu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselzeroJ0}
\label{\detokenize{reference/externalLibraries:gslsfbesselzeroj0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}zero\PYGZus{}J0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselzeroJ1}
\label{\detokenize{reference/externalLibraries:gslsfbesselzeroj1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}zero\PYGZus{}J1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselzeroJnu}
\label{\detokenize{reference/externalLibraries:gslsfbesselzerojnu}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}zero\PYGZus{}Jnu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfclausen}
\label{\detokenize{reference/externalLibraries:gslsfclausen}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}clausen}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhydrogenicR1}
\label{\detokenize{reference/externalLibraries:gslsfhydrogenicr1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hydrogenicR\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdawson}
\label{\detokenize{reference/externalLibraries:gslsfdawson}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}dawnson}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye1}
\label{\detokenize{reference/externalLibraries:gslsfdebye1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye2}
\label{\detokenize{reference/externalLibraries:gslsfdebye2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye3}
\label{\detokenize{reference/externalLibraries:gslsfdebye3}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye4}
\label{\detokenize{reference/externalLibraries:gslsfdebye4}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}4}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye5}
\label{\detokenize{reference/externalLibraries:gslsfdebye5}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}5}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye6}
\label{\detokenize{reference/externalLibraries:gslsfdebye6}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}6}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdilog}
\label{\detokenize{reference/externalLibraries:gslsfdilog}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}dilog}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfmultiply}
\label{\detokenize{reference/externalLibraries:gslsfmultiply}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintKcomp}
\label{\detokenize{reference/externalLibraries:gslsfellintkcomp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}Kcomp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintEcomp}
\label{\detokenize{reference/externalLibraries:gslsfellintecomp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}Ecomp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintPcomp}
\label{\detokenize{reference/externalLibraries:gslsfellintpcomp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}Pcomp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintDcomp}
\label{\detokenize{reference/externalLibraries:gslsfellintdcomp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}Dcomp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintF}
\label{\detokenize{reference/externalLibraries:gslsfellintf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}F}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintE}
\label{\detokenize{reference/externalLibraries:gslsfellinte}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}E}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintRC}
\label{\detokenize{reference/externalLibraries:gslsfellintrc}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}RC}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsferfc}
\label{\detokenize{reference/externalLibraries:gslsferfc}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}erfc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflogerfc}
\label{\detokenize{reference/externalLibraries:gslsflogerfc}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}log\PYGZus{}erfc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsferf}
\label{\detokenize{reference/externalLibraries:gslsferf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}erf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsferfZ}
\label{\detokenize{reference/externalLibraries:gslsferfz}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}erf\PYGZus{}Z}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsferfQ}
\label{\detokenize{reference/externalLibraries:gslsferfq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}erf\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhazard}
\label{\detokenize{reference/externalLibraries:gslsfhazard}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hazard}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexp}
\label{\detokenize{reference/externalLibraries:gslsfexp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}exp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpmult}
\label{\detokenize{reference/externalLibraries:gslsfexpmult}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}exp\PYGZus{}mult}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpm1}
\label{\detokenize{reference/externalLibraries:gslsfexpm1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expm1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexprel}
\label{\detokenize{reference/externalLibraries:gslsfexprel}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}exprel}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexprel2}
\label{\detokenize{reference/externalLibraries:gslsfexprel2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}exprel\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpreln}
\label{\detokenize{reference/externalLibraries:gslsfexpreln}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}exprel\PYGZus{}n}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintE1}
\label{\detokenize{reference/externalLibraries:gslsfexpinte1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}E1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintE2}
\label{\detokenize{reference/externalLibraries:gslsfexpinte2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}E2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintEn}
\label{\detokenize{reference/externalLibraries:gslsfexpinten}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}En}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintE1scaled}
\label{\detokenize{reference/externalLibraries:gslsfexpinte1scaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}E1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintE2scaled}
\label{\detokenize{reference/externalLibraries:gslsfexpinte2scaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}E1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintEnscaled}
\label{\detokenize{reference/externalLibraries:gslsfexpintenscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}En\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintEi}
\label{\detokenize{reference/externalLibraries:gslsfexpintei}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}Ei}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintEiscaled}
\label{\detokenize{reference/externalLibraries:gslsfexpinteiscaled}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}Ei\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfShi}
\label{\detokenize{reference/externalLibraries:gslsfshi}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}Shi}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfChi}
\label{\detokenize{reference/externalLibraries:gslsfchi}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}Chi}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpint3}
\label{\detokenize{reference/externalLibraries:gslsfexpint3}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfSi}
\label{\detokenize{reference/externalLibraries:gslsfsi}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}Si}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfCi}
\label{\detokenize{reference/externalLibraries:gslsfci}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}Ci}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfatanint}
\label{\detokenize{reference/externalLibraries:gslsfatanint}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}atanint}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidiracm1}
\label{\detokenize{reference/externalLibraries:gslsffermidiracm1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}m1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidirac0}
\label{\detokenize{reference/externalLibraries:gslsffermidirac0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidirac1}
\label{\detokenize{reference/externalLibraries:gslsffermidirac1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidirac2}
\label{\detokenize{reference/externalLibraries:gslsffermidirac2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidiracint}
\label{\detokenize{reference/externalLibraries:gslsffermidiracint}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidiracmhalf}
\label{\detokenize{reference/externalLibraries:gslsffermidiracmhalf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}mhalf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidirachalf}
\label{\detokenize{reference/externalLibraries:gslsffermidirachalf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}half}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidirac3half}
\label{\detokenize{reference/externalLibraries:gslsffermidirac3half}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}3half}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidiracinc0}
\label{\detokenize{reference/externalLibraries:gslsffermidiracinc0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}inc\PYGZus{}0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflngamma}
\label{\detokenize{reference/externalLibraries:gslsflngamma}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lngamma}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgamma}
\label{\detokenize{reference/externalLibraries:gslsfgamma}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gamma}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgammastar}
\label{\detokenize{reference/externalLibraries:gslsfgammastar}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gammastar}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgammainv}
\label{\detokenize{reference/externalLibraries:gslsfgammainv}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gammainv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsftaylorcoeff}
\label{\detokenize{reference/externalLibraries:gslsftaylorcoeff}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}taylorcoeff}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffact}
\label{\detokenize{reference/externalLibraries:gslsffact}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fact}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdoublefact}
\label{\detokenize{reference/externalLibraries:gslsfdoublefact}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}doublefact}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflnfact}
\label{\detokenize{reference/externalLibraries:gslsflnfact}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lnfact}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflndoublefact}
\label{\detokenize{reference/externalLibraries:gslsflndoublefact}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lndoublefact}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflnchoose}
\label{\detokenize{reference/externalLibraries:gslsflnchoose}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lnchoose}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfchoose}
\label{\detokenize{reference/externalLibraries:gslsfchoose}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}choose}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflnpoch}
\label{\detokenize{reference/externalLibraries:gslsflnpoch}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lnpoch}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpoch}
\label{\detokenize{reference/externalLibraries:gslsfpoch}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}poch}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpochrel}
\label{\detokenize{reference/externalLibraries:gslsfpochrel}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}pochrel}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgammaincQ}
\label{\detokenize{reference/externalLibraries:gslsfgammaincq}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gamma\PYGZus{}inc\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgammaincP}
\label{\detokenize{reference/externalLibraries:gslsfgammaincp}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gamma\PYGZus{}inc\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgammainc}
\label{\detokenize{reference/externalLibraries:gslsfgammainc}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gamma\PYGZus{}inc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflnbeta}
\label{\detokenize{reference/externalLibraries:gslsflnbeta}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lnbeta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbeta}
\label{\detokenize{reference/externalLibraries:gslsfbeta}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}beta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbetainc}
\label{\detokenize{reference/externalLibraries:gslsfbetainc}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
gsl\PYGZus{}sf\PYGZus{}betaçinc(a, b, c)
\end{sphinxVerbatim}


\subsubsection{gslsfgegenpoly1}
\label{\detokenize{reference/externalLibraries:gslsfgegenpoly1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gegenpoly\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgegenpoly2}
\label{\detokenize{reference/externalLibraries:gslsfgegenpoly2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gegenpoly\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgegenpoly3}
\label{\detokenize{reference/externalLibraries:gslsfgegenpoly3}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gegenpoly\PYGZus{}3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgegenpolyn}
\label{\detokenize{reference/externalLibraries:gslsfgegenpolyn}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gegenpoly\PYGZus{}n}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhyperg0F1}
\label{\detokenize{reference/externalLibraries:gslsfhyperg0f1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}0F1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhyperg1F1int}
\label{\detokenize{reference/externalLibraries:gslsfhyperg1f1int}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}1F1\PYGZus{}inc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhyperg1F1}
\label{\detokenize{reference/externalLibraries:gslsfhyperg1f1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}1F1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhypergUint}
\label{\detokenize{reference/externalLibraries:gslsfhyperguint}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}U\PYGZus{}inc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhypergU}
\label{\detokenize{reference/externalLibraries:gslsfhypergu}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}U}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhyperg2F0}
\label{\detokenize{reference/externalLibraries:gslsfhyperg2f0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}U\PYGZus{}2F0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflaguerre1}
\label{\detokenize{reference/externalLibraries:gslsflaguerre1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}laguerre\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflaguerre2}
\label{\detokenize{reference/externalLibraries:gslsflaguerre2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}laguerre\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflaguerre3}
\label{\detokenize{reference/externalLibraries:gslsflaguerre3}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}laguerre\PYGZus{}3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflaguerren}
\label{\detokenize{reference/externalLibraries:gslsflaguerren}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}laguerre\PYGZus{}n}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflambertW0}
\label{\detokenize{reference/externalLibraries:gslsflambertw0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lambert\PYGZus{}W0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflambertWm1}
\label{\detokenize{reference/externalLibraries:gslsflambertwm1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lambert\PYGZus{}Wm1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendrePl}
\label{\detokenize{reference/externalLibraries:gslsflegendrepl}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}Pl}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreP1}
\label{\detokenize{reference/externalLibraries:gslsflegendrep1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}P1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreP2}
\label{\detokenize{reference/externalLibraries:gslsflegendrep2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}P2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreP3}
\label{\detokenize{reference/externalLibraries:gslsflegendrep3}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}P3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreQ0}
\label{\detokenize{reference/externalLibraries:gslsflegendreq0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}Q0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreQ1}
\label{\detokenize{reference/externalLibraries:gslsflegendreq1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}Q1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreQl}
\label{\detokenize{reference/externalLibraries:gslsflegendreql}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}Ql}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendrePlm}
\label{\detokenize{reference/externalLibraries:gslsflegendreplm}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}Plm}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendresphPlm}
\label{\detokenize{reference/externalLibraries:gslsflegendresphplm}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}sphP1m}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendrearraysize}
\label{\detokenize{reference/externalLibraries:gslsflegendrearraysize}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}array\PYGZus{}size}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalPhalf}
\label{\detokenize{reference/externalLibraries:gslsfconicalphalf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}half}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalPmhalf}
\label{\detokenize{reference/externalLibraries:gslsfconicalpmhalf}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}mhalf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalP0}
\label{\detokenize{reference/externalLibraries:gslsfconicalp0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalP1}
\label{\detokenize{reference/externalLibraries:gslsfconicalp1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalPsphreg}
\label{\detokenize{reference/externalLibraries:gslsfconicalpsphreg}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}sph\PYGZus{}reg}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalPcylreg}
\label{\detokenize{reference/externalLibraries:gslsfconicalpcylreg}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}cyl\PYGZus{}reg}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreH3d0}
\label{\detokenize{reference/externalLibraries:gslsflegendreh3d0}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}H3d\PYGZus{}0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreH3d1}
\label{\detokenize{reference/externalLibraries:gslsflegendreh3d1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}H3d\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreH3d}
\label{\detokenize{reference/externalLibraries:gslsflegendreh3d}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}H3d}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflog}
\label{\detokenize{reference/externalLibraries:gslsflog}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}log}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflogabs}
\label{\detokenize{reference/externalLibraries:gslsflogabs}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}log\PYGZus{}abs}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflog1plusx}
\label{\detokenize{reference/externalLibraries:gslsflog1plusx}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}log\PYGZus{}1plusx}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflog1plusxmx}
\label{\detokenize{reference/externalLibraries:gslsflog1plusxmx}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}log\PYGZus{}1plusx\PYGZus{}mx}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpowint}
\label{\detokenize{reference/externalLibraries:gslsfpowint}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}pow\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsiint}
\label{\detokenize{reference/externalLibraries:gslsfpsiint}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsi}
\label{\detokenize{reference/externalLibraries:gslsfpsi}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsi1piy}
\label{\detokenize{reference/externalLibraries:gslsfpsi1piy}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi\PYGZus{}1piy}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsi1int}
\label{\detokenize{reference/externalLibraries:gslsfpsi1int}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi\PYGZus{}1\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsi1}
\label{\detokenize{reference/externalLibraries:gslsfpsi1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsin}
\label{\detokenize{reference/externalLibraries:gslsfpsin}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi\PYGZus{}n}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfsynchrotron1}
\label{\detokenize{reference/externalLibraries:gslsfsynchrotron1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}synchrotron\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfsynchrotron2}
\label{\detokenize{reference/externalLibraries:gslsfsynchrotron2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}synchrotron\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsftransport2}
\label{\detokenize{reference/externalLibraries:gslsftransport2}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}transport\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsftransport3}
\label{\detokenize{reference/externalLibraries:gslsftransport3}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}transport\PYGZus{}3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsftransport4}
\label{\detokenize{reference/externalLibraries:gslsftransport4}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}transport\PYGZus{}4}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsftransport5}
\label{\detokenize{reference/externalLibraries:gslsftransport5}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}transport\PYGZus{}5}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfsin}
\label{\detokenize{reference/externalLibraries:gslsfsin}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}sin}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfcos}
\label{\detokenize{reference/externalLibraries:gslsfcos}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}cos}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhypot}
\label{\detokenize{reference/externalLibraries:gslsfhypot}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hypot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfsinc}
\label{\detokenize{reference/externalLibraries:gslsfsinc}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}sinc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflnsinh}
\label{\detokenize{reference/externalLibraries:gslsflnsinh}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lnsinh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflncosh}
\label{\detokenize{reference/externalLibraries:gslsflncosh}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lncosh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfanglerestrictsymm}
\label{\detokenize{reference/externalLibraries:gslsfanglerestrictsymm}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}andle\PYGZus{}restrict\PYGZus{}symm}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfanglerestrictpos}
\label{\detokenize{reference/externalLibraries:gslsfanglerestrictpos}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}angle\PYGZus{}restrict\PYGZus{}pos}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfzetaint}
\label{\detokenize{reference/externalLibraries:gslsfzetaint}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}zeta\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfzeta}
\label{\detokenize{reference/externalLibraries:gslsfzeta}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}zeta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfzetam1}
\label{\detokenize{reference/externalLibraries:gslsfzetam1}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}zetam1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfzetam1int}
\label{\detokenize{reference/externalLibraries:gslsfzetam1int}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}zetam1\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhzeta}
\label{\detokenize{reference/externalLibraries:gslsfhzeta}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hzeta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfetaint}
\label{\detokenize{reference/externalLibraries:gslsfetaint}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}eta\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfeta}
\label{\detokenize{reference/externalLibraries:gslsfeta}}
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}eta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{ff-Ipopt}
\label{\detokenize{reference/externalLibraries:ff-ipopt}}
Refer to the \sphinxhref{https://projects.coin-or.org/Ipopt}{Ipopt documentation} for more informations.


\subsubsection{IPOPT}
\label{\detokenize{reference/externalLibraries:ipopt}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-38}Todo:}
todo
\end{sphinxadmonition}


\subsection{fflapack}
\label{\detokenize{reference/externalLibraries:fflapack}}
Refer to the \sphinxhref{http://www.netlib.org/lapack/}{LAPACK documentation} for more informations.


\subsubsection{inv}
\label{\detokenize{reference/externalLibraries:inv}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-39}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dgeev}
\label{\detokenize{reference/externalLibraries:dgeev}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-40}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{zgeev}
\label{\detokenize{reference/externalLibraries:zgeev}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-41}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{geev}
\label{\detokenize{reference/externalLibraries:geev}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-42}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{geev}
\label{\detokenize{reference/externalLibraries:id13}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-43}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dggev}
\label{\detokenize{reference/externalLibraries:dggev}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-44}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{zggev}
\label{\detokenize{reference/externalLibraries:zggev}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-45}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dsygvd}
\label{\detokenize{reference/externalLibraries:dsygvd}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-46}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dgesdd}
\label{\detokenize{reference/externalLibraries:dgesdd}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-47}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{zhegv}
\label{\detokenize{reference/externalLibraries:zhegv}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-48}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dsyev}
\label{\detokenize{reference/externalLibraries:dsyev}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-49}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{zheev}
\label{\detokenize{reference/externalLibraries:zheev}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-50}Todo:}
todo
\end{sphinxadmonition}


\subsection{ff-mmap-semaphore}
\label{\detokenize{reference/externalLibraries:ff-mmap-semaphore}}

\subsubsection{Wait}
\label{\detokenize{reference/externalLibraries:wait}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-51}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{trywait}
\label{\detokenize{reference/externalLibraries:trywait}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-52}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{Post}
\label{\detokenize{reference/externalLibraries:post}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-53}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{msync}
\label{\detokenize{reference/externalLibraries:msync}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-54}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{Read}
\label{\detokenize{reference/externalLibraries:read}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-55}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{Write}
\label{\detokenize{reference/externalLibraries:write}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-56}Todo:}
todo
\end{sphinxadmonition}


\subsection{ffnewuoa}
\label{\detokenize{reference/externalLibraries:ffnewuoa}}

\subsubsection{newuoa}
\label{\detokenize{reference/externalLibraries:newuoa}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-57}Todo:}
todo
\end{sphinxadmonition}


\subsection{ff-NLopt}
\label{\detokenize{reference/externalLibraries:ff-nlopt}}
Refer to the \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLOPT documentation} for more informations.


\subsubsection{nloptDIRECT}
\label{\detokenize{reference/externalLibraries:nloptdirect}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-58}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTL}
\label{\detokenize{reference/externalLibraries:nloptdirectl}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-59}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTLRand}
\label{\detokenize{reference/externalLibraries:nloptdirectlrand}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-60}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTScal}
\label{\detokenize{reference/externalLibraries:nloptdirectscal}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-61}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTNoScal}
\label{\detokenize{reference/externalLibraries:nloptdirectnoscal}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-62}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTLNoScal}
\label{\detokenize{reference/externalLibraries:nloptdirectlnoscal}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-63}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTLRandNoScal}
\label{\detokenize{reference/externalLibraries:nloptdirectlrandnoscal}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-64}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptOrigDIRECT}
\label{\detokenize{reference/externalLibraries:nloptorigdirect}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-65}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptOrigDIRECTL}
\label{\detokenize{reference/externalLibraries:nloptorigdirectl}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-66}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptStoGO}
\label{\detokenize{reference/externalLibraries:nloptstogo}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-67}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptStoGORand}
\label{\detokenize{reference/externalLibraries:nloptstogorand}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-68}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptLBFGS}
\label{\detokenize{reference/externalLibraries:nloptlbfgs}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-69}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptPRAXIS}
\label{\detokenize{reference/externalLibraries:nloptpraxis}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-70}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptVar1}
\label{\detokenize{reference/externalLibraries:nloptvar1}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-71}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptVar2}
\label{\detokenize{reference/externalLibraries:nloptvar2}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-72}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptTNewton}
\label{\detokenize{reference/externalLibraries:nlopttnewton}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-73}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptTNewtonRestart}
\label{\detokenize{reference/externalLibraries:nlopttnewtonrestart}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-74}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptTNewtonPrecond}
\label{\detokenize{reference/externalLibraries:nlopttnewtonprecond}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-75}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptTNewtonPrecondRestart}
\label{\detokenize{reference/externalLibraries:nlopttnewtonprecondrestart}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-76}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptCRS2}
\label{\detokenize{reference/externalLibraries:nloptcrs2}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-77}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptMMA}
\label{\detokenize{reference/externalLibraries:nloptmma}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-78}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptCOBYLA}
\label{\detokenize{reference/externalLibraries:nloptcobyla}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-79}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptNEWUOA}
\label{\detokenize{reference/externalLibraries:nloptnewuoa}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-80}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptNEWUOABound}
\label{\detokenize{reference/externalLibraries:nloptnewuoabound}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-81}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptNelderMead}
\label{\detokenize{reference/externalLibraries:nloptneldermead}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-82}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptSbplx}
\label{\detokenize{reference/externalLibraries:nloptsbplx}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-83}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptBOBYQA}
\label{\detokenize{reference/externalLibraries:nloptbobyqa}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-84}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptISRES}
\label{\detokenize{reference/externalLibraries:nloptisres}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-85}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptSLSQP}
\label{\detokenize{reference/externalLibraries:nloptslsqp}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-86}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptMLSL}
\label{\detokenize{reference/externalLibraries:nloptmlsl}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-87}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptMLSLLDS}
\label{\detokenize{reference/externalLibraries:nloptmlsllds}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-88}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptAUGLAG}
\label{\detokenize{reference/externalLibraries:nloptauglag}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-89}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{nloptAUGLAGEQ}
\label{\detokenize{reference/externalLibraries:nloptauglageq}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-90}Todo:}
todo
\end{sphinxadmonition}


\subsection{ffrandom}
\label{\detokenize{reference/externalLibraries:ffrandom}}

\subsubsection{srandomdev}
\label{\detokenize{reference/externalLibraries:srandomdev}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-91}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{srandom}
\label{\detokenize{reference/externalLibraries:srandom}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-92}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{random}
\label{\detokenize{reference/externalLibraries:random}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-93}Todo:}
todo
\end{sphinxadmonition}


\subsection{FreeFemQA}
\label{\detokenize{reference/externalLibraries:freefemqa}}

\subsubsection{MeshGenQA}
\label{\detokenize{reference/externalLibraries:meshgenqa}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-94}Todo:}
todo
\end{sphinxadmonition}


\subsection{freeyams}
\label{\detokenize{reference/externalLibraries:freeyams}}

\subsubsection{freeyams}
\label{\detokenize{reference/externalLibraries:id14}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-95}Todo:}
todo
\end{sphinxadmonition}


\subsection{gmsh}
\label{\detokenize{reference/externalLibraries:gmsh}}
Need

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gsmh}\PYG{l+s}{\PYGZdq{}}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{gmsh}} software is available \sphinxhref{http://gmsh.info/}{here}


\subsubsection{gmshload}
\label{\detokenize{reference/externalLibraries:gmshload}}
Load a 2D mesh build with Gmsh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{gmshload}\PYG{p}{(}\PYG{n}{MeshFile}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{reftri}\PYG{o}{=}\PYG{n}{RefTri}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{renum}\PYG{o}{=}\PYG{n}{Renum}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MeshFile}} (\sphinxcode{\sphinxupquote{string}}) Mesh file name

\item {} 
\sphinxcode{\sphinxupquote{reftri=}} (.. todo:: todo)

\item {} 
\sphinxcode{\sphinxupquote{renum=}} (.. todo:: todo)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\end{itemize}


\subsubsection{gmshload3}
\label{\detokenize{reference/externalLibraries:gmshload3}}
Load a 3D mesh build with Gmsh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{gmshload}\PYG{p}{(}\PYG{n}{MeshFile}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{reftet}\PYG{o}{=}\PYG{n}{RefTet}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{renum}\PYG{o}{=}\PYG{n}{Renum}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MeshFile}} (\sphinxcode{\sphinxupquote{string}}) Mesh file name

\item {} 
\sphinxcode{\sphinxupquote{reftet=}} (.. todo:: todo)

\item {} 
\sphinxcode{\sphinxupquote{renum=}} (.. todo:: todo)

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh3}})

\end{itemize}


\subsubsection{savegmsh}
\label{\detokenize{reference/externalLibraries:savegmsh}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-96}Todo:}
todo
\end{sphinxadmonition}


\subsection{gsl}
\label{\detokenize{reference/externalLibraries:gsl}}

\subsubsection{gslpolysolvequadratic}
\label{\detokenize{reference/externalLibraries:gslpolysolvequadratic}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-97}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{gslpolysolvecubic}
\label{\detokenize{reference/externalLibraries:gslpolysolvecubic}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-98}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{gslpolycomplexsolve}
\label{\detokenize{reference/externalLibraries:gslpolycomplexsolve}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-99}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{gslrnguniform}
\label{\detokenize{reference/externalLibraries:gslrnguniform}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-100}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{gslrnguniformpos}
\label{\detokenize{reference/externalLibraries:gslrnguniformpos}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-101}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{gslname}
\label{\detokenize{reference/externalLibraries:gslname}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-102}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{gslrngget}
\label{\detokenize{reference/externalLibraries:gslrngget}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-103}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{gslrngmin}
\label{\detokenize{reference/externalLibraries:gslrngmin}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-104}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{gslrngmax}
\label{\detokenize{reference/externalLibraries:gslrngmax}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-105}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{gslrngset}
\label{\detokenize{reference/externalLibraries:gslrngset}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-106}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{gslrngtype}
\label{\detokenize{reference/externalLibraries:gslrngtype}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-107}Todo:}
todo
\end{sphinxadmonition}


\subsection{ilut}
\label{\detokenize{reference/externalLibraries:ilut}}

\subsubsection{applyIlutPrecond}
\label{\detokenize{reference/externalLibraries:applyilutprecond}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-108}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{makeIlutPrecond}
\label{\detokenize{reference/externalLibraries:makeilutprecond}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-109}Todo:}
todo
\end{sphinxadmonition}


\subsection{iohdf5}
\label{\detokenize{reference/externalLibraries:iohdf5}}

\subsubsection{savehdf5sol}
\label{\detokenize{reference/externalLibraries:savehdf5sol}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-110}Todo:}
todo
\end{sphinxadmonition}


\subsection{iovtk}
\label{\detokenize{reference/externalLibraries:iovtk}}

\subsubsection{savevtk}
\label{\detokenize{reference/externalLibraries:savevtk}}
Save mesh or solution in vtk/vtu format.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savevtk}\PYG{p}{(}\PYG{n}{FileName}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{,} \PYG{n}{Uz}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{dataname}\PYG{o}{=}\PYG{n}{DataName}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{withsurfacemesh}\PYG{o}{=}\PYG{n}{WithSurfaceMesh}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{order}\PYG{o}{=}\PYG{n}{Order}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{floatmesh}\PYG{o}{=}\PYG{n}{FloatMesh}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{floatsol}\PYG{o}{=}\PYG{n}{FloatSol}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{bin}\PYG{o}{=}\PYG{n}{Bin}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{swap}\PYG{o}{=}\PYG{n}{Swap}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{FileName}} (\sphinxcode{\sphinxupquote{string}}) File name: \sphinxcode{\sphinxupquote{*.vtk}} or
\sphinxcode{\sphinxupquote{*.vtu}}

\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}})

\item {} 
\sphinxcode{\sphinxupquote{{[}Ux, Uy, Uz{]}, p}} (\sphinxcode{\sphinxupquote{fespace}} function of vector of \sphinxcode{\sphinxupquote{fespace}} functions) Solutions to save, as much as wanted

\item {} 
\sphinxcode{\sphinxupquote{dataname=}} (\sphinxcode{\sphinxupquote{string}}) Name of solutions, seprated by a space

\item {} 
\sphinxcode{\sphinxupquote{withsurfacemesh=}} (\sphinxcode{\sphinxupquote{bool}})
.. todo:: todo

\item {} 
\sphinxcode{\sphinxupquote{order=}} (\sphinxcode{\sphinxupquote{int{[}int{]}}}) Order of solutions.

Available: 0 or 1

\item {} 
\sphinxcode{\sphinxupquote{floatmesh=}} (\sphinxcode{\sphinxupquote{bool}}) .. todo:: todo

\item {} 
\sphinxcode{\sphinxupquote{floatsol=}} (\sphinxcode{\sphinxupquote{bool}}) .. todo:: todo

\item {} 
\sphinxcode{\sphinxupquote{bin=}} (\sphinxcode{\sphinxupquote{bool}}) If true, save file in binary format

\item {} 
\sphinxcode{\sphinxupquote{swap}} (\sphinxcode{\sphinxupquote{bool}}) .. todo:: todo

\end{itemize}

Output:
\begin{itemize}
\item {} 
None

\end{itemize}


\subsubsection{vtkload}
\label{\detokenize{reference/externalLibraries:vtkload}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-111}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{vtkload3}
\label{\detokenize{reference/externalLibraries:vtkload3}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-112}Todo:}
todo
\end{sphinxadmonition}


\subsection{isoline}
\label{\detokenize{reference/externalLibraries:isoline}}
Need

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{isoline}\PYG{l+s}{\PYGZdq{}}
\end{sphinxVerbatim}


\subsubsection{isoline}
\label{\detokenize{reference/externalLibraries:id15}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{N} \PYG{o}{=} \PYG{n+nf}{isoline}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{xy}\PYG{p}{,} \PYG{k+kp}{iso}\PYG{o}{=}\PYG{n}{Iso}\PYG{p}{,} \PYG{k+kp}{close}\PYG{o}{=}\PYG{n}{Close}\PYG{p}{,} \PYG{k+kp}{smoothing}\PYG{o}{=}\PYG{n}{Smoothing}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{n}{Ratio}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{Eps}\PYG{p}{,} \PYG{k+kp}{beginend}\PYG{o}{=}\PYG{n}{BeginEnd}\PYG{p}{,} \PYG{k+kp}{file}\PYG{o}{=}\PYG{n}{File}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-113}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{Curve}
\label{\detokenize{reference/externalLibraries:curve}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-114}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{Area}
\label{\detokenize{reference/externalLibraries:area}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-115}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{findallocalmin}
\label{\detokenize{reference/externalLibraries:findallocalmin}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-116}Todo:}
todo
\end{sphinxadmonition}


\subsection{lapack}
\label{\detokenize{reference/externalLibraries:lapack}}

\subsubsection{inv}
\label{\detokenize{reference/externalLibraries:id16}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-117}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dgeev}
\label{\detokenize{reference/externalLibraries:id17}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-118}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{zgeev}
\label{\detokenize{reference/externalLibraries:id18}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-119}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{geev}
\label{\detokenize{reference/externalLibraries:id19}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-120}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dggev}
\label{\detokenize{reference/externalLibraries:id20}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-121}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{zggev}
\label{\detokenize{reference/externalLibraries:id21}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-122}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dsygvd}
\label{\detokenize{reference/externalLibraries:id22}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-123}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dgesdd}
\label{\detokenize{reference/externalLibraries:id23}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-124}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{zhegv}
\label{\detokenize{reference/externalLibraries:id24}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-125}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dsyev}
\label{\detokenize{reference/externalLibraries:id25}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-126}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{zheev}
\label{\detokenize{reference/externalLibraries:id26}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-127}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dgelsy}
\label{\detokenize{reference/externalLibraries:dgelsy}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-128}Todo:}
todo
\end{sphinxadmonition}


\subsection{lgbmo}
\label{\detokenize{reference/externalLibraries:lgbmo}}

\subsubsection{bmo}
\label{\detokenize{reference/externalLibraries:bmo}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-129}Todo:}
todo
\end{sphinxadmonition}


\subsection{mat\_dervieux}
\label{\detokenize{reference/externalLibraries:mat-dervieux}}

\subsubsection{MatUpWind1}
\label{\detokenize{reference/externalLibraries:matupwind1}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-130}Todo:}
todo
\end{sphinxadmonition}


\subsection{mat\_psi}
\label{\detokenize{reference/externalLibraries:mat-psi}}

\subsubsection{MatUpWind0}
\label{\detokenize{reference/externalLibraries:matupwind0}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-131}Todo:}
todo
\end{sphinxadmonition}


\subsection{medit}
\label{\detokenize{reference/externalLibraries:medit}}\label{\detokenize{reference/externalLibraries:referencemedit}}

\subsubsection{medit}
\label{\detokenize{reference/externalLibraries:id27}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-132}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{savesol}
\label{\detokenize{reference/externalLibraries:savesol}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-133}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{readsol}
\label{\detokenize{reference/externalLibraries:readsol}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-134}Todo:}
todo
\end{sphinxadmonition}


\subsection{metis}
\label{\detokenize{reference/externalLibraries:metis}}

\subsubsection{metisnodal}
\label{\detokenize{reference/externalLibraries:metisnodal}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-135}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{metisdual}
\label{\detokenize{reference/externalLibraries:metisdual}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-136}Todo:}
todo
\end{sphinxadmonition}


\subsection{MetricKuate}
\label{\detokenize{reference/externalLibraries:metrickuate}}

\subsubsection{MetricKuate}
\label{\detokenize{reference/externalLibraries:id28}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-137}Todo:}
todo
\end{sphinxadmonition}


\subsection{MetricPk}
\label{\detokenize{reference/externalLibraries:metricpk}}

\subsubsection{MetricPk}
\label{\detokenize{reference/externalLibraries:id29}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-138}Todo:}
todo
\end{sphinxadmonition}


\subsection{mmg3d}
\label{\detokenize{reference/externalLibraries:mmg3d}}

\subsubsection{mmg3d}
\label{\detokenize{reference/externalLibraries:id30}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-139}Todo:}
todo
\end{sphinxadmonition}


\subsection{mmg3d-v4.0}
\label{\detokenize{reference/externalLibraries:mmg3d-v4-0}}

\subsubsection{mmg3d}
\label{\detokenize{reference/externalLibraries:id31}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-140}Todo:}
todo
\end{sphinxadmonition}


\subsection{msh3}
\label{\detokenize{reference/externalLibraries:msh3}}

\subsubsection{change}
\label{\detokenize{reference/externalLibraries:change}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-141}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{movemesh23}
\label{\detokenize{reference/externalLibraries:movemesh23}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-142}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{movemesh2D3Dsurf}
\label{\detokenize{reference/externalLibraries:movemesh2d3dsurf}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-143}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{movemesh3}
\label{\detokenize{reference/externalLibraries:movemesh3}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-144}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{movemesh}
\label{\detokenize{reference/externalLibraries:movemesh}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-145}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{movemesh3D}
\label{\detokenize{reference/externalLibraries:movemesh3d}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-146}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{deplacement}
\label{\detokenize{reference/externalLibraries:deplacement}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-147}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{checkbemesh}
\label{\detokenize{reference/externalLibraries:checkbemesh}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-148}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{buildlayers}
\label{\detokenize{reference/externalLibraries:id32}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-149}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{bcube}
\label{\detokenize{reference/externalLibraries:bcube}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-150}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{cube}
\label{\detokenize{reference/externalLibraries:cube}}
Construct a cubic mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{n}{nnX}\PYG{p}{,} \PYG{n}{nnY}\PYG{p}{,} \PYG{n}{nnZ}\PYG{p}{,} \PYG{p}{[}\PYG{n}{X}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{Flags}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{Region}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nnX}} (\sphinxcode{\sphinxupquote{int}}) Number of discretization point along \(x\)

\item {} 
\sphinxcode{\sphinxupquote{nnY}} (\sphinxcode{\sphinxupquote{int}}) Number of discretization point along \(y\)

\item {} 
\sphinxcode{\sphinxupquote{nnZ}} (\sphinxcode{\sphinxupquote{int}}) Number of discretization point along \(z\)

\item {} 
\sphinxcode{\sphinxupquote{X(x)}} (\sphinxcode{\sphinxupquote{func}}) \sphinxstyleemphasis{{[}Optional{]}} Affine function of \(x\) to define the length Default: \sphinxcode{\sphinxupquote{x}}

\item {} 
\sphinxcode{\sphinxupquote{Y(y)}} (\sphinxcode{\sphinxupquote{func}}) \sphinxstyleemphasis{{[}Optional{]}} Affine function of \(y\) to define the width Default: \sphinxcode{\sphinxupquote{y}}

\item {} 
\sphinxcode{\sphinxupquote{Z(z)}} (\sphinxcode{\sphinxupquote{func}}) \sphinxstyleemphasis{{[}Optional{]}} Affine function of \(z\) to define the height Default: \sphinxcode{\sphinxupquote{z}}

\item {} 
\sphinxcode{\sphinxupquote{label=}} (\sphinxcode{\sphinxupquote{int{[}int{]}}}) \sphinxstyleemphasis{{[}Optional{]}}

List of surface labels Default: \sphinxcode{\sphinxupquote{{[}1, 2, 3, 4, 5, 6{]}}}

\item {} 
\sphinxcode{\sphinxupquote{flags=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

Refer to {\hyperref[\detokenize{reference/functions:functionsquare}]{\sphinxcrossref{\DUrole{std,std-ref}{square}}}}

\item {} 
\sphinxcode{\sphinxupquote{region=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

Region number of the cube volume Default: \sphinxcode{\sphinxupquote{0}}

\end{itemize}

Output:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh3}}) Cube mesh

\end{itemize}


\subsubsection{trunc}
\label{\detokenize{reference/externalLibraries:trunc}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-151}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{gluemesh}
\label{\detokenize{reference/externalLibraries:gluemesh}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-152}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{extract}
\label{\detokenize{reference/externalLibraries:extract}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-153}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{showborder}
\label{\detokenize{reference/externalLibraries:showborder}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-154}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{getborder}
\label{\detokenize{reference/externalLibraries:getborder}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-155}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{AddLayers}
\label{\detokenize{reference/externalLibraries:addlayers}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-156}Todo:}
todo
\end{sphinxadmonition}


\subsection{mshmet}
\label{\detokenize{reference/externalLibraries:mshmet}}

\subsubsection{mshmet}
\label{\detokenize{reference/externalLibraries:id33}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-157}Todo:}
todo
\end{sphinxadmonition}


\subsection{MUMPS}
\label{\detokenize{reference/externalLibraries:mumps}}

\subsubsection{defaulttoMUMPSseq}
\label{\detokenize{reference/externalLibraries:defaulttomumpsseq}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-158}Todo:}
todo
\end{sphinxadmonition}


\subsection{MUMPS\_seq}
\label{\detokenize{reference/externalLibraries:mumps-seq}}

\subsubsection{defaulttoMUMPSseq}
\label{\detokenize{reference/externalLibraries:id34}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-159}Todo:}
todo
\end{sphinxadmonition}


\subsection{netgen}
\label{\detokenize{reference/externalLibraries:netgen}}

\subsubsection{netg}
\label{\detokenize{reference/externalLibraries:netg}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-160}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{netgstl}
\label{\detokenize{reference/externalLibraries:netgstl}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-161}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{netgload}
\label{\detokenize{reference/externalLibraries:netgload}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-162}Todo:}
todo
\end{sphinxadmonition}


\subsection{NewSolver}
\label{\detokenize{reference/externalLibraries:newsolver}}

\subsubsection{defaulttoUMFPACK}
\label{\detokenize{reference/externalLibraries:defaulttoumfpack}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-163}Todo:}
todo
\end{sphinxadmonition}


\subsection{PARDISO}
\label{\detokenize{reference/externalLibraries:pardiso}}

\subsubsection{defaulttoPARDISO}
\label{\detokenize{reference/externalLibraries:defaulttopardiso}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-164}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{ompsetnumthreads}
\label{\detokenize{reference/externalLibraries:ompsetnumthreads}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-165}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{ompgetnumthreads}
\label{\detokenize{reference/externalLibraries:ompgetnumthreads}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-166}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{ompgetmaxthreads}
\label{\detokenize{reference/externalLibraries:ompgetmaxthreads}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-167}Todo:}
todo
\end{sphinxadmonition}


\subsection{pcm2rnm}
\label{\detokenize{reference/externalLibraries:pcm2rnm}}

\subsubsection{readpcm}
\label{\detokenize{reference/externalLibraries:readpcm}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-168}Todo:}
todo
\end{sphinxadmonition}


\subsection{pipe}
\label{\detokenize{reference/externalLibraries:pipe}}

\subsubsection{flush}
\label{\detokenize{reference/externalLibraries:flush}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-169}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{sleep}
\label{\detokenize{reference/externalLibraries:sleep}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-170}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{usleep}
\label{\detokenize{reference/externalLibraries:usleep}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-171}Todo:}
todo
\end{sphinxadmonition}


\subsection{qf11to25}
\label{\detokenize{reference/externalLibraries:qf11to25}}

\subsubsection{QF1d}
\label{\detokenize{reference/externalLibraries:qf1d}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-172}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{QF2d}
\label{\detokenize{reference/externalLibraries:qf2d}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-173}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{QF3d}
\label{\detokenize{reference/externalLibraries:qf3d}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-174}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{tripleQF}
\label{\detokenize{reference/externalLibraries:tripleqf}}

\subsection{scotch}
\label{\detokenize{reference/externalLibraries:scotch}}

\subsubsection{scotch}
\label{\detokenize{reference/externalLibraries:id35}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-175}Todo:}
todo
\end{sphinxadmonition}


\subsection{shell}
\label{\detokenize{reference/externalLibraries:shell}}

\subsubsection{readdir}
\label{\detokenize{reference/externalLibraries:readdir}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-176}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{unlink}
\label{\detokenize{reference/externalLibraries:unlink}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-177}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{rmdir}
\label{\detokenize{reference/externalLibraries:rmdir}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-178}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{cddir}
\label{\detokenize{reference/externalLibraries:cddir}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-179}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{chdir}
\label{\detokenize{reference/externalLibraries:chdir}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-180}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{basename}
\label{\detokenize{reference/externalLibraries:basename}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-181}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{dirname}
\label{\detokenize{reference/externalLibraries:dirname}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-182}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{mkdir}
\label{\detokenize{reference/externalLibraries:mkdir}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-183}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{chmod}
\label{\detokenize{reference/externalLibraries:chmod}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-184}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{cpfile}
\label{\detokenize{reference/externalLibraries:cpfile}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-185}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{stat}
\label{\detokenize{reference/externalLibraries:stat}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-186}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{isdir}
\label{\detokenize{reference/externalLibraries:isdir}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-187}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{getenv}
\label{\detokenize{reference/externalLibraries:getenv}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-188}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{setenv}
\label{\detokenize{reference/externalLibraries:setenv}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-189}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{unsetenv}
\label{\detokenize{reference/externalLibraries:unsetenv}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-190}Todo:}
todo
\end{sphinxadmonition}


\subsection{splitedges}
\label{\detokenize{reference/externalLibraries:splitedges}}

\subsubsection{SplitedgeMesh}
\label{\detokenize{reference/externalLibraries:splitedgemesh}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-191}Todo:}
todo
\end{sphinxadmonition}


\subsection{splitmesh12}
\label{\detokenize{reference/externalLibraries:splitmesh12}}

\subsubsection{splitmesh12}
\label{\detokenize{reference/externalLibraries:id36}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-192}Todo:}
todo
\end{sphinxadmonition}


\subsection{splitmesh3}
\label{\detokenize{reference/externalLibraries:splitmesh3}}

\subsubsection{splitmesh3}
\label{\detokenize{reference/externalLibraries:id37}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-193}Todo:}
todo
\end{sphinxadmonition}


\subsection{splitmesh4}
\label{\detokenize{reference/externalLibraries:splitmesh4}}

\subsubsection{splimesh4}
\label{\detokenize{reference/externalLibraries:splimesh4}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-194}Todo:}
todo
\end{sphinxadmonition}


\subsection{splitmesh6}
\label{\detokenize{reference/externalLibraries:splitmesh6}}

\subsubsection{splitmesh6}
\label{\detokenize{reference/externalLibraries:id38}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-195}Todo:}
todo
\end{sphinxadmonition}


\subsection{SuperLu}
\label{\detokenize{reference/externalLibraries:superlu}}

\subsubsection{defaulttoSuperLu}
\label{\detokenize{reference/externalLibraries:defaulttosuperlu}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-196}Todo:}
todo
\end{sphinxadmonition}


\subsection{symmetrizeCSR}
\label{\detokenize{reference/externalLibraries:symmetrizecsr}}

\subsubsection{symmetrizeCSR}
\label{\detokenize{reference/externalLibraries:id39}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-197}Todo:}
todo
\end{sphinxadmonition}


\subsection{tetgen}
\label{\detokenize{reference/externalLibraries:tetgen}}
Refer to the \sphinxhref{http://wias-berlin.de/software/tetgen/}{Tetgen documentation} for more informations.


\subsubsection{tetgconvexhull}
\label{\detokenize{reference/externalLibraries:tetgconvexhull}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-198}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{tetgtransfo}
\label{\detokenize{reference/externalLibraries:tetgtransfo}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-199}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{tetg}
\label{\detokenize{reference/externalLibraries:tetg}}
Build a 3D mesh from a surface.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{reftet}\PYG{o}{=}\PYG{n}{RefTet}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{switch}\PYG{o}{=}\PYG{n}{Switch}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{nbofholes}\PYG{o}{=}\PYG{n}{NbOfHoles}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{holelist}\PYG{o}{=}\PYG{n}{HoleList}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{n}{NbOfRegions}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{RegionList}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{nboffacetcl}\PYG{o}{=}\PYG{n}{NbOfFaceTcl}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{facetcl}\PYG{o}{=}\PYG{n}{FaceTcl}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-200}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{tetgreconstruction}
\label{\detokenize{reference/externalLibraries:tetgreconstruction}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-201}Todo:}
todo
\end{sphinxadmonition}


\subsection{UMFPACK64}
\label{\detokenize{reference/externalLibraries:umfpack64}}

\subsubsection{defaulttoUMFPACK64}
\label{\detokenize{reference/externalLibraries:defaulttoumfpack64}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-202}Todo:}
todo
\end{sphinxadmonition}


\subsection{VTK\_writer\_3d}
\label{\detokenize{reference/externalLibraries:vtk-writer-3d}}

\subsubsection{Vtkaddmesh}
\label{\detokenize{reference/externalLibraries:vtkaddmesh}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-203}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{Vtkaddscalar}
\label{\detokenize{reference/externalLibraries:vtkaddscalar}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-204}Todo:}
todo
\end{sphinxadmonition}


\subsection{VTK\_writer}
\label{\detokenize{reference/externalLibraries:vtk-writer}}

\subsubsection{Vtkaddmesh}
\label{\detokenize{reference/externalLibraries:id40}}
\begin{sphinxadmonition}{note}{\label{reference/externalLibraries:index-205}Todo:}
todo
\end{sphinxadmonition}


\subsubsection{Vtkaddscalar}
\label{\detokenize{reference/externalLibraries:id41}}

\chapter{Mathematical Models}
\label{\detokenize{model/index:mathematical-models}}\label{\detokenize{model/index::doc}}
\sphinxstyleemphasis{Summary}:

This chapter goes deeper into a number of problems that \sphinxstylestrong{FreeFem++} can solve.
It is a complement to the {\hyperref[\detokenize{tutorial/index:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{Tutorial part}}}} which was only an introduction.

\sphinxstylestrong{Users are invited to contribute to make this models database grow.}


\section{Static problems}
\label{\detokenize{model/staticProblems:static-problems}}\label{\detokenize{model/staticProblems::doc}}

\subsection{Soap Film}
\label{\detokenize{model/staticProblems:soap-film}}\label{\detokenize{model/staticProblems:modelstatissoap}}
Our starting point here will be the mathematical model to find the shape of \sphinxstylestrong{soap film} which is glued to the ring on the \(xy-\)plane:
\begin{equation*}
\begin{split}C=\{(x,y);\;x=\cos t,\,y=\sin t,\,0\leq t\leq 2\pi \}\end{split}
\end{equation*}
We assume the shape of the film is described by the graph \((x,y,u(x,y))\) of the vertical displacement \(u(x,y)\, (x^2+y^2<1)\) under a vertical pressure \(p\) in terms of force per unit area and an initial tension \(\mu\) in terms of force per unit length.

Consider the “small plane” ABCD, A:\((x,y,u(x,y))\), B:\((x,y,u(x+\delta x,y))\), C:\((x,y,u(x+\delta x,y+\delta y))\) and D:\((x,y,u(x,y+\delta y))\).

Denote by \(\vec{n}(x,y)=(n_x(x,y),n_y(x,y),n_z(x,y))\) the normal vector of the surface \(z=u(x,y)\).
We see that the vertical force due to the tension \(\mu\) acting along the edge AD is \(-\mu n_x(x,y)\delta y\) and the the vertical force acting along the edge AD is:
\begin{equation*}
\begin{split}\mu n_x(x+\delta x,y)\delta y\simeq \mu\left(n_x(x,y)+\frac{\p n_x}{\p x}\delta x\right)(x,y)\delta y\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{StaticProblems_SoapFilm}.png}
\end{figure}

Similarly, for the edges AB and DC we have:
\begin{equation*}
\begin{split}-\mu n_y(x,y)\delta x,\quad\mu\left(n_y(x,y)+\p n_y/\p y\right)(x,y)\delta x\end{split}
\end{equation*}
The force in the vertical direction on the surface ABCD due to the tension \(\mu\) is given by:
\begin{equation*}
\begin{split}\mu\left(\p n_x/\p x\right)\delta x\delta y+T\left(\p n_y/\p y\right)\delta y\delta x\end{split}
\end{equation*}
Assuming small displacements, we have:
\begin{equation*}
\begin{split}\begin{array}{rcccl}
    \nu_x&=&(\p u/\p x)/\sqrt{1+(\p u/\p x)^2+(\p u/\p y)^2}&\simeq& \p u/\p x,\\
    \nu_y&=&(\p u/\p y)/\sqrt{1+(\p u/\p x)^2+(\p u/\p y)^2}&\simeq& \p u/\p y
\end{array}\end{split}
\end{equation*}
Letting \(\delta x\to dx,\, \delta y\to dy\), we have the equilibrium of the vertical displacement of soap film on ABCD by \(p\):
\begin{equation*}
\begin{split}\mu dx dy\p^2 u/\p x^2 +\mu dx dy\p^2 u/\p y^2 + p dx dy = 0\end{split}
\end{equation*}
Using the Laplace operator \(\Delta = \p^2 /\p x^2 + \p^2 /\p y^2\), we can find the virtual displacement write the following:
\begin{equation*}
\begin{split}-\Delta u = f\quad \mbox{in }\Omega\end{split}
\end{equation*}
where \(f=p/\mu\), \(\Omega =\{(x,y);\;x^{2}+y^{2}<1\}\).

{\hyperref[\detokenize{tutorial/poisson:tutorialpoisson}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson’s equation}}}} appears also in \sphinxstylestrong{electrostatics} taking the form of \(f=\rho / \epsilon\) where \(\rho\) is the charge density, \(\epsilon\) the dielectric constant and \(u\) is named as electrostatic potential.

The soap film is glued to the ring \(\p \Omega =C\), then we have the boundary condition:
\begin{equation*}
\begin{split}u=0\quad \mbox{on }\p \Omega\end{split}
\end{equation*}
If the force is gravity, for simplify, we assume that \(f=-1\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{;} \PYG{c+c1}{//ue: exact solution}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{disk} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{femp1}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{femp1} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{laplace} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//bilinear form}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//linear form}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//boundary condition}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{laplace}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{n}{femp1} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{u} \PYG{o}{\PYGZhy{}} \PYG{n}{ue}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kp}{err}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{k+kp}{err}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error H10 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{/// Re\PYGZhy{}run with a mesh adaptation ///}

\PYG{c+c1}{// Mesh adaptation}
\PYG{n}{disk} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{laplace}\PYG{p}{;}
\PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{u} \PYG{o}{\PYGZhy{}} \PYG{n}{ue}\PYG{p}{;} \PYG{c+c1}{//become FE\PYGZhy{}function on adapted mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kp}{err}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{k+kp}{err}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error H10 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{StaticProblems_SoapFilmSol}.png}
\caption{Isovalue of \(u\)}\label{\detokenize{model/staticProblems:examplestaticproblemssoapfilmsol}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{StaticProblems_SoapFilm3D}.png}
\caption{A side view of \(u\)}\label{\detokenize{model/staticProblems:examplestaticproblemssoapfilm3d}}\end{figure}

In the 37th line, the \(L^2\)-error estimation between the exact solution \(u_e\),
\begin{equation*}
\begin{split}\|u_h - u_e\|_{0,\Omega}=\left(\int_{\Omega}|u_h-u_e|^2\, \d x\d y\right)^{1/2}\end{split}
\end{equation*}
and in the following line, the \(H^1\)-error seminorm estimation:
\begin{equation*}
\begin{split}|u_h - u_e|_{1,\Omega}=\left(\int_{\Omega}|\nabla u_h-\nabla u_e|^2\, \d x\d y\right)^{1/2}\end{split}
\end{equation*}
are done on the initial mesh.
The results are \(\|u_h - u_e\|_{0,\Omega}=0.000384045,\, |u_h - u_e|_{1,\Omega}=0.0375506\).

After the adaptation, we have \(\|u_h - u_e\|_{0,\Omega}=0.000109043,\, |u_h - u_e|_{1,\Omega}=0.0188411\).
So the numerical solution is improved by adaptation of mesh.


\subsection{Electrostatics}
\label{\detokenize{model/staticProblems:electrostatics}}
We assume that there is no current and a time independent charge distribution.
Then the electric field \(\mathbf{E}\) satisfies:
\begin{equation}\label{equation:model/staticProblems:eqn::Maxwell}
\begin{split}\begin{array}{rcl}
    \mathrm{div}\mathbf{E} &=& \rho/\epsilon\\
    \mathrm{curl}\mathbf{E} &=& 0
\end{array}\end{split}
\end{equation}
where \(\rho\) is the charge density and \(\epsilon\) is called the permittivity of free space.

From the equation \eqref{equation:model/staticProblems:eqn::Maxwell} We can introduce the electrostatic potential such that \(\mathbf{E}=-\nabla \phi\).
Then we have Poisson’s equation \(-\Delta \phi=f\), \(f=-\rho/\epsilon\).

We now obtain the equipotential line which is the level curve of \(\phi\), when there are no charges except conductors \(\{C_i\}_{1,\cdots,K}\).
Let us assume \(K\) conductors \(C_1,\cdots,C_K\) within an enclosure \(C_0\).

Each one is held at an electrostatic potential \(\varphi_i\).
We assume that the enclosure \(C0\) is held at potential 0.
In order to know \(\varphi(x)\) at any point \(x\) of the domain \(\Omega\), we must solve:
\begin{equation*}
\begin{split}-\Delta \varphi =0\quad \textrm{ in }\Omega\end{split}
\end{equation*}
where \(\Omega\) is the interior of \(C_0\) minus the conductors \(C_i\), and \(\Gamma\) is the boundary of \(\Omega\), that is \(\sum_{i=0}^N C_i\).

Here \(g\) is any function of \(x\) equal to \(\varphi_i\) on \(C_i\) and to 0 on \(C_0\).
The boundary equation is a reduced form for:
\begin{equation*}
\begin{split}\varphi =\varphi_{i}\;\text{on }C_{i},\;i=1...N,\varphi =0\;\text{on }C_{0}.\end{split}
\end{equation*}
First we give the geometrical informations; \(C_0=\{(x,y);\; x^2+y^2=5^2\}\), \(C_1=\{(x,y):\;\frac{1}{0.3^2}(x-2)^2+\frac{1}{3^2}y^2=1\}\), \(C_2=\{(x,y):\; \frac{1}{0.3^2}(x+2)^2+\frac{1}{3^2}y^2=1\}\).

Let \(\Omega\) be the disk enclosed by \(C_0\) with the elliptical holes enclosed by \(C_1\) and \(C_2\).
Note that \(C_0\) is described counterclockwise, whereas the elliptical holes are described clockwise, because the boundary must be oriented so that the computational domain is to its left.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Electro} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//bilinear}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//boundary condition on C\PYGZus{}0}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{//+1 volt on C\PYGZus{}1}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C2}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{//\PYGZhy{}1 volt on C\PYGZus{}2}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Electro}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_ElectrostaticsMesh}.png}
\caption{Disk with two elliptical holes}\label{\detokenize{model/staticProblems:examplestaticproblemselectrostaticsmesh}}\label{\detokenize{model/staticProblems:figdiskwithholes}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_Electrostatics}.png}
\caption{Equipotential lines where \(C_1\) is located in right hand side}\label{\detokenize{model/staticProblems:examplestaticproblemselectrostatics}}\label{\detokenize{model/staticProblems:figdiskwithlines}}\end{subfigure}


\end{figure}



\subsection{Aerodynamics}
\label{\detokenize{model/staticProblems:aerodynamics}}\label{\detokenize{model/staticProblems:DiskWithHoles}}
Let us consider a wing profile \(S\) in a uniform flow.
Infinity will be represented by a large circle \(\Gamma_{\infty}\).
As previously, we must solve:
\begin{equation}\label{equation:model/staticProblems:eqn:NACA-5-5}
\begin{split}\Delta \varphi=0\quad\textrm{in }\Omega,
\quad \varphi|_S=c,\quad
\varphi|_{\Gamma_{\infty}}=u_{\infty 1x}-u_{\infty2x}\end{split}
\end{equation}
where \(\Omega\) is the area occupied by the fluid, \(u_{\infty}\) is the air speed at infinity, \(c\) is a constant to be determined so that \(\p_n\varphi\) is continuous at the trailing edge \(P\) of \(S\) (so-called Kutta-Joukowski condition).
Lift is proportional to \(c\).

To find \(c\) we use a superposition method.
As all equations in \eqref{equation:model/staticProblems:eqn:NACA-5-5} are linear, the solution \(\varphi_c\) is a linear function of \(c\)
\begin{equation*}
\begin{split}\varphi_c = \varphi_0 + c\varphi_1\end{split}
\end{equation*}
where \(\varphi_0\) is a solution of \eqref{equation:model/staticProblems:eqn:NACA-5-5} with \(c = 0\) and \(\varphi_1\) is a solution with \(c = 1\) and zero speed at infinity.

With these two fields computed, we shall determine \(c\) by requiring the continuity of \(\p \varphi /\p n\) at the trailing edge.
An equation for the upper surface of a NACA0012 (this is a classical wing profile in aerodynamics; the rear of the wing is called the trailing edge) is:
\begin{equation*}
\begin{split}y = 0.17735\sqrt{x} - 0.075597x - 0.212836x^2 + 0.17363x^3 - 0.06254x^4\end{split}
\end{equation*}
Taking an incidence angle \(\alpha\) such that \(\tan \alpha = 0.1\), we must solve:
\begin{equation*}
\begin{split}-\Delta\varphi = 0\qquad \textrm{in }\Omega, \quad \varphi|_{\Gamma_1} = y - 0.1x,\quad \varphi |_{\Gamma_2} = c\end{split}
\end{equation*}
where \(\Gamma_2\) is the wing profile and \(\Gamma_1\) is an approximation of infinity.
One finds \(c\) by solving:
\begin{equation*}
\begin{split}\begin{array}{ccccccc}
    -\Delta\varphi_0 &= 0 &\textrm{in }\Omega&,\qquad \varphi_0|_{\Gamma_1} &= y - 0.1x&, \quad \varphi_0|_{\Gamma_2} &= 0,\\
    -\Delta\varphi_1 &= 0 &\textrm{in }\Omega&, \qquad \varphi_1|_{\Gamma_1} &= 0&, \quad \varphi_1|_{\Gamma_2} &= 1
\end{array}\end{split}
\end{equation*}
The solution \(\varphi = \varphi_0+c\varphi_1\) allows us to find \(c\) by writing that \(\p_n\varphi\) has no jump at the trailing edge \(P = (1, 0)\).

We have \(\p n\varphi -(\varphi (P^+)-\varphi (P))/\delta\) where \(P^+\) is the point just above \(P\) in the direction normal to the profile at a distance \(\delta\).
Thus the jump of \(\p_n\varphi\) is \((\varphi_0|_{P^+} +c(\varphi_1|_{P^+} -1))+(\varphi_0|_{P^-} +c(\varphi_1|_{P^-} -1))\) divided by \(\delta\) because the normal changes sign between the lower and upper surfaces. Thus
\begin{equation*}
\begin{split}c = -\frac{\varphi_0|_{P^+} + \varphi_0|_{P^-}}
{(\varphi_1|_{P^+} + \varphi_1|_{P^-} - 2)} ,\end{split}
\end{equation*}
which can be programmed as:
\begin{equation*}
\begin{split}c = -\frac{\varphi_0(0.99, 0.01) + \varphi_0(0.99,-0.01)}
{(\varphi_1(0.99, 0.01) + \varphi_1(0.99,-0.01) - 2)} .\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{upper}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{lower}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Zoom} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{upper}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lower}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{upper}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lower}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{psi0}\PYG{p}{,} \PYG{n}{psi1}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{ZVh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{Joukowski0}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{psi0}\PYG{o}{=}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{upper}\PYG{p}{,} \PYG{n}{lower}\PYG{p}{,} \PYG{n}{psi0}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{solve} \PYG{n+nf}{Joukowski1}\PYG{p}{(}\PYG{n}{psi1}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{psi1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{upper}\PYG{p}{,} \PYG{n}{lower}\PYG{p}{,} \PYG{n}{psi1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{psi1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//continuity of pressure at trailing edge}
\PYG{k+kt}{real} \PYG{n}{beta} \PYG{o}{=} \PYG{n}{psi0}\PYG{p}{(}\PYG{l+m+mf}{0.99}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{)} \PYG{o}{+} \PYG{n}{psi0}\PYG{p}{(}\PYG{l+m+mf}{0.99}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{beta} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{beta} \PYG{o}{/} \PYG{p}{(}\PYG{n}{psi1}\PYG{p}{(}\PYG{l+m+mf}{0.99}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{)} \PYG{o}{+} \PYG{n}{psi1}\PYG{p}{(}\PYG{l+m+mf}{0.99}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Vh} \PYG{n}{psi} \PYG{o}{=} \PYG{n}{beta}\PYG{o}{*}\PYG{n}{psi1} \PYG{o}{+} \PYG{n}{psi0}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ZVh} \PYG{n}{Zpsi} \PYG{o}{=} \PYG{n}{psi}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Zpsi}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ZVh} \PYG{n}{cp} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{cp}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ZVh} \PYG{n}{Zcp} \PYG{o}{=} \PYG{n}{cp}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Zcp}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_Aerodynamics1}.png}
\caption{Isovalue of \(cp = -(\p_x\psi)^2 - (\p_y\psi)^2\)}\label{\detokenize{model/staticProblems:examplestaticproblemsaerodynamics1}}\label{\detokenize{model/staticProblems:figisovalueofcp}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_Aerodynamics2}.png}
\caption{Zooming of \(cp\)}\label{\detokenize{model/staticProblems:examplestaticproblemsaerodynamics2}}\label{\detokenize{model/staticProblems:figzoomingofcp}}\end{subfigure}


\end{figure}



\subsection{Error estimation}
\label{\detokenize{model/staticProblems:error-estimation}}\label{\detokenize{model/staticProblems:IsovalueOfCp}}
There are famous estimation between the numerical result \(u_h\) and the exact solution \(u\) of the {\hyperref[\detokenize{tutorial/poisson:tutorialpoisson}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson’s problem}}}}:

If triangulations \(\{\mathcal{T}_h\}_{h\downarrow 0}\) is regular (see {\hyperref[\detokenize{documentation/meshGeneration:meshregulartriangulation}]{\sphinxcrossref{\DUrole{std,std-ref}{Regular Triangulation}}}}), then we have the estimates:
\begin{equation}\label{equation:model/staticProblems:eqn::ErrorEstimatation}
\begin{split}\begin{array}{rcl}
    |\nabla u - \nabla u_h|_{0,\Omega} &\le& C_1h \\
    \|u - u_h\|_{0,\Omega} &\le& C_2h^2
\end{array}\end{split}
\end{equation}
with constants \(C_1,\, C_2\) independent of \(h\), if \(u\) is in \(H^2(\Omega)\).
It is known that \(u\in H^2(\Omega)\) if \(\Omega\) is convex.

In this section we check \eqref{equation:model/staticProblems:eqn::ErrorEstimatation}.
We will pick up numericall error if we use the numerical derivative, so we will use the following for \eqref{equation:model/staticProblems:eqn::ErrorEstimatation}.
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \int_{\Omega}|\nabla u - \nabla u_h|^2\, \d x\d y &=&\int_{\Omega}\nabla u\cdot \nabla(u - 2u_h)\, \d x\d y+ \int_{\Omega}\nabla u_h\cdot \nabla u_h\, \d x\d y\\
    &=&\int_{\Omega}f(u-2u_h)\, \d x\d y+\int_{\Omega}fu_h\, \d x\d y
\end{array}\end{split}
\end{equation*}
The constants \(C_1,\, C_2\) are depend on \(\mathcal{T}_h\) and \(f\), so we will find them by \sphinxstylestrong{FreeFem++}.

In general, we cannot get the solution \(u\) as a elementary functions even if spetical functions are added.
Instead of the exact solution, here we use the approximate solution \(u_0\) in \(V_h(\mathcal{T}_h,P_2),\, h\sim 0\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{//Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th0} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{V0h}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{V0h} \PYG{n}{u0}\PYG{p}{,} \PYG{n}{v0}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{Poisson0} \PYG{p}{(}\PYG{n}{u0}\PYG{p}{,} \PYG{n}{v0}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v0}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v0}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v0}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u0}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error loop}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{errL2}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{errH1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Mesh}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{n}{i}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{n}{i}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Fespace}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Ph} \PYG{n}{h} \PYG{o}{=} \PYG{k+kr}{hTriangle}\PYG{p}{;} \PYG{c+c1}{//get the size of all triangles}

    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{solve} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
            \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
            \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{n}{V0h} \PYG{n}{uu} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//interpolate solution on first mesh}
    \PYG{n}{errL2}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n}{uu} \PYG{o}{\PYGZhy{}} \PYG{n}{u0}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{n}{errH1}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u0} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{uu} \PYG{o}{+} \PYG{n}{uu}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Display}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C1 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{errL2}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{errL2}\PYG{p}{.}\PYG{k+kr}{min}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{errH1}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{errH1}\PYG{p}{.}\PYG{k+kr}{min}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

We can guess that \(C_1=0.0179253(0.0173266)\) and \(C_2=0.0729566(0.0707543)\), where the numbers inside the parentheses are minimum in calculation.


\subsection{Periodic Boundary Conditions}
\label{\detokenize{model/staticProblems:periodic-boundary-conditions}}
We now solve the Poisson equation:
\begin{equation*}
\begin{split}-\Delta u = sin(x+\pi/4.)*cos(y+\pi/4.)\end{split}
\end{equation*}
on the square \(]0,2\pi[^2\) under bi-periodic boundary condition \(u(0,y)=u(2\pi,y)\) for all \(y\) and \(u(x,0)=u(x,2\pi)\) for all \(x\).

These boundary conditions are achieved from the definition of the periodic finite element space.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//right hand side}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{c+c1}{//defined the fespace with periodic condition}
\PYG{c+c1}{//label: 2 and 4 are left and right side with y the curve abscissa}
\PYG{c+c1}{//       1 and 2 are bottom and upper side with x the curve abscissa}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{laplace} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{vh}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{laplace}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{StaticProblems_PeriodicBoundaryConditions}.png}
\caption{The isovalue of solution \(u\) with periodic boundary condition}\label{\detokenize{model/staticProblems:examplestaticproblemsperiodicboundaryconditions}}\end{figure}

The periodic condition does not necessarily require parallel boundaries.
The following example give such example.

\begin{sphinxadmonition}{tip}{Tip:}
Periodic boundary conditions - non-parallel boundaries

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r2} \PYG{o}{=} \PYG{l+m+mf}{1.732}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{c+c1}{//warning for periodic condition:}
\PYG{c+c1}{//side a and c}
\PYG{c+c1}{//on side a (label 1) \PYGZdl{} x \PYGZbs{}in [0,1] \PYGZdl{} or \PYGZdl{} x\PYGZhy{}y\PYGZbs{}in [\PYGZhy{}1,1] \PYGZdl{}}
\PYG{c+c1}{//on side c (label 3) \PYGZdl{} x \PYGZbs{}in [\PYGZhy{}1,0]\PYGZdl{} or \PYGZdl{} x\PYGZhy{}y\PYGZbs{}in[\PYGZhy{}1,1] \PYGZdl{}}
\PYG{c+c1}{//so the common abscissa can be respectively \PYGZdl{}x\PYGZdl{} and \PYGZdl{}x+1\PYGZdl{}}
\PYG{c+c1}{//or you can can try curviline abscissa \PYGZdl{}x\PYGZhy{}y\PYGZdl{} and \PYGZdl{}x\PYGZhy{}y\PYGZdl{}}
\PYG{c+c1}{//1 first way}
\PYG{c+c1}{//fespace Vh(Th, P2, periodic=[[2, 1+x], [4, x], [1, x], [3, 1+x]]);}
\PYG{c+c1}{//2 second way}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{intf} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{mTh} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{k} \PYG{o}{=}  \PYG{n}{intf} \PYG{o}{/} \PYG{n}{mTh}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{laplace} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vh}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{laplace}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{StaticProblems_PeriodicBoundaryConditions2}.png}
\caption{The isovalue of solution \(u\) for \(\Delta u = ((y+x)^{2}+1)((y-x)^{2}+1) - k\), in \(\Omega\) and \(\p_{n} u =0\) on hole, and with two periodic boundary condition on external border}\label{\detokenize{model/staticProblems:examplestaticproblemsperiodicboundaryconditions2}}\end{figure}
\end{sphinxadmonition}

An other example with no equal border, just to see if the code works.

\begin{sphinxadmonition}{tip}{Tip:}
Periodic boundary conditions - non-equal border

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Macro}
\PYG{c+c1}{//irregular boundary condition to build border AB}
\PYG{k+kt}{macro} \PYG{n+nf}{LINEBORDER}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{lab}\PYG{p}{)}
    \PYG{k+kt}{border} \PYG{k+kp}{A}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real} \PYG{n}{t1}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{A}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{t1}\PYG{o}{+}\PYG{k+kp}{B}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{A}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{t1}\PYG{o}{+}\PYG{k+kp}{B}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{lab}\PYG{p}{;} \PYG{p}{\PYGZcb{}} \PYG{c+c1}{//EOM}
\PYG{c+c1}{// compute \PYGZbs{}\textbar{}\textbar{}AB\textbar{}\PYGZbs{}\textbar{} A=(ax,ay) et B =(bx,by)}
\PYG{k+kt}{macro} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{ax}\PYG{p}{,} \PYG{n}{ay}\PYG{p}{,} \PYG{n}{bx}\PYG{p}{,} \PYG{n}{by}\PYG{p}{)}
    \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ax}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ay}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{by}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//EOM}
\PYG{k+kt}{macro} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//EOM}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Ax} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{n}{Ay} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Bx} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{By} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Cx} \PYG{o}{=} \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{n}{Cy} \PYG{o}{=} \PYG{l+m+mf}{2.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Dx} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Dy} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{gx} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Ax}\PYG{o}{+}\PYG{n}{Bx}\PYG{o}{+}\PYG{n}{Cx}\PYG{o}{+}\PYG{n}{Dx}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{gy} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Ay}\PYG{o}{+}\PYG{n}{By}\PYG{o}{+}\PYG{n}{Cy}\PYG{o}{+}\PYG{n}{Dy}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{n}{LINEBORDER}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,}\PYG{k+kp}{B}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{LINEBORDER}\PYG{p}{(}\PYG{k+kp}{B}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{LINEBORDER}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,}\PYG{n}{D}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{LINEBORDER}\PYG{p}{(}\PYG{n}{D}\PYG{p}{,}\PYG{k+kp}{A}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{AB}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{BC}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{CD}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{DA}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,}\PYG{k+kp}{fixedborder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{real} \PYG{k+kr}{l1} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Ax}\PYG{p}{,}\PYG{n}{Ay}\PYG{p}{,}\PYG{n}{Bx}\PYG{p}{,}\PYG{n}{By}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{l2} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Bx}\PYG{p}{,}\PYG{n}{By}\PYG{p}{,}\PYG{n}{Cx}\PYG{p}{,}\PYG{n}{Cy}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{l3} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Cx}\PYG{p}{,}\PYG{n}{Cy}\PYG{p}{,}\PYG{n}{Dx}\PYG{p}{,}\PYG{n}{Dy}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{l4} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Dx}\PYG{p}{,}\PYG{n}{Dy}\PYG{p}{,}\PYG{n}{Ax}\PYG{p}{,}\PYG{n}{Ay}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{s1} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Ax}\PYG{p}{,}\PYG{n}{Ay}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{/}\PYG{k+kr}{l1}\PYG{p}{;} \PYG{c+c1}{//absisse on AB = \textbar{}\textbar{}AX\textbar{}\textbar{}/\textbar{}\textbar{}AB\textbar{}\textbar{}}
\PYG{k+kt}{func} \PYG{n}{s2} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Bx}\PYG{p}{,}\PYG{n}{By}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{/}\PYG{k+kr}{l2}\PYG{p}{;} \PYG{c+c1}{//absisse on BC = \textbar{}\textbar{}BX\textbar{}\textbar{}/\textbar{}\textbar{}BC\textbar{}\textbar{}}
\PYG{k+kt}{func} \PYG{n}{s3} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Cx}\PYG{p}{,}\PYG{n}{Cy}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{/}\PYG{n}{l3}\PYG{p}{;} \PYG{c+c1}{//absisse on CD = \textbar{}\textbar{}CX\textbar{}\textbar{}/\textbar{}\textbar{}CD\textbar{}\textbar{}}
\PYG{k+kt}{func} \PYG{n}{s4} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Dx}\PYG{p}{,}\PYG{n}{Dy}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{/}\PYG{n}{l4}\PYG{p}{;} \PYG{c+c1}{//absisse on DA = \textbar{}\textbar{}DX\textbar{}\textbar{}/\textbar{}\textbar{}DA\textbar{}\textbar{}}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{c+c1}{//to see the abscisse value of the periodic condition}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{s1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{s3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{s2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{s4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//reset verbosity}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{cc} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{cc} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{gx}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{gy}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cc}\PYG{p}{)}\PYG{o}{/}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{compatibility = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{gx}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{gy}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cc}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{gx}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{gy}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cc}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Periodic boundry conditions - Poisson cube-balloon

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}} \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}} \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hs} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{c+c1}{//mesh size on sphere}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{N} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{n}{z0} \PYG{o}{=} \PYG{l+m+mo}{06}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{+}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{+}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{z}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{+}\PYG{n}{z0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{bool} \PYG{n}{buildTh} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th}\PYG{p}{;}
\PYG{k}{try} \PYG{p}{\PYGZob{}} \PYG{c+c1}{//a way to build one time the mesh or read it if the file exist}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{readmesh3}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th\PYGZhy{}hex\PYGZhy{}sph.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{catch} \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{buildTh} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{buildTh}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MeshSurface.idp}\PYG{l+s}{\PYGZdq{}}

    \PYG{c+c1}{// Surface Mesh}
    \PYG{k+kt}{mesh3} \PYG{n}{ThH} \PYG{o}{=} \PYG{n}{SurfaceHex}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{ThS} \PYG{o}{=} \PYG{n}{Sphere}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{mesh3} \PYG{n}{ThHS} \PYG{o}{=} \PYG{n}{ThH} \PYG{o}{+} \PYG{n}{ThS}\PYG{p}{;}

    \PYG{k+kt}{real} \PYG{n}{voltet} \PYG{o}{=} \PYG{p}{(}\PYG{n}{hs}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{ThHS}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pqaAAYYQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}

    \PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th\PYGZhy{}hex\PYGZhy{}sph.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{reg} \PYG{o}{=} \PYG{k+kr}{region}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ centre = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ exterieur = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.7}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Poisson} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{vh}\PYG{o}{*}\PYG{n}{f}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Poisson}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_PeriodicBoundaryConditionsPoisson1}.png}
\caption{View of the surface isovalue of periodic solution \(uh\)}\label{\detokenize{model/staticProblems:examplestaticproblemsperiodicboundaryconditionspoisson1}}\label{\detokenize{model/staticProblems:figcubeballoon}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_PeriodicBoundaryConditionsPoisson2}.png}
\caption{View a the cut of the solution \(uh\) with ffmedit}\label{\detokenize{model/staticProblems:examplestaticproblemsperiodicboundaryconditionspoisson2}}\end{subfigure}


\end{figure}

\end{sphinxadmonition}


\subsection{Poisson Problems with mixed boundary condition}
\label{\detokenize{model/staticProblems:poisson-problems-with-mixed-boundary-condition}}\label{\detokenize{model/staticProblems:modelstaticpoissonwithmixedboundarycondition}}\label{\detokenize{model/staticProblems:CubeBalloon}}
Here we consider the Poisson equation with mixed boundary conditions:

For given functions \(f\) and \(g\), find \(u\) such that:
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\Delta u &=& f & \textrm{ in }\Omega\\
    u &=& g &\textrm{ on }\Gamma_D\\
    \p u/\p n &=& 0 &\textrm{ on }\Gamma_N
\end{array}\end{split}
\end{equation*}
where \(\Gamma_D\) is a part of the boundary \(\Gamma\) and \(\Gamma_N=\Gamma\setminus \overline{\Gamma_D}\).

The solution \(u\) has the singularity at the points \(\{\gamma_1,\gamma_2\}=\overline{\Gamma_D}\cap\overline{\Gamma_N}\).

When \(\Omega=\{(x,y);\; -1<x<1,\, 0<y<1\}\), \(\Gamma_N=\{(x,y);\; -1\le x<0,\, y=0\}\), \(\Gamma_D=\p \Omega\setminus \Gamma_N\), the singularity will appear at \(\gamma_1=(0,0),\, \gamma_2(-1,0)\), and \(u\) has the expression:
\begin{equation*}
\begin{split}u=K_iu_S + u_R,\, u_R\in H^2(\textrm{near }\gamma_i),\, i=1,2\end{split}
\end{equation*}
with a constants \(K_i\).

Here \(u_S = r_j^{1/2}\sin(\theta_j/2)\) by the local polar coordinate \((r_j,\theta_j\) at \(\gamma_j\) such that \((r_1,\theta_1)=(r,\theta)\).

Instead of polar coordinate system \((r,\theta)\), we use that \(r\) = \sphinxcode{\sphinxupquote{sqrt}} (\(x^2+y^2\)) and \(\theta\) = \sphinxcode{\sphinxupquote{atan2}} (\(y,x\)) in \sphinxstylestrong{FreeFem++}.

Assume that \(f=-2\times 30(x^2+y^2)\) and \(g=u_e=10(x^2+y^2)^{1/4}\sin\left([\tan^{-1}(y/x)]/2\right)+30(x^2y^2)\), where \(u_e\)S is the exact solution.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//given function}
\PYG{c+c1}{//the singular term of the solution is K*us (K: constant)}
\PYG{k+kt}{func} \PYG{n}{us} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n+nf}{atan2}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mf}{10.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{n}{K}\PYG{o}{*}\PYG{n}{us} \PYG{o}{+} \PYG{l+m+mi}{30}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{k+kr}{N}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{D1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{D2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{D3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{D4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{T0h} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D2}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D3}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D4}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{T0h}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{V0h}\PYG{p}{(}\PYG{n}{T0h}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{V0h} \PYG{n}{u0}\PYG{p}{,} \PYG{n}{v0}\PYG{p}{;}

\PYG{c+c1}{//Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{Poisson0} \PYG{p}{(}\PYG{n}{u0}\PYG{p}{,} \PYG{n}{v0}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{T0h}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v0}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v0}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{T0h}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v0}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u0}\PYG{o}{=}\PYG{n}{ue}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation by the singular term}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{T0h}\PYG{p}{,} \PYG{n}{us}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{us}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{ue}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error in H1 norm}
\PYG{n}{Vh} \PYG{n}{uue} \PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{H1e} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uue}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uue}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{uue}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{err0} \PYG{o}{=} \PYG{n}{u0} \PYG{o}{\PYGZhy{}} \PYG{n}{ue}\PYG{p}{;}
\PYG{n}{Vh} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{u} \PYG{o}{\PYGZhy{}} \PYG{n}{ue}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{H1err0} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{err0}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{err0}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{err0}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{H1err} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{k+kp}{err}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{k+kp}{err}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kp}{err}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Relative error in first mesh = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{H1err0}\PYG{p}{)}\PYG{o}{/}\PYG{n}{H1e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Relative error in adaptive mesh = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{H1err}\PYG{p}{)}\PYG{o}{/}\PYG{n}{H1e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

From line 35 to 37, mesh adaptations are done using the base of singular term.

In line 61, \sphinxcode{\sphinxupquote{H1e}} = \(|u_e|_{1,\Omega}\) is calculated.

In lines 64 and 65, the relative errors are calculated, that is:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \|u^0_h-u_e\|_{1,\Omega}/H1e&=&0.120421\\
    \|u^a_h-u_e\|_{1,\Omega}/H1e&=&0.0150581
\end{array}\end{split}
\end{equation*}
where \(u^0_h\) is the numerical solution in \sphinxcode{\sphinxupquote{T0h}} and \(u^a_h\) is \sphinxcode{\sphinxupquote{u}} in this program.


\subsection{Poisson with mixed finite element}
\label{\detokenize{model/staticProblems:poisson-with-mixed-finite-element}}
Here we consider the Poisson equation with mixed boundary value problems:

For given functions \(f\) , \(g_d\), \(g_n\), find \(p\) such that
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\Delta p &=& 1 & \textrm{ in }\Omega\\
    p &=& g_d & \textrm{ on }\Gamma_D\\
    \p p/\p n &=& g_n & \textrm{ on }\Gamma_N
\end{array}\end{split}
\end{equation*}
where \(\Gamma_D\) is a part of the boundary \(\Gamma\) and \(\Gamma_N=\Gamma\setminus \overline{\Gamma_D}\).

The mixed formulation is: find \(p\) and \(\mathbf{u}\) such that:
\begin{equation*}
\begin{split}\begin{array}{rcll}
    \nabla p + \mathbf{u} &=& \mathbf{0} & \textrm{ in }\Omega\\
    \nabla. \mathbf{u} &=& f & \textrm{ in }\Omega\\
    p &=& g_d & \textrm{ on }\Gamma_D\\
    \p u. n &=& \mathbf{g}_n.n & \textrm{ on }\Gamma_N
\end{array}\end{split}
\end{equation*}
where \(\mathbf{g}_n\) is a vector such that \(\mathbf{g}_n.n = g_n\).

The variational formulation is:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \forall \mathbf{v} \in \mathbb{V}_0: & \int_\Omega p \nabla.v + \mathbf{v} \mathbf{v} &= \int_{\Gamma_d} g_d \mathbf{v}.n\\
    \forall {q} \in \mathbb{P}: & \int_\Omega q \nabla.u &= \int_\Omega q f\nonumber\\
    & \p u. n &= \mathbf{g}_n.n \quad \textrm{on }\Gamma_N
\end{array}\end{split}
\end{equation*}
where the functional space are:
\begin{equation*}
\begin{split}\mathbb{P}= L^2(\Omega),
\qquad\mathbb{V}= H(div)=\{\mathbf{v}\in L^2(\Omega)^2,\nabla.\mathbf{v}\in L^2(\Omega)\}\end{split}
\end{equation*}
and:
\begin{equation*}
\begin{split}\mathbb{V}_0 = \{\mathbf{v}\in \mathbb{V};\quad\mathbf{v}. n = 0 \quad\mathrm{on }\;\;\Gamma_N\}\end{split}
\end{equation*}
To write the \sphinxstylestrong{FreeFem++} example, we have just to choose the finites elements spaces.

Here \(\mathbb{V}\) space is discretize with Raviart-Thomas finite element \sphinxcode{\sphinxupquote{RT0}} and \(\mathbb{P}\) is discretize by constant finite element \sphinxcode{\sphinxupquote{P0}}.

\sphinxstylestrong{Example 9.10} LaplaceRT.edp

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{gd} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1n} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g2n} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{laplaceMixte} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{GMRES}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.0e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mf}{1e30}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{150}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{p}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{l+m+mf}{1e\PYGZhy{}15} \PYG{c+c1}{//this term is here to be sure}
        \PYG{c+c1}{// that all sub matrix are inversible (LU requirement)}
        \PYG{o}{+} \PYG{n}{u1}\PYG{o}{*}\PYG{n}{v1}
        \PYG{o}{+} \PYG{n}{u2}\PYG{o}{*}\PYG{n}{v2}
        \PYG{o}{+} \PYG{n}{p}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{+} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)} \PYG{p}{(}
        \PYG{n}{q}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{gd}\PYG{o}{*}\PYG{p}{(}\PYG{n}{v1}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{+}\PYG{n}{v2}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{n}{g1n}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{n}{g2n}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{laplaceMixte}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Metric Adaptation and residual error indicator}
\label{\detokenize{model/staticProblems:metric-adaptation-and-residual-error-indicator}}
We do metric mesh adaption and compute the classical residual error indicator \(\eta_{T}\) on the element \(T\) for the Poisson problem.

First, we solve the same problem as in a previous example.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{k+kp}{viso}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{o}{+}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{16.}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kr}{be}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bf}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bd}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bf}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Nh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Nh} \PYG{n}{rho}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Probem1} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.0e\PYGZhy{}6}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{l+m+mf}{1.0e\PYGZhy{}10}
        \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

Now, the local error indicator \(\eta_{T}\) is:
\begin{equation*}
\begin{split}\eta_{T} =\left( h_{T}^{2} || f + \Delta u_{{h}} ||_{L^{2}(T)}^{2} +\sum_{e\in \mathcal{E}_{K}} h_{e} \,||\, [ \frac{\p u_{h}}{\p n_{k}}] \,||^{2}_{L^{2}(e)} \right)^{\frac{1}{2}}\end{split}
\end{equation*}
where \(h_{T}\) is the longest edge of \(T\), \({\cal E}_T\) is the set of \(T\) edge not on \(\Gamma=\p \Omega\), \(n_{T}\) is the outside unit normal to \(K\), \(h_{e}\) is the length of edge \(e\), \([ g ]\) is the jump of the function \(g\) across edge (left value minus right value).

Of course, we can use a variational form to compute \(\eta_{T}^{2}\), with test function constant function in each triangle.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Error}
\PYG{k+kt}{varf} \PYG{n+nf}{indicator2} \PYG{p}{(}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{chiK}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{k+kr}{lenEdge}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{hTriangle}\PYG{o}{*}\PYG{p}{(}\PYG{n}{f} \PYG{o}{+} \PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve}
    \PYG{n}{Probem1}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{indicator2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Nh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{rho} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rho = min }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ max=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{indicator density}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mesh (before adaptation)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{,} \PYG{n}{anisomax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mesh (after adaptation)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{u} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
    \PYG{n}{rho} \PYG{o}{=} \PYG{n}{rho}\PYG{p}{;}
    \PYG{n}{error} \PYG{o}{=} \PYG{n}{error}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If the method is correct, we expect to look the graphics by an almost constant function \(\eta\) on your computer as in \hyperref[\detokenize{model/staticProblems:examplestaticproblemsmetricadaptation}]{Fig.\@ \ref{\detokenize{model/staticProblems:examplestaticproblemsmetricadaptation}}} and \hyperref[\detokenize{model/staticProblems:examplestaticproblemsmetricadaptation2}]{Fig.\@ \ref{\detokenize{model/staticProblems:examplestaticproblemsmetricadaptation2}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{StaticProblems_MetricAdaptation}.png}
\caption{Density of the error indicator with isotropic \(P_{2}\) metric}\label{\detokenize{model/staticProblems:examplestaticproblemsmetricadaptation}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{StaticProblems_MetricAdaptation2}.png}
\caption{Density of the error indicator with isotropic \(P_{2}\) metric}\label{\detokenize{model/staticProblems:examplestaticproblemsmetricadaptation2}}\end{subfigure}


\end{figure}



\subsection{Adaptation using residual error indicator}
\label{\detokenize{model/staticProblems:adaptation-using-residual-error-indicator}}\label{\detokenize{model/staticProblems:modelstaticproblemadaptationusingresidualerrorindicator}}\label{\detokenize{model/staticProblems:DensityError}}
In the previous example we compute the error indicator, now we use it, to adapt the mesh.
The new mesh size is given by the following formulae:
\begin{equation*}
\begin{split}h_{n+1}(x) = \frac{h_{n}(x)}{f_{n}(\eta_K(x))}\end{split}
\end{equation*}
where \(\eta_n(x)\) is the level of error at point \(x\) given by the local error indicator, \(h_n\) is the previous “mesh size” field, and \(f_n\) is a user function define by \(f_n = min(3,max(1/3,\eta_n / \eta_n^* ))\) where \(\eta_n^* = mean(\eta_n) c\), and \(c\) is an user coefficient generally close to one.

First a macro \sphinxcode{\sphinxupquote{MeshSizecomputation}} is defined to get a \(P_1\) mesh size as the average of edge length.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// macro the get the current mesh size parameter}
\PYG{c+c1}{// in:}
\PYG{c+c1}{// Th the mesh}
\PYG{c+c1}{// Vh P1 fespace on Th}
\PYG{c+c1}{// out :}
\PYG{c+c1}{// h: the Vh finite element finite set to the current mesh size}
\PYG{k+kt}{macro} \PYG{n+nf}{MeshSizecomputation} \PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{count}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/*mesh size (lenEdge = integral(e) 1 ds)*/}
    \PYG{k+kt}{varf} \PYG{n}{vmeshsizen} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{qfnbpE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/*number of edges per vertex*/}
    \PYG{k+kt}{varf} \PYG{n}{vedgecount} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{qfnbpE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/*mesh size*/}
    \PYG{n}{count} \PYG{o}{=} \PYG{n}{vedgecount}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
    \PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vmeshsizen}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{count min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{count}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{count}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{/}\PYG{n}{count}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{} bound meshsize = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//}
\end{sphinxVerbatim}

A second macro to re-mesh according to the new mesh size.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// macro to remesh according the de residual indicator}
\PYG{c+c1}{// in:}
\PYG{c+c1}{// Th the mesh}
\PYG{c+c1}{// Ph P0 fespace on Th}
\PYG{c+c1}{// Vh P1 fespace on Th}
\PYG{c+c1}{// vindicator the varf to evaluate the indicator}
\PYG{c+c1}{// coef on etameam}
\PYG{k+kt}{macro} \PYG{n+nf}{ReMeshIndicator} \PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{n}{vindicator}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Vh} \PYG{n}{h}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+cm}{/*evaluate the mesh size*/}
    \PYG{n}{MeshSizecomputation}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Ph} \PYG{n}{etak}\PYG{p}{;}
    \PYG{n}{etak}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vindicator}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{etak}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{etak}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{etastar}\PYG{o}{=} \PYG{k+kp}{coef}\PYG{o}{*}\PYG{p}{(}\PYG{n}{etak}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{/}\PYG{n}{etak}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{etastar = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{etastar} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ sum = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{etak}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+cm}{/*etaK is discontinous*/}
    \PYG{c+cm}{/*we use P1 L2 projection with mass lumping*/}
    \PYG{n}{Vh} \PYG{n}{fn}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n}{veta}\PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{etak}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n}{vun}\PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fn}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{veta}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{sigma}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vun}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fn}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fn}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{/} \PYG{k+kp}{sigma}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{fn} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{fn}\PYG{o}{/}\PYG{n}{etastar}\PYG{p}{,}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{0.3333}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/*new mesh size*/}
    \PYG{n}{h} \PYG{o}{=} \PYG{n}{h} \PYG{o}{/} \PYG{n}{fn}\PYG{p}{;}
    \PYG{c+cm}{/*build the mesh*/}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hinit} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;} \PYG{c+c1}{//initial mesh size}
\PYG{k+kt}{func} \PYG{n}{f}\PYG{o}{=}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kr}{be}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bf}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bd}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bf}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for the mesh size and solution}
\PYG{n}{Vh} \PYG{n}{h} \PYG{o}{=} \PYG{n}{hinit}\PYG{p}{;} \PYG{c+c1}{//the FE function for the mesh size}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for the error indicator}

\PYG{c+c1}{//Build a mesh with the given mesh size hinit}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{l+m+mf}{1.0e\PYGZhy{}10}
        \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{indicator2} \PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{chiK}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{k+kr}{lenEdge}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{hTriangle}\PYG{o}{*}\PYG{p}{(}\PYG{n}{f} \PYG{o}{+} \PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{u} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{Poisson}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real} \PYG{n}{cc} \PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{n}{cc}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{ReMeshIndicator}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{n}{indicator2}\PYG{p}{,} \PYG{n}{cc}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_AdaptationResidualError}.png}
\caption{The error indicator with isotropic \(P_{1}\)}\label{\detokenize{model/staticProblems:examplestaticproblemsadaptationresidualerror}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_AdaptationResidualError2}.png}
\caption{The mesh and isovalue of the solution}\label{\detokenize{model/staticProblems:examplestaticproblemsadaptationresidualerror2}}\end{subfigure}
\phantomsection\label{\detokenize{model/staticProblems:ErrorIndicator}}

\end{figure}



\section{Elasticity}
\label{\detokenize{model/elasticity:elasticity}}\label{\detokenize{model/elasticity::doc}}
Consider an elastic plate with undeformed shape \(\Omega\times ]-h,h[\) in \(\mathbb{R}^3\), \(\Omega\subset\mathbb{R}^2\).

By the deformation of the plate, we assume that a point \(P(x_1,x_2,x_3)\) moves to \({\cal P}(\xi_1,\xi_2,\xi_3)\).
The vector \(\mathbf{u}=(u_1,u_2,u_3)=(\xi_1-x_1,\xi_2-x_2,\xi_3-x_3)\) is called the \sphinxstyleemphasis{displacement vector}.

By the deformation, the line segment \(\overline{\mathbf{x},\mathbf{x}+\tau\Delta\mathbf{x}}\) moves approximately to \(\overline{\mathbf{x}+\mathbf{u}(\mathbf{x}),\mathbf{x}+\tau\Delta\mathbf{x} +\mathbf{u}(\mathbf{x}+\tau\Delta\mathbf{x})}\) for small \(\tau\), where \(\mathbf{x}=(x_1,x_2,x_3),\, \Delta\mathbf{x} =(\Delta x_1,\Delta x_2,\Delta x_3)\).

We now calculate the ratio between two segments:
\begin{equation*}
\begin{split}\eta(\tau)=\tau^{-1}|\Delta\mathbf{x}|^{-1}
\left(|\mathbf{u}(\mathbf{x}+\tau\Delta\mathbf{x})
-\mathbf{u}(\mathbf{x})+\tau\Delta\mathbf{x}|-\tau|\Delta\mathbf{x}|\right)\end{split}
\end{equation*}
then we have (see e.g. \sphinxcite{reference:necas2017}, p.32)
\begin{equation*}
\begin{split}\lim_{\tau\to 0}\eta(\tau)=(1+2e_{ij}\nu_i\nu_j)^{1/2}-1,
\quad 2e_{ij}=\frac{\partial u_k}{\partial x_i}\frac{\partial u_k}{\partial x_j}+\left(\frac{\partial u_i}{\partial x_j}+
\frac{\partial u_j}{\partial x_i}\right)\end{split}
\end{equation*}
where \(\nu_i=\Delta x_i|\Delta\mathbf{x}|^{-1}\).
If the deformation is \sphinxstyleemphasis{small}, then we may consider that:
\begin{equation*}
\begin{split}(\partial u_k/\partial x_i)(\partial u_k/\partial x_i)\approx 0\end{split}
\end{equation*}
and the following is called \sphinxstyleemphasis{small strain tensor}:
\begin{equation*}
\begin{split}\varepsilon_{ij}(u)=\frac{1}{2}\left(\frac{\partial u_i}{\partial x_j}+
\frac{\partial u_j}{\partial x_i}\right)\end{split}
\end{equation*}
The tensor \(e_{ij}\) is called \sphinxstyleemphasis{finite strain tensor}.

Consider the small plane \(\Delta \Pi(\mathbf{x})\) centered at \(\mathbf{x}\) with the unit normal direction \(\mathbf{n}=(n_1,n_2,n_3)\), then the surface on \(\Delta \Pi(\mathbf{x})\) at \(\mathbf{x}\) is:
\begin{equation*}
\begin{split}(\sigma_{1j}(\mathbf{x})n_j, \sigma_{2j}(\mathbf{x})n_j, \sigma_{3j}(\mathbf{x})n_j)\end{split}
\end{equation*}
where \(\sigma_{ij}(\mathbf{x})\) is called \sphinxstyleemphasis{stress tensor} at \(\mathbf{x}\).
Hooke’s law is the assumption of a linear relation between \(\sigma_{ij}\) and \(\varepsilon_{ij}\) such as:
\begin{equation*}
\begin{split}\sigma_{ij}(\mathbf{x})=c_{ijkl}(\mathbf{x})\varepsilon_{ij}(\mathbf{x})\end{split}
\end{equation*}
with the symmetry \(c_{ijkl}=c_{jikl}, c_{ijkl}=c_{ijlk}, c_{ijkl}=c_{klij}\).

If Hooke’s tensor \(c_{ijkl}(\mathbf{x})\) do not depend on the choice of coordinate system, the material is called \sphinxstyleemphasis{isotropic} at \(\mathbf{x}\).

If \(c_{ijkl}\) is constant, the material is called \sphinxstyleemphasis{homogeneous}.
In homogeneous isotropic case, there is \sphinxstyleemphasis{Lamé constants} \(\lambda, \mu\) (see e.g. \sphinxcite{reference:necas2017}, p.43) satisfying
\begin{equation*}
\begin{split}\sigma_{ij}=\lambda\delta_{ij}\textrm{div}\mathbf{u}+2\mu \varepsilon_{ij}\end{split}
\end{equation*}
where \(\delta_{ij}\) is Kronecker’s delta.

We assume that the elastic plate is fixed on \(\Gamma_D\times ]-h,h[,\, \Gamma_D\subset \partial\Omega\).
If the body force \(\mathbf{f}=(f_1,f_2,f_3)\) is given in \(\Omega\times]-h,h[\) and surface force \(\mathbf{g}\) is given in \(\Gamma_N\times]-h,h[, \Gamma_N=\partial\Omega\setminus\overline{\Gamma_D}\), then the equation of equilibrium is given as follows:
\begin{equation}\label{equation:model/elasticity:eqn::elasticity}
\begin{split}\begin{array}{rcl}
    -\partial_j \sigma_{ij}&=&f_i~~\textrm{in }\Omega\times ]-h,h[,\quad
    i=1,2,3\\
    \sigma_{ij}n_j&=&g_i~~\textrm{on }\Gamma_N\times ]-h,h[,\quad
    u_i=0~~\textrm{on }\Gamma_D\times ]-h,h[,\quad i=1,2,3
\end{array}\end{split}
\end{equation}
We now explain the plain elasticity.
\begin{itemize}
\item {} 
\sphinxstylestrong{Plain strain:}

On the end of plate, the contact condition \(u_3=0,\, g_3=\) is satisfied.

In this case, we can suppose that \(f_3=g_3=u_3=0\) and \(\mathbf{u}(x_1,x_2,x_3)=\overline{u}(x_1,x_2)\) for all \(-h<x_3<h\).

\item {} 
\sphinxstylestrong{Plain stress:}

The cylinder is assumed to be very thin and subjected to no load on the ends \(x_3=\pm h\), that is,
\begin{equation*}
\begin{split}\sigma_{3i}=0,\quad x_3=\pm h,\quad i~1,2,3\end{split}
\end{equation*}
The assumption leads that \(\sigma_{3i}=0\) in \(\Omega\times ]-h,h[\) and \(\mathbf{u}(x_1,x_2,x_3)=\overline{u}(x_1,x_2)\) for all \(-h<x_3<h\).

\item {} 
\sphinxstylestrong{Generalized plain stress:}

The cylinder is subjected to no load at \(x_3=\pm h\).
Introducing the mean values with respect to thickness,
\begin{equation*}
\begin{split}\overline{u}_i(x_1,x_2)=\frac{1}{2h}\int_{-h}^h{u(x_1,x_2,x_3)dx_3}\end{split}
\end{equation*}
and we derive \(\overline{u}_3\equiv 0\).
Similarly we define the mean values \(\overline{f},\overline{g}\) of the body force and surface force as well as the mean values \(\overline{\varepsilon}_{ij}\) and \(\overline{\sigma}_{ij}\) of the components of stress and strain, respectively.

\end{itemize}

In what follows we omit the overlines of \(\overline{u}, \overline{f},\overline{g}, \overline{\varepsilon}_{ij}\) and \(\overline{\varepsilon}_{ij}\).
Then we obtain similar equation of equilibrium given in \eqref{equation:model/elasticity:eqn::elasticity} replacing \(\Omega\times ]-h,h[\) with \(\Omega\) and changing \(i=1,2\).
In the case of plane stress, \(\sigma_{ij}=\lambda^* \delta_{ij}\textrm{div}u+2\mu\varepsilon_{ij}, \lambda^*=(2\lambda \mu)/(\lambda+\mu)\).

The equations of elasticity are naturally written in variational form for the displacement vector \(\mathbf{u}(\mathbf{x})\in V\) as:
\begin{equation*}
\begin{split}\int_\Omega [2\mu\epsilon_{ij}(\mathbf{u})\epsilon_{ij}(\mathbf{v})
+\lambda \epsilon_{ii}(\mathbf{u})\epsilon_{jj}(\mathbf{v})]
=\int_\Omega \mathbf{f}\cdot \mathbf{v} +\int_\Gamma \mathbf{g}\cdot \mathbf{v},
\forall \mathbf{v}\in V\end{split}
\end{equation*}
where \(V\) is the linear closed subspace of \(H^1(\Omega)^2\).

\begin{sphinxadmonition}{tip}{Tip:}
Beam

Consider an elastic plate with the undeformed rectangle shape \(]0,10[\times ]0,2[\).
The body force is the gravity force \(\mathbf{f}\) and the boundary force \(\mathbf{g}\) is zero on lower and upper side.
On the two vertical sides of the beam are fixed.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.29}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{gravity} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.05}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{real} \PYG{n}{sqrt2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n+nf}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{solve} \PYG{n+nf}{Elasticity} \PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)} \PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{gravity}\PYG{o}{*}\PYG{n}{s}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{uu}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Movemesh}
\PYG{k+kt}{mesh} \PYG{n}{th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Beam 3D

Consider elastic box with the undeformed parallelepiped shape \(]0,5[\times ]0,1[\times]0,1[\).
The body force is the gravity force \(\mathbf{f}\) and the boundary force \(\mathbf{g}\) is zero on all face except one the one vertical left face where the beam is fixed.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cube.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Nxyz} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Bxyz} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{5.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Lxyz} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21.5e4}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.29}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{gravity} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.05}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Cube}\PYG{p}{(}\PYG{n}{Nxyz}\PYG{p}{,} \PYG{n}{Bxyz}\PYG{p}{,} \PYG{n}{Lxyz}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{real} \PYG{n}{sqrt2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n+nf}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)} \PYG{p}{[}
    \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{solve} \PYG{n+nf}{Lame} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{)} \PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{gravity}\PYG{o}{*}\PYG{n}{v3}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k+kt}{real} \PYG{n}{dmax} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max displacement = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dmax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Movemesh}
\PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{o}{/}\PYG{n}{dmax}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ref2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Thm} \PYG{o}{=} \PYG{n}{movemesh3}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u1}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{u2}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{,} \PYG{k+kr}{z}\PYG{o}{+}\PYG{n}{u3}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{ref2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Thm} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Thm}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{ref2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Thm}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coef amplification = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Elasticity_Beam3D}.jpg}
\caption{3d Beam deformed and undeformed box}\label{\detokenize{model/elasticity:elasticity-beam3d}}\end{figure}
\end{sphinxadmonition}


\subsection{Fracture Mechanics}
\label{\detokenize{model/elasticity:fracture-mechanics}}
Consider the plate with the crack whose undeformed shape is a curve \(\Sigma\) with the two edges \(\gamma_1,\, \gamma_2\).

We assume the stress tensor \(\sigma_{ij}\) is the state of plate stress regarding \((x,y)\in \Omega_{\Sigma}=\Omega\setminus \Sigma\).
Here \(\Omega\) stands for the undeformed shape of elastic plate without crack.

If the part \(\Gamma_N\) of the boundary \(\partial\Omega\) is fixed and a load \({\cal L}=(\mathbf{f},\mathbf{g})\in L^2(\Omega)^2\times L^2(\Gamma_N)^2\) is given, then the displacement \(\mathbf{u}\) is the minimizer of the potential energy functional:
\begin{equation*}
\begin{split}{\cal E}(\mathbf{v};{\cal L},\Omega_{\Sigma})
=\int_{\Omega_{\Sigma}}
\{w(x,\mathbf{v})-\mathbf{f}\cdot \mathbf{v}\}
-\int_{\Gamma_N}\mathbf{g}\cdot \mathbf{v}\end{split}
\end{equation*}
over the functional space \(V(\Omega_{\Sigma})\),
\begin{equation*}
\begin{split}V(\Omega_{\Sigma})
=\left\{ \mathbf{v}\in H^1(\Omega_{\Sigma})^2;\;
\mathbf{v}=0\quad \hbox{ on }
\Gamma_D=\partial\Omega\setminus\overline{\Gamma_N}\right\},\end{split}
\end{equation*}
where \(w(x,\mathbf{v})=\sigma_{ij}(\mathbf{v})\varepsilon_{ij}(\mathbf{v})/2\),
\begin{equation*}
\begin{split}\sigma_{ij}(\mathbf{v})=C_{ijkl}(x)\varepsilon_{kl}(\mathbf{v}),\quad
\varepsilon_{ij}(\mathbf{v})=(\partial v_i/\partial x_j+
\partial v_j/\partial x_i)/2,
\qquad (C_{ijkl}:\quad \hbox{Hooke's tensor}).\end{split}
\end{equation*}
If the elasticity is homogeneous isotropic, then the displacement \(\mathbf{u}(x)\) is decomposed in an open neighborhood \(U_k\) of \(\gamma_k\) as in (see e.g. \sphinxcite{reference:ohtsuka2000})
\begin{equation}\label{equation:model/elasticity:eqn::SIF}
\begin{split}\mathbf{u}(x) =
\sum_{l=1}^2 K_l(\gamma_k) r_k^{1/2} S^C_{kl}(\theta_k)
+ \mathbf{u}_{k,R}(x)
\quad \mbox{for }x\in \Omega_{\Sigma}\cap U_k,\, k=1,2\end{split}
\end{equation}
with \(\mathbf{u}_{k,R} \in H^2(\Omega_\Sigma\cap U_k)^2\), where \(U_k,\, k=1,2\) are open neighborhoods of \(\gamma_k\) such that \(\partial L_1\cap U_1=\gamma_1,\, \partial L_m\cap U_2=\gamma_2\), and
\begin{equation*}
\begin{split}\begin{array}{rcl}
    S^C_{k1}(\theta_k) & = & \frac 1 {4\mu} \frac 1 {(2\pi)^{1/2}}
        \left[ \begin{array}{c}
        [2\kappa-1]\cos(\theta_k/2)-\cos(3\theta_k/2)\\
        -[2\kappa+1]\sin(\theta_k/2)+\sin(3\theta_k/2)
        \end{array}\right],\\
    S^C_{k2}(\theta_k) & = & \frac 1 {4\mu} \frac 1 {(2\pi)^{1/2}}
        \left[ \begin{array}{c}
        -[2\kappa-1]\sin(\theta_k/2)+3\sin(3\theta_k/2)\\
        -[2\kappa+1]\cos(\theta_k/2)+\cos(3\theta_k/2)
        \end{array}\right]. \nonumber
\end{array}\end{split}
\end{equation*}
where \(\mu\) is the shear modulus of elasticity, \(\kappa=3-4\nu\) (\(\nu\) is the Poisson’s ratio) for plane strain and \(\kappa=\frac {3-\nu} {1+\nu}\) for plane stress.

The coefficients \(K_1(\gamma_i)\) and \(K_2(\gamma_i),\) which are important parameters in fracture mechanics, are called stress intensity factors of the opening mode (mode I) and the sliding mode (mode II), respectively.

For simplicity, we consider the following simple crack
\begin{equation*}
\begin{split}\Omega=\{(x,y):\; -1<x<1, -1<y<1\},\qquad
\Sigma=\{(x,y):\; -1\le x\le 0, y=0\}\end{split}
\end{equation*}
with only one crack tip \(\gamma=(0,0)\).
Unfortunately, \sphinxstylestrong{FreeFem++} cannot treat crack, so we use the modification of the domain with U-shape channel (see {\hyperref[\detokenize{documentation/meshGeneration:meshexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{U-shape example}}}}, \hyperref[\detokenize{documentation/meshGeneration:ushape}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:ushape}}}) with \(d=0.0001\).
The undeformed crack \(\Sigma\) is approximated by
\begin{equation*}
\begin{split}\Sigma_d = \{(x,y):\; -1\le x\le -10*d, -d\le y\le d\} \cup\{(x,y):\; -10*d\le x\le 0, -d+0.1*x\le y\le d-0.1*x\}\end{split}
\end{equation*}
and \(\Gamma_D=\)\sphinxcode{\sphinxupquote{R}} in {\hyperref[\detokenize{documentation/meshGeneration:meshexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{U-shape example}}}}, \hyperref[\detokenize{documentation/meshGeneration:ushape}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:ushape}}}.

In this example, we use three technique:
\begin{itemize}
\item {} 
Fast Finite Element Interpolator from the mesh \sphinxcode{\sphinxupquote{Th}} to \sphinxcode{\sphinxupquote{Zoom}} for the scale-up of near \(\gamma\).

\item {} 
After obtaining the displacement vector \(\mathbf{u}=(u,v)\), we shall watch the deformation of the crack near \(\gamma\) as follows,

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Plate} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Plate}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Adaptivity is an important technique here, because a large singularity occurs at \(\gamma\) as shown in \eqref{equation:model/elasticity:eqn::SIF}.

\end{itemize}

The first example creates mode I deformation by the opposed surface force on \sphinxcode{\sphinxupquote{B}} and \sphinxcode{\sphinxupquote{T}} in the vertical direction of \(\Sigma\), and the displacement is fixed on \sphinxcode{\sphinxupquote{R}}.

In a laboratory, fracture engineers use photoelasticity to make stress field visible, which shows the principal stress difference
\begin{equation*}
\begin{split}\sigma_1-\sigma_2=\sqrt{(\sigma_{11}-\sigma_{22})^2+4\sigma_{12}^2}\end{split}
\end{equation*}
where \(\sigma_1\) and \(\sigma_2\) are the principal stresses.

In opening mode, the photoelasticity make symmetric pattern concentrated at \(\gamma\).

\begin{sphinxadmonition}{tip}{Tip:}
Crack Opening, \(K_2(\gamma)=0\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//Parameters}
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{0.0001}\PYG{p}{;} \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{cb} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ca} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tip} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.29}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{L1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{n}{tip}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{+}\PYG{n}{tip}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{R}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{T}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{ca}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{R}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{T}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{cb}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{n}{ca}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Zoom} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{R}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{T}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{zVh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{zVh} \PYG{n}{Sx}\PYG{p}{,} \PYG{n}{Sy}\PYG{p}{,} \PYG{n}{Sxy}\PYG{p}{,} \PYG{k+kr}{N}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{solve} \PYG{n+nf}{Problem} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{T}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{s}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{s}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Plate} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//deformation near gamma}
    \PYG{n}{Sx} \PYG{o}{=} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Sy} \PYG{o}{=} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Sxy} \PYG{o}{=} \PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Sx}\PYG{o}{\PYGZhy{}}\PYG{n}{Sy}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{Sxy}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//principal stress difference}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Plate}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Plate}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Adaptmesh}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{Problem}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_Fracture1}.png}
\caption{Crack open displacement (COD) on the first mesh}\label{\detokenize{model/elasticity:id4}}\label{\detokenize{model/elasticity:figcodfirstmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_Fracture2}.png}
\caption{Principal stress difference on the first mesh}\label{\detokenize{model/elasticity:id5}}\label{\detokenize{model/elasticity:figstressfirstmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_Fracture3}.png}
\caption{COD on the last adaptive mesh}\label{\detokenize{model/elasticity:id6}}\label{\detokenize{model/elasticity:figcodlastmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_Fracture4}.png}
\caption{Principal stress difference on the last adaptive mesh}\label{\detokenize{model/elasticity:id7}}\label{\detokenize{model/elasticity:figstresslastmesh}}\end{subfigure}
\phantomsection\label{\detokenize{model/elasticity:CrackAndPrincipalStress}}

\end{figure}

\end{sphinxadmonition}

It is difficult to create mode II deformation by the opposed shear force on \sphinxcode{\sphinxupquote{B}} and \sphinxcode{\sphinxupquote{T}} that is observed in a laboratory.
So we use the body shear force along \(\Sigma\), that is, the \(x\)-component \(f_1\) of the body force \(\mathbf{f}\) is given by
\begin{equation*}
\begin{split}f_1(x,y)=H(y-0.001)*H(0.1-y)-H(-y-0.001)*H(y+0.1)\end{split}
\end{equation*}
where \(H(t)=1\) if \(t>0\); \(= 0\) if \(t<0\).

\begin{sphinxadmonition}{tip}{Tip:}
Crack Sliding, \(K_2(\gamma)=0\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{0.0001}\PYG{p}{;} \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{cb} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ca} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tip} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.29}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{L1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{n}{tip}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{+}\PYG{n}{tip}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{R}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{T}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{ca}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{R}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{T}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{cb}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{n}{ca}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Zoom} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{R}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{T}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{zVh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{zVh} \PYG{n}{Sx}\PYG{p}{,} \PYG{n}{Sy}\PYG{p}{,} \PYG{n}{Sxy}\PYG{p}{,} \PYG{k+kr}{N}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{fx} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.001}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.001}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{solve} \PYG{n+nf}{Problem} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{fx}\PYG{o}{*}\PYG{n}{w}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Plate} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//deformation near gamma}
    \PYG{n}{Sx} \PYG{o}{=} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Sy} \PYG{o}{=} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Sxy} \PYG{o}{=} \PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Sx}\PYG{o}{\PYGZhy{}}\PYG{n}{Sy}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{Sxy}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//principal stress difference}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Plate}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Plate}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Adaptmesh}
    \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{Problem}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_FractureSliding1}.png}
\caption{COD on the first mesh}\label{\detokenize{model/elasticity:id8}}\label{\detokenize{model/elasticity:figfracturesliding1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_FractureSliding2}.png}
\caption{Principal stress difference in the first mesh}\label{\detokenize{model/elasticity:id9}}\label{\detokenize{model/elasticity:figfracturesliding2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_FractureSliding3}.png}
\caption{COD on the last adaptive mesh}\label{\detokenize{model/elasticity:id10}}\label{\detokenize{model/elasticity:figfracturesliding3}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_FractureSliding4}.png}
\caption{Principal stress difference on the last adaptive mesh}\label{\detokenize{model/elasticity:id11}}\label{\detokenize{model/elasticity:figfracturesliding4}}\end{subfigure}
\phantomsection\label{\detokenize{model/elasticity:CrackAndPrincipalStress}}

\end{figure}

\end{sphinxadmonition}


\section{Non-linear static problems}
\label{\detokenize{model/nonLinearStaticProblems:non-linear-static-problems}}\label{\detokenize{model/nonLinearStaticProblems::doc}}
Here we propose to solve the following non-linear academic problem of minimization of a functional:
\begin{equation*}
\begin{split}J(u) = \int_\Omega \frac{1}{2} f(|\nabla u|^2) - u*b\end{split}
\end{equation*}
where \(u\) is function of \(H^1_0(\Omega)\) and \(f\) defined by:
\begin{equation*}
\begin{split}f(x) = a*x + x-ln(1+x),\ f'(x) = a+\frac{x}{1+x},\ f''(x) = \frac{1}{(1+x)^2}\end{split}
\end{equation*}

\subsection{Newton-Raphson algorithm}
\label{\detokenize{model/nonLinearStaticProblems:newton-raphson-algorithm}}
Now, we solve the Euler problem \(\nabla J (u) = 0\) with Newton-Raphson algorithm, that is:
\begin{equation*}
\begin{split}u^{n+1} = u^n - ( \nabla^2 J (u^{n}))^{-1}*\nabla J(u^n)\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{0.001}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{alpha}\PYG{p}{;} \PYG{c+c1}{//to store \textbar{}nabla u\textbar{}\PYGZca{}2}
\PYG{n}{Ph} \PYG{n}{dalpha} \PYG{p}{;} \PYG{c+c1}{//to store 2f\PYGZsq{}\PYGZsq{}(\textbar{}nabla u\textbar{}\PYGZca{}2)}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{f} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{u}\PYG{o}{*}\PYG{n}{a} \PYG{o}{+} \PYG{n}{u} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{log}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{df} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{+}\PYG{n}{u}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{ddf} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{l+m+mf}{1.} \PYG{o}{/} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Problem}
\PYG{c+c1}{//the variational form of evaluate dJ = nabla J}
\PYG{c+c1}{//dJ = f\PYGZsq{}()*(dx(u)*dx(vh) + dy(u)*dy(vh))}
\PYG{k+kt}{varf} \PYG{n+nf}{vdJ} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{vh}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{//the variational form of evaluate ddJ = nabla\PYGZca{}2 J}
\PYG{c+c1}{//hJ(uh,vh) = f\PYGZsq{}()*(dx(uh)*dx(vh) + dy(uh)*dy(vh))}
\PYG{c+c1}{//  + 2*f\PYGZsq{}\PYGZsq{}()(dx(u)*dx(uh) + dy(u)*dy(uh)) * (dx(u)*dx(vh) + dy(u)*dy(vh))}
\PYG{k+kt}{varf} \PYG{n+nf}{vhJ} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{dalpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Newton algorithm}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Compute f\PYGZsq{} and f\PYGZsq{}\PYGZsq{}}
    \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dalpha} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{ddf}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// nabla J}
    \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=} \PYG{n}{vdJ}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Residual}
    \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ residu\PYGZca{}2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(} \PYG{n}{res} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}12}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

    \PYG{c+c1}{// HJ}
    \PYG{k+kt}{matrix} \PYG{n}{H} \PYG{o}{=} \PYG{n}{vhJ}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Newton}
    \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{H}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{w}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Solution with Newton\PYGZhy{}Raphson}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Eigen value problems}
\label{\detokenize{model/eigenValueProblems:eigen-value-problems}}\label{\detokenize{model/eigenValueProblems::doc}}
This section depends on your installation of FreeFem++; you need to have compiled \sphinxcode{\sphinxupquote{ARPACK}}.
This tool is available in FreeFem++ if the word eigenvalue appears in line \sphinxcode{\sphinxupquote{Load:}}, like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZhy{}\PYGZhy{} FreeFem++ v*.** \PYG{o}{(}date *** *** ** **:**:** CET ****\PYG{o}{)}
 file : ***.edp
 Load: lg\PYGZus{}fem lg\PYGZus{}mesh eigenvalue
\end{sphinxVerbatim}

This tool is based on \sphinxhref{http://www.caam.rice.edu/software/ARPACK/}{arpack++}, the object-oriented version of \sphinxcode{\sphinxupquote{ARPACK}} eigenvalue package \sphinxcite{reference:lehoucq1998}.

The function \sphinxcode{\sphinxupquote{EigenValue}} computes the generalized eigenvalue of \(A u = \lambda B u\).
The Shift-invert method is used by default, with sigma =\(\sigma\) the shift of the method.

The matrix \(OP\) is defined with \(A - \sigma B\).

The return value is the number of converged eigenvalues (can be greater than the number of requested eigenvalues nev=)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{n}{OP}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{n}{Nev}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the matrix \(OP= A - \sigma B\) with a solver and boundary condition, and the matrix \(B\).

There is also a functional interface:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{n}{FOP1}\PYG{p}{,} \PYG{n}{FB}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{n}{Nev}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \(n\) is the size of the problem, and the operators are now defined through functions, defining respectively the matrix product of \(OP^{-1}\) and \(B\), as in

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n}{OP1}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{FOP1}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au} \PYG{o}{=} \PYG{n}{OP}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{u}\PYG{p}{;} \PYG{k}{return} \PYG{n}{Au}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{FB}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au} \PYG{o}{=} \PYG{k+kp}{B}\PYG{o}{*}\PYG{n}{u}\PYG{p}{;} \PYG{k}{return} \PYG{n}{Au}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If you want finer control over the method employed in \sphinxcode{\sphinxupquote{ARPACK}}, you can specify which mode \sphinxcode{\sphinxupquote{ARPACK}} will work with (\sphinxcode{\sphinxupquote{mode=}} , see ARPACK documentation \sphinxcite{reference:lehoucq1998}). The operators necessary for the chosen mode can be passed through the optional parameters \sphinxcode{\sphinxupquote{A=}}, \sphinxcode{\sphinxupquote{A1=}}, \sphinxcode{\sphinxupquote{B=}}, \sphinxcode{\sphinxupquote{B1=}}, (see below).
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{mode=1}}: Regular mode for solving \(A u = \lambda u\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{FOP}\PYG{p}{,} \PYG{k+kp}{mode}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{n}{Nev}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the function FOP defines the matrix product of A

\item {} 
\sphinxcode{\sphinxupquote{mode=2}}: Regular inverse mode for solving \(A u = \lambda B u\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{FOP}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{FB}\PYG{p}{,} \PYG{k+kp}{B1}\PYG{o}{=}\PYG{n}{FB1}\PYG{p}{,} \PYG{k+kp}{mode}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{n}{Nev}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the functions FOP, FB and FB1 define respectively the matrix product of \(A\), \(B\) and \(B^{-1}\)

\item {} 
\sphinxcode{\sphinxupquote{mode=3}}: Shift-invert mode for solving \(A u = \lambda B u\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{A1}\PYG{o}{=}\PYG{n}{FOP1}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{FB}\PYG{p}{,} \PYG{k+kp}{mode}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{n}{Sigma}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{n}{Nev}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the functions FOP1 and FB define respectively the matrix product of \(OP^{-1} = (A - \sigma B)^{-1}\) and \(B\)

\end{itemize}

You can also specify which subset of eigenvalues you want to compute (\sphinxcode{\sphinxupquote{which=}}).
The default value is \sphinxcode{\sphinxupquote{which="LM"}}, for eigenvalues with largest magnitude.
\sphinxcode{\sphinxupquote{"SM"}} is for smallest magnitude, \sphinxcode{\sphinxupquote{"LA"}} for largest algebraic value, \sphinxcode{\sphinxupquote{"SA"}} for smallest algebraic value, and \sphinxcode{\sphinxupquote{"BE"}} for both ends of the spectrum.

Remark: For complex problems, you need to use the keyword \sphinxcode{\sphinxupquote{complexEigenValue}} instead of \sphinxcode{\sphinxupquote{EigenValue}} when passing operators through functions.

\begin{sphinxadmonition}{note}{Note:}
Boundary condition and Eigenvalue Problems

The locking (Dirichlet) boundary condition is make with exact penalization so we put \sphinxcode{\sphinxupquote{1e30=tgv}} on the diagonal term of the locked degree of freedom (see {\hyperref[\detokenize{documentation/finiteElement:variationalformsparsematrixpde}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite element chapter}}}}). So take Dirichlet boundary condition just on \(A\) and not on \(B\) because we solve \(w=OP^{-1}*B*v\).

If you put locking (Dirichlet) boundary condition on \(B\) matrix (with key work \sphinxcode{\sphinxupquote{on}}) you get small spurious modes \((10^{-30})\), due to boundary condition, but if you forget the locking boundary condition on \(B\) matrix (no keywork \sphinxcode{\sphinxupquote{on}}) you get huge spurious \((10^{30})\) modes associated to these boundary conditons. We compute only small mode, so we get the good one in this case.
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sym=}} The problem is symmetric (all the eigen value are real)

\item {} 
\sphinxcode{\sphinxupquote{nev=}} The number desired eigenvalues (nev) close to the shift.

\item {} 
\sphinxcode{\sphinxupquote{value=}} The array to store the real part of the eigenvalues

\item {} 
\sphinxcode{\sphinxupquote{ivalue=}} The array to store the imaginary part of the eigenvalues

\item {} 
\sphinxcode{\sphinxupquote{vector=}} The FE function array to store the eigenvectors

\item {} 
\sphinxcode{\sphinxupquote{rawvector=}} An array of type \sphinxcode{\sphinxupquote{real{[}int,int{]}}} to store eigenvectors by column.

For real non symmetric problems, complex eigenvectors are given as two consecutive vectors, so if eigenvalue \(k\) and \(k+1\) are complex conjugate eigenvalues, the \(k\)th vector will contain the real part and the \(k+1\)th vector the imaginary part of the corresponding complex conjugate eigenvectors.

\item {} 
\sphinxcode{\sphinxupquote{tol=}} The relative accuracy to which eigenvalues are to be determined;

\item {} 
\sphinxcode{\sphinxupquote{sigma=}} The shift value;

\item {} 
\sphinxcode{\sphinxupquote{maxit=}} The maximum number of iterations allowed;

\item {} 
\sphinxcode{\sphinxupquote{ncv=}} The number of Arnoldi vectors generated at each iteration of \sphinxcode{\sphinxupquote{ARPACK}};

\item {} 
\sphinxcode{\sphinxupquote{mode=}} The computational mode used by \sphinxcode{\sphinxupquote{ARPACK}} (see above);

\item {} 
\sphinxcode{\sphinxupquote{which=}} The requested subset of eigenvalues (see above).

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
Laplace eigenvalue

In the first example, we compute the eigenvalues and the eigenvectors of the Dirichlet problem on square \(\Omega=]0,\pi[^2\).

The problem is to find: \(\lambda\), and \(\nabla u_{\lambda}\) in \(\mathbb{R}{\times} H^1_0(\Omega)\)
\begin{equation*}
\begin{split}\int_\Omega \nabla u_{\lambda} \nabla v = \lambda \int_\Omega u v \quad \forall v \in H^1_0(\Omega)\end{split}
\end{equation*}
The exact eigenvalues are \(\lambda_{n,m} =(n^2+m^2), (n,m)\in {\mathbb{N}_*}^2\) with the associated eigenvectors are \(u_{{m,n}}=\sin(nx)*\sin(my)\).

We use the generalized inverse shift mode of the \sphinxtitleref{arpack++} library, to find 20 eigenvalues and eigenvectors close to the shift value \(\sigma=20\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{c+c1}{//value of the shift}
\PYG{k+kt}{int} \PYG{k+kp}{nev} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{c+c1}{//number of computed eigen value close to sigma}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{c+c1}{// OP = A \PYGZhy{} sigma B ; // the shifted matrix}
\PYG{k+kt}{varf} \PYG{k+kp}{op} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{k+kp}{sigma}\PYG{o}{*} \PYG{n}{u1}\PYG{o}{*}\PYG{n}{u2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{b} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u2}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//no boundary condition}

\PYG{k+kt}{matrix} \PYG{n}{OP} \PYG{o}{=} \PYG{k+kp}{op}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Crout}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//crout solver because the matrix in not positive}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}20}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// important remark:}
\PYG{c+c1}{// the boundary condition is make with exact penalization:}
\PYG{c+c1}{// we put 1e30=tgv on the diagonal term of the lock degree of freedom.}
\PYG{c+c1}{// So take Dirichlet boundary condition just on \PYGZdl{}a\PYGZdl{} variational form}
\PYG{c+c1}{// and not on \PYGZdl{}b\PYGZdl{} variational form.}
\PYG{c+c1}{// because we solve \PYGZdl{} w=OP\PYGZca{}\PYGZhy{}1*B*v \PYGZdl{}}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ev}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the nev eigenvalue}
\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{eV}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the nev eigenvector}

\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{n}{OP}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{k+kp}{sym}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{k+kp}{sigma}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{n}{ev}\PYG{p}{,} \PYG{k+kp}{vector}\PYG{o}{=}\PYG{n}{eV}\PYG{p}{,}
    \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kp}{maxit}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{ncv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Display \PYGZam{} Plot}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{u1} \PYG{o}{=} \PYG{n}{eV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{gg} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{mm} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{)} \PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lambda[}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ev}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{ev}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{eV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Eigen Vector }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ value =}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{ev}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The output of this example is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
lambda\PYG{o}{[}\PYG{l+m}{0}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{5}.0002, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}1.46519e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{1}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{8}.00074, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}4.05158e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{2}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{10}.0011, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{2}.84925e\PYGZhy{}12
lambda\PYG{o}{[}\PYG{l+m}{3}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{10}.0011, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}7.25456e\PYGZhy{}12
lambda\PYG{o}{[}\PYG{l+m}{4}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{13}.002, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}1.74257e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{5}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{13}.0039, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{1}.22554e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{6}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{17}.0046, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}1.06274e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{7}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{17}.0048, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{1}.03883e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{8}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{18}.0083, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}4.05497e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{9}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{20}.0096, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}2.21678e\PYGZhy{}13
lambda\PYG{o}{[}\PYG{l+m}{10}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{20}.0096, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}4.16212e\PYGZhy{}14
lambda\PYG{o}{[}\PYG{l+m}{11}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{25}.014, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}7.42931e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{12}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{25}.0283, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{6}.77444e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{13}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{26}.0159, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{3}.19864e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{14}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{26}.0159, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}4.9652e\PYGZhy{}12
lambda\PYG{o}{[}\PYG{l+m}{15}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{29}.0258, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}9.99573e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{16}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{29}.0273, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{1}.38242e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{17}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{32}.0449, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{1}.2522e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{18}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{34}.049, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{3}.40213e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{19}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{34}.0492, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{2}.41751e\PYGZhy{}10
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EigenValueProblems1}.png}
\caption{Isovalue of 11th eigenvector \(u_{4,3}-u_{3,4}\)}\label{\detokenize{model/eigenValueProblems:id3}}\label{\detokenize{model/eigenValueProblems:figeigenvalueproblems1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EigenValueProblems2}.png}
\caption{Isovalue of 12th eigenvector \(u_{4,3}+u_{3,4}\)}\label{\detokenize{model/eigenValueProblems:id4}}\label{\detokenize{model/eigenValueProblems:figeigenvalueproblems2}}\end{subfigure}
\phantomsection\label{\detokenize{model/eigenValueProblems:EigenValueProblems}}

\end{figure}

\end{sphinxadmonition}


\section{Evolution problems}
\label{\detokenize{model/evolutionProblems:evolution-problems}}\label{\detokenize{model/evolutionProblems::doc}}
\sphinxstylestrong{FreeFem++} also solves evolution problems such as the heat equation:
\begin{equation}\label{equation:model/evolutionProblems:eqn::heatequation}
\begin{split}\begin{array}{rcll}
    \frac{\p u}{\p t}-\mu\Delta u &=& f & \textrm{ in }\Omega\times ]0,T[\\
    u(\mathbf{x},0) &=& u_0(\mathbf{x}) & \textrm{ in }\Omega\\
    \left(\p u/\p n\right)(\mathbf{x},t) &=& 0 & \textrm{ on }\p\Omega\times ]0,T[
\end{array}\end{split}
\end{equation}
with a positive viscosity coefficient \(\mu\) and homogeneous Neumann boundary conditions.

We solve \eqref{equation:model/evolutionProblems:eqn::heatequation} by FEM in space and finite differences in time.

We use the definition of the partial derivative of the solution in the time derivative:
\begin{equation*}
\begin{split}\frac{\p u}{\p t}(x,y,t) = \lim_{\tau \to 0}\frac{u(x,y,t)-u(x,y,t-\tau )}{\tau }\end{split}
\end{equation*}
which indicates that \(u^m(x,y)=u(x,y,m\tau )\) will satisfy approximatively:
\begin{equation*}
\begin{split}\frac{\p u}{\p t}(x,y,m\tau )\simeq \frac{u^m(x,y)-u^{m-1}(x,y)}{\tau }\end{split}
\end{equation*}
The time discretization of heat equation \eqref{equation:model/evolutionProblems:eqn::heatequation} is as follows, \(\forall m=0,\cdots,[T/\tau ]\):
\begin{equation*}
\begin{split}\begin{array}{rcll}
    \frac{u^{m+1}-u^{m}}{\tau }-\mu\Delta u^{m+1} &=& f^{m+1} & \textrm{ in }\Omega\\
    u^0(\mathbf{x}) &=& u_0(\mathbf{x}) & \textrm{ in }\Omega\\
    \p u^{m+1}/\p n(\mathbf{x}) &=& 0 & \textrm{ on }\p\Omega
\end{array}\end{split}
\end{equation*}
which is so-called \sphinxstyleemphasis{backward Euler method} for \eqref{equation:model/evolutionProblems:eqn::heatequation}.

To obtain the variational formulation, multiply with the test function \(v\) both sides of the equation:
\begin{equation*}
\begin{split}\int_{\Omega}\{u^{m+1}v-\tau \Delta u^{m+1}v\}=\int_{\Omega}\{u^m+\tau f^{m+1}\}v\end{split}
\end{equation*}
By the divergence theorem, we have:
\begin{equation*}
\begin{split}\int_{\Omega}\{u^{m+1}v+\tau\nabla u^{m+1}\cdot \nabla v\}
-\int_{\p\Omega} \tau \left( \p u^{m+1}/\p n\right) v
=\int_{\Omega }\{u^mv+\tau f^{m+1}v\}\end{split}
\end{equation*}
By the boundary condition \(\p u^{m+1}/\p n=0\), it follows that:
\begin{equation}\label{equation:model/evolutionProblems:eqn::heatequationBWE}
\begin{split}\int_{\Omega} \{u^{m+1}v+\tau \nabla u^{m+1}\cdot \nabla v\}
-\int_{\Omega }\{u^mv+\tau f^{m+1}v\}
=0\end{split}
\end{equation}
Using the identity just above, we can calculate the finite element approximation \(u_h^m\) of \(u^m\) in a step-by-step manner with respect to \(t\).

\begin{sphinxadmonition}{tip}{Tip:}
Example

We now solve the following example with the exact solution \(u(x,y,t)=tx^4\), \(\Omega = ]0,1[^2\).
\begin{equation*}
\begin{split}\begin{array}{rcll}
    \frac{{\p u}}{{\p t}} - \mu \Delta u &=& x^4 - \mu 12tx^2 & \textrm{ in }\Omega\times ]0,3[\\
    u(x,y,0) &=& 0 & \textrm{ on }\Omega\\
    \left. u \right|_{\p\Omega} &=& t*x^4
\end{array}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{g}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{dHeat} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
        \PYG{o}{+} \PYG{n}{dt}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{uu}\PYG{o}{*}\PYG{n}{v}
        \PYG{o}{\PYGZhy{}} \PYG{n}{dt}\PYG{o}{*}\PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{uu} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{k+kp}{t} \PYG{o}{=} \PYG{k+kp}{t}\PYG{o}{+}\PYG{n}{dt}\PYG{p}{;}
    \PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{*}\PYG{l+m+mi}{12}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{n}{g} \PYG{o}{=} \PYG{k+kp}{t}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{;}
    \PYG{n}{uu} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{dHeat}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} L\PYGZca{}2\PYGZhy{}Error=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

In the last statement, the \(L^2\)-error \(\left(\int_{\Omega}\left| u-tx^4\right|^2\right)^{1/2}\) is calculated at \(t=m\tau, \tau =0.1\). At \(t=0.1\), the error is 0.000213269. The errors increase with \(m\) and 0.00628589 at \(t=3\).

The iteration of the backward Euler \eqref{equation:model/evolutionProblems:eqn::heatequationBWE} is made by {\hyperref[\detokenize{reference/loops:loopfor}]{\sphinxcrossref{\DUrole{std,std-ref}{for loop}}}}.

\begin{sphinxadmonition}{note}{Note:}
The stiffness matrix in the loop is used over and over again.
\sphinxstylestrong{FreeFem++} support reuses of stiffness matrix.
\end{sphinxadmonition}
\end{sphinxadmonition}


\subsection{Mathematical Theory on Time Difference Approximations.}
\label{\detokenize{model/evolutionProblems:mathematical-theory-on-time-difference-approximations}}
In this section, we show the advantage of implicit schemes.
Let \(V, H\) be separable Hilbert space and \(V\) is dense in \(H\).
Let \(a\) be a continuous bilinear form over \(V \times V\) with coercivity and symmetry.

Then \(\sqrt{a(v,v)}\) become equivalent to the norm \(\| v\|\) of \(V\).

\sphinxstylestrong{Problem Ev(f,Omega)}: For a given \(f\in L^2(0,T;V'),\, u^0\in H\)
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \frac{d}{dt}(u(t),v)+a(u(t),v)&=&( f(t),v)\qquad \forall v\in V,\quad a.e. \, t\in [0,T]\\
    u(0)&=&u^0\nonumber
\end{array}\end{split}
\end{equation*}
where \(V'\) is the dual space of \(V\).

Then, there is an unique solution \(u\in L^{\infty}(0,T;H)\cap L^2(0,T;V)\).

Let us denote the time step by \(\tau>0\), \(N_T=[T/\tau]\).
For the discretization, we put \(u^n = u(n\tau)\) and consider the time difference for each \(\theta\in [0,1]\)
\begin{equation}\label{equation:model/evolutionProblems:eqn::t-method}
\begin{split}\begin{array}{rcl}
    \frac{1}{\tau}\left( u_h^{n+1}-u_h^n,\phi_i\right) +a\left( u_h^{n+\theta},\phi_i\right)&=&\langle f^{n+\theta},\phi_i\rangle\\
    i=1,&\cdots&, m,\quad n=0,\cdots, N_T\nonumber\\
    u_h^{n+\theta}&=&\theta u_h^{n+1}+(1-\theta)u_h^n,\\
    f^{n+\theta}&=&\theta f^{n+1}+(1-\theta)f^n\nonumber
\end{array}\end{split}
\end{equation}
Formula \eqref{equation:model/evolutionProblems:eqn::t-method} is the \sphinxstyleemphasis{forward Euler scheme} if \(\theta=0\), \sphinxstyleemphasis{Crank-Nicolson scheme} if \(\theta=1/2\), the \sphinxstyleemphasis{backward Euler scheme} if \(\theta=1\).

Unknown vectors \(u^n=(u_h^1,\cdots,u_h^M)^T\) in
\begin{equation*}
\begin{split}u_h^n(x)=u^n_1\phi_1(x)+\cdots+u^n_m\phi_m(x),\quad u^n_1,\cdots,u^n_m\in \R\end{split}
\end{equation*}
are obtained from solving the matrix
\begin{equation}\label{equation:model/evolutionProblems:eqn::Evolution-1}
\begin{split}(M+\theta\tau A)u^{n+1}=\{M-(1-\theta)\tau A\}u^n
+\tau\left\{\theta f^{n+1}+(1-\theta)f^n\right\}\\
M=(m_{ij}),\quad m_{ij}=(\phi_j,\phi_i),\qquad
A=(a_{ij}),\quad a_{ij}=a(\phi_j,\phi_i)\nonumber\end{split}
\end{equation}
Refer \sphinxcite{reference:tabata1994}, pp.70\textendash{}75 for solvability of \eqref{equation:model/evolutionProblems:eqn::Evolution-1}. The stability of \eqref{equation:model/evolutionProblems:eqn::Evolution-1} is in \sphinxcite{reference:tabata1994}, Theorem 2.13:

Let \(\{\mathcal{T}_h\}_{h\downarrow 0}\) be regular triangulations (see {\hyperref[\detokenize{documentation/meshGeneration:meshregulartriangulation}]{\sphinxcrossref{\DUrole{std,std-ref}{Regular Triangulation}}}}).
Then there is a number \(c_0>0\) independent of \(h\) such that,
\begin{equation*}
\begin{split}|u_h^n|^2\le
\left\{
\begin{array}{lr}
\frac{1}{\delta}\left\{
|u^0_h|^2+\tau \sum_{k=0}^{n-1}\|f^{k+\theta}\|^2_{V_h'}
\right\}&\theta\in [0,1/2)\\
|u^0_h|^2+\tau \sum_{k=0}^{n-1}\|f^{k+\theta}\|^2_{V_h'}&\theta\in [1/2,1]
\end{array}
\right.\end{split}
\end{equation*}
if the following are satisfied:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
When \(\theta\in [0,1/2)\), then we can take a time step \(\tau\) in such a way that
\begin{quote}
\begin{equation*}
\begin{split}\tau <\frac{2(1-\delta)}{(1-2\theta)c_0^2}h^2\end{split}
\end{equation*}
for arbitrary \(\delta\in (0,1)\).
\end{quote}

\item {} 
When \(1/2\leq \theta\leq 1\), we can take \(\tau\) arbitrary.

\end{enumerate}

\begin{sphinxadmonition}{tip}{Tip:}
Example

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{tau} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{k+kt}{real}
\PYG{n}{theta} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{oldU}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{f1}\PYG{p}{,} \PYG{n}{f0}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{h} \PYG{o}{=} \PYG{k+kr}{hTriangle}\PYG{p}{;} \PYG{c+c1}{// mesh sizes for each triangle}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{f} \PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{12}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{11}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// File}
\PYG{k+kt}{ofstream} \PYG{n+nf}{out}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{err02.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//file to store calculations}
\PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mesh size = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, time step = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tau} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{o}{/}\PYG{n}{tau}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{o}{*}\PYG{n}{tau} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{aTau} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
        \PYG{o}{+} \PYG{n}{theta}\PYG{o}{*}\PYG{n}{tau}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{oldU}\PYG{o}{*}\PYG{n}{v}
        \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{theta}\PYG{p}{)}\PYG{o}{*}\PYG{n}{tau}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{oldU}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{oldU}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{oldU}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{tau}\PYG{o}{*}\PYG{p}{(}\PYG{n}{theta}\PYG{o}{*}\PYG{n}{f1} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{theta}\PYG{p}{)}\PYG{o}{*}\PYG{n}{f0}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Theta loop}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{theta} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{T} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{n}{oldU} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{theta} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{o}{/}\PYG{n}{tau}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Update}
        \PYG{k+kp}{t} \PYG{o}{=} \PYG{k+kp}{t} \PYG{o}{+} \PYG{n}{tau}\PYG{p}{;}
        \PYG{n}{f0} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{*}\PYG{n}{tau}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{f1} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{tau}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// Solve}
        \PYG{n}{aTau}\PYG{p}{;}
        \PYG{n}{oldU} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

        \PYG{c+c1}{// Plot}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// Error}
        \PYG{n}{Vh} \PYG{n}{uex} \PYG{o}{=} \PYG{k+kp}{t}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//exact solution = tx\PYGZca{}2(1\PYGZhy{}x)\PYGZca{}2}
        \PYG{n}{Vh} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{u} \PYG{o}{\PYGZhy{}} \PYG{n}{uex}\PYG{p}{;} \PYG{c+c1}{// err = FE\PYGZhy{}sol \PYGZhy{} exact}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kp}{err}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)}\PYG{o}{/}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{uex}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{theta} \PYG{o}{=} \PYG{n}{theta} \PYG{o}{+} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{EvolutionProblems_TimeDifference}.png}
\caption{\(\max_{x\in\Omega}\vert u_h^n(\theta)-u_{ex}(n\tau)\vert\max_{x\in\Omega}\vert u_{ex}(n\tau)\vert at n=0,1,\cdots,29\)}\label{\detokenize{model/evolutionProblems:figevolutiontimediff}}\end{figure}

We can see in \hyperref[\detokenize{model/evolutionProblems:figevolutiontimediff}]{Fig.\@ \ref{\detokenize{model/evolutionProblems:figevolutiontimediff}}} that \(u_h^n(\theta)\) become unstable at \(\theta=0.4\), and figures are omitted in the case \(\theta<0.4\).
\end{sphinxadmonition}


\subsection{Convection}
\label{\detokenize{model/evolutionProblems:convection}}
The hyperbolic equation
\begin{equation}\label{equation:model/evolutionProblems:eqn::conv}
\begin{split}\p_t u +\mathbf{\alpha} \cdot \nabla u=f;\ \textrm{ for a vector-valued function }\mathbf{\alpha}\end{split}
\end{equation}
appears frequently in scientific problems, for example in the Navier-Stokes equations, in the Convection-Diffusion equation, etc.

In the case of 1-dimensional space, we can easily find the general solution \((x,t)\mapsto u(x,t)=u^0(x-\alpha t)\) of the following equation, if \(\alpha\) is constant,
\begin{equation}\label{equation:model/evolutionProblems:eqn::conv0}
\begin{split}\begin{array}{rcl}
    \p_t u +\alpha\p_x u &=& 0\\
    u(x,0) &=& u^0(x),
\end{array}\end{split}
\end{equation}
because \(\p_t u +\alpha\p_x u=-\alpha\dot{u}^0+a\dot{u}^0=0\), where \(\dot{u}^0=du^0(x)/dx\).

Even if \(\alpha\) is not constant, the construction works on similar principles.
One begins with the ordinary differential equation (with the convention that \(\alpha\) is prolonged by zero apart from \((0,L)\times (0,T)\)):
\begin{equation*}
\begin{split}\dot{X}(\tau )=+\alpha(X(\tau ),\tau ),\ \tau \in (0,t)\quad X(t)=x\end{split}
\end{equation*}
In this equation \(\tau\) is the variable and \(x,t\) are parameters, and we denote the solution by \(X_{x,t}(\tau )\).
Then it is noticed that \((x,t)\rightarrow v(X(\tau),\tau)\) in \(\tau=t\) satisfies the equation
\begin{equation*}
\begin{split}\p _{t}v+\alpha\p _{x}v=\p _{t}X\dot{v}+a\p _{x}X\dot{v}%
=0\end{split}
\end{equation*}
and by the definition \(\p _{t}X=\dot{X}=+\alpha\) and \(\p_{x}X=\p _{x}x\) in \(\tau=t\), because if \(\tau =t\) we have \(X(\tau )=x\).

The general solution of \eqref{equation:model/evolutionProblems:eqn::conv0} is thus the value of the boundary condition in \(X_{x, t}(0)\), that is to say \(u(x,t)=u^{0}(X_{x,t}(0))\) where \(X_{x,t}(0)\) is on the \(x\) axis, \(u(x,t)=u^{0}(X_{x,t}(0))\) if \(X_{x,t}(0)\) is on the axis of \(t\).

In higher dimension \(\Omega \subset R^{d},~d=2,3\), the equation for the convection is written
\begin{equation*}
\begin{split}\p _{t}u+\mathbf{\alpha}\cdot \nabla u=0\hbox{ in }\Omega \times (0,T)\end{split}
\end{equation*}
where \(\mathbf{a}(x,t)\in \R^{d}\).

\sphinxstylestrong{FreeFem++} implements the Characteristic-Galerkin method for convection operators.
Recall that the equation \eqref{equation:model/evolutionProblems:eqn::conv} can be discretized as
\begin{equation*}
\begin{split}\frac{Du}{Dt} = f\;\;\textrm{i.e. }\frac{du}{dt}\left( {X(t),t} \right) = f\left(X( t ),t \right)\textrm{ where }\frac{dX}{dt}( t ) = \mathbf{\alpha}( {X(t),t})\end{split}
\end{equation*}
where \(D\) is the total derivative operator.
So a good scheme is one step of backward convection by the method of Characteristics-Galerkin
\begin{equation}\label{equation:model/evolutionProblems:eqn::Charac}
\begin{split}\frac{1}{{\tau }}\left(u^{m + 1}(x) - u^m(X^m(x))\right) = f^m (x)\end{split}
\end{equation}
where \(X^m (x)\) is an approximation of the solution at \(t = m\tau\) of the ordinary differential equation
\begin{equation*}
\begin{split}\frac{d\mathbf{X}}{dt}(t) = \mathbf{\alpha}^m(\mathbf{X}(t)), \mathbf{X}((m + 1)\tau) = x.\end{split}
\end{equation*}
where \(\mathbf{\alpha}^m(x)=(\alpha_1(x,m\tau ),\alpha_2(x,m\tau))\).
Because, by Taylor’s expansion, we have
\begin{equation}\label{equation:model/evolutionProblems:eqn::conv1}
\begin{split}\begin{array}{rcl}
    u^m(\mathbf{X}(m\tau ))&=&
    u^m(\mathbf{X}((m+1)\tau )) -
    \tau \sum_{i=1}^d \frac{\p u^m}{\p x_i}(\mathbf{X}((m+1)\tau ))
    \frac{\p X_i}{\p t}((m+1)\tau )
    +o(\tau )\nonumber\\
    &=&u^m(x)-\tau \mathbf{\alpha}^m(x)\cdot \nabla u^m(x)+o(\tau )
\end{array}\end{split}
\end{equation}
where \(X_i(t)\) are the i-th component of \(\mathbf{X}(t)\), \(u^m(x)=u(x,m\tau )\) and we used the chain rule and \(x=\mathbf{X}((m+1)\tau )\).
From \eqref{equation:model/evolutionProblems:eqn::conv1}, it follows that
\begin{equation*}
\begin{split}u^m(X^m(x))=u^m(x)-\tau \mathbf{\alpha}^m(x)\cdot \nabla u^m(x)+o(\tau )\end{split}
\end{equation*}
Also we apply Taylor’s expansion for \(t \rightarrow u^m(x-\mathbf{\alpha}^m(x)t),0\le t\le \tau\), then
\begin{equation*}
\begin{split}u^m(x-\mathbf{\alpha}\tau )=u^m(x)-\tau \mathbf{\alpha}^m(x)\cdot \nabla u^m(x)+o(\tau ).\end{split}
\end{equation*}
Putting

\sphinxcode{\sphinxupquote{convect}}\(\left( {\mathbf{\alpha},-\tau ,u^m } \right)\approx u^m \left(x - \mathbf{\alpha}^m\tau \right)\)

we can get the approximation

\(u^m \left( {X^m( x )} \right) \approx\) \sphinxcode{\sphinxupquote{convect}} \(\left( {[a_1^m ,a_2^m],-\tau ,u^m } \right)\) by \(X^m \approx x \mapsto x- \tau [a_1^m(x) ,a_2^m(x)]\)

A classical convection problem is that of the “rotating bell” (quoted from \sphinxcite{reference:lucquin1998}, p.16).

Let \(\Omega\) be the unit disk centered at 0, with its center rotating with speed \(\alpha_1 = y,\, \alpha_2 = -x\).
We consider the problem \eqref{equation:model/evolutionProblems:eqn::conv} with \(f=0\) and the initial condition \(u(x,0)=u^0(x)\), that is, from \eqref{equation:model/evolutionProblems:eqn::Charac}

\(u^{m + 1}(x) = u^m(X^m(x))\approx\) \sphinxcode{\sphinxupquote{convect}}\((\mathbf{\alpha},-\tau ,u^m)\)

The exact solution is \(u(x, t) = u(\mathbf{X}(t))\) where \(\mathbf{X}\) equals \(x\) rotated around the origin by an angle \(\theta = -t\) (rotate in clockwise).
So, if \(u^0\) in a 3D perspective looks like a bell, then \(u\) will have exactly the same shape, but rotated by the same amount.
The program consists in solving the equation until \(T = 2\pi\), that is for a full revolution and to compare the final solution with the initial one; they should be equal.

\begin{sphinxadmonition}{tip}{Tip:}
Convect

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.17}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u0}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{a1} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{a2} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;} \PYG{c+c1}{//rotation velocity}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{;}

\PYG{c+c1}{// Initialization}
\PYG{n}{u} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{;}
    \PYG{n}{u0} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

    \PYG{c+c1}{// Convect}
    \PYG{n}{u} \PYG{o}{=} \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{u0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//u\PYGZca{}\PYGZob{}m+1\PYGZcb{}=u\PYGZca{}m(X\PYGZca{}m(x))}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, max=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The scheme \sphinxcode{\sphinxupquote{convect}} is unconditionally stable, then the bell become lower and lower (the maximum of \(u^{37}\) is \(0.406\) as shown in \hyperref[\detokenize{model/evolutionProblems:figevolutionconvect}]{Fig.\@ \ref{\detokenize{model/evolutionProblems:figevolutionconvect}}}.
\end{sphinxadmonition}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EvolutionProblem_Convect}.png}
\caption{\(u^0=e^{-10((x-0.3)^2 +(y-0.3)^2)}\)}\label{\detokenize{model/evolutionProblems:id6}}\label{\detokenize{model/evolutionProblems:figevolutionconvect}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EvolutionProblem_Convect2}.png}
\caption{The bell at \(t=6.29\)}\label{\detokenize{model/evolutionProblems:id7}}\label{\detokenize{model/evolutionProblems:figevolutionconvect2}}\end{subfigure}


\end{figure}

\end{sphinxadmonition}


\subsection{2D Black-Scholes equation for an European Put option}
\label{\detokenize{model/evolutionProblems:d-black-scholes-equation-for-an-european-put-option}}\label{\detokenize{model/evolutionProblems:EvolutionProblem_Convect}}
In mathematical finance, an option on two assets is modeled by a Black-Scholes equations in two space variables, (see for example \sphinxcite{reference:wilmott1995} or \sphinxcite{reference:achdou2005}).
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \p _t u &+& \frac{{\left( {\sigma _1 x } \right)^2 }}{2}\frac{{\p ^2 u}}{{\p x^2 }} + \frac{{\left( {\sigma _2 y } \right)^2 }}{2}\frac{{\p ^2 u}}{{\p y^2 }} \\
    &&{\rm{ }} + \rho x y \frac{{\p ^2 u}}{{\p x \p y }} + rS_1 \frac{{\p u}}{{\p x }} + rS_2 \frac{{\p u}}{{\p y }} - rP = 0 \nonumber
\end{array}\end{split}
\end{equation*}
which is to be integrated in \(\left( {0,T} \right) \times \R^ + \times \R^ +\) subject to, in the case of a put
\begin{equation*}
\begin{split}u\left( {x , y ,T} \right) = \left( {K - \max \left( {x ,y } \right)} \right)^+\end{split}
\end{equation*}
Boundary conditions for this problem may not be so easy to device.
As in the one dimensional case the PDE contains boundary conditions on the axis \(x_1 = 0\) and on the axis \(x_2 = 0\), namely two one dimensional Black-Scholes equations driven respectively by the data \(u\left( {0, + \infty ,T} \right)\) and \(u\left( { + \infty ,0,T} \right)\).
These will be automatically accounted for because they are embedded in the PDE.
So if we do nothing in the variational form (i.e. if we take a Neumann boundary condition at these two axis in the strong form) there will be no disturbance to these.
At infinity in one of the variable, as in 1D, it makes sense to impose \(u=0\).
We take
\begin{equation*}
\begin{split}\sigma _1  = 0.3,\;\;\sigma _2  = 0.3,\;\;\rho  = 0.3,\;\;r = 0.05,\;\;K = 40,\;\;T = 0.5\end{split}
\end{equation*}
An implicit Euler scheme is used and a mesh adaptation is done every 10 time steps.
To have an unconditionally stable scheme, the first order terms are treated by the Characteristic Galerkin method, which, roughly, approximates
\begin{equation*}
\begin{split}\frac{{\p u}}{{\p t}} + a_1 \frac{{\p u}}{{\p x}} + a_2 \frac{{\p u}}{{\p y}} \approx \frac{1}{{\tau }}\left( {u^{n + 1} \left( x \right) - u^n \left( {x - \mathbf{\alpha}\tau } \right)} \right)\end{split}
\end{equation*}
\begin{sphinxadmonition}{tip}{Tip:}
Black-Scholes

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mi}{80}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{LL} \PYG{o}{=} \PYG{l+m+mi}{80}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{sigx} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{sigy} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{rho} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{n}{L}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{LL}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{K}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{xveloc}\PYG{p}{,} \PYG{n}{yveloc}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uold}\PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{*}\PYG{n}{dt} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Mesh adaptation}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{abserror}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbjacoby}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}
        \PYG{k+kp}{err}\PYG{o}{=}\PYG{l+m+mf}{0.001}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{k+kp}{omega}\PYG{o}{=}\PYG{l+m+mf}{1.8}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{l+m+mf}{1.8}\PYG{p}{,} \PYG{k+kp}{nbsmooth}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,}
        \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{maxsubdiv}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kp}{rescaling}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{xveloc} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{r} \PYG{o}{+} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{sigx}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sigx}\PYG{o}{*}\PYG{n}{sigy}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{n}{yveloc} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{r} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{sigy}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sigx}\PYG{o}{*}\PYG{n}{sigy}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{n}{u} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Update}
    \PYG{n}{uold} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{solve} \PYG{n+nf}{eq1}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{j}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{p}{(}\PYG{n}{r}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{sigx}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{2}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{sigy}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{2}
            \PYG{o}{+} \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sigx}\PYG{o}{*}\PYG{n}{sigy}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{/}\PYG{l+m+mi}{2}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{v}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xveloc}\PYG{p}{,} \PYG{n}{yveloc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{uold}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{j} \PYG{o}{=} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Results are shown on \hyperref[\detokenize{model/evolutionProblems:figevolutionblacksholes1}]{Fig.\@ \ref{\detokenize{model/evolutionProblems:figevolutionblacksholes1}}} and \hyperref[\detokenize{model/evolutionProblems:figevolutionblacksholes2}]{Fig.\@ \ref{\detokenize{model/evolutionProblems:figevolutionblacksholes2}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EvolutionProblems_BlackSholes}.png}
\caption{The adapted triangulation}\label{\detokenize{model/evolutionProblems:id8}}\label{\detokenize{model/evolutionProblems:figevolutionblacksholes1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EvolutionProblems_BlackSholes2}.png}
\caption{The level line of the European basquet put option}\label{\detokenize{model/evolutionProblems:id9}}\label{\detokenize{model/evolutionProblems:figevolutionblacksholes2}}\end{subfigure}
\phantomsection\label{\detokenize{model/evolutionProblems:EvolutionProblems_BlackSholes}}

\end{figure}

\end{sphinxadmonition}


\section{Navier-Stokes equations}
\label{\detokenize{model/navierStokesEquations:navier-stokes-equations}}\label{\detokenize{model/navierStokesEquations::doc}}
The Stokes equations are: for a given \(\mathbf{f}\in L^2(\Omega)^2\):
\begin{equation}\label{equation:model/navierStokesEquations:eqn::Stokes}
\begin{split}\left.\begin{array}{cl}
    -\Delta \mathbf{u}+\nabla p & =\mathbf{f} \\
    \nabla\cdot \mathbf{u} &=0
\end{array}\right\}\quad \hbox{ in }\Omega\end{split}
\end{equation}
where \(\mathbf{u}=(u_1,u_2)\) is the velocity vector and \(p\) the pressure.
For simplicity, let us choose Dirichlet boundary conditions on the velocity, \(\mathbf{u}=\mathbf{u}_{\Gamma}\) on \(\Gamma\).

In \sphinxcite{reference:temam1977}, Theorem 2.2, there is a weak form of \eqref{equation:model/navierStokesEquations:eqn::Stokes}:

Find \(\mathbf{v}=(v_1,v_2)\in \mathbf{V}(\Omega)\):
\begin{equation*}
\begin{split}\mathbf{V}(\Omega)=\{\mathbf{w}\in H^1_0(\Omega)^2|\; \textrm{div}\mathbf{w}=0\}\end{split}
\end{equation*}
which satisfy:
\begin{equation*}
\begin{split}\sum_{i=1}^2\int_{\Omega}\nabla u_i\cdot \nabla v_i=\int_{\Omega}\mathbf{f}\cdot \mathbf{w}
\quad \textrm{for all }v\in V\end{split}
\end{equation*}
Here it is used the existence \(p\in H^1(\Omega)\) such that \(\mathbf{u}=\nabla p\), if:
\begin{equation*}
\begin{split}\int_{\Omega}\mathbf{u}\cdot \mathbf{v}=0\quad \textrm{for all }\mathbf{v}\in V\end{split}
\end{equation*}
Another weak form is derived as follows: We put:
\begin{equation*}
\begin{split}\mathbf{V}=H^1_0(\Omega)^2;\quad
W=\left\{q\in L^2(\Omega)\left|\; \int_{\Omega}q=0\right.\right\}\end{split}
\end{equation*}
By multiplying the first equation in \eqref{equation:model/navierStokesEquations:eqn::Stokes} with \(v\in V\) and the second with \(q\in W\), subsequent integration over \(\Omega\), and an application of Green’s formula, we have:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \int_{\Omega}\nabla\mathbf{u}\cdot \nabla\mathbf{v}-\int_{\Omega}\textrm{div}\mathbf{v}\, p
    &=&\int_{\Omega}\mathbf{f}\cdot\mathbf{v}\\
    \int_{\Omega}\textrm{div}\mathbf{u}\, q&=&0
\end{array}\end{split}
\end{equation*}
This yields the weak form of \eqref{equation:model/navierStokesEquations:eqn::Stokes}:

Find \((\mathbf{u},p)\in \mathbf{V}\times W\) such that:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    a(\mathbf{u},\mathbf{v})+b(\mathbf{v},p)&=&(\mathbf{f},\mathbf{v})\\
    b(\mathbf{u},q)&=&0
\end{array}\end{split}
\end{equation*}
for all \((\mathbf{v},q)\in V\times W\), where:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    a(\mathbf{u},\mathbf{v})&=&\int_{\Omega}\nabla \mathbf{u}\cdot \nabla\mathbf{v}
    =\sum_{i=1}^2\int_{\Omega}\nabla u_i\cdot \nabla v_i\\
    b(\mathbf{u},q)&=&-\int_{\Omega}\textrm{div}\mathbf{u}\, q
\end{array}\end{split}
\end{equation*}
Now, we consider finite element spaces \(\mathbf{V}_h\subset \mathbf{V}\) and \(W_h\subset W\), and we assume the following basis functions:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    &&\mathbf{V}_h=V_h\times V_h,\quad
    V_h=\{v_h|\; v_h=v_1\phi_1+\cdots +v_{M_V}\phi_{M_V}\},\\
    &&W_h=\{q_h|\; q_h=q_1\varphi_1+\cdots +q_{M_W}\varphi_{M_W}\}
\end{array}\end{split}
\end{equation*}
The discrete weak form is: Find \((\mathbf{u}_{h},p_{h}) \in \mathbf{V}_{h} \times W_{h}\) such that:
\begin{equation}\label{equation:model/navierStokesEquations:eqn::vfStokes}
\begin{split}\begin{array}{cll}
    a(\mathbf{u}_h,\mathbf{v}_h)+b(\mathbf{v}_h,p) &= (\mathbf{f},\mathbf{v}_h) ,
    &\forall \mathbf{v}_{h} \in \mathbf{V}_{h} \\
    b(\mathbf{u}_h,q_h)&= 0,
    &\forall q_{h} \in W_{h}
\end{array}\end{split}
\end{equation}
\begin{sphinxadmonition}{note}{Note:}
Assume that:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
There is a constant \(\alpha_h>0\) such that:
\begin{quote}
\begin{equation*}
\begin{split}a(\mathbf{v}_h,\mathbf{v}_h)\ge \alpha\| \mathbf{v}_h\|_{1,\Omega}^2\quad \textrm{for all }\mathbf{v}_h\in Z_h\end{split}
\end{equation*}
where:
\begin{equation*}
\begin{split}Z_h=\{\mathbf{v}_h\in \mathbf{V}_h|\; b(\mathbf{w}_h,q_h)=0\quad \textrm{for all }q_h\in W_h\}\end{split}
\end{equation*}\end{quote}

\item {} 
There is a constant \(\beta_h>0\) such that:
\begin{quote}
\begin{equation*}
\begin{split}\sup_{\mathbf{v}_h\in \mathbf{V}_h}\frac{b(\mathbf{v}_h,q_h)}{\| \mathbf{v}_h\|_{1,\Omega}}
\ge \beta_h\| q_h\|_{0,\Omega}\quad \textrm{for all }q_h\in W_h\end{split}
\end{equation*}
Then we have an unique solution \((\mathbf{u}_h,p_h)\) of \eqref{equation:model/navierStokesEquations:eqn::vfStokes} satisfying:
\begin{equation*}
\begin{split}\| \mathbf{u}-\mathbf{u}_h\|_{1,\Omega}+\| p-p_h\|_{0,\Omega}
\le C\left(
\inf_{\mathbf{v}_h\in \mathbf{V}_h}\| u-v_h\|_{1,\Omega}
+\inf_{q_h\in W_h}\| p-q_h\|_{0,\Omega}\right)\end{split}
\end{equation*}
with a constant \(C>0\) (see e.g. \sphinxcite{reference:roberts1993}, Theorem 10.4).
\end{quote}

\end{enumerate}
\end{sphinxadmonition}

Let us denote that:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    A&=&(A_{ij}),\, A_{ij}=\int_{\Omega}\nabla \phi_j\cdot \nabla \phi_i\qquad
    i,j=1,\cdots,M_{\mathbf{V}}\\
    \mathbf{B}&=&(Bx_{ij},By_{ij}),\,
    Bx_{ij}=-\int_{\Omega}\p \phi_j/\p x\, \varphi_i\qquad
    By_{ij}=-\int_{\Omega}\p \phi_j/\p y\, \varphi_i\nonumber\\
    &&\qquad i=1,\cdots,M_W;j=1,\cdots,M_V\nonumber
\end{array}\end{split}
\end{equation*}
then \eqref{equation:model/navierStokesEquations:eqn::vfStokes} is written by:
\begin{equation*}
\begin{split}\left(
\begin{array}{cc}
    \mathbf{A}&\mathbf{\mathbf{B}}^*\\
    \mathbf{B}&0
\end{array}
\right)
\left(
\begin{array}{cc}
    \mathbf{U}_h\\
    \{p_h\}
\end{array}
\right)
=
\left(
\begin{array}{cc}
    \mathbf{F}_h\\
    0
\end{array}
\right)\end{split}
\end{equation*}
where:
\begin{equation*}
\begin{split}&\mathbf{A}=\left(
\begin{array}{cc}
A&0\\
0&A
\end{array}
\right)
\qquad
\mathbf{B}^*=\left\{
\begin{array}{c}
Bx^T\\
By^T
\end{array}
\right\}
\qquad
\mathbf{U}_h=\left\{
\begin{array}{c}
\{u_{1,h}\}\\
\{u_{2,h}\}
\end{array}
\right\}
\qquad
\mathbf{F}_h=\left\{
\begin{array}{c}
\{\textstyle{\int_{\Omega}f_1\phi_i}\}\\
\{\textstyle{\int_{\Omega}f_2\phi_i}\}
\end{array}
\right\}\end{split}
\end{equation*}
\sphinxstylestrong{Penalty method:} This method consists of replacing \eqref{equation:model/navierStokesEquations:eqn::vfStokes} by a more regular problem:

Find \((\mathbf{v}_h^{\epsilon},p_h^{\epsilon})\in \mathbf{V}_h\times \tilde{W}_{h}\) satisfying:
\begin{equation}\label{equation:model/navierStokesEquations:eqn::PvfStokes}
\begin{split}\begin{array}{cll}
    a(\mathbf{u}_h^\epsilon,\mathbf{v}_h)+b(\mathbf{v}_h,p_h^{\epsilon}) &= (\mathbf{f},\mathbf{v}_h) ,
    &\forall \mathbf{v}_{h} \in \mathbf{V}_{h} \\
    b(\mathbf{u}_h^{\epsilon},q_h)-\epsilon(p_h^{\epsilon},q_h)&= 0,
    &\forall q_{h} \in \tilde{W}_{h}
\end{array}\end{split}
\end{equation}
where \(\tilde{W}_h\subset L^2(\Omega)\).
Formally, we have:
\begin{equation*}
\begin{split}\textrm{div}\mathbf{u}_h^{\epsilon}=\epsilon p_h^{\epsilon}\end{split}
\end{equation*}
and the corresponding algebraic problem:
\begin{equation*}
\begin{split}\left(
\begin{array}{cc}
\mathbf{A}&B^*\\
B&-\epsilon I
\end{array}
\right)
\left(
\begin{array}{cc}
\mathbf{U}_h^{\epsilon}\\
\{p_h^{\epsilon}\}
\end{array}
\right)
=
\left(
\begin{array}{cc}
\mathbf{F}_h\\
0
\end{array}
\right)\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
We can eliminate \(p_h^\epsilon=(1/\epsilon)BU_h^{\epsilon}\) to obtain:
\begin{equation}\label{equation:model/navierStokesEquations:eqn::StiffPvfStokes}
\begin{split}(A+(1/\epsilon)B^*B)\mathbf{U}_h^{\epsilon}=\mathbf{F}_h^{\epsilon}\end{split}
\end{equation}
Since the matrix \(A+(1/\epsilon)B^*B\) is symmetric, positive-definite, and sparse, \eqref{equation:model/navierStokesEquations:eqn::StiffPvfStokes} can be solved by known technique.
There is a constant \(C>0\) independent of \(\epsilon\) such that:
\begin{equation*}
\begin{split}\|\mathbf{u}_h-\mathbf{u}_h^\epsilon\|_{1,\Omega}+
\|p_h-p_h^{\epsilon}\|_{0,\Omega}\le C\epsilon\end{split}
\end{equation*}
(see e.g. \sphinxcite{reference:roberts1993}, 17.2)
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Cavity

The driven cavity flow problem is solved first at zero Reynolds number (Stokes flow) and then at Reynolds 100.
The velocity pressure formulation is used first and then the calculation is repeated with the stream function vorticity formulation.

We solve the driven cavity problem by the penalty method \eqref{equation:model/navierStokesEquations:eqn::PvfStokes} where \(\mathbf{u}_{\Gamma}\cdot \mathbf{n}=0\) and \(\mathbf{u}_{\Gamma}\cdot \mathbf{s}=1\) on the top boundary and zero elsewhere (\(\mathbf{n}\) is the unit normal to \(\Gamma\), and \(\mathbf{s}\) the unit tangent to \(\Gamma\)).

The mesh is constructed by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We use a classical Taylor-Hood element technique to solve the problem:

The velocity is approximated with the \(P_{2}\) FE (\(X_{h}\) space), and the pressure is approximated with the \(P_{1}\) FE (\(M_{h}\) space), where:
\begin{equation*}
\begin{split}X_{h} = \left\{ \mathbf{v} \in H^{1}(]0,1[^2) \left|\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{2}\right.\right\}\end{split}
\end{equation*}
and:
\begin{equation*}
\begin{split}M_{h} = \left\{ v \in H^{1}(]0,1[^2) \left|\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{1} \right.\right\}\end{split}
\end{equation*}
The FE spaces and functions are constructed by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//definition of the velocity component space}
\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//definition of the pressure space}
\PYG{n}{Xh} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{;}
\end{sphinxVerbatim}

The Stokes operator is implemented as a system-solve for the velocity \((u1,u2)\) and the pressure \(p\).
The test function for the velocity is \((v1,v2)\) and \(q\) for the pressure, so the variational form \eqref{equation:model/navierStokesEquations:eqn::vfStokes} in freefem language is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{solve} \PYG{n+nf}{Stokes} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Crout}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}
            \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{0.000001}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

Each unknown has its own boundary conditions.

If the streamlines are required, they can be computed by finding \(\psi\) such that \(rot\psi=u\) or better:
\begin{equation*}
\begin{split}-\Delta\psi=\nabla\times u\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Xh} \PYG{n}{psi}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{;}

\PYG{k+kt}{solve} \PYG{n+nf}{streamlines} \PYG{p}{(}\PYG{n}{psi}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{phi}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{psi}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

Now the Navier-Stokes equations are solved:
\begin{equation*}
\begin{split}{\p {u}\over\p t} +u\cdot\nabla u-\nu \Delta u+\nabla p=0, \nabla\cdot u=0\end{split}
\end{equation*}
with the same boundary conditions and with initial conditions \(u=0\).

This is implemented by using the convection operator \sphinxcode{\sphinxupquote{convect}} for the term \({\p u\over\p t} +u\cdot\nabla u\), giving a discretization in time
\begin{equation*}
\begin{split}\begin{array}{cl}
    \frac{1}{\tau } (u^{n+1}-u^n\circ X^n) -\nu\Delta u^{n+1} + \nabla p^{n+1} &=0,\\
    \nabla\cdot u^{n+1} &= 0
\end{array}\end{split}
\end{equation*}
The term \(u^n\circ X^n(x)\approx u^n(x-u^n(x)\tau )\) will be computed by the operator \sphinxcode{\sphinxupquote{convect}}, so we obtain:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{NS} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Crout}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{v1} \PYG{o}{+} \PYG{n}{u2}\PYG{o}{*}\PYG{n}{v2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{nu} \PYG{o}{*} \PYG{p}{(}
              \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{0.000001}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{up1}\PYG{p}{,}\PYG{n}{up2}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{up1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v1}
        \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{up1}\PYG{p}{,}\PYG{n}{up2}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{up2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{n}{up1} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{;}
    \PYG{n}{up2} \PYG{o}{=} \PYG{n}{u2}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{NS}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[u1,u2] and p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Notice that the stiffness matrices are reused (keyword \sphinxcode{\sphinxupquote{init=i}})

The complete script is available in {\hyperref[\detokenize{example/misc:examplecavity}]{\sphinxcrossref{\DUrole{std,std-ref}{cavity example}}}}.
\end{sphinxadmonition}


\subsection{Uzawa Algorithm and Conjugate Gradients}
\label{\detokenize{model/navierStokesEquations:uzawa-algorithm-and-conjugate-gradients}}\label{\detokenize{model/navierStokesEquations:navierstokesuzawaconjugategradients}}
We solve Stokes problem without penalty.
The classical iterative method of Uzawa is described by the algorithm (see e.g. \sphinxcite{reference:roberts1993}, 17.3, \sphinxcite{reference:glowinski1979}, 13 or \sphinxcite{reference:glowinski1985}, 13):
\begin{itemize}
\item {} 
\sphinxstylestrong{Initialize:} Let \(p_h^0\) be an arbitrary chosen element of \(L^2(\Omega)\).

\item {} 
\sphinxstylestrong{Calculate :math:{}`mathbf\{u\}\_h{}`:} Once \(p_h^n\) is known, \(\mathbf{v}_h^n\) is the solution of:
\begin{quote}
\begin{equation*}
\begin{split}\mathbf{u}_h^n = A^{-1}(\mathbf{f}_h-\mathbf{B}^*p_h^n)\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxstylestrong{Advance :math:{}`p\_h{}`:} Let \(p_h^{n+1}\) be defined by;
\begin{quote}
\begin{equation*}
\begin{split}p_h^{n+1}=p_h^n+\rho_n\mathbf{B}\mathbf{u}_h^n\end{split}
\end{equation*}\end{quote}

\end{itemize}

There is a constant \(\alpha>0\) such that \(\alpha\le \rho_n\le 2\) for each \(n\), then \(\mathbf{u}_h^n\) converges to the solution \(\mathbf{u}_h\), and then \(B\mathbf{v}_h^n\to 0\) as \(n\to \infty\) from the \sphinxstyleemphasis{Advance} \(p_h\). This method in general converges quite slowly.

First we define mesh, and the Taylor-Hood approximation.
So \(X_{h}\) is the velocity space, and \(M_{h}\) is the pressure space.

\begin{sphinxadmonition}{tip}{Tip:}
Stokes Uzawa

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{bc1}\PYG{p}{,} \PYG{n}{bc2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{b}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{p}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{ppp}\PYG{p}{;} \PYG{c+c1}{//ppp is a working pressure}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{bx} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{by} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{a} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{;}
\PYG{c+c1}{//remark: put the on(3,u1=1) before on(1,2,4,u1=0)}
\PYG{c+c1}{//because we want zero on intersection}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Bx} \PYG{o}{=} \PYG{n}{bx}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//B=(Bx, By)}
\PYG{k+kt}{matrix} \PYG{n}{By} \PYG{o}{=} \PYG{n}{by}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{bc1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//boundary condition contribution on u1}
\PYG{n}{bc2} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//no boundary condition contribution on u2}

\PYG{c+c1}{//p\PYGZus{}h\PYGZca{}n \PYGZhy{}\PYGZgt{} B A\PYGZca{}\PYGZhy{}1 \PYGZhy{} B\PYGZca{}* p\PYGZus{}h\PYGZca{}n = \PYGZhy{}div u\PYGZus{}h}
\PYG{c+c1}{//is realized as the function divup}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{divup} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{pp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//compute u1(pp)}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bx}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{bc1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{c+c1}{//compute u2(pp)}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{By}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{bc2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{c+c1}{//u\PYGZca{}n = (A\PYGZca{}\PYGZhy{}1 Bx\PYGZca{}T p\PYGZca{}n, By\PYGZca{}T p\PYGZca{}n)\PYGZca{}T}
    \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bx}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//ppp = Bx u\PYGZus{}1}
    \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{By}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//+ By u\PYGZus{}2}

    \PYG{k}{return} \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Initialization}
\PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//p\PYGZus{}h\PYGZca{}0 = 0}
\PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{divup}\PYG{p}{,} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//p\PYGZus{}h\PYGZca{}\PYGZob{}n+1\PYGZcb{} = p\PYGZus{}h\PYGZca{}n + B u\PYGZus{}h\PYGZca{}n}
\PYG{c+c1}{// if n\PYGZgt{} 50 or \textbar{}p\PYGZus{}h\PYGZca{}\PYGZob{}n+1\PYGZcb{} \PYGZhy{} p\PYGZus{}h\PYGZca{}n\textbar{} \PYGZlt{}= 10\PYGZca{}\PYGZhy{}6, then the loop end}
\PYG{n}{divup}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//compute the final solution}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{NSUzawaCahouetChabart.edp}
\label{\detokenize{model/navierStokesEquations:nsuzawacahouetchabart-edp}}
In this example we solve the Navier-Stokes equation past a cylinder with the Uzawa algorithm preconditioned by the Cahouet-Chabart method (see \sphinxcite{reference:glowinski2003} for all the details).

The idea of the preconditioner is that in a periodic domain, all differential operators commute and the Uzawa algorithm comes to solving the linear operator \(\nabla. ( (\alpha Id + \nu \Delta)^{-1} \nabla\), where \(Id\) is the identity operator.
So the preconditioner suggested is \(\alpha \Delta^{-1} + \nu Id\).

To implement this, we do:

\begin{sphinxadmonition}{tip}{Tip:}
NS Uzawa Cahouet Chabart

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{D} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{H} \PYG{o}{=} \PYG{l+m+mf}{0.41}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cx0} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cy0} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;} \PYG{c+c1}{//center of cylinder}
\PYG{k+kt}{real} \PYG{n}{xa} \PYG{o}{=} \PYG{l+m+mf}{0.15}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ya} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{xe} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ye} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{15}\PYG{p}{;}

\PYG{c+c1}{//TODO}
\PYG{k+kt}{real} \PYG{n}{Um} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;} \PYG{c+c1}{//max velocity (Rey 100)}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{U1} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{*}\PYG{n}{Um}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{p}{(}\PYG{n}{H}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{H}\PYG{o}{*}\PYG{n}{H}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Boundary condition}
\PYG{k+kt}{func} \PYG{n}{U2} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{n}{D}\PYG{o}{/}\PYG{n}{nn}\PYG{o}{/}\PYG{n}{Um}\PYG{p}{;} \PYG{c+c1}{//CFL = 1}
\PYG{k+kt}{real} \PYG{n}{epspq} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}

\PYG{c+c1}{// Variables}
\PYG{k+kt}{func} \PYG{n}{Ub} \PYG{o}{=} \PYG{n}{Um}\PYG{o}{*}\PYG{l+m+mf}{2.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Rey} \PYG{o}{=} \PYG{n}{Ub}\PYG{o}{*}\PYG{n}{D}\PYG{o}{/}\PYG{n}{nu}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{fr1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{fr2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{H}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{fr3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{2.2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{H}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{fr4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{H}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{fr5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cx0}\PYG{o}{+}\PYG{n}{D}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{cy0}\PYG{o}{+}\PYG{n}{D}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{fr1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fr2}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fr3}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fr4}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fr5}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{nn}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{p}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1dc}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{w}\PYG{p}{;} \PYG{c+c1}{//vorticity}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n}{von1} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{n}{U1}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{n}{U2}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{//remark : the value 100 in next varf is manualy fitted, because free outlet.}
\PYG{k+kt}{varf} \PYG{n+nf}{vA} \PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=}
    \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{grad}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{p}\PYG{o}{*}\PYG{n}{q}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vM} \PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf2pT}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{p}\PYG{o}{*}\PYG{n}{q}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vu} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{v1}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vu1} \PYG{p}{(}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vu2} \PYG{p}{(}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vonu1} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{n}{U1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vonu2} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{n}{U2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{pAM} \PYG{o}{=} \PYG{n}{vM}\PYG{p}{(}\PYG{n}{Mh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{pAA} \PYG{o}{=} \PYG{n}{vA}\PYG{p}{(}\PYG{n}{Mh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{AU} \PYG{o}{=} \PYG{n}{vu}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{B1} \PYG{o}{=} \PYG{n}{vu1}\PYG{p}{(}\PYG{n}{Mh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{B2} \PYG{o}{=} \PYG{n}{vu2}\PYG{p}{(}\PYG{n}{Mh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{brhs1} \PYG{o}{=} \PYG{n}{vonu1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{brhs2} \PYG{o}{=} \PYG{n}{vonu2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vrhs1}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vv}\PYG{o}{*}\PYG{n}{alpha}\PYG{p}{)} \PYG{o}{+} \PYG{n}{vonu1}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vrhs2}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v1}\PYG{o}{*}\PYG{n}{alpha}\PYG{p}{)} \PYG{o}{+} \PYG{n}{vonu2}\PYG{p}{;}

\PYG{c+c1}{// Uzawa function}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{JUzawa} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{pp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{brhs1}\PYG{p}{;} \PYG{n}{b1} \PYG{o}{+}\PYG{o}{=} \PYG{k+kp}{B1}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{brhs2}\PYG{p}{;} \PYG{n}{b2} \PYG{o}{+}\PYG{o}{=} \PYG{n}{B2}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{AU}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{b1}\PYG{p}{;}
    \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{AU}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{b2}\PYG{p}{;}
    \PYG{n}{pp} \PYG{o}{=} \PYG{k+kp}{B1}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{pp} \PYG{o}{+}\PYG{o}{=} \PYG{n}{B2}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{pp} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{pp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Preconditioner function}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Precon} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{p}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pa} \PYG{o}{=} \PYG{n}{pAA}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{p}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pm} \PYG{o}{=} \PYG{n}{pAM}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{p}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pp} \PYG{o}{=} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{pa} \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{n}{pm}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{pp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Initialization}
\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k+kt}{int} \PYG{n}{ndt} \PYG{o}{=} \PYG{n}{T}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ndt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{n}{brhs1} \PYG{o}{=} \PYG{n}{vrhs1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{brhs2} \PYG{o}{=} \PYG{n}{vrhs2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{JUzawa}\PYG{p}{,} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{Precon}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{k+kp}{eps}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{res}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{eps} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kp}{eps}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Vorticity}
    \PYG{n}{w} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{dt} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{T}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dt} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{o}{*}\PYG{n}{T}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u1 max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}
    \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, u2 max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}
    \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, p max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
Stop test of the conjugate gradient

Because we start from the previous solution and the end the previous solution is close to the final solution, don’t take a relative stop test to the first residual, take an absolute stop test (negative here).
\end{sphinxadmonition}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{NavierStokesEquations}.png}
\caption{The vorticity at Reynolds number 100 a time 2s with the Cahouet-Chabart method.}\label{\detokenize{model/navierStokesEquations:id8}}\end{figure}
\end{sphinxadmonition}


\section{Variational Inequality}
\label{\detokenize{model/variationalInequality:variational-inequality}}\label{\detokenize{model/variationalInequality::doc}}
We present, a classical example of variational inequality.

Let us denote \(\mathcal{C} = \{ u\in H^1_0(\Omega), u \le g \}\)

The problem is:
\begin{equation*}
\begin{split}u = arg \min_{u\in \mathcal{C}} J(u) = \frac{1}{2} \int_\Omega \nabla u . \nabla u - \int_\Omega f u\end{split}
\end{equation*}
where \(f\) and \(g\) are given function.

The solution is a projection on the convex \(\mathcal{C}\) of \(f^\star\) for the scalar product \(((v,w)) = \int_\Omega \nabla v . \nabla w\) of \(H^1_0(\Omega)\) where \(f^\star\) is solution of:
\begin{equation*}
\begin{split}(f^\star, v ) = \int_{\Omega}{f v}, \forall v \in H^1_0(`\Omega)\end{split}
\end{equation*}
The projection on a convex satisfy clearly \(\forall v \in \mathcal{C}, \quad (( u -v , u - \tilde{f} )) \leq 0\), and after expanding, we get the classical inequality:
\begin{equation*}
\begin{split}\forall v \in \mathcal{C}, \quad \int_\Omega \nabla(u -v) \nabla u \leq \int_\Omega (u-v) f\end{split}
\end{equation*}
We can also rewrite the problem as a saddle point problem:

Find \(\lambda, u\) such that:
\begin{equation*}
\begin{split}\max_{\lambda\in L^2(\Omega), \lambda\geq 0} \min_{u\in H^1_0(\Omega)} \mathcal{L}(u,\lambda) = \frac{1}{2} \int_\Omega \nabla u . \nabla u - \int_\Omega f u + \int_{\Omega} \lambda (u-g)^+\end{split}
\end{equation*}
where \(((u-g)^+ = max(0,u-g)\).

This saddle point problem is equivalent to find \(u, \lambda\) such that:
\begin{equation*}
\begin{split}\left\{
\begin{array}{cc}
    \displaystyle \int_\Omega \nabla u . \nabla v + \lambda v^+ \,d\omega= \int_\Omega f u , &\forall v \in H^1_0(\Omega) \cr
    \displaystyle \int_\Omega \mu (u-g)^+ = 0 , & \forall \mu \in L^2(\Omega) , \mu \geq 0, \lambda \geq 0,
\end{array}\right.\end{split}
\end{equation*}
An algorithm to solve the previous problem is:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
k=0, and choose \(\lambda_0\) belong \(H^{-1}(\Omega)\)

\item {} 
Loop on \(k = 0, .....\)
\begin{itemize}
\item {} 
set \(\mathcal{I}_{k} = \{ x \in \Omega / \lambda_{k} + c * ( u_{k+1} - g) \leq 0 \}\)

\item {} 
\(V_{g,k+1} = \{ v\in H^1_0(\Omega) / v = g\) on \({I}_{k} \}\),

\item {} 
\(V_{0,k+1} = \{ v\in H^1_0(\Omega) / v = 0\) on \({I}_{k} \}\),

\item {} 
Find \(u_{k+1} \in V_{g,k+1}\) and \(\lambda_{k+1} \in H^{-1}(\Omega)\) such that
\begin{equation*}
\begin{split}\left\{\begin{array}{cc}
   \displaystyle \int_\Omega \nabla u_{k+1}. \nabla v_{k+1} \,d\omega = \int_\Omega f v_{k+1} , &\forall v_{k+1} \in V_{0,k+1} \cr
   \displaystyle <\lambda_{k+1},v> = \int_\Omega \nabla u_{k+1}. \nabla v - f v \,d\omega &
\end{array}\right.\end{split}
\end{equation*}
where \(<,>\) is the duality bracket between \(H^{1}_0(\Omega)\) and \(H^{-1}(\Omega)\), and \(c\) is a penalty constant (large enough).

\end{itemize}

\end{enumerate}

You can find all the mathematics about this algorithm in \sphinxcite{reference:ito2003}.

Now how to do that in FreeFem++? The full example is:

\begin{sphinxadmonition}{tip}{Tip:}
Variational inequality

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{;} \PYG{c+c1}{//penalty parameter of the algoritm}
\PYG{k+kt}{real} \PYG{k+kp}{tgv} \PYG{o}{=} \PYG{l+m+mf}{1e30}\PYG{p}{;} \PYG{c+c1}{//a huge value for exact penalization}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//right hand side function}
\PYG{k+kt}{func} \PYG{n}{fd} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//Dirichlet boundary condition function}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{c+c1}{//number of degree of freedom}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{uhp}\PYG{p}{;} \PYG{c+c1}{//u\PYGZca{}n+1 and u\PYGZca{}n}
\PYG{n}{Vh} \PYG{n}{Ik}\PYG{p}{;} \PYG{c+c1}{//to define the set where the containt is reached.}
\PYG{n}{Vh} \PYG{n}{g} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;} \PYG{c+c1}{//discret function g}
\PYG{n}{Vh} \PYG{n}{lambda} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{a} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{vh}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{n}{fd}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{//the mass Matrix construction}
\PYG{k+kt}{varf} \PYG{n+nf}{vM} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{uh}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//two versions of the matrix of the problem}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{k+kp}{tgv}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//one changing}
\PYG{k+kt}{matrix} \PYG{n}{AA} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//one for computing residual}

\PYG{k+kt}{matrix} \PYG{n}{M} \PYG{o}{=} \PYG{n}{vM}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to do a fast computing of L\PYGZca{}2 norm : sqrt(u\PYGZsq{}*(w=M*u))}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Aiin}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Aii} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag}\PYG{p}{;} \PYG{c+c1}{//get the diagonal of the matrix}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhs} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{k+kp}{tgv}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Initialization}
\PYG{n}{Ik} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{uhp} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kp}{tgv}\PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{rhs}\PYG{p}{;} \PYG{c+c1}{//get a copy of the Right hand side}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Ak}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the complementary of Ik ( !Ik = (Ik\PYGZhy{}1))}
    \PYG{n}{Ak} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{n}{Ak} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{Ik}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{c+c1}{//adding new locking condition on b and on the diagonal if (Ik ==1 )}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{Ik}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{*} \PYG{n}{g}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{n}{b} \PYG{o}{*}\PYG{o}{=} \PYG{k+kp}{tgv}\PYG{p}{;} \PYG{n}{b} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{Ak} \PYG{p}{.}\PYG{o}{*} \PYG{n}{rhs}\PYG{p}{;}
    \PYG{n}{Aiin} \PYG{o}{=} \PYG{n}{Ik}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*} \PYG{k+kp}{tgv}\PYG{p}{;} \PYG{n}{Aiin} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Ak} \PYG{p}{.}\PYG{o}{*} \PYG{n}{Aii}\PYG{p}{;} \PYG{c+c1}{//set Aii= tgv i in Ik}
    \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag} \PYG{o}{=} \PYG{n}{Aiin}\PYG{p}{;} \PYG{c+c1}{//set the matrix diagonal}
    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//important to change preconditioning for solving}

    \PYG{c+c1}{// Solve}
    \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*} \PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//solve the problem with more locking condition}

    \PYG{c+c1}{// Residual}
    \PYG{n}{lambda}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{AA} \PYG{o}{*} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//compute the residual (fast with matrix)}
    \PYG{n}{lambda}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{rhs}\PYG{p}{;} \PYG{c+c1}{//remark rhs = \PYGZhy{}\PYGZbs{}int f v}

    \PYG{n}{Ik} \PYG{o}{=} \PYG{p}{(}\PYG{n}{lambda} \PYG{o}{+} \PYG{n}{c}\PYG{o}{*}\PYG{p}{(} \PYG{n}{g}\PYG{o}{\PYGZhy{}} \PYG{n}{uh}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{c+c1}{//the new locking value}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Ik}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ lock set }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{c+c1}{//trick to compute L\PYGZca{}2 norm of the variation (fast method)}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{diff}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Mdiff}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{diff} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{uhp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{Mdiff} \PYG{o}{=} \PYG{n}{M}\PYG{o}{*}\PYG{n}{diff}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{Mdiff}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{diff}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{} u\PYGZus{}\PYGZob{}k=1\PYGZcb{} \PYGZhy{} u\PYGZus{}\PYGZob{}k\PYGZcb{} \textbar{}\textbar{}\PYGZus{}2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Stop test}
    \PYG{k}{if}\PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{uhp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
As you can see on this example, some vector, or matrix operator are not implemented so a way is to skip the expression and we use operator \sphinxcode{\sphinxupquote{+=}},  \sphinxcode{\sphinxupquote{-=}} to merge the result.
\end{sphinxadmonition}
\end{sphinxadmonition}


\section{Domain decomposition}
\label{\detokenize{model/domainDecomposition:domain-decomposition}}\label{\detokenize{model/domainDecomposition::doc}}
We present three classic examples of domain decomposition technique: first, Schwarz algorithm with overlapping, second Schwarz algorithm without overlapping (also call Shur complement), and last we show to use the conjugate gradient to solve the boundary problem of the Shur complement.


\subsection{Schwarz overlapping}
\label{\detokenize{model/domainDecomposition:schwarz-overlapping}}\label{\detokenize{model/domainDecomposition:domaindecompositionschwarzoverlapping}}
To solve:
\begin{equation*}
\begin{split}-\Delta u =f,\;\mbox{in}\;\Omega=\Omega_1\cup\Omega_2\quad u|_\Gamma=0\end{split}
\end{equation*}
the Schwarz algorithm runs like this:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\Delta u^{n+1}_1&=&f\;\mbox{in}\;\Omega_1\quad
    u^{n+1}_1|_{\Gamma_1}=u^n_2\\
    -\Delta u^{n+1}_2&=&f\;\mbox{in}\;\Omega_2\quad
    u^{n+1}_2|_{\Gamma_2}=u^n_1
\end{array}\end{split}
\end{equation*}
where \(\Gamma_i\) is the boundary of \(\Omega_i\) and on the condition that \(\Omega_1\cap\Omega_2\neq\emptyset\) and that \(u_i\) are zero at iteration 1.

Here we take \(\Omega_1\) to be a quadrangle, \(\Omega_2\) a disk and we apply the algorithm starting from zero.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{DomainDecomposition_Schwarz1}.png}
\caption{The 2 overlapping mesh \sphinxcode{\sphinxupquote{TH}} and \sphinxcode{\sphinxupquote{th}}}\label{\detokenize{model/domainDecomposition:id1}}\end{figure}

\begin{sphinxadmonition}{tip}{Tip:}
Schwarz overlapping

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kp}{inside} \PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//inside boundary}
\PYG{k+kt}{int} \PYG{n}{outside} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//outside boundary}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{k+kp}{inside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{k+kp}{inside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{e1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e1}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n}{TH}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to see the 2 meshes}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{VH}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{VH} \PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{PB} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{)}\PYG{p}{(}
         \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
       \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{)}\PYG{p}{(}
       \PYG{o}{\PYGZhy{}} \PYG{n}{V}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{k+kp}{inside}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{u}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{pb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
         \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
       \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
       \PYG{o}{\PYGZhy{}} \PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{k+kp}{inside}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Calculation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Solve}
   \PYG{n}{PB}\PYG{p}{;}
   \PYG{n}{pb}\PYG{p}{;}

   \PYG{c+c1}{// Plot}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{DomainDecomposition_Schwarz2}.png}
\caption{Isovalues of the solution at iteration 0}\label{\detokenize{model/domainDecomposition:id2}}\label{\detokenize{model/domainDecomposition:figdomaindecomposition-schwarz2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{DomainDecomposition_Schwarz3}.png}
\caption{Isovalues of the solution at iteration 0}\label{\detokenize{model/domainDecomposition:id3}}\label{\detokenize{model/domainDecomposition:figdomaindecomposition-schwarz3}}\end{subfigure}
\caption{Schwarz overlapping}

\end{figure}

\end{sphinxadmonition}


\subsection{Schwarz non overlapping Scheme}
\label{\detokenize{model/domainDecomposition:schwarz-non-overlapping-scheme}}\label{\detokenize{model/domainDecomposition:DomainDecomposition_Schwarz}}
To solve:
\begin{equation*}
\begin{split}-\Delta u =f\;\mbox{in}\;\Omega=\Omega_1\cup\Omega_2\quad u|_\Gamma=0\end{split}
\end{equation*}
the Schwarz algorithm for domain decomposition without overlapping runs like this

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{DomainDecomposition_Schwarz4}.png}
\caption{The two none overlapping mesh \sphinxcode{\sphinxupquote{TH}} and \sphinxcode{\sphinxupquote{th}}}\label{\detokenize{model/domainDecomposition:id4}}\end{figure}

Let introduce \(\Gamma_i\) is common the boundary of \(\Omega_1\) and \(\Omega_2\) and \(\Gamma_e^i= \partial \Omega_i \setminus \Gamma_i\).

The problem find \(\lambda\) such that \((u_1|_{\Gamma_i}=u_2|_{\Gamma_i})\) where \(u_i\) is solution of the following Laplace problem:
\begin{equation*}
\begin{split}-\Delta u_i=f\;\mbox{in}\;\Omega_i\quad
u_i|_{\Gamma_i}=\lambda \quad
u_i|_{\Gamma_e^i} = 0\end{split}
\end{equation*}
To solve this problem we just make a loop with upgrading \(\lambda\) with
\begin{equation*}
\begin{split}\lambda = \lambda {\pm} \frac{(u_1-u_2)}{2}\end{split}
\end{equation*}
where the sign \(+\) or \(-\) of \({\pm}\) is choose to have convergence.

\begin{sphinxadmonition}{tip}{Tip:}
Schwarz non-overlapping

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kp}{inside} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{outside} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{k+kp}{inside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{k+kp}{inside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e1}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n}{TH}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{vh} \PYG{n}{lambda}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{VH}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{VH} \PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{PB} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{V}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{V}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{pb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve}
    \PYG{n}{PB}\PYG{p}{;}
    \PYG{n}{pb}\PYG{p}{;}
    \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{lambda} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{U}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{DomainDecomposition_Schwarz5}.png}
\caption{Isovalues of the solution at iteration 0 without overlapping}\label{\detokenize{model/domainDecomposition:id5}}\label{\detokenize{model/domainDecomposition:figdomaindecomposition-schwarz5}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{DomainDecomposition_Schwarz6}.png}
\caption{Isovalues of the solution at iteration 9 without overlapping}\label{\detokenize{model/domainDecomposition:id6}}\label{\detokenize{model/domainDecomposition:figdomaindecomposition-schwarz6}}\end{subfigure}


\end{figure}

\end{sphinxadmonition}


\subsection{Schwarz conjuguate gradient}
\label{\detokenize{model/domainDecomposition:schwarz-conjuguate-gradient}}\label{\detokenize{model/domainDecomposition:DomainDecomposition_Schwarz}}
To solve \(-\Delta u =f \;\mbox{in}\;\Omega=\Omega_1\cup\Omega_2\quad u|_\Gamma=0\) the Schwarz algorithm for domain decomposition without overlapping runs like this

Let introduce \(\Gamma_i\) is common the boundary of \(\Omega_1\) and \(\Omega_2\) and \(\Gamma_e^i= \partial \Omega_i \setminus \Gamma_i\).

The problem find \(\lambda\) such that \((u_1|_{\Gamma_i}=u_2|_{\Gamma_i})\) where \(u_i\) is solution of the following Laplace problem:
\begin{equation*}
\begin{split}-\Delta u_i=f\;\mbox{in}\;\Omega_i\quad
u_i|_{\Gamma_i}=\lambda \quad
u_i|_{\Gamma_e^i} = 0\end{split}
\end{equation*}
The version of this example uses the Shur complement.
The problem on the border is solved by a conjugate gradient method.

\begin{sphinxadmonition}{tip}{Tip:}
Schwarz conjugate gradient

First, we construct the two domains:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kp}{inside} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{outside} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{GammaInside}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{k+kp}{inside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{GammaArc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{GammaInside}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma3}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{GammaInside}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{GammaArc}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n}{Th2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now, define the finite element spaces:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh1}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{lambda}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
It is impossible to define a function just on a part of boundary, so the \(\lambda\) function must be defined on the all domain \(\Omega_1\) such as:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh1} \PYG{n}{lambda}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

The two Poisson’s problems:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n+nf}{Pb1} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{v1}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{v1}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{Pb2} \PYG{p}{(}\PYG{n}{u2}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{v2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{v2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

And, we define a border matrix, because the \(\lambda\) function is none zero inside the domain \(\Omega_1\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{b}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u2}\PYG{o}{*}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{n}{Vh1}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The boundary problem function,
\begin{equation*}
\begin{split}\lambda \longrightarrow \int_{\Gamma_i }(u_1-u_2) v_{1}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Boundary problem function}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{BoundaryProblem} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{lambda}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{l}\PYG{p}{;} \PYG{c+c1}{//make FE function form l}
   \PYG{n}{Pb1}\PYG{p}{;}
   \PYG{n}{Pb2}\PYG{p}{;}
   \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;} \PYG{c+c1}{//no refactorization i != 0}
   \PYG{n}{v1} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{\PYGZhy{}}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{lambda}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{B}\PYG{o}{*}\PYG{n}{v1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{lambda}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The difference between the two notations \sphinxcode{\sphinxupquote{v1}} and \sphinxcode{\sphinxupquote{v1{[}{]}}} is: \sphinxcode{\sphinxupquote{v1}} is the finite element function and \sphinxcode{\sphinxupquote{v1{[}{]}}} is the vector in the canonical basis of the finite element function \sphinxcode{\sphinxupquote{v1}}.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve}
\PYG{k+kt}{real} \PYG{n}{cpu}\PYG{o}{=}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{BoundaryProblem}\PYG{p}{,} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//compute the final solution, because CG works with increment}
\PYG{n}{BoundaryProblem}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//solve again to have right u1, u2}

\PYG{c+c1}{// Display \PYGZam{} Plot}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{} CPU time schwarz\PYGZhy{}gc:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Fluid-structure coupled problem}
\label{\detokenize{model/fluidStructureCoupledProblem:fluid-structure-coupled-problem}}\label{\detokenize{model/fluidStructureCoupledProblem::doc}}
This problem involves the Lamé system of elasticity and the Stokes system for viscous fluids with velocity \(\mathbf{u}\) and pressure \(p\):
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\Delta\mathbf{u} + \mathbf{\nabla} p &=& 0 & \hbox{ in }\Omega\\
    \nabla\cdot\mathbf{u} &=& 0 & \hbox{ in }\Omega\\
    \mathbf{u} &=& \mathbf{u}_\Gamma & \hbox{ on }\Gamma=\partial\Omega
\end{array}\end{split}
\end{equation*}
where \(u_\Gamma\) is the velocity of the boundaries.
The force that the fluid applies to the boundaries is the normal stress
\begin{equation*}
\begin{split}\mathbf{h} =(\nabla\mathbf{u} +\nabla\mathbf{u}^T)\mathbf{n} -p\mathbf{n}\end{split}
\end{equation*}
Elastic solids subject to forces deform: a point in the solid at (x,y) goes to (X,Y) after.
When the displacement vector \(\mathbf{v}=(v_1,v_2) = (X-x, Y-y)\) is small, Hooke’s law relates the stress tensor \(\sigma\) inside the solid to the deformation tensor \(\epsilon\):
\begin{equation*}
\begin{split}\sigma_{ij} = \lambda \delta_{ij} \nabla.\mathbf{v} + 2\mu\epsilon_{ij},
\,
\epsilon_{ij} = {1\over 2}({\partial v_i\over\partial x_j} + {\partial v_j\over\partial x_i} )\end{split}
\end{equation*}
where \(\delta\) is the Kronecker symbol and where \(\lambda\), \(\mu\) are two constants describing the material mechanical properties in terms of the modulus of elasticity, and Young’s modulus.

The equations of elasticity are naturally written in variational form for the displacement vector \(v(x)\in V\) as:
\begin{equation*}
\begin{split}\int_\Omega \left[2\mu\epsilon_{ij}(\mathbf{v})\epsilon_{ij}(\mathbf{w})
+\lambda \epsilon_{ii}(v)\epsilon_{jj}(\mathbf{w})\right]
=\int_\Omega \mathbf{g}\cdot \mathbf{w} +\int_\Gamma \mathbf{h}\cdot \mathbf{w},%\`{u}
\forall \mathbf{w}\in V\end{split}
\end{equation*}
The data are the gravity force \(\mathbf{g}\) and the boundary stress \(\mathbf{h}\).

\begin{sphinxadmonition}{tip}{Tip:}
Fluide-structure
In our example, the Lamé system and the Stokes system are coupled by a common boundary on which the fluid stress creates a displacement of the boundary and hence changes the shape of the domain where the Stokes problem is integrated.
The geometry is that of a vertical driven cavity with an elastic lid.
The lid is a beam with weight so it will be deformed by its own weight and by the normal stress due to the fluid reaction.
The cavity is the \(10 \times 10\) square and the lid is a rectangle of height \(l=2\).

A beam sits on a box full of fluid rotating because the left vertical side has velocity one.
The beam is bent by its own weight, but the pressure of the fluid modifies the bending.

The bending displacement of the beam is given by \((uu, vv)\) whose solution is given as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{bottombeam} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//label of bottombeam}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.29}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{gravity} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.05}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}

\PYG{c+c1}{// Mesh (solid)}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{bottombeam}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace (solid)}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{s}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{real} \PYG{n}{sqrt2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n+nf}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem (solid)}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{solve} \PYG{n+nf}{Elasticity}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{gravity}\PYG{o}{*}\PYG{n}{s}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{uu}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Then Stokes equation for fluids at low speed are solved in the box below the beam, but the beam has deformed the box (see border h):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh (fluid)}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{+}\PYG{k+kp}{t} \PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{g}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{h}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{vv}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(} \PYG{k+kp}{t}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mf}{0.001} \PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{9.999}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{sh} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{h}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{g}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We use the Uzawa conjugate gradient to solve the Stokes problem like in {\hyperref[\detokenize{model/navierStokesEquations:navierstokesuzawaconjugategradients}]{\sphinxcrossref{\DUrole{std,std-ref}{Navier-Stokes equations}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Fespace (fluid)}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{bc1}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{brhs}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{bcx}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{bcy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{p}\PYG{p}{,} \PYG{n}{ppp}\PYG{p}{;}

\PYG{c+c1}{// Problem (fluid)}
\PYG{k+kt}{varf} \PYG{n+nf}{bx} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{)}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{by} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{)}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{Lap} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n}{bc1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Lap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{Lap}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Bx} \PYG{o}{=} \PYG{n}{bx}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{By} \PYG{o}{=} \PYG{n}{by}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{)}\PYG{p}{;}


\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{divup} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{pp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{verb} \PYG{o}{=} \PYG{k+kr}{verbosity}\PYG{p}{;}
    \PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bx}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{bc1}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{*}\PYG{n}{bcx}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{By}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{bc1}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{*}\PYG{n}{bcy}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bx}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{By}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{n}{verb}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

do a loop on the two problems

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Coupling loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{step} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{step} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{step}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve (fluid)}
    \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{divup}\PYG{p}{,} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}3}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{divup}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now the beam will feel the stress constraint from the fluid:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Forces}
\PYG{n}{Vh} \PYG{n}{sigma11}\PYG{p}{,} \PYG{n}{sigma22}\PYG{p}{,} \PYG{n}{sigma12}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uu1}\PYG{o}{=}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv1}\PYG{o}{=}\PYG{n}{vv}\PYG{p}{;}

\PYG{n}{sigma11}\PYG{p}{(}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sigma22}\PYG{p}{(}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sigma12}\PYG{p}{(}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

which comes as a boundary condition to the PDE of the beam:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve (solid)}
\PYG{k+kt}{solve} \PYG{n+nf}{Elasticity2} \PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{step}\PYG{p}{)}
\PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)}
    \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{)}
\PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
    \PYG{o}{\PYGZhy{}} \PYG{n}{gravity}\PYG{o}{*}\PYG{n}{s}
\PYG{p}{)}
\PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n}{bottombeam}\PYG{p}{)}\PYG{p}{(}
    \PYG{o}{\PYGZhy{}} \PYG{k+kp}{coef}\PYG{o}{*}\PYG{p}{(}\PYG{n}{sigma11}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{w} \PYG{o}{+} \PYG{n}{sigma22}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{s} \PYG{o}{+} \PYG{n}{sigma12}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{w}\PYG{o}{+}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{)}
\PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{uu}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n}{uu}\PYG{o}{\PYGZhy{}}\PYG{n}{uu1}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n}{vv}\PYG{o}{\PYGZhy{}}\PYG{n}{vv1}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Erreur L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

Notice that the matrix generated by \sphinxcode{\sphinxupquote{Elasticity2}} is reused (see {\hyperref[\detokenize{reference/types:typeproblemdesign}]{\sphinxcrossref{\DUrole{std,std-ref}{init=i}}}}).
Finally we deform the beam:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Movemesh}
\PYG{n}{th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Fluid velocity and pressure, displacement vector of the structure and displaced geometry in the fluid-structure interaction of a soft side and a driven cavity are shown \hyperref[\detokenize{model/fluidStructureCoupledProblem:figfsi1}]{Fig.\@ \ref{\detokenize{model/fluidStructureCoupledProblem:figfsi1}}}, \hyperref[\detokenize{model/fluidStructureCoupledProblem:figfsi2}]{Fig.\@ \ref{\detokenize{model/fluidStructureCoupledProblem:figfsi2}}} and \hyperref[\detokenize{model/fluidStructureCoupledProblem:figfsi3}]{Fig.\@ \ref{\detokenize{model/fluidStructureCoupledProblem:figfsi3}}}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{FluidStructure1}.png}
\caption{Velocity and pressure}\label{\detokenize{model/fluidStructureCoupledProblem:figfsi1}}\end{figure}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FluidStructure2}.png}
\caption{Displacement}\label{\detokenize{model/fluidStructureCoupledProblem:id1}}\label{\detokenize{model/fluidStructureCoupledProblem:figfsi2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FluidStructure3}.png}
\caption{Moved mesh}\label{\detokenize{model/fluidStructureCoupledProblem:id2}}\label{\detokenize{model/fluidStructureCoupledProblem:figfsi3}}\end{subfigure}
\phantomsection\label{\detokenize{model/fluidStructureCoupledProblem:FluidStructure}}

\end{figure}

\end{sphinxadmonition}


\section{Transmission problem}
\label{\detokenize{model/transmissionProblem:transmission-problem}}\label{\detokenize{model/transmissionProblem::doc}}
Consider an elastic plate whose displacement change vertically, which is made up of three plates of different materials, welded on each other.

Let \(\Omega_i\), \(i=1,2,3\) be the domain occupied by \(i\)-th material with tension \(\mu_i\) (see {\hyperref[\detokenize{model/staticProblems:modelstatissoap}]{\sphinxcrossref{\DUrole{std,std-ref}{Soap film}}}}).

The computational domain \(\Omega\) is the interior of \(\overline{\Omega_1}\cup \overline{\Omega_2}\cup \overline{\Omega_3}\).
The vertical displacement \(u(x,y)\) is obtained from:
\begin{equation}\label{equation:model/transmissionProblem:eqn::transm}
\begin{split}\begin{array}{rcll}
    -\mu_i\Delta u &=& f & \textrm{ in }\Omega_i\\
    \mu_i\p_n u|_{\Gamma_{i}} &=& -\mu_j\p_n u|_{\Gamma_{j}} & \textrm{ on }\overline{\Omega_{i}}\cap\overline{\Omega_{j}} \textrm{ if }1\le i< j\le 3
\end{array}\end{split}
\end{equation}
where \(\p_n u|_{\Gamma_{i}}\) denotes the value of the normal derivative \(\p_n u\) on the boundary \(\Gamma_i\) of the domain \(\Omega_i\).

By introducing the characteristic function \(\chi_i\) of \(\Omega_i\), that is:
\begin{equation*}
\begin{split}\chi_i(x)=1\ \textrm{ if }x\in\Omega_i;\
\chi_i(x)=0\ \textrm{ if }x\not\in\Omega_i\end{split}
\end{equation*}
we can easily rewrite \eqref{equation:model/transmissionProblem:eqn::transm} to the weak form.
Here we assume that \(u=0\) on \(\Gamma=\p\Omega\).

Transmission problem: For a given function \(f\), find \(u\) such that:
\begin{equation*}
\begin{split}a(u,v) = \ell(f,v) \textrm{ for all }v\in H^1_0(\Omega)\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{rcl}
    a(u,v) &=& \int_{\Omega}\mu \nabla u\cdot \nabla v\nonumber\\
    \ell(f,v) &=& \int_{\Omega}fv\nonumber
\end{array}\end{split}
\end{equation*}
where \(\mu=\mu_1\chi_1+\mu_2\chi_2+\mu_3\chi_3\).
Here we notice that \(\mu\) become the discontinuous function.

This example explains the definition and manipulation of \sphinxstyleemphasis{region}, i.e. sub-domains of the whole domain.
Consider this L-shaped domain with 3 diagonals as internal boundaries, defining 4 sub-domains:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{i1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{i2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{i3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+}\PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i1}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i2}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i3}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//constant discontinuous functions / element}
\PYG{n}{Ph} \PYG{n}{reg}\PYG{o}{=}\PYG{k+kr}{region}\PYG{p}{;} \PYG{c+c1}{//defined the P0 function associated to region number}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{reg}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{TransmissionProblem_Region}.png}
\caption{The function \sphinxcode{\sphinxupquote{reg}}}\label{\detokenize{model/transmissionProblem:id1}}\end{figure}

\sphinxcode{\sphinxupquote{region}} is a keyword of \sphinxstylestrong{FreeFem++} which is in fact a variable depending of the current position (is not a function today, use \sphinxcode{\sphinxupquote{Ph reg=region;}} to set a function).
This variable value returned is the number of the sub-domain of the current position.
This number is defined by \sphinxcode{\sphinxupquote{buildmesh}} which scans while building the mesh all its connected component.

So to get the number of a region containing a particular point one does:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Characteristic function}
\PYG{k+kt}{int} \PYG{n}{nupper} \PYG{o}{=} \PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{l+m+mf}{0.9}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//get the region number of point (0.4,0.9)}
\PYG{k+kt}{int} \PYG{n}{nlower} \PYG{o}{=} \PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//get the region number of point (0.4,0.1)}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nlower = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{n}{nlower} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, nupper = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nupper}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{nlower}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{nupper}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{TransmissionProblem_Nu}.png}
\caption{The function \sphinxcode{\sphinxupquote{nu}}}\label{\detokenize{model/transmissionProblem:id2}}\end{figure}

This is particularly useful to define discontinuous functions such as might occur when one part of the domain is copper and the other one is iron, for example.

We this in mind we proceed to solve a Laplace equation with discontinuous coefficients (\(\nu\) is 1, 6 and 11 below).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{lap} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n+nf}{d}\PYG{p}{,} \PYG{n}{e}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{TransmissionProblem_U}.png}
\caption{The isovalue of the solution \(u\)}\label{\detokenize{model/transmissionProblem:id3}}\end{figure}


\section{Free boundary problems}
\label{\detokenize{model/freeBoundaryProblem:free-boundary-problems}}\label{\detokenize{model/freeBoundaryProblem::doc}}
The domain \(\Omega\) is defined with:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{c+c1}{//length}
\PYG{k+kt}{real} \PYG{n}{hr} \PYG{o}{=} \PYG{l+m+mf}{2.1}\PYG{p}{;} \PYG{c+c1}{//left height}
\PYG{k+kt}{real} \PYG{n}{hl} \PYG{o}{=} \PYG{l+m+mf}{0.35}\PYG{p}{;} \PYG{c+c1}{//right height}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//bottom: Gamma\PYGZus{}a}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{hr}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//right: Gamma\PYGZus{}b}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{n}{hr}\PYG{o}{\PYGZhy{}}\PYG{n}{hl}\PYG{p}{)}\PYG{o}{/}\PYG{n}{L}\PYG{o}{+}\PYG{n}{hl}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//free surface: Gamma\PYGZus{}f}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{hl}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// left: Gamma\PYGZus{}d}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{FreeBoundary_Mesh1}.png}
\caption{The mesh of the domain \(\Omega\)}\label{\detokenize{model/freeBoundaryProblem:id1}}\end{figure}

The free boundary problem is:

Find \(u\) and \(\Omega\) such that:
\begin{equation*}
\begin{split}\left\{
\begin{array}{rcll}
   -\Delta u &=& 0 & \mbox{ in }\Omega\\
   u &=& y & \mbox{ on }\Gamma_b\\
   \partial u \over \partial n &=& 0 & \mbox{ on }\Gamma_d\cup\Gamma_a\\
   \partial u \over \partial n &=& {q \over K} n_x & \mbox{ on }\Gamma_f\\
   u &=& y & \mbox{ on }\Gamma_f
\end{array}
\right.\end{split}
\end{equation*}
We use a fixed point method;

\(\Omega^0 = \Omega\)

In two step, fist we solve the classical following problem:
\begin{equation*}
\begin{split}\left\{
\begin{array}{rcll}
    -\Delta u &=& 0 & \mbox{ in }\Omega^n\\
    u &=& y & \mbox{ on }\Gamma^n_b\\
    \partial u \over \partial n &=& 0 & \mbox{ on }\Gamma^n_d\cup\Gamma^n_a\\
    u &=& y & \mbox{ on }\Gamma^n_f
\end{array}
\right.\end{split}
\end{equation*}
The variational formulation is:

Find \(u\) on \(V=H^1(\Omega^n)\), such than \(u=y\) on \(\Gamma^n_b\) and \(\Gamma^n_f\)
\begin{equation*}
\begin{split}\int_{\Omega^n}\nabla u \nabla u' = 0,\ \forall u' \in V \mbox{ with } u' =0 \mbox{ on }\Gamma^n_b \cup \Gamma^n_f\end{split}
\end{equation*}
And secondly to construct a domain deformation \(\mathcal{F}(x,y)=[x,y-v(x,y)]\) where \(v\) is solution of the following problem:
\begin{equation*}
\begin{split}\left\{
\begin{array}{rcll}
    -\Delta v &=& 0 & \mbox{ in }\Omega^n\\
    v &=& 0 & \mbox{ on }\Gamma^n_a\\
    \partial v \over \partial n &=& 0 & \mbox{ on }\Gamma^n_b\cup\Gamma^n_d\\
    \partial v \over \partial n &=& {\partial u \over \partial n} - {q\over K} n_x & \mbox{ on }\Gamma^n_f
\end{array}
\right.\end{split}
\end{equation*}
The variational formulation is:

Find \(v\) on \(V\), such than \(v=0\) on \(\Gamma^n_a\):
\begin{equation*}
\begin{split}\int_{\Omega^n} \nabla v \nabla v' = \int_{\Gamma_f^n}({\partial u \over \partial n} - { q\over K} n_x )v',\ \quad \forall v' \in V \mbox{ with } v' =0 \mbox{ on }\Gamma^n_a\end{split}
\end{equation*}
Finally the new domain \(\Omega^{n+1} = \mathcal{F}(\Omega^n)\)

\begin{sphinxadmonition}{tip}{Tip:}
Free boundary

The \sphinxstylestrong{FreeFem++} implementation is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{c+c1}{//length}
\PYG{k+kt}{real} \PYG{n}{hr} \PYG{o}{=} \PYG{l+m+mf}{2.1}\PYG{p}{;} \PYG{c+c1}{//left height}
\PYG{k+kt}{real} \PYG{n}{hl} \PYG{o}{=} \PYG{l+m+mf}{0.35}\PYG{p}{;} \PYG{c+c1}{//right height}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{q} \PYG{o}{=} \PYG{l+m+mf}{0.02}\PYG{p}{;} \PYG{c+c1}{//incoming flow}
\PYG{k+kt}{real} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{c+c1}{//permeability}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//bottom: Gamma\PYGZus{}a}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{hr}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//right: Gamma\PYGZus{}b}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{n}{hr}\PYG{o}{\PYGZhy{}}\PYG{n}{hl}\PYG{p}{)}\PYG{o}{/}\PYG{n}{L}\PYG{o}{+}\PYG{n}{hl}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//free surface: Gamma\PYGZus{}f}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{hl}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// left: Gamma\PYGZus{}d}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Pu} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{Pv} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{vv}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{n}{q}\PYG{o}{/}\PYG{n}{K}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{errv} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{erradap} \PYG{o}{=} \PYG{l+m+mf}{0.001}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{errv} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{Pu}\PYG{p}{;}
    \PYG{n}{Pv}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{n}{errv} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Movemesh}
    \PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{mintcc} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{mint} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{v}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{mint} \PYG{o}{\PYGZlt{}} \PYG{n}{mintcc} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{j}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//mesh too bad =\PYGZgt{} remeshing}
        \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{erradap}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{mintcc} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{while} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real} \PYG{n}{mint} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{v}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{mint} \PYG{o}{\PYGZgt{}} \PYG{n}{mintcc}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min \textbar{}T\textbar{} = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{mint} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kp}{coef} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Display}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} errv = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{errv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FreeBoundary_Sol}.png}
\caption{The final solution on the new domain \(\Omega^{72}\)}\label{\detokenize{model/freeBoundaryProblem:id2}}\label{\detokenize{model/freeBoundaryProblem:figfreeboundary-sol}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FreeBoundary_Mesh2}.png}
\caption{The adapted mesh of the domain \(\Omega^{72}\)}\label{\detokenize{model/freeBoundaryProblem:id3}}\label{\detokenize{model/freeBoundaryProblem:figfreeboundary-mesh2}}\end{subfigure}
\phantomsection\label{\detokenize{model/freeBoundaryProblem:FreeBoundary}}

\end{figure}

\end{sphinxadmonition}


\section{Non-linear elasticity}
\label{\detokenize{model/nonLinearElasticity:non-linear-elasticity}}\label{\detokenize{model/nonLinearElasticity::doc}}
The nonlinear elasticity problem is: find the displacement \((u_{1},u_{2})\) minimizing \(J\):
\begin{equation*}
\begin{split}\min J(u_{1},u_{2}) = \int_{\Omega} f(F2) - \int_{\Gamma_{p}} P_{a} \, u_{2}\end{split}
\end{equation*}
where \(F2(u_{1},u_{2}) = A(E[u_{1},u_{2}],E[u_{1},u_{2}])\) and \(A(X,Y)\) is bilinear symmetric positive form with respect two matrix \(X,Y\).

where \(f\) is a given \(\mathcal{C}^2\) function, and \(E[u_{1},u_{2}] = (E_{ij})_{i=1,2,\,j=1,2}\) is the Green-Saint Venant deformation tensor defined with:
\begin{equation*}
\begin{split}E_{ij} = 0.5 \big( ( \p_i u_j + \p_j u_i ) + \sum_k \p_i u_k {\times} \p_j u_k \big)\end{split}
\end{equation*}
Denote \(\mathbf{u}=(u_{1},u_{2})\), \(\mathbf{v}=(v_{1},v_{2})\), \(\mathbf{w}=(w_{1},w_{2})\).
So, the differential of \(J\) is:
\begin{equation*}
\begin{split}DJ(\mathbf{u})(\mathbf{v}) = \int DF2(\mathbf{u})(\mathbf{v}) \;f'(F2(\mathbf{u}))) - \int_{\Gamma_{p}} P_{a} v_{2}\end{split}
\end{equation*}
where \(DF2(\mathbf{u})(\mathbf{v}) = 2 \; A(DE[\mathbf{u}](\mathbf{v}),E[\mathbf{u}])\) and \(DE\) is the first differential of \(E\).

The second order differential is:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    D^2 J(\mathbf{u})((\mathbf{v}),(\mathbf{w})) &=& \displaystyle\int DF2(\mathbf{u})(\mathbf{v}) \; DF2(\mathbf{u})(\mathbf{w}) \; f''(F2(\mathbf{u}))) \\
    &+& \displaystyle\int \; D^2F2(\mathbf{u})(\mathbf{v},\mathbf{w}) \; f'(F2(\mathbf{u})))
\end{array}\end{split}
\end{equation*}
where:
\begin{equation*}
\begin{split}D^2F2(\mathbf{u})(\mathbf{v},\mathbf{w}) = 2 \; A(\;D^2E[\mathbf{u}](\mathbf{v},\mathbf{w})\;,\;E[\mathbf{u}]\;) + 2 \; A(\;DE[\mathbf{u}](\mathbf{v})\;,DE[\mathbf{u}](\mathbf{w})\;) .\end{split}
\end{equation*}
and \(D^{2}E\) is the second differential of \(E\).

So all notations can be define with {\hyperref[\detokenize{reference/types:typemacrodesign}]{\sphinxcrossref{\DUrole{std,std-ref}{macro}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{k+kt}{macro} \PYG{n}{EL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//is [epsilon\PYGZus{}11, 2epsilon\PYGZus{}12, epsilon\PYGZus{}22]}

 \PYG{k+kt}{macro} \PYG{n}{ENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{[}
     \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{,}
     \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
     \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}
 \PYG{p}{]} \PYG{c+c1}{//}

 \PYG{k+kt}{macro} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{[}
     \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
     \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
     \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
 \PYG{p}{]} \PYG{c+c1}{//}

 \PYG{k+kt}{macro} \PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n}{EL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//is [E\PYGZus{}11, 2E\PYGZus{}12, E\PYGZus{}22]}
 \PYG{k+kt}{macro} \PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{(}\PYG{n}{EL}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
 \PYG{k+kt}{macro} \PYG{n}{ddE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{c+c1}{//}
 \PYG{k+kt}{macro} \PYG{n}{F2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
 \PYG{k+kt}{macro} \PYG{n}{dF2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}\PYG{p}{)} \PYG{c+c1}{//}
 \PYG{k+kt}{macro} \PYG{n}{ddF2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)} \PYG{p}{(}
     \PYG{p}{(}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}
     \PYG{o}{+} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{ddE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}
 \PYG{p}{)} \PYG{c+c1}{//}
\end{sphinxVerbatim}

The Newton Method is:

choose \(n=0\),and \(u_0,v_0\) the initial displacement
\begin{itemize}
\item {} 
loop:
\begin{itemize}
\item {} 
find \((du,dv)\) : solution of
\begin{equation*}
\begin{split}D^2J(u_n,v_n)((w,s),(du,dv)) = DJ(u_n,v_n)(w,s) , \quad \forall w,s\end{split}
\end{equation*}
\item {} 
\(un = un - du,\quad vn =vn - dv\)

\item {} 
until \((du,dv)\) small is enough

\end{itemize}

\end{itemize}

The way to implement this algorithm in FreeFem++ is use a macro tool to implement \(A\) and \(F2\), \(f\), \(f'\),\(f''\).

A macro is like in \sphinxcode{\sphinxupquote{ccp}} preprocessor of C++, but this begin by \sphinxcode{\sphinxupquote{macro}} and the end of the macro definition is before the comment \sphinxcode{\sphinxupquote{//}}.
In this case the macro is very useful because the type of parameter can be change.
And it is easy to make automatic differentiation.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{NonLinearElasticity_Mesh1}.png}
\caption{The deformed domain}\label{\detokenize{model/nonLinearElasticity:id1}}\end{figure}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{EL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//is [epsilon\PYGZus{}11, 2epsilon\PYGZus{}12, epsilon\PYGZus{}22]}

\PYG{k+kt}{macro} \PYG{n}{ENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{[}
    \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}
    \PYG{p}{]} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{[}
    \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{]} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n}{EL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//is [E\PYGZus{}11, 2E\PYGZus{}12, E\PYGZus{}22]}
\PYG{k+kt}{macro} \PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{(}\PYG{n}{EL}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{ddE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{F2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{dF2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{ddF2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)} \PYG{p}{(}
      \PYG{p}{(}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}
    \PYG{o}{+} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{ddE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}
    \PYG{p}{)} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{f}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.25}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{df}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{ddf}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{l+m+mf}{0.012e5}\PYG{p}{;} \PYG{c+c1}{//kg/cm\PYGZca{}2}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{l+m+mf}{0.4e5}\PYG{p}{;} \PYG{c+c1}{//kg/cm\PYGZca{}2}
\PYG{k+kt}{real} \PYG{n}{Pa} \PYG{o}{=} \PYG{l+m+mf}{1e2}\PYG{p}{;}

\PYG{c+c1}{// sigma = 2 mu E + lambda tr(E) Id}
\PYG{c+c1}{// A(u,v) = sigma(u):E(v)}
\PYG{c+c1}{//}
\PYG{c+c1}{// ( a b )}
\PYG{c+c1}{// ( b c )}
\PYG{c+c1}{//}
\PYG{c+c1}{// tr*Id : (a,b,c) \PYGZhy{}\PYGZgt{} (a+c,0,a+c)}
\PYG{c+c1}{// so the associed matrix is:}
\PYG{c+c1}{// ( 1 0 1 )}
\PYG{c+c1}{// ( 0 0 0 )}
\PYG{c+c1}{// ( 1 0 1 )}

\PYG{k+kt}{real} \PYG{n}{a11} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a22} \PYG{o}{=} \PYG{n}{mu}\PYG{p}{;} \PYG{c+c1}{//because [0, 2*t12, 0]\PYGZsq{} A [0, 2*s12,0] = 2*mu*(t12*s12 + t21*s21) = 4*mu*t12*s12}
\PYG{k+kt}{real} \PYG{n}{a33} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a12} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a13} \PYG{o}{=} \PYG{n}{lambda}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a23} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{// symetric part}
\PYG{k+kt}{real} \PYG{n}{a21} \PYG{o}{=} \PYG{n}{a12}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a31} \PYG{o}{=} \PYG{n}{a13}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a32} \PYG{o}{=} \PYG{n}{a23}\PYG{p}{;}

\PYG{c+c1}{//the matrix A}
\PYG{k+kt}{func} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{a11}\PYG{p}{,} \PYG{n}{a12}\PYG{p}{,} \PYG{n}{a13}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{a21}\PYG{p}{,} \PYG{n}{a22}\PYG{p}{,} \PYG{n}{a23}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{a31}\PYG{p}{,} \PYG{n}{a32}\PYG{p}{,} \PYG{n}{a33}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{l+m+mf}{.3}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//label: 1 bottom, 2 right, 3 up, 4 left;}
\PYG{k+kt}{int} \PYG{n}{bottom} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{right} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{upper} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{left} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{e2}\PYG{p}{,} \PYG{n}{fe2}\PYG{p}{,} \PYG{n}{dfe2}\PYG{p}{,} \PYG{n}{ddfe2}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Sh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Sh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{vmass} \PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{uu}\PYG{o}{*}\PYG{n}{w} \PYG{o}{+} \PYG{n}{vv}\PYG{o}{*}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{M} \PYG{o}{=} \PYG{n}{vmass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{NonLin}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//(D\PYGZca{}2 J(un))}
           \PYG{n}{dF2}\PYG{p}{(}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{o}{*}\PYG{n}{dF2}\PYG{p}{(}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{ddfe2}
        \PYG{o}{+} \PYG{n}{ddF2}\PYG{p}{(}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{ddfe2}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{upper}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Pa}\PYG{o}{*}\PYG{n}{s}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//(D J(un))}
          \PYG{n}{dF2}\PYG{p}{(}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{dfe2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{right}\PYG{p}{,} \PYG{n}{left}\PYG{p}{,} \PYG{n}{uu}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Newton\PYGZsq{}s method}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Loop }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{e2} \PYG{o}{=} \PYG{n}{F2}\PYG{p}{(}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dfe2} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n}{e2}\PYG{p}{)} \PYG{p}{;}
    \PYG{n}{ddfe2} \PYG{o}{=} \PYG{n}{ddf}\PYG{p}{(}\PYG{n}{e2}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{e2 max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{e2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{de2 max = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dfe2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dfe2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dde2 max = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ddfe2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ddfe2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{NonLin}\PYG{p}{;}
    \PYG{n}{w}\PYG{p}{[}\PYG{p}{]}  \PYG{o}{=} \PYG{n}{M}\PYG{o}{*}\PYG{n}{uu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Residual}
    \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{w}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{uu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//L\PYGZca{}2 norm of [uu, vv]}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ L\PYGZca{}2 residual = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{v1} \PYG{o}{=} \PYG{n}{vv}\PYG{p}{;}
    \PYG{n}{u1} \PYG{o}{=} \PYG{n}{uu}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u1 min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, u1 max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{v1 min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{v1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, v2 max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uu, vv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{un}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{uu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{k+kp}{displacement}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{res} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Movemesh}
\PYG{k+kt}{mesh} \PYG{n}{th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{un}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vn}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Compressible Neo-Hookean materials}
\label{\detokenize{model/compressibleNeoHookeanMaterials:compressible-neo-hookean-materials}}\label{\detokenize{model/compressibleNeoHookeanMaterials::doc}}
Author: \sphinxstyleemphasis{Alex Sadovsky}


\subsection{Notation}
\label{\detokenize{model/compressibleNeoHookeanMaterials:notation}}
In what follows, the symbols \(\mathbf{u}, \bF, \bB, \bC, \stress\) denote, respectively, the displacement field, the deformation gradient, the left Cauchy-Green strain tensor \(\bB = \bF \bF^T\), the right Cauchy-Green strain tensor \(\bC =\bF^T \bF\), and the Cauchy stress tensor.

We also introduce the symbols \(I_1 := \tr \bC\) and \(J := \det\bF\).
Use will be made of the identity:
\begin{equation*}
\begin{split}{\p J \over \p \bC} = J \bC^{-1}\end{split}
\end{equation*}
The symbol \(\Id\) denotes the identity tensor.
The symbol \(\Omega_{0}\) denotes the reference configuration of the body to be deformed.
The unit volume in the reference (resp., deformed) configuration is denoted \(dV\) (resp., \(dV_{0}\)); these two are related by:
\begin{equation*}
\begin{split}dV = J dV_{0},\end{split}
\end{equation*}
which allows an integral over \(\Omega\) involving the Cauchy stress \(\bT\) to be rewritten as an integral of the Kirchhoff stress \(\kappa = J \bT\) over \(\Omega_{0}\).


\subsection{Recommended References}
\label{\detokenize{model/compressibleNeoHookeanMaterials:recommended-references}}
For an exposition of nonlinear elasticity and of the underlying linear and tensor algebra, see \sphinxcite{reference:ogden1984}.
For an advanced mathematical analysis of the Finite Element Method, see \sphinxcite{reference:raviart1998}.


\subsection{A Neo-Hookean Compressible Material}
\label{\detokenize{model/compressibleNeoHookeanMaterials:a-neo-hookean-compressible-material}}
\sphinxstyleemphasis{Constitutive Theory and Tangent Stress Measures}

The strain energy density function is given by:
\begin{equation*}
\begin{split}W = {\mu \over 2}(I_1 - \tr \Id - 2 \ln J)\end{split}
\end{equation*}
(see \sphinxcite{reference:horgan2004}, formula (12)).

The corresponding 2nd Piola-Kirchoff stress tensor is given by:
\begin{equation*}
\begin{split}\bS_{n} := {\p W \over \p\bE} (\bF_{n})
=
\mu (\Id - \bC^{-1})\end{split}
\end{equation*}
The Kirchhoff stress, then, is:
\begin{equation*}
\begin{split}\kappa
= \bF \bS \bF^{T}
= \mu (\bB - \Id)\end{split}
\end{equation*}
The tangent Kirchhoff stress tensor at \(\bF_{n}\) acting on \(\delta \bF_{n+1}\) is, consequently:
\begin{equation*}
\begin{split}{\p \kappa \over \p \bF} (\bF_{n}) \delta \bF_{n+1}
=
\mu
\left[
\bF_{n} (\delta \bF_{n+1})^T
+
\delta \bF_{n+1} (\bF_{n})^T
\right]\end{split}
\end{equation*}
\sphinxstyleemphasis{The Weak Form of the BVP in the Absence of Body (External) Forces}

The \(\Omega_0\) we are considering is an elliptical annulus, whose boundary consists of two concentric ellipses (each allowed to be a circle as a special case), with the major axes parallel.
Let \(P\) denote the dead stress load (traction) on a portion \(\partial \Omega_0^{t}\) (= the inner ellipse) of the boundary \(\partial \Omega_0\).
On the rest of the boundary, we prescribe zero displacement.

The weak formulation of the boundary value problem is:
\begin{equation*}
\begin{split}\arr{lll}
0
& = &
\int_{\Omega_0}
\kappa[\bF]
\:
:
\:
\left\{
(\Grad \otimes \mathbf{w}) (\bF)^{-1}
\right\}\\
& - & \int_{\p \Omega_0^{t}} P \cdot \hat{N}_0\\
\rra\end{split}
\end{equation*}
For brevity, in the rest of this section we assume \(P = 0\).
The provided FreeFem++ code, however, does not rely on this assumption and allows for a general value and direction of \(P\).

Given a Newton approximation \(\mathbf{u}_n\) of the displacement field \(\mathbf{u}\) satisfying the BVP, we seek the correction \(\delta \mathbf{u}_{n+1}\) to obtain a better approximation:
\begin{equation*}
\begin{split}\mathbf{u}_{n+1} = \mathbf{u}_{n} + \delta \mathbf{u}_{n+1}\end{split}
\end{equation*}
by solving the weak formulation:
\begin{equation*}
\begin{split}\arr{lll}
    0 &=& \int_{\Omega_0}\kappa[\bF_{n} + \delta \bF_{n+1}]\: :\: \left\{(\Grad \otimes \mathbf{w}) (\bF_{n} + \delta\bF_{n+1})^{-1}\right\}- \int_{\p \Omega_0} P \cdot \hat{N}_0\\
    &=& \int_{\Omega_0}\left\{\kappa[\bF_{n}] + {\p \kappa \over \p \bF}[\bF_{n}]\delta \bF_{n+1}\right\}\: :\: \left\{(\Grad \otimes \mathbf{w})(\bF_{n} + \delta \bF_{n+1})^{-1}\right\}\\
    &=& \int_{\Omega_0}\left\{\kappa[\bF_{n}] + {\p \kappa \over \p \bF}[\bF_{n}]\delta \bF_{n+1}\right\}\: :\: \left\{(\Grad \otimes \mathbf{w}) (\bF_{n}^{-1} + \bF_{n}^{-2} \delta \bF_{n+1})\right\}\\
    \\
    &=& \int_{\Omega_0}\kappa[\bF_{n}]\: :\: \left\{(\Grad \otimes \mathbf{w})\bF_{n}^{-1}\right\}\\
    &-& \int_{\Omega_0}\kappa[\bF_{n}]\: :\: \left\{(\Grad \otimes \mathbf{w})(\bF_{n}^{-2} \delta \bF_{n+1})\right\}\\
    &+& \int_{\Omega_0}\left\{{\p \kappa \over \p \bF}[\bF_{n}]\delta \bF_{n+1}\right\}\: :\: \left\{(\Grad \otimes \mathbf{w})
\bF_{n}^{-1}
\right\}
\\
\rra
\quad
\mbox{for all test functions} \mathbf{w},\end{split}
\end{equation*}
where we have taken:
\begin{equation*}
\begin{split}\delta \bF_{n+1} = \Grad \otimes \delta \mathbf{u}_{n+1}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Contrary to standard notational use, the symbol \(\delta\) here bears no variational context.
By \(\delta\) we mean simply an increment in the sense of Newton’s Method.
The role of a variational virtual displacement here is played by \(\mathbf{w}\).
\end{sphinxadmonition}


\subsection{An Approach to Implementation in FreeFem++}
\label{\detokenize{model/compressibleNeoHookeanMaterials:an-approach-to-implementation-in-freefem}}
Introducing the code-like notation, where a string in \(< >\)’s is to be read as one symbol, the individual components of the tensor:
\begin{equation*}
\begin{split}<TanK>
 :=
{\p \kappa \over \p \bF}[\bF_{n}]
\delta \bF_{n+1}\end{split}
\end{equation*}
will be implemented as the macros \(<TanK11>\), \(<TanK12>\), …

The individual components of the tensor quantities:
\begin{equation*}
\begin{split}\bD_{1} :=
\bF_{n} (\delta \bF_{n+1})^T
+
\delta \bF_{n+1} (\bF_{n})^T,\end{split}
\end{equation*}\begin{equation*}
\begin{split}\bD_{2} :=
\bF_{n}^{-T} \delta \bF_{n+1},\end{split}
\end{equation*}\begin{equation*}
\begin{split}\bD_{3} :=
(\Grad \otimes \mathbf{w})
\bF_{n}^{-2} \delta \bF_{n+1},\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}\bD_{4} :=
(\Grad \otimes \mathbf{w})
\bF_{n}^{-1},\end{split}
\end{equation*}
will be implemented as the macros:
\begin{equation*}
\begin{split}\arr{l}
<d1Aux11>, <d1Aux12>, \quad \ldots \quad, <d1Aux22>,\\
<d2Aux11>, <d2Aux12>, \quad \ldots \quad, <d2Aux22>\\
<d3Aux11>, <d3Aux12>, \quad \ldots \quad, <d3Aux22>\\
<d4Aux11>, <d4Aux12>, \quad \ldots \quad, <d4Aux22>\\
\rra,\end{split}
\end{equation*}
respectively.

In the above notation, the tangent Kirchhoff stress term becomes
\begin{equation*}
\begin{split}{\p \kappa \over \p \bF} (\bF_{n})
\: \delta \bF_{n+1}
=
\mu
\: \bD_{1}\end{split}
\end{equation*}
while the weak BVP formulation acquires the form:
\begin{equation*}
\begin{split}\arr{lll}
0 & = &
\int_{\Omega_0}
\kappa[\bF_{n}]
\:
:
\:
\bD_{4}
\\
&-&
\int_{\Omega_0}
\kappa[\bF_{n}]
\:
:
\:
\bD_{3}
\\
&+&
\int_{\Omega_0}
\left\{
{\p \kappa \over \p \bF}[\bF_{n}]
\delta \bF_{n+1}
\right\}
\:
:
\:
\bD_{4}
\\
\rra
\quad
\mbox{for all test functions} \mathbf{w}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Macro}
\PYG{c+c1}{//Macros for the gradient of a vector field (u1, u2)}
\PYG{k+kt}{macro} \PYG{n+nf}{grad11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macros for the deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{n}{grad11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mf}{0.0} \PYG{o}{+} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mf}{0.0} \PYG{o}{+} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macros for the incremental deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{grad11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{grad12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{grad21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{grad22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macro for the determinant of the deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macros for the inverse of the deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{Finv11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Finv22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Finv12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
    \PYG{o}{\PYGZhy{}} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Finv21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
    \PYG{o}{\PYGZhy{}} \PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macros for the square of the inverse of the deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{FFinv11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}
    \PYG{o}{+} \PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{FFinv12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{FFinv21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{FFinv22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macros for the inverse of the transpose of the deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{FinvT11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{FinvT12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{FinvT21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{FinvT22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//The left Cauchy\PYGZhy{}Green strain tensor}
\PYG{k+kt}{macro} \PYG{n}{B11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{B12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{B21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{B22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{//The macros for the auxiliary tensors (D0, D1, D2, ...): Begin}
\PYG{o}{/}\PYG{o}{/}\PYG{n}{The} \PYG{n}{tensor} \PYG{n}{quantity} \PYG{n}{D0} \PYG{o}{=} \PYG{n}{F}\PYG{p}{\PYGZob{}}\PYG{k+kr}{n}\PYG{p}{\PYGZcb{}} \PYG{p}{(}\PYG{n}{delta} \PYG{n}{F}\PYG{p}{\PYGZob{}}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{n}{T}
\PYG{k+kt}{macro} \PYG{n}{d0Aux11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d0Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d0Aux21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d0Aux22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{///The tensor quantity D1 = D0 + D0\PYGZca{}T}
\PYG{k+kt}{macro} \PYG{n}{d1Aux11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{d0Aux11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d1Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{d0Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{d0Aux21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d1Aux21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{d1Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d1Aux22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}\PYG{p}{(}
      \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{d0Aux22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{///The tensor quantity D2 = F\PYGZca{}\PYGZob{}\PYGZhy{}T\PYGZcb{}\PYGZus{}\PYGZob{}n\PYGZcb{} dF\PYGZus{}\PYGZob{}n+1\PYGZcb{}}
\PYG{k+kt}{macro} \PYG{n}{d2Aux11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d2Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d2Aux21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d2Aux22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{///The tensor quantity D3 = F\PYGZca{}\PYGZob{}\PYGZhy{}2\PYGZcb{}\PYGZus{}\PYGZob{}n\PYGZcb{} dF\PYGZus{}\PYGZob{}n+1\PYGZcb{}}
\PYG{k+kt}{macro} \PYG{n}{d3Aux11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d3Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d3Aux21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d3Aux22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{///The tensor quantity D4 = (grad w) * Finv}
\PYG{k+kt}{macro} \PYG{n}{d4Aux11} \PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d4Aux12} \PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d4Aux21} \PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d4Aux22} \PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}
\PYG{c+c1}{//The macros for the auxiliary tensors (D0, D1, D2, ...): End}

\PYG{c+c1}{//The macros for the various stress measures: BEGIN}
\PYG{c+c1}{//The Kirchhoff stress tensor}
\PYG{k+kt}{macro} \PYG{n}{StressK11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{B11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{//The Kirchhoff stress tensor}
\PYG{k+kt}{macro} \PYG{n}{StressK12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{B12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{//The Kirchhoff stress tensor}
\PYG{k+kt}{macro} \PYG{n}{StressK21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{B21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{//The Kirchhoff stress tensor}
\PYG{k+kt}{macro} \PYG{n}{StressK22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{B22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{//The tangent Kirchhoff stress tensor}
\PYG{k+kt}{macro} \PYG{n}{TanK11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{d1Aux11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{TanK12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{d1Aux12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{TanK21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{d1Aux21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{TanK22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{d1Aux22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}
\PYG{c+c1}{//The macros for the stress tensor components: END}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{l+m+mf}{5.e2}\PYG{p}{;} \PYG{c+c1}{//Elastic coefficients (kg/cm\PYGZca{}2)}
\PYG{k+kt}{real} \PYG{n}{D} \PYG{o}{=} \PYG{l+m+mf}{1.e3}\PYG{p}{;} \PYG{c+c1}{//(1 / compressibility)}
\PYG{k+kt}{real} \PYG{n}{Pa} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.e2}\PYG{p}{;} \PYG{c+c1}{//Stress loads}

\PYG{k+kt}{real} \PYG{n}{InnerRadius} \PYG{o}{=} \PYG{l+m+mf}{1.e0}\PYG{p}{;} \PYG{c+c1}{//The wound radius}
\PYG{k+kt}{real} \PYG{n}{OuterRadius} \PYG{o}{=} \PYG{l+m+mf}{4.e0}\PYG{p}{;} \PYG{c+c1}{//The outer (truncated) radius}
\PYG{k+kt}{real} \PYG{k+kp}{tol} \PYG{o}{=} \PYG{l+m+mf}{1.e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Tolerance (L\PYGZca{}2)}
\PYG{k+kt}{real} \PYG{n}{InnerEllipseExtension} \PYG{o}{=} \PYG{l+m+mf}{1.e0}\PYG{p}{;} \PYG{c+c1}{//Extension of the inner ellipse ((major axis) \PYGZhy{} (minor axis))}

\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{InnerEdge}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{n}{InnerEllipseExtension}\PYG{p}{)}\PYG{o}{*}\PYG{n}{InnerRadius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{InnerRadius}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{OuterEdge}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{l+m+mf}{0.0}\PYG{o}{*}\PYG{n}{InnerEllipseExtension}\PYG{p}{)}\PYG{o}{*}\PYG{n}{OuterRadius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{OuterRadius}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{InnerEdge}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{OuterEdge}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{bottom} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{right} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{upper} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{left} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1dc}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u1n}\PYG{p}{,}\PYG{n}{u2n}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{ehat1x}\PYG{p}{,} \PYG{n}{ehat1y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{ehat2x}\PYG{p}{,} \PYG{n}{ehat2y}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{auxVec1}\PYG{p}{,} \PYG{n}{auxVec2}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//The individual elements of the total 1st Piola\PYGZhy{}Kirchoff stress}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{ef1}\PYG{p}{,} \PYG{n}{ef2}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Sh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Sh} \PYG{n}{p}\PYG{p}{,} \PYG{n}{ppp}\PYG{p}{;}
\PYG{n}{Sh} \PYG{n}{StrK11}\PYG{p}{,} \PYG{n}{StrK12}\PYG{p}{,} \PYG{n}{StrK21}\PYG{p}{,} \PYG{n}{StrK22}\PYG{p}{;}
\PYG{n}{Sh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{vfMass1D}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{p}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Mass1D} \PYG{o}{=} \PYG{n}{vfMass1D}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,} \PYG{n}{Sh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{p}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Mass1D} \PYG{o}{*} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{DomainMass} \PYG{o}{=} \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DomainMass = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{DomainMass} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vmass} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{v1} \PYG{o}{+} \PYG{n}{u2}\PYG{o}{*}\PYG{n}{v2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{DomainMass} \PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{Mass} \PYG{o}{=} \PYG{n}{vmass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{Id} \PYG{o}{=} \PYG{n}{vmass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//Define the standard Euclidean basis functions}
\PYG{p}{[}\PYG{n}{ehat1x}\PYG{p}{,} \PYG{n}{ehat1y}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{[}\PYG{n}{ehat2x}\PYG{p}{,} \PYG{n}{ehat2y}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{ContParam}\PYG{p}{,} \PYG{n}{dContParam}\PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{neoHookeanInc} \PYG{p}{(}\PYG{p}{[}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{p}{(}
              \PYG{n}{StressK11} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d3Aux11}\PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{StressK12} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d3Aux12}\PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{StressK21} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d3Aux21}\PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{StressK22} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d3Aux22}\PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n}{TanK11} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{TanK12} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{TanK21} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{TanK22} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{StressK11} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{StressK12} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{StressK21} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{StressK22} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{c+c1}{//Choose one of the following two boundary conditions involving Pa:}
    \PYG{c+c1}{// Load vectors normal to the boundary:}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Pa} \PYG{o}{*} \PYG{p}{(}\PYG{n}{w1}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n}{w2}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{c+c1}{//Load vectors tangential to the boundary:}
    \PYG{c+c1}{//\PYGZhy{} int1d(Th, 1)(}
    \PYG{c+c1}{//    Pa * (w1*N.y \PYGZhy{} w2*N.x)}
    \PYG{c+c1}{//)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{varu1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{varu2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{//Auxiliary variables}
\PYG{k+kt}{matrix} \PYG{n}{auxMat}\PYG{p}{;}

\PYG{c+c1}{// Newton\PYGZsq{}s method}
\PYG{n}{ContParam} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{n}{dContParam} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{c+c1}{//Initialization:}
\PYG{p}{[}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{[}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{k+kp}{tol}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{eforceres}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{loopcount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{loopmax} \PYG{o}{=} \PYG{l+m+mi}{45}\PYG{p}{;}

\PYG{c+c1}{// Iterations}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{loopcount} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{loopmax} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{res} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{k+kp}{tol}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{loopcount} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Loop }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{loopcount} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{neoHookeanInc}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{u1} \PYG{o}{=} \PYG{n}{varu1}\PYG{p}{;}
    \PYG{n}{u2} \PYG{o}{=} \PYG{n}{varu2}\PYG{p}{;}

    \PYG{c+c1}{// Residual}
    \PYG{n}{w1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Mass}\PYG{o}{*}\PYG{n}{varu1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{varu1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//L\PYGZca{}2 norm of [varu1, varu2]}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ L\PYGZca{}2 residual = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Newton}
    \PYG{n}{u1n}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{varu1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1n}\PYG{p}{,}\PYG{n}{u2n}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{k+kp}{displacement}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Movemesh}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u1n}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{u2n}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1n}\PYG{p}{,}\PYG{n}{u2n}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Whispering gallery modes}
\label{\detokenize{model/whisperingGalleryModes:whispering-gallery-modes}}\label{\detokenize{model/whisperingGalleryModes::doc}}
Author: \sphinxhref{http://linkeding.com/in/grudinin}{I. S. Grudinin}

In whispering gallery mode (WGM) resonators, which are typically spheres or disks, electromagnetic field is trapped by total internal reflections from the boundary.
Modes of such resonators are distinguished by compact volume and record high quality factors (Q) in a broad range of frequencies.

Modern applications of such resonators include microwave and optical cavities for atomic clocks, cavity optomechanics, nonlinear and quantum optics.
Analytical solutions for WG modes are only available for a limited number of idealized geometries, such as sphere or ellipsoid.
Since resonator dimensions are typically much larger than optical wavelength, direct application of numerical 3D finite difference time domain (FDTD) or finite element methods (FEM) is not practical.
It’s possible to solve the vectorial wave equation by reducing it to a two dimensional case by taking axial symmetry into account.

Such reduction leads to a system of 3 equations to be solved in a 2D “\(\rho-z\)” section of a resonator.
Please refer to \sphinxcite{reference:oxborrow2007} for a detailed derivation and to \sphinxcite{reference:grudinin2012} for an example of using FreeFem++ to compute WGMs.


\subsection{Wave equation for the WGMs}
\label{\detokenize{model/whisperingGalleryModes:wave-equation-for-the-wgms}}
Since electric field is discontinuous on the surface of a dielectric and magnetic field is typically not, we derive our equations for the magnetic field.
The electric field can be easily derived at a later stage from \(\vec{E}=\frac{i}{\omega\epsilon_0}\hat{\epsilon}^{-1}\nabla\times\vec{H}\).
Following a standard procedure starting with Maxwell equations we derive a wave equation in a single-axis anisotropic medium such as an optical crystal:
\begin{equation}\label{equation:model/whisperingGalleryModes:eqn::wave}
\begin{split}\nabla\times\left(\hat{\epsilon}^{-1}\nabla\times\vec{H}\right)-k_0^2\vec{H}-\alpha\nabla\left(\nabla\cdot\vec{H}\right)=0\end{split}
\end{equation}
Here \(k_0=\omega/c\) is the wavenumber, \(\alpha\) is the penalty term added to fight spurious FEM solutions.
For anisotropic single-axis medium with \(\partial\hat{\epsilon}/\partial\phi=0\) in cylindrical system of coordinates we have:
\begin{equation*}
\begin{split}\hat{\epsilon}=\begin{pmatrix} \epsilon_{\rho} & 0 & 0 \\ 0 & \epsilon_{\rho} & 0 \\ 0 & 0 & \epsilon_z \end{pmatrix}. \nonumber\end{split}
\end{equation*}
We now assume axial symmetry of our electromagnetic fields and insert an imaginary unity in front of the \(H_{\phi}\) to allow all field components to be real numbers and also to account for the phase shift of this component \(\vec{H}(\rho,\phi,z)=\left\{H_{\rho}(\rho,z),iH_{\phi}(\rho,z),H_z(\rho,z)\right\}\times e^{im\phi}\).

We write the wave equation \eqref{equation:model/whisperingGalleryModes:eqn::wave} explicitly in cylindrical coordinates, thus obtaining a set of three differential equations for the domain \(\Omega\) given by the resonator’s cross section and some space outside:
\begin{equation}\label{equation:model/whisperingGalleryModes:eqn::system}
\begin{split}\begin{array}{rcl}
    A_1\{{H}_{\rho}^t,{H}_{\phi}^t,{H}_{z}^t\}&=&0\\ \nonumber
    A_2\{{H}_{\rho}^t,{H}_{\phi}^t,{H}_{z}^t\}&=&0\\ \nonumber
    A_3\{{H}_{\rho}^t,{H}_{\phi}^t,{H}_{z}^t\}&=&0
\end{array}\end{split}
\end{equation}
The numerical solutions of these equations and boundary conditions can be found with FreeFem++ if we write the system in the weak, or integral form.


\subsection{Weak formulation}
\label{\detokenize{model/whisperingGalleryModes:weak-formulation}}
In general, to obtain the integral or “weak” statements equivalent to system \eqref{equation:model/whisperingGalleryModes:eqn::system} and boundary conditions we form a scalar dot product between an arbitrary magnetic field test function \(\mathbf{H}^t=\{{H}_{\rho}^t,{H}_{\phi}^t,{H}_{z}^t\}\) and the components of our vectorial equation \(A_1,A_2,A_3\), and integrate over the resonator’s cross section domain \(\Omega\) (and its boundary for the boundary conditions):
\begin{equation*}
\begin{split}\int\limits_{\Omega}(H^t_{\rho}A_1+H^t_{\phi}A_2+H^t_{z}A_3)d\Omega\end{split}
\end{equation*}
We can reduce the order of partial derivatives in this integral by using the Green’s formula for integration by parts.
For example:
\begin{equation*}
\begin{split}\int\limits_{\Omega}H_z^t \frac{\partial^2 H_z}{\partial \rho^2 }d\Omega=
-\int\limits_{\Omega}\frac{\partial H_z^t}{\partial \rho}\frac{\partial H_z}{\partial \rho }d\Omega+\oint H_z^t\frac{\partial H_z}{\partial \rho}n_{\rho}d\Gamma\end{split}
\end{equation*}
Thus converting equations \eqref{equation:model/whisperingGalleryModes:eqn::system} we obtain a large expression for the weak form.


\subsection{A dielectric sphere example with FreeFem++}
\label{\detokenize{model/whisperingGalleryModes:a-dielectric-sphere-example-with-freefem}}
We now compute the fundamental mode frequency for a fused silica sphere.
The sphere is 36 micrometer in diameter, the refractive index is 1.46, the boundary condition is the magnetic wall (which can actually be omitted as it holds automatically).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{radius} \PYG{o}{=} \PYG{l+m+mi}{36}\PYG{p}{;} \PYG{c+c1}{//approximate radius of the cavity}
\PYG{k+kt}{real} \PYG{n}{yb} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{yt} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{yb}\PYG{p}{;} \PYG{c+c1}{//window yb=bottom and yt=top coordinates}
\PYG{k+kt}{real} \PYG{n}{xl} \PYG{o}{=} \PYG{n}{radius}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{xr} \PYG{o}{=} \PYG{n}{radius}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{c+c1}{//window xl=left and xr=right coordinates}
\PYG{k+kt}{real} \PYG{n}{angle} \PYG{o}{=} \PYG{n+nf}{asin}\PYG{p}{(}\PYG{p}{(}\PYG{n}{yt}\PYG{p}{)}\PYG{o}{/}\PYG{n}{radius}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//angle of the sphere segment to model in radians}
\PYG{k+kt}{int} \PYG{n}{Nm} \PYG{o}{=} \PYG{l+m+mi}{60}\PYG{p}{;} \PYG{c+c1}{//number of mesh vertices per border}
\PYG{k+kt}{real} \PYG{n}{ne} \PYG{o}{=} \PYG{l+m+mf}{1.46}\PYG{p}{;} \PYG{c+c1}{//n\PYGZus{}e\PYGZhy{}extraordinary refractive index (root of permittivity parallel to z\PYGZhy{}axis, epara)}
\PYG{k+kt}{real} \PYG{n}{no} \PYG{o}{=} \PYG{l+m+mf}{1.46}\PYG{p}{;} \PYG{c+c1}{//n\PYGZus{}o\PYGZhy{}ordinary refractive index (root of permittivity orthogonal to z\PYGZhy{}axis, eorto)}
\PYG{k+kt}{real} \PYG{n}{nm} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//refractive index of surrounding medium (air)}

\PYG{k+kt}{int} \PYG{k+kp}{nev} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{c+c1}{// number of eigen values to find}

\PYG{k+kt}{int} \PYG{n}{M} \PYG{o}{=} \PYG{l+m+mi}{213}\PYG{p}{;} \PYG{c+c1}{//azimuthal mode order \PYGZti{} 2Pi*n*R/lambda}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//penalty term}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{W1l}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xl}\PYG{o}{+}\PYG{p}{(}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{xl}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yt}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{W1r}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xr}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{xr}\PYG{o}{\PYGZhy{}}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yt}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{W2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xr}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yb}\PYG{o}{+}\PYG{p}{(}\PYG{n}{yt}\PYG{o}{\PYGZhy{}}\PYG{n}{yb}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{W3l}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xl}\PYG{o}{+}\PYG{p}{(}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{xl}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yb}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{W3r}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xr}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{xr}\PYG{o}{\PYGZhy{}}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yb}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{W4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xl}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yt}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{yt}\PYG{o}{\PYGZhy{}}\PYG{n}{yb}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{S}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{W1r}\PYG{p}{(}\PYG{n}{Nm}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{W1l}\PYG{p}{(}\PYG{n}{Nm}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{W4}\PYG{p}{(}\PYG{n}{Nm}\PYG{p}{)} \PYG{o}{+} \PYG{n}{W3l}\PYG{p}{(}\PYG{n}{Nm}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{W3r}\PYG{p}{(}\PYG{n}{Nm}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{W2}\PYG{p}{(}\PYG{n}{Nm}\PYG{p}{)} \PYG{o}{+} \PYG{n}{S}\PYG{p}{(}\PYG{n}{Nm}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{WindowIndex}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{reg} \PYG{o}{=} \PYG{k+kr}{region}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{ncav} \PYG{o}{=} \PYG{n}{reg}\PYG{p}{(}\PYG{n}{xl}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// cavity}
\PYG{k+kt}{int} \PYG{n}{nair} \PYG{o}{=} \PYG{n}{reg}\PYG{p}{(}\PYG{n}{xr}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//air}
\PYG{n}{Ph} \PYG{n}{eorto} \PYG{o}{=} \PYG{n}{no}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{ncav}\PYG{p}{)} \PYG{o}{+} \PYG{n}{nm}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{nair}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//subdomains for epsilon values inside and outside the resonators}
\PYG{n}{Ph} \PYG{n}{epara} \PYG{o}{=} \PYG{n}{ne}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{ncav}\PYG{p}{)} \PYG{o}{+} \PYG{n}{nm}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{nair}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//subdomains for epsilon values inside and outside the resonators}

\PYG{c+c1}{//supplementary variables to store eigenvectors, defined on mesh Th with P2 elements \PYGZhy{} Largange quadratic.}
\PYG{k+kt}{fespace} \PYG{n+nf}{Supp}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Supp} \PYG{n}{eHsqr}\PYG{p}{;}

\PYG{c+c1}{//3d vector FE space}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{vHr}\PYG{p}{,} \PYG{n}{vHphi}\PYG{p}{,} \PYG{n}{vHz}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//magnetic field components on Vh space and test functions vH}

\PYG{c+c1}{// Macro}
\PYG{c+c1}{//boundary condition macros}
\PYG{k+kt}{macro} \PYG{n+nf}{EWall}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{)} \PYG{p}{(}
      \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hz}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Hr}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n}{Hz}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}
    \PYG{o}{\PYGZhy{}} \PYG{n}{epara}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hz}\PYG{o}{*}\PYG{n}{M} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}
    \PYG{o}{+} \PYG{n}{eorto}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hphi} \PYG{o}{\PYGZhy{}} \PYG{n}{Hr}\PYG{o}{*}\PYG{n}{M}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{MWall}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Hphi} \PYG{o}{+} \PYG{n}{Hz}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{Hr}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}
    \PYG{o}{+} \PYG{n}{epara}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hz}\PYG{o}{*}\PYG{n}{M} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}
    \PYG{o}{+} \PYG{n}{eorto}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hphi} \PYG{o}{\PYGZhy{}} \PYG{n}{Hr}\PYG{o}{*}\PYG{n}{M}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y} \PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=}\PYG{p}{(}\PYG{n}{M}\PYG{o}{/}\PYG{p}{(}\PYG{n}{ne}\PYG{o}{*}\PYG{n}{radius}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{// value of the shift (k\PYGZca{}2), where the modes will be found}
\PYG{k+kt}{varf} \PYG{n+nf}{b} \PYG{p}{(}\PYG{p}{[}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{vHr}\PYG{p}{,} \PYG{n}{vHphi}\PYG{p}{,} \PYG{n}{vHz}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hr}\PYG{o}{*}\PYG{n}{vHr}\PYG{o}{+}\PYG{n}{Hphi}\PYG{o}{*}\PYG{n}{vHphi}\PYG{o}{+}\PYG{n}{Hz}\PYG{o}{*}\PYG{n}{vHz}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}
\PYG{c+c1}{// OP = A \PYGZhy{} sigma B ; // the shifted matrix}
\PYG{k+kt}{varf} \PYG{k+kp}{op} \PYG{p}{(}\PYG{p}{[}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{vHr}\PYG{p}{,} \PYG{n}{vHphi}\PYG{p}{,} \PYG{n}{vHz}\PYG{p}{]}\PYG{p}{)}\PYG{o}{=}
    \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}
              \PYG{p}{(}\PYG{n}{eorto}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHphi}\PYG{o}{*}\PYG{n}{Hphi} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHphi}\PYG{o}{*}\PYG{n}{Hr} \PYG{o}{+} \PYG{n}{Hphi}\PYG{o}{*}\PYG{n}{vHr}\PYG{p}{)} \PYG{o}{+} \PYG{n}{M}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{vHr}\PYG{o}{*}\PYG{n}{Hr}\PYG{p}{)} \PYG{o}{+} \PYG{n}{epara}\PYG{o}{*}\PYG{n}{M}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{vHz}\PYG{o}{*}\PYG{n}{Hz}\PYG{p}{)}\PYG{o}{/}\PYG{k+kr}{x} \PYG{c+c1}{//A/r}
            \PYG{o}{+} \PYG{n}{eorto}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vHphi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hphi} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{n}{Hr}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHphi} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{n}{vHr}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{epara}\PYG{o}{*}\PYG{n}{M}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHz}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Hz}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vHphi}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//B}
            \PYG{o}{+} \PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{n}{eorto}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vHphi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)} \PYG{o}{+} \PYG{n}{epara}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vHz}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vHr}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hz}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vHphi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//C}
        \PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{eorto}\PYG{o}{*}\PYG{n}{epara}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}
              \PYG{p}{(}\PYG{n}{vHr}\PYG{o}{*}\PYG{n}{Hr} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHphi}\PYG{o}{*}\PYG{n}{Hr} \PYG{o}{+} \PYG{n}{Hphi}\PYG{o}{*}\PYG{n}{vHr}\PYG{p}{)} \PYG{o}{+} \PYG{n}{M}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{vHphi}\PYG{o}{*}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{/}\PYG{k+kr}{x} \PYG{c+c1}{//D/r}
            \PYG{o}{+} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vHr}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vHz}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hr} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{n}{Hphi}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{n}{vHr} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{n}{vHphi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hz}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//E}
            \PYG{o}{+} \PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vHr}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vHz}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hz}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//F}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}}\PYG{k+kp}{sigma}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHr}\PYG{o}{*}\PYG{n}{Hr} \PYG{o}{+} \PYG{n}{vHphi}\PYG{o}{*}\PYG{n}{Hphi} \PYG{o}{+} \PYG{n}{vHz}\PYG{o}{*}\PYG{n}{Hz}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{c+c1}{//electric wall boundary condition on the boundary of computation domain}
    \PYG{o}{+}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{EWall}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{)}\PYG{o}{*}\PYG{n}{EWall}\PYG{p}{(}\PYG{n}{vHr}\PYG{p}{,} \PYG{n}{vHphi}\PYG{p}{,} \PYG{n}{vHz}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}
\PYG{c+c1}{//setting sparce matrices and assigning the solver UMFPACK to solve eigenvalue problem}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{OP} \PYG{o}{=} \PYG{k+kp}{op}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ev}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the nev eigenvalue}
\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{eHr}\PYG{p}{,} \PYG{n}{eHphi}\PYG{p}{,} \PYG{n}{eHz}\PYG{p}{]}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the nev eigenvector}
\PYG{c+c1}{//calling ARPACK on sparce matrices with the assigned solver UMFPACK:}
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{n}{OP}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{k+kp}{sym}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{k+kp}{sigma}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{n}{ev}\PYG{p}{,} \PYG{k+kp}{vector}\PYG{o}{=}\PYG{n}{eHr}\PYG{p}{,} \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kp}{maxit}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{ncv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{k} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//sometimes the number of converged eigen values}
                 \PYG{c+c1}{//can be greater than nev}

\PYG{c+c1}{//file to output mode values}
\PYG{k+kt}{ofstream} \PYG{n+nf}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{modes.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//setting number of digits in the file output}
\PYG{k+kt}{int} \PYG{n}{nold} \PYG{o}{=} \PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{precision}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot \PYGZam{} Save}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{ev}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{eHsqr} \PYG{o}{=} \PYG{p}{(}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{eHr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eHphi}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eHz}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//intensity from magnetic field components}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{eHsqr}\PYG{p}{,} \PYG{k+kp}{WindowIndex}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{n}{LabelColors}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{aspectratio}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mode }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, lambda=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{lambda}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, F=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{p}{(}\PYG{l+m+mf}{299792.458}\PYG{o}{/}\PYG{n}{lambda}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mode }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, ka=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{ev}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{n}{radius} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{Examples}
\label{\detokenize{example/index:examples}}\label{\detokenize{example/index:id1}}\label{\detokenize{example/index::doc}}

\section{Misc}
\label{\detokenize{example/misc:misc}}\label{\detokenize{example/misc::doc}}

\subsection{Poisson’s Equation}
\label{\detokenize{example/misc:poisson-s-equation}}\label{\detokenize{example/misc:examplepoissonequation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{H} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{NAdapt} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{L}\PYG{p}{,} \PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{h}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{h}\PYG{p}{,} \PYG{n}{H}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{l}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{l}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{H}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b6}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{H}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{L}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{h}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{p}{(}\PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b4}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{p}{(}\PYG{n}{H}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b5}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{l}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b6}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{H}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Change P1 to P2 to test P2 finite element}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f} \PYG{o}{*} \PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{b3}\PYG{p}{,} \PYG{n}{b4}\PYG{p}{,} \PYG{n}{b5}\PYG{p}{,} \PYG{n}{b6}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation iterations}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{NAdapt}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Solve}
   \PYG{n}{Poisson}\PYG{p}{;}

   \PYG{c+c1}{// Plot}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// Adaptmesh}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{inquire}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{error} \PYG{o}{=} \PYG{n}{error} \PYG{o}{*} \PYG{k+kp}{coef}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{poisson_associated_mesh}.jpg}
\caption{Adapted mesh}\label{\detokenize{example/misc:id1}}\label{\detokenize{example/misc:figexamplepoisson}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{poisson_adapted_mesh}.jpg}
\caption{Solution on adapted mesh}\label{\detokenize{example/misc:id2}}\label{\detokenize{example/misc:figexamplepoissonadapt}}\end{subfigure}
\caption{Poisson}

\end{figure}



\subsection{Poisson’s equation 3D}
\label{\detokenize{example/misc:poisson-s-equation-3d}}\label{\detokenize{example/misc:examplepoissonequation3d}}\label{\detokenize{example/misc:Poisson}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mf}{4.}\PYG{o}{*}\PYG{k+kr}{z}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{18.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ]\PYGZhy{}pi/2, pi/2[X]0,2pi[}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{n}{f3}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P23d}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uhe} \PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uhe min: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} max: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u2e}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Lap3d} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{ue}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Lap3d}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u min: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.} \PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} max: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{ue}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n+nf}{d} \PYG{o}{=} \PYG{n}{ue} \PYG{o}{\PYGZhy{}} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} diff l\PYGZca{}intfy = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{d}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n}{u2} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{n}{u2e} \PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{,} \PYG{n}{u2e}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{poisson_3d}.jpg}
\caption{Iso-surfaces of the solution}\label{\detokenize{example/misc:id3}}\end{figure}


\subsection{Stokes Equation on a cube}
\label{\detokenize{example/misc:stokes-equation-on-a-cube}}\label{\detokenize{example/misc:examplestokesequationonacube}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{// Dynamically loaded tools for 3D}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th0} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rdown} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{reffaceup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow}\PYG{o}{=}\PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c8x8x8}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 3D mesh visualization with medit}

\PYG{c+c1}{// Fespaces}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uz}\PYG{p}{,} \PYG{n}{p2}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{VVh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{VVh} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{VVh} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem (directly solved)}
\PYG{k+kt}{solve} \PYG{n}{vStokes} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q}
        \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{)} \PYG{o}{*} \PYG{n}{p}
        \PYG{o}{+} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{o}{*} \PYG{n}{q} \PYG{o}{*} \PYG{n}{p}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 3D visualization of pressure isolines}

\PYG{c+c1}{// See 10 plan of the velocity in 2D}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Cut plane}
    \PYG{k+kt}{real} \PYG{n}{yy} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{10.}\PYG{p}{;}
    \PYG{c+c1}{// 3D to 2D interpolation}
    \PYG{n}{ux} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{yy}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{uz} \PYG{o}{=} \PYG{n}{u3}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{yy}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{p2} \PYG{o}{=} \PYG{n}{p}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{yy}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uz}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cut y = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{yy}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Stokes3d}.jpg}
\caption{Solution}\label{\detokenize{example/misc:id4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Stokes3d-Th}.jpg}
\caption{Associated mesh}\label{\detokenize{example/misc:id5}}\end{subfigure}
\caption{Stokes}

\end{figure}



\subsection{Cavity}
\label{\detokenize{example/misc:cavity}}\label{\detokenize{example/misc:examplecavity}}\label{\detokenize{example/misc:Stokes3d}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{300}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{rho} \PYG{o}{=} \PYG{l+m+mf}{500.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{uin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fx} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fy} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{noslip} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{inflow} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{;}

\PYG{c+c1}{//Macros}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}\PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{c+c1}{//}

\PYG{c+c1}{//Time}
\PYG{k+kt}{real} \PYG{n}{cpu}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{tabcpu}\PYG{p}{;}

\PYG{c+c1}{//mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C2}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C4}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C4}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{UPh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{UPh} \PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{UPh} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{,} \PYG{n}{ph}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{UPh} \PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{//Solve}
\PYG{k+kt}{varf} \PYG{n+nf}{navierstokes}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{,} \PYG{n}{ph}\PYG{p}{]}\PYG{p}{)}
  \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{rho}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{*} \PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{]}
    \PYG{o}{+} \PYG{n}{mu}\PYG{o}{*} \PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{:}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n}{ph}\PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{o}{*}\PYG{n}{p}\PYG{o}{*}\PYG{n}{ph}
    \PYG{p}{)}

  \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)} \PYG{p}{(}
      \PYG{p}{[}\PYG{n}{fx}\PYG{p}{,} \PYG{n}{fy}\PYG{p}{]}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{]}
    \PYG{o}{+} \PYG{n}{rho}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{*} \PYG{p}{[}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{upx}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{)}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{]}
    \PYG{p}{)}

  \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{noslip}\PYG{p}{,} \PYG{n}{ux}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{inflow}\PYG{p}{,} \PYG{n}{ux}\PYG{o}{=}\PYG{n}{uin}\PYG{p}{,} \PYG{n}{uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{p}{;}

\PYG{c+c1}{//Initialization}
\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{NS} \PYG{o}{=} \PYG{n}{navierstokes}\PYG{p}{(}\PYG{n}{UPh}\PYG{p}{,} \PYG{n}{UPh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{NSrhs} \PYG{o}{=} \PYG{n}{navierstokes}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{UPh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//Time loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
  \PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{;}

  \PYG{n}{NSrhs} \PYG{o}{=} \PYG{n}{navierstokes}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{UPh}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ux}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{NS}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{NSrhs}\PYG{p}{;}

  \PYG{n+nf}{plot}\PYG{p}{(} \PYG{p}{[}\PYG{n}{ux}\PYG{p}{,}\PYG{n}{uy}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//CPU}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ CPU = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}
\PYG{n}{tabcpu} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Mesh Generation}
\label{\detokenize{example/meshGeneration:mesh-generation}}\label{\detokenize{example/meshGeneration:examplemeshgeneration}}\label{\detokenize{example/meshGeneration::doc}}

\subsection{Square mesh}
\label{\detokenize{example/meshGeneration:square-mesh}}\label{\detokenize{example/meshGeneration:examplemeshsquare}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th0} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10} \PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mf}{1.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x1} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{labs} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{mesh} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{labs}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square flags = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Mesh adaptation}
\label{\detokenize{example/meshGeneration:mesh-adaptation}}\label{\detokenize{example/meshGeneration:examplemeshadaptation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{0.0001}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{hmin} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{10.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{h}\PYG{o}{*}\PYG{n+nf}{atan2}\PYG{p}{(}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mf}{5.0}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;} \PYG{c+c1}{//old mesh is deleted}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptation1}.jpg}
\caption{Initial mesh}\label{\detokenize{example/meshGeneration:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptation2}.jpg}
\caption{Adapted mesh}\label{\detokenize{example/meshGeneration:id2}}\end{subfigure}
\caption{Mesh adaptation}

\end{figure}



\subsection{Mesh adaptation for the Poisson’s problem}
\label{\detokenize{example/meshGeneration:mesh-adaptation-for-the-poisson-s-problem}}\label{\detokenize{example/meshGeneration:examplemeshadaptationforthepoissonproblem}}\label{\detokenize{example/meshGeneration:MeshAdaptation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kr}{be}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bf}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bd}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bf}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
      \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Poisson}\PYG{p}{;}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{error} \PYG{o}{=} \PYG{n}{error}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptationPoisson1}.jpg}
\caption{Initial mesh}\label{\detokenize{example/meshGeneration:id3}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptationPoisson2}.jpg}
\caption{Adapted mesh}\label{\detokenize{example/meshGeneration:id4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptationPoissonU}.jpg}
\caption{Solution on adapted mesh}\label{\detokenize{example/meshGeneration:id5}}\end{subfigure}
\caption{Mesh adaptation (Poisson)}

\end{figure}



\subsection{Uniform mesh adaptation}
\label{\detokenize{example/meshGeneration:uniform-mesh-adaptation}}\label{\detokenize{example/meshGeneration:exampleuniformmeshadaptation}}\label{\detokenize{example/meshGeneration:MeshAdaptationPoisson}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// The initial mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// More than one time due to the}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// adaptation bound {}`maxsubdiv={}`}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{UniformMeshAdaptation1}.jpg}
\caption{Initial mesh}\label{\detokenize{example/meshGeneration:id6}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{UniformMeshAdaptation2}.jpg}
\caption{Adapted mesh}\label{\detokenize{example/meshGeneration:id7}}\end{subfigure}
\caption{Uniform mesh adaptation}

\end{figure}



\subsection{Borders}
\label{\detokenize{example/meshGeneration:borders}}\label{\detokenize{example/meshGeneration:exampleborders}}\label{\detokenize{example/meshGeneration:UniformMeshAdaptation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{upper} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{others} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{inner} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}

   \PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C05}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C06}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
      \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
      \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 1 has region number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 2 has redion number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to see a plot of the border mesh}
   \PYG{k+kt}{mesh} \PYG{n}{Thwithouthole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{mesh} \PYG{n}{Thwithhole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithouthole}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithhole}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{;}
   \PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{c+c1}{//  mesh Thwithhole = buildmesh(a(50) + b(\PYGZhy{}30)); // do not do this because the two}
   \PYG{c+c1}{// circles have the same radius = \PYGZdl{}0.3\PYGZdl{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Borders1}.jpg}
\caption{Mesh with two regions}\label{\detokenize{example/meshGeneration:id8}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Borders2}.jpg}
\caption{Mesh without a hole}\label{\detokenize{example/meshGeneration:id9}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Borders3}.jpg}
\caption{Mesh with a hole}\label{\detokenize{example/meshGeneration:id10}}\end{subfigure}
\caption{Borders}

\end{figure}



\subsection{Change}
\label{\detokenize{example/meshGeneration:change}}\label{\detokenize{example/meshGeneration:examplechange}}\label{\detokenize{example/meshGeneration:Borders}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Change edges\PYGZsq{} label from 2 to 0}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r2}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Change edges\PYGZsq{} label from 4 to 0}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Th1} \PYG{o}{+} \PYG{n}{Th2}\PYG{p}{;} \PYG{c+c1}{// \PYGZsq{}gluing together\PYGZsq{} Th1 and Th2 meshes}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nb lab = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}
   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{+}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// Definition of a macro}

\PYG{k+kt}{solve} \PYG{k+kr}{P}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Change}.jpg}
\caption{Result}\label{\detokenize{example/meshGeneration:id11}}\end{figure}


\subsection{Cube}
\label{\detokenize{example/meshGeneration:cube}}\label{\detokenize{example/meshGeneration:examplecube}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l6} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{37}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{57}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{r11} \PYG{o}{=} \PYG{l+m+mi}{11}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{z}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l6}\PYG{p}{,} \PYG{k+kp}{flags} \PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, border area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{bordermeasure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{k+kp}{err} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{sx} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{sy} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{sz} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sx}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sy}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{iz} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sz}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ix} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iy}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{16}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iz}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
      \PYG{c+c1}{//value of ix,iy,iz =\PYGZgt{} face min 0, face max 2, no face 1}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Label = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, s = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ix} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iz} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{k}{if}\PYG{p}{(} \PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ii} \PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{real} \PYG{n}{volr11} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume region = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{volr11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{volr11} \PYG{o}{\PYGZhy{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nb err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kp}{err}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Cube}.jpg}
\caption{Cube}\label{\detokenize{example/meshGeneration:id12}}\end{figure}


\subsection{Empty mesh}
\label{\detokenize{example/meshGeneration:empty-mesh}}\label{\detokenize{example/meshGeneration:exampleemptymesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ssd}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{)}\PYG{p}{;}
   \PYG{c+c1}{// Builds the pseudo region numbering}
   \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ssd}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{iq} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{// Because we have 2 triangles per quad}
      \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
      \PYG{n}{ssd}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ix}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{n}{iy}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{c+c1}{// Builds an emtpy mesh with all edges that satisfy e=T1 cap T2 and ssd[T1] != ssd[T2]}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ssd}\PYG{p}{)}\PYG{p}{;}
   \PYG{c+c1}{// Plot}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EmptyMesh1}.jpg}
\caption{Empty square}\label{\detokenize{example/meshGeneration:id13}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EmptyMesh2}.jpg}
\caption{Empty diamond}\label{\detokenize{example/meshGeneration:id14}}\end{subfigure}
\caption{Empty mesh}

\end{figure}



\subsection{3 points}
\label{\detokenize{example/meshGeneration:points}}\label{\detokenize{example/meshGeneration:example3points}}\label{\detokenize{example/meshGeneration:EmptyMesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Square for Three\PYGZhy{}Point Bend Specimens fixed on Fix1, Fix2}
\PYG{c+c1}{// It will be loaded on Load}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{m} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Left}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Right}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Load}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Left}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Fix1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{Fix2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot3}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Right}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Load}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{3Points}.jpg}
\caption{3 Points}\label{\detokenize{example/meshGeneration:id15}}\end{figure}


\subsection{Bezier}
\label{\detokenize{example/meshGeneration:bezier}}\label{\detokenize{example/meshGeneration:examplebezier}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// A cubic Bezier curve connecting two points with two control points}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{bzi}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{p0}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{p1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q2}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{p0}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{q1}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{+} \PYG{n}{q2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{p1}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p00} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p11} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.95}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{q30} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{G1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{G1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G3}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G4}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Bezier}.jpg}
\caption{Bezier}\label{\detokenize{example/meshGeneration:id16}}\end{figure}


\subsection{Build layer mesh}
\label{\detokenize{example/meshGeneration:build-layer-mesh}}\label{\detokenize{example/meshGeneration:examplebuildlayermesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{C1} \PYG{o}{=} \PYG{l+m+mi}{99}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{C2} \PYG{o}{=} \PYG{l+m+mi}{98}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C14}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C23}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C24}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C23}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C24}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Ths} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a box with one hole and two regions}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayer} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{XX} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ} \PYG{o}{=} \PYG{k+kr}{z}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r3} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// Change upper surface mesh\PYGZsq{}s triangles labels}
\PYG{c+c1}{// generated by the 2D mesh\PYGZsq{}s triangles Th}
\PYG{c+c1}{// from label 4 to label 12}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r4} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// Change lower surface mesh\PYGZsq{}s triangles labels}
\PYG{c+c1}{// generated by the 2D mesh\PYGZsq{}s triangles Th}
\PYG{c+c1}{// from label 4 to label 45}

\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{MaxLayer}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{,}
   \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{,} \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{r3}\PYG{p}{,} \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{r4}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{box 2 regions 1 hole}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a sphere with TetGen}
\PYG{k+kt}{func} \PYG{n}{XX1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY1} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{test} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paACQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{test} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sph} \PYG{o}{=} \PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1}\PYG{p}{]}\PYG{p}{,}
   \PYG{k+kp}{switch}\PYG{o}{=}\PYG{n}{test}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sphere 2 regions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{BuildLayerMesh1}.jpg}
\caption{Box with a hole}\label{\detokenize{example/meshGeneration:id17}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{BuildLayerMesh2}.jpg}
\caption{Sphere}\label{\detokenize{example/meshGeneration:id18}}\end{subfigure}
\caption{Build layer mesh}

\end{figure}



\subsection{Sphere}
\label{\detokenize{example/meshGeneration:sphere}}\label{\detokenize{example/meshGeneration:examplesphere}}\label{\detokenize{example/meshGeneration:BuildLayerMesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameter}
\PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2D}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ]\PYGZhy{}pi/2, pi/2[X]0, 2pi[}
\PYG{c+c1}{// A parametrization of a sphere}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Partial derivative of the parametrization DF}
\PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{//M = DF\PYGZca{}t DF}
\PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{c+c1}{// Periodic condition}
\PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation}
\PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{inquire}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Sphere}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{n}{f3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Sphere1}.jpg}
\caption{Initial mesh}\label{\detokenize{example/meshGeneration:id19}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Sphere2}.jpg}
\caption{Sphere}\label{\detokenize{example/meshGeneration:id20}}\end{subfigure}
\caption{Sphere}\phantomsection\label{\detokenize{example/meshGeneration:Sphere}}

\end{figure}



\section{Finite Element}
\label{\detokenize{example/finiteElement:finite-element}}\label{\detokenize{example/finiteElement:examplefinteelement}}\label{\detokenize{example/finiteElement::doc}}

\subsection{Periodic 3D}
\label{\detokenize{example/finiteElement:periodic-3d}}\label{\detokenize{example/finiteElement:exampleperiodic3d}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kr}{searchMethod}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// More safe seach algo}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nnb} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{nni} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nz} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{n}{h}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2D}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{i1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b4}\PYG{p}{(}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i1}\PYG{p}{(}\PYG{n}{nni}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZob{}} \PYG{c+c1}{// Cleaning the memory correctly}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{old2new}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh2} \PYG{n}{sorder} \PYG{o}{=} \PYG{k+kr}{x} \PYG{o}{+} \PYG{k+kr}{y}\PYG{p}{;}
    \PYG{n+nf}{sort}\PYG{p}{(}\PYG{n}{sorder}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{old2new}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{new2old} \PYG{o}{=} \PYG{n}{old2new}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// Inverse permutation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{renumv}\PYG{o}{=}\PYG{n}{new2old}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sorder}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{fespace} \PYG{n}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh2} \PYG{n}{nu}\PYG{p}{;}
    \PYG{n}{nu}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nu=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Mesh 3D}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rlow} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rtet} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{nz}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{reftet}\PYG{o}{=}\PYG{n}{rtet}\PYG{p}{,} \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{reffaceup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow}\PYG{o}{=}\PYG{n}{rlow}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ int }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{area}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Periodic}.jpg}
\caption{Periodic mesh}\label{\detokenize{example/finiteElement:id1}}\end{figure}


\subsection{Lagrange multipliers}
\label{\detokenize{example/finiteElement:lagrange-multipliers}}\label{\detokenize{example/finiteElement:examplelagrangemultipliers}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{k+kr}{x} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{n1} \PYG{o}{=} \PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{va} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vL} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vb} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{va}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{vL}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{vb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Block matrix}
\PYG{k+kt}{matrix} \PYG{n}{AA} \PYG{o}{=} \PYG{p}{[} \PYG{p}{[} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{B} \PYG{p}{]}\PYG{p}{,} \PYG{p}{[} \PYG{k+kp}{B}\PYG{o}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{]} \PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xx}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{l}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{b1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{// Builds the right hand side block}
\PYG{k+kp}{bb} \PYG{o}{=} \PYG{p}{[}\PYG{n}{b}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{xx} \PYG{o}{=} \PYG{n}{AA}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{k+kp}{bb}\PYG{p}{;}

\PYG{c+c1}{// Set values}
\PYG{p}{[}\PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{l}\PYG{p}{]} \PYG{o}{=} \PYG{n}{xx}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ l = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{l}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , b(u, 1) =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{B}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{uh}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{LagrangeMultipliers}.jpg}
\caption{Result}\label{\detokenize{example/finiteElement:id2}}\end{figure}


\section{Visualization}
\label{\detokenize{example/visualization:visualization}}\label{\detokenize{example/visualization:examplevisualization}}\label{\detokenize{example/visualization::doc}}

\subsection{Plot}
\label{\detokenize{example/visualization:plot}}\label{\detokenize{example/visualization:exampleplot}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot scalar and vectorial FE function}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{vh}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Zoom on box defined by the two corner points [0.1,0.2] and [0.5,0.6]}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{grey}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Compute a cut}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{k+kt}{real}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{k+kt}{real}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
    \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{// Value of uh at point (i/10., i/10.)}
\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZob{}} \PYG{c+c1}{// File for gnuplot}
    \PYG{k+kt}{ofstream} \PYG{n}{gnu}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{gnu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Calls the gnuplot command, waits 5 seconds and generates a postscript plot (UNIX ONLY)}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{echo \PYGZsq{}plot }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ w l }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ pause 5 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set term postscript }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set output }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{gnuplot.eps}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ replot }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ quit\PYGZsq{} \textbar{} gnuplot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Plot1}.jpg}
\caption{First plot}\label{\detokenize{example/visualization:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Plot2}.jpg}
\caption{Second plot}\label{\detokenize{example/visualization:id2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Plot3}.png}
\caption{Gnuplot}\label{\detokenize{example/visualization:id3}}\end{subfigure}
\caption{Plot}

\end{figure}



\subsection{HSV}
\label{\detokenize{example/visualization:hsv}}\label{\detokenize{example/visualization:examplehsv}}\label{\detokenize{example/visualization:Plot}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// From: http://en.wikipedia.org/wiki/HSV\PYGZus{}color\PYGZus{}space}
\PYG{c+c1}{// The HSV (Hue, Saturation, Value) model defines a color space}
\PYG{c+c1}{// in terms of three constituent components:}
\PYG{c+c1}{// HSV color space as a color wheel}
\PYG{c+c1}{// Hue, the color type (such as red, blue, or yellow):}
\PYG{c+c1}{// Ranges from 0\PYGZhy{}360 (but normalized to 0\PYGZhy{}100\PYGZpc{} in some applications like here)}
\PYG{c+c1}{// Saturation, the \PYGZdq{}vibrancy\PYGZdq{} of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}
\PYG{c+c1}{// The lower the saturation of a color, the more \PYGZdq{}grayness\PYGZdq{} is present}
\PYG{c+c1}{// and the more faded the color will appear.}
\PYG{c+c1}{// Value, the brightness of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{colorhsv}\PYG{o}{=}\PYG{p}{[} \PYG{c+c1}{// Color hsv model}
    \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{c+c1}{// Dark blue}
    \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// Blue}
    \PYG{l+m+mf}{5.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// Magenta}
    \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// Red}
    \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.5} \PYG{p}{,} \PYG{l+m+mi}{1} \PYG{c+c1}{// Light red}
    \PYG{p}{]}\PYG{p}{;}
 \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{31}\PYG{p}{)}\PYG{p}{;}

 \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kp}{viso}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{o}{*}\PYG{l+m+mf}{0.1}\PYG{p}{;}

 \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{hsv}\PYG{o}{=}\PYG{n}{colorhsv}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{HSV}.jpg}
\caption{Result}\label{\detokenize{example/visualization:id4}}\end{figure}


\subsection{Medit}
\label{\detokenize{example/visualization:medit}}\label{\detokenize{example/visualization:examplemedit}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Old way}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{u}\PYG{o}{*}\PYG{l+m+mf}{.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Saves u.points and u.faces file}
\PYG{c+c1}{// build a u.bb file for medit}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.bb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2 1 1 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ 2 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// Calls medit command}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmedit u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Cleans files on unix\PYGZhy{}like OS}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rm u.bb u.faces u.points}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Medit1}.jpg}
\caption{2D plot}\label{\detokenize{example/visualization:id5}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Medit2}.jpg}
\caption{Plot with elevation}\label{\detokenize{example/visualization:id6}}\end{subfigure}
\caption{Medit}

\end{figure}



\subsection{Paraview}
\label{\detokenize{example/visualization:paraview}}\label{\detokenize{example/visualization:exampleparaview}}\label{\detokenize{example/visualization:Medit}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Order} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{DataName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n+nf}{savevtk}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.vtu}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{dataname}\PYG{o}{=}\PYG{n}{DataName}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{n}{Order}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Paraview}.jpg}
\caption{Result}\label{\detokenize{example/visualization:id7}}\end{figure}


\section{Algorithms \& Optimizations}
\label{\detokenize{example/algoOptimizations:algorithms-optimizations}}\label{\detokenize{example/algoOptimizations:examplealgorithmsoptimization}}\label{\detokenize{example/algoOptimizations::doc}}

\subsection{Algorithms}
\label{\detokenize{example/algoOptimizations:algorithms}}\label{\detokenize{example/algoOptimizations:examplealgorithms}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nerr} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{debugJ} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{debugdJ} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{umax} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Algorithms tests}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{k+kp}{stop} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{g}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ stop = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iter} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{g}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{g}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{iter} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{15}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// minimization of J(u) = 1./2 * sum (i+1) u\PYGZus{}i\PYGZca{}2 \PYGZhy{} b\PYGZus{}i}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{//J}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.5} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//the gradiant of J (this is a affine version (the RHS is in)}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{n}{u} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ\PYGZhy{}b: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//return of global variable ok}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//the gradiant of the bilinear part of J (the RHS is remove)}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ0} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ0: u =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//return of global variable ok}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//erro calculation}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n}{error} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{matId} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{int} \PYG{n}{verb}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{c+c1}{//verbosity}
    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//set right hand side}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{c+c1}{//set initial gest}

    \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGC (Affine) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}15}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{,} \PYG{k+kp}{stop}\PYG{o}{=}\PYG{k+kp}{stop}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGC (Affine with stop) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGC (Linear) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{AffineGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{AffineGMRES (Affine) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{LinearGMRES}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGMRES (Linear) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


    \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NLCG: J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


    \PYG{c+c1}{//warning: BFGS use a full matrix of size nxn (where n=u.n)}
    \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{n+nf}{BFGS}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{nbiterline}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BFGS: J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{nerr}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}} \PYG{c+c1}{// A real non linear test}
    \PYG{c+c1}{// Parameters}
    \PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{0.001}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
    \PYG{c+c1}{//f(u) = a*u + u\PYGZhy{}ln(1+u), f\PYGZsq{}(u) = a+ u/(1+u), f\PYGZsq{}\PYGZsq{}(u) = 1/(1+u)\PYGZca{}2}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{u}\PYG{o}{*}\PYG{n}{a}\PYG{o}{+}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{log}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{df}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{a}\PYG{o}{+}\PYG{n}{u}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{ddf}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Mesh}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Fespace}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Ph} \PYG{n}{alpha}\PYG{p}{;} \PYG{c+c1}{//store df(\textbar{}nabla u\textbar{}\PYGZca{}2)}

    \PYG{c+c1}{// The functionnal J}
    \PYG{c+c1}{//J(u) = 1/2 int\PYGZus{}Omega f(\textbar{}nabla u\textbar{}\PYGZca{}2) \PYGZhy{} int\PYGZus{}Omega u b}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
        \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{f}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// The gradiant of J}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
        \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
        \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n+nf}{au} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
            \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                  \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
                \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{vh}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{;}

        \PYG{n}{u} \PYG{o}{=} \PYG{n}{au}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Problem}
    \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{alap} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{k+kt}{varf} \PYG{n+nf}{amass}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{uh}\PYG{o}{*}\PYG{n}{vh}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{k+kt}{matrix} \PYG{n}{Amass} \PYG{o}{=} \PYG{n}{amass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{Alap}\PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Preconditionner}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{w} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
        \PYG{n}{u} \PYG{o}{=} \PYG{n}{Alap}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array variable}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{int} \PYG{n}{conv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{conv} \PYG{o}{=} \PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{C}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{conv}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

        \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Alap} \PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Restart with new preconditionner }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{conv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, eps =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solution with NLCG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{umax} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{sss}\PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{sss}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{nerr}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Algorithms1}.png}
\caption{Result \sphinxcode{\sphinxupquote{u}}}\label{\detokenize{example/algoOptimizations:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Algorithms2}.png}
\caption{\sphinxcode{\sphinxupquote{df(dx(u)*dx(u) + dy(u)*dy(u))}}}\label{\detokenize{example/algoOptimizations:id2}}\end{subfigure}
\caption{Algorithms}

\end{figure}



\subsection{CMAES variational inequality}
\label{\detokenize{example/algoOptimizations:cmaes-variational-inequality}}\label{\detokenize{example/algoOptimizations:examplecmaesvariationalinequality}}\label{\detokenize{example/algoOptimizations:Algorithms}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{NN} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{starttol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{bctol} \PYG{o}{=} \PYG{l+m+mf}{6.e\PYGZhy{}12}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{pena} \PYG{o}{=} \PYG{l+m+mf}{1000.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{NN}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ou1}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation loops}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{al} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{al} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{al}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{varf} \PYG{n}{BVF} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF1} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF2} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f2}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}  \PYG{n}{BVF}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{LVF1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{LVF2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{varf} \PYG{n+nf}{Vbord} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{In}\PYG{p}{,} \PYG{n}{Bord}\PYG{p}{;}
    \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Vbord}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{In}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{gh1} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{gh2} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g2}\PYG{p}{;}

    \PYG{c+c1}{// Function which creates a vector of the search space type from}
    \PYG{c+c1}{// two finite element functions}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{FEFToSSP} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Splits a vector from the search space and fills}
    \PYG{c+c1}{// two finite element functions with it}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{SSPToFEF} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{IneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{constraints}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{constraints}\PYG{p}{.}\PYG{k+kr}{l2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
        \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Au2} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{Au1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
        \PYG{n}{Au2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{val} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au1} \PYG{o}{+} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au2}\PYG{p}{;}
        \PYG{n}{val} \PYG{o}{+}\PYG{o}{=}  \PYG{n}{pena} \PYG{o}{*} \PYG{n}{IneqC}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{iter}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{200} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{199}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{adapt level }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{al}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} iteration }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} J = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{val}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{val} \PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{al} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
        \PYG{n}{start}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
        \PYG{n}{FEFToSSP}\PYG{p}{(}\PYG{n}{ou1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real} \PYG{n}{mini} \PYG{o}{=} \PYG{n+nf}{cmaes}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{stopMaxFunEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stopTolX}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}3}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{initialStdDev}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.025}\PYG{o}{/}\PYG{p}{(}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{l+m+mf}{100.}\PYG{p}{,}\PYG{n}{al}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{;}
    \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{best1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ou1} \PYG{o}{=} \PYG{n}{best1}\PYG{p}{;}
    \PYG{n}{ou2} \PYG{o}{=} \PYG{n}{best2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{CMAESVariationalInequality}.png}
\caption{Results}\label{\detokenize{example/algoOptimizations:id3}}\end{figure}


\subsection{IPOPT minimal surface \& volume}
\label{\detokenize{example/algoOptimizations:ipopt-minimal-surface-volume}}\label{\detokenize{example/algoOptimizations:exampleipoptminimalsurfacevolume}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{np} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{regtest}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{shapeswitch} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{40.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{treshold} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r0} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{rr} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{r0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{e}\PYG{o}{*}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{RR} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{rr}\PYG{o}{*}\PYG{n}{rr}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{p}{,} \PYG{n}{np}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Initial shape definition}
\PYG{c+c1}{//outside of the mesh adaptation loop to initialize with the previous optimial shape found on further iterations}
\PYG{n}{Vh} \PYG{n}{startshape} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{lz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation loop}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{lm} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{kkk} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{iter}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{sin2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// A function which transform Th in 3d mesh (r=rho)}
    \PYG{c+c1}{//a point (theta,phi) of Th becomes ( r(theta,phi)*cos(theta)*sin(phi) , r(theta,phi)*sin(theta)*sin(phi) , r(theta,phi)*cos(phi) )}
    \PYG{c+c1}{//then displays the resulting mesh with medit}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{Plot3D} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kt}{string} \PYG{k+kp}{cmm}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{ffplot}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rhoo}\PYG{p}{;}
        \PYG{n}{rhoo}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rho}\PYG{p}{;}
        \PYG{c+c1}{//mesh sTh = square(np, np/2, [2*pi*x, pi*y]);}
        \PYG{c+c1}{//fespace sVh(sTh, P1);}
        \PYG{c+c1}{//Vh rhoplot = rhoo;}
        \PYG{k}{try}\PYG{p}{\PYGZob{}}
            \PYG{k+kt}{mesh3} \PYG{n}{Sphere} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{ffplot}\PYG{p}{)}
                \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{else}
                \PYG{n+nf}{medit}\PYG{p}{(}\PYG{k+kp}{cmm}\PYG{p}{,} \PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PLOT ERROR}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Surface computation}
    \PYG{c+c1}{//Maybe is it possible to use movemesh23 to have the surface function less complicated}
    \PYG{c+c1}{//However, it would not simplify the gradient and the hessian}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Area} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{rho4} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho4}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rho(theta,phi) on [0,2pi]x[0,pi] \PYGZhy{} S=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{res}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else}
            \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shape\PYGZus{}evolution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{rho2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{alpha}\PYG{p}{;}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{varf} \PYG{n}{dArea} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
            \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{alpha}\PYG{o}{*}\PYG{n}{v} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{)}
            \PYG{p}{;}

        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dArea}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{matrix} \PYG{n}{hessianA}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{sqrtPsi3}\PYG{p}{,} \PYG{n}{C00}\PYG{p}{,} \PYG{n}{C01}\PYG{p}{,} \PYG{n}{C02}\PYG{p}{,} \PYG{n}{C11}\PYG{p}{,} \PYG{n}{C12}\PYG{p}{,} \PYG{n}{C22}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{;}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Vh} \PYG{n}{C0}\PYG{p}{,} \PYG{n}{C1}\PYG{p}{,} \PYG{n}{C2}\PYG{p}{;}
            \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqrtPsi3} \PYG{o}{=} \PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sqrtPsi}\PYG{p}{;}
            \PYG{n}{C0} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
            \PYG{n}{C1} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C2} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C00} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C01} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C1}\PYG{p}{;}
            \PYG{n}{C02} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
            \PYG{n}{C11} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C12} \PYG{o}{=} \PYG{n}{C1}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
            \PYG{n}{C22} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C2}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{varf} \PYG{n}{d2Area} \PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
            \PYG{o}{=}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}
                      \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                \PYG{p}{)}
                \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi3} \PYG{o}{*} \PYG{p}{(}
                      \PYG{n}{C00}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C11}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C22}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                \PYG{p}{)}
            \PYG{p}{)}
            \PYG{p}{;}
        \PYG{n}{hessianA} \PYG{o}{=} \PYG{n}{d2Area}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{hessianA}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Volume computation}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Volume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{rho3} \PYG{o}{=} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n+nf}{dVolume}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dVolume}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{matrix} \PYG{n}{hessianV}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianVolume}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{hessianV} \PYG{o}{=} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{hessianV}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//if we want to use the volume as a constraint function}
    \PYG{c+c1}{//we must wrap it in some freefem functions returning the appropriate type}
    \PYG{c+c1}{//The lagrangian hessian also have to be wrapped since the Volume is not linear with}
    \PYG{c+c1}{//respect to rho, it will constribbute to the hessian.}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ipVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vol} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Volume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{k}{return} \PYG{n}{vol}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{matrix} \PYG{n}{mdV}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipGradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{:}\PYG{p}{)} \PYG{o}{=} \PYG{n}{GradVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mdV} \PYG{o}{=} \PYG{n}{dvol}\PYG{p}{;} \PYG{k}{return} \PYG{n}{mdV}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{matrix} \PYG{n}{HLagrangian}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipHessianLag} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{objfact}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{lambda}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{HLagrangian} \PYG{o}{=} \PYG{n}{objfact}\PYG{o}{*}\PYG{n}{HessianArea}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{HessianVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{HLagrangian}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//building struct for GradVolume}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{gvi}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{gvj}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{gvi} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{startshape}\PYG{p}{;} \PYG{c+c1}{//the starting value}
    \PYG{n}{Vh} \PYG{n}{ub} \PYG{o}{=} \PYG{l+m+mf}{1.e19}\PYG{p}{;} \PYG{c+c1}{//bounds definition}
    \PYG{n}{Vh} \PYG{n}{lb} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Gaussian} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{Y}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{theta}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real} \PYG{n}{deltax2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(}\PYG{n}{X}\PYG{o}{\PYGZhy{}}\PYG{n}{theta}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{deltay2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{Y}\PYG{o}{\PYGZhy{}}\PYG{n}{phi}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{deltax2} \PYG{o}{+} \PYG{n}{deltay2}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{k+kp}{sigma}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{n}{disc1} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{disc2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{lb} \PYG{o}{=} \PYG{n}{r0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{q} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{q} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{o}{+}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{,} \PYG{n}{g}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{disc1}\PYG{p}{,} \PYG{n}{disc2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{Vobj} \PYG{o}{=} \PYG{n}{Volume}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{Vnvc} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{object\PYGZus{}inside}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{clb} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{cub} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{alpha}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Vobj} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{Vnvc}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Call IPOPT}
    \PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{Area}\PYG{p}{,} \PYG{n}{GradArea}\PYG{p}{,} \PYG{n}{ipHessianLag}\PYG{p}{,} \PYG{n}{ipVolume}\PYG{p}{,} \PYG{n}{ipGradVolume}\PYG{p}{,}
            \PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{clb}\PYG{p}{,} \PYG{n}{cub}\PYG{o}{=}\PYG{n}{cub}\PYG{p}{,} \PYG{n}{checkindex}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{maxiter}\PYG{o}{=}\PYG{n}{kkk}\PYG{o}{\PYGZlt{}}\PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{?} \PYG{l+m+mi}{40}\PYG{o}{:}\PYG{l+m+mi}{150}\PYG{p}{,}
            \PYG{n}{warmstart}\PYG{o}{=}\PYG{n}{kkk}\PYG{p}{,} \PYG{n}{lm}\PYG{o}{=}\PYG{n}{lm}\PYG{p}{,} \PYG{n}{uz}\PYG{o}{=}\PYG{n}{uz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lz}\PYG{o}{=}\PYG{n}{lz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{0.00001}\PYG{p}{,} \PYG{n}{structjacc}\PYG{o}{=}\PYG{p}{[}\PYG{n}{gvi}\PYG{p}{,}\PYG{n}{gvj}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IPOPT: res =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Shape\PYGZus{}at\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{GradArea}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ShapeGradient}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,}
            \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{50000}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{startshape} \PYG{o}{=} \PYG{n}{rc}\PYG{p}{;}
        \PYG{n}{uz} \PYG{o}{=} \PYG{n}{uz}\PYG{p}{;}
        \PYG{n}{lz} \PYG{o}{=} \PYG{n}{lz}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{regtest} \PYG{o}{=} \PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{IPOPTMinimalSurfaceVolume}.png}
\caption{Mesh}\label{\detokenize{example/algoOptimizations:id4}}\end{figure}


\subsection{CMAES MPI variational inequality}
\label{\detokenize{example/algoOptimizations:cmaes-mpi-variational-inequality}}\label{\detokenize{example/algoOptimizations:examplecmaesmpivariationalinequality}}
Command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{4} CMAESMPIVariationalInequality.edp \PYGZhy{}glut ffglut
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mpi\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{NN} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{starttol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{bctol} \PYG{o}{=} \PYG{l+m+mf}{6.e\PYGZhy{}12}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{pena} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{NN}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ou1}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{;}

\PYG{c+c1}{// Mehs adaptation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{al} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{al} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{al}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{varf} \PYG{n}{BVF} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF1} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF2} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f2}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{BVF}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{LVF1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{LVF2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{varf} \PYG{n+nf}{Vbord} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{In}\PYG{p}{,} \PYG{n}{Bord}\PYG{p}{;}
    \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Vbord}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{In}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{gh1} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{gh2} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g2}\PYG{p}{;}

    \PYG{c+c1}{//Function which create a vector of the search space type from}
    \PYG{c+c1}{//two finite element functions}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{FEFToSSP} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//Function spliting a vector from the search space and fills}
    \PYG{c+c1}{//two finite element functions with it}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{SSPToFEF} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{IneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{constraints}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{constraints}\PYG{p}{.}\PYG{k+kr}{l2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
        \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Au2} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{Au1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
        \PYG{n}{Au2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{val} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au1} \PYG{o}{+} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au2}\PYG{p}{;}
        \PYG{n}{val} \PYG{o}{+}\PYG{o}{=}  \PYG{n}{pena} \PYG{o}{*} \PYG{n}{IneqC}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{adapt level }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{al}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} iteration }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} J = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{val}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{val} \PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{al}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
        \PYG{n}{start}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
        \PYG{n}{FEFToSSP}\PYG{p}{(}\PYG{n}{ou1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real} \PYG{n}{mini} \PYG{o}{=} \PYG{n}{cmaesMPI}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{stopMaxFunEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stopTolX}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}4}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{initialStdDev}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.025}\PYG{o}{/}\PYG{p}{(}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{l+m+mf}{100.}\PYG{p}{,}\PYG{n}{al}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{;}
    \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{best1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ou1} \PYG{o}{=} \PYG{n}{best1}\PYG{p}{;}
    \PYG{n}{ou2} \PYG{o}{=} \PYG{n}{best2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{CMAESMPIVariationalInequality}.png}
\caption{Result}\label{\detokenize{example/algoOptimizations:id5}}\end{figure}


\section{Parallelization}
\label{\detokenize{example/parallelization:parallelization}}\label{\detokenize{example/parallelization:exampleparallelization}}\label{\detokenize{example/parallelization::doc}}

\subsection{MPI-GMRES 2D}
\label{\detokenize{example/parallelization:mpi-gmres-2d}}\label{\detokenize{example/parallelization:examplempigmres2d}}
To launch this script, use for example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{12} MPIGMRES2D.edp \PYGZhy{}d \PYG{l+m}{1} \PYGZhy{}k \PYG{l+m}{1} \PYGZhy{}gmres \PYG{l+m}{2} \PYGZhy{}n \PYG{l+m}{50}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//usage :}
\PYG{c+c1}{//ff\PYGZhy{}mpirun [mpi parameter] MPIGMRES2d.edp [\PYGZhy{}glut ffglut] [\PYGZhy{}n N] [\PYGZhy{}k K] [\PYGZhy{}d D] [\PYGZhy{}ns] [\PYGZhy{}gmres [0\textbar{}1]}
\PYG{c+c1}{//arguments:}
\PYG{c+c1}{//\PYGZhy{}glut ffglut : to see graphicaly the process}
\PYG{c+c1}{//\PYGZhy{}n N: set the mesh cube split NxNxN}
\PYG{c+c1}{//\PYGZhy{}d D: set debug flag D must be one for mpiplot}
\PYG{c+c1}{//\PYGZhy{}k K: to refined by K all element}
\PYG{c+c1}{//\PYGZhy{}ns: remove script dump}
\PYG{c+c1}{//\PYGZhy{}gmres}
\PYG{c+c1}{//0: use iterative schwarz algo.}
\PYG{c+c1}{//1: Algo GMRES on residu of schwarz algo}
\PYG{c+c1}{//2: DDM GMRES}
\PYG{c+c1}{//3: DDM GMRES with coarse grid preconditionner (Good one)}

\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPICG}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{metis}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{getARGV.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPIplot.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPIGMRESmacro.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//more safe seach algo (warning can be very expensive in case of lot of ouside point)}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kr}{version} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mf}{3.11}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//need at least v3.11}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ttt}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ittt}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n}{settt} \PYG{p}{\PYGZob{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{ittt}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{mpiWtime}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{c+c1}{//}

\PYG{c+c1}{// Arguments}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}vv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{vdebug} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ksplit} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}k}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nloc} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{sff} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{gmres} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}gmres}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{dplot} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nC} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}N}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{nloc}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kr}{verbosity}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ARGV: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if}\PYG{p}{(}\PYG{k+kr}{mpirank}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kr}{verbosity}\PYG{p}{)}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ vdebug: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vdebug} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, kspilt }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, nloc }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, sff }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{withplot} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{withmetis} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{RAS} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{sPk} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{P2\PYGZhy{}2gd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{Pk} \PYG{o}{=} \PYG{n+nc}{P2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{sizeoverlaps} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//size of overlap}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l111} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//mesh labels}

\PYG{c+c1}{// MPI function}
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{plotMPIall}\PYG{p}{(}\PYG{k+kt}{mesh} \PYG{o}{\PYGZam{}}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{cm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
        \PYG{n}{PLOTMPIALL}\PYG{p}{(}\PYG{k+kt}{mesh}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{k+kp}{cmm}\PYG{o}{=}\PYG{n}{cm}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// MPI}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//trick : make a no split mpiWorld}

\PYG{k+kt}{int} \PYG{n}{npart} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//total number of partion}
\PYG{k+kt}{int} \PYG{n}{ipart} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//current partition number}

\PYG{k+kt}{int} \PYG{n}{njpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//Number of part with intersection (a jpart) with ipart without ipart}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{jpart}\PYG{p}{(}\PYG{n}{npart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//list of jpart}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{ipart}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Final N = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit}\PYG{o}{*}\PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, nloc = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, split = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{settt}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thg} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nloc}\PYG{p}{,} \PYG{n}{nloc}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l111}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{ThC} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nC}\PYG{p}{,} \PYG{n}{nC}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l111}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// Coarse mesh}

\PYG{k+kt}{mesh} \PYG{n}{Thi}\PYG{p}{,} \PYG{n}{Thin}\PYG{p}{;} \PYG{c+c1}{//with overlap, without olverlap}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Phg}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Phg} \PYG{n}{part}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vhg}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vhg} \PYG{n}{unssd}\PYG{p}{;} \PYG{c+c1}{//boolean function: 1 in the subdomain, 0 elswhere}

\PYG{k+kt}{fespace} \PYG{n+nf}{VhC}\PYG{p}{(}\PYG{n}{ThC}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// of the coarse problem}

\PYG{c+c1}{// Partitioning}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{nupart}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{nupart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{npart} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{metisdual}\PYG{p}{(}\PYG{n}{nupart}\PYG{p}{,} \PYG{n}{Thg}\PYG{p}{,} \PYG{n}{npart}\PYG{p}{)}\PYG{p}{;}

    \PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nupart}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nupart}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{part}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{nupart}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{withplot} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{part}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dual}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Overlapping partition}
\PYG{n}{Phg} \PYG{n}{suppi} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{part}\PYG{o}{\PYGZhy{}}\PYG{n}{ipart}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{n}{Thin} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{suppi}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// non\PYGZhy{}overlapping mesh, interfaces have label 10}
\PYG{k+kt}{int} \PYG{n}{nnn} \PYG{o}{=} \PYG{n}{sizeoverlaps}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{c+c1}{// to be sure}
\PYG{n}{AddLayers}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{suppi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nnn}\PYG{p}{,} \PYG{n}{unssd}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//see above! suppi and unssd are modified}
\PYG{n}{unssd}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{n}{nnn}\PYG{p}{;} \PYG{c+c1}{//to put value nnn a 0}
\PYG{k+kt}{real} \PYG{n}{nnn0} \PYG{o}{=} \PYG{n}{nnn} \PYG{o}{\PYGZhy{}} \PYG{n}{sizeoverlaps} \PYG{o}{+} \PYG{l+m+mf}{0.001}\PYG{p}{;}
\PYG{n}{Thi} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{unssd}\PYG{o}{\PYGZgt{}}\PYG{n}{nnn0}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//overlapping mesh, interfaces have label 10}

\PYG{n}{settt}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n}{Vhi}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{npij} \PYG{o}{=} \PYG{n}{npart}\PYG{p}{;}
\PYG{n}{Vhi}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pij}\PYG{p}{(}\PYG{n}{npij}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local partition of unit + pii}
\PYG{n}{Vhi} \PYG{n}{pii}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{nnn1} \PYG{o}{=} \PYG{o}{+}\PYG{l+m+mf}{0.001}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/*}
\PYG{c+cm}{    construction of the partition of the unit,}
\PYG{c+cm}{    let phi\PYGZus{}i P1 FE function 1 on Thin and zero ouside of Thi and positive}
\PYG{c+cm}{    the partition is build with}
\PYG{c+cm}{    p\PYGZus{}i = phi\PYGZus{}i/ \PYGZbs{}sum phi\PYGZus{}i}

\PYG{c+cm}{    to build the partition of one domain i}
\PYG{c+cm}{    we nned to find all j such that supp(phi\PYGZus{}j) \PYGZbs{}cap supp(phi\PYGZus{}j) is not empty}
\PYG{c+cm}{    \PYGZlt{}=\PYGZgt{} int phi\PYGZus{}j}
\PYG{c+cm}{    */}
    \PYG{c+c1}{//build a local mesh of thii such that all computation of the unit partition are}
    \PYG{c+c1}{//exact in thii}
    \PYG{k+kt}{mesh} \PYG{n}{Thii} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{unssd}\PYG{o}{\PYGZgt{}}\PYG{n}{nnn1}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//overlapping mesh, interfaces have label 10}

    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//find all j mes (supp(p\PYGZus{}j) cap supp(p\PYGZus{}i)) \PYGZgt{}0}
        \PYG{c+c1}{//compute all phi\PYGZus{}j on Thii}
        \PYG{c+c1}{//remark: supp p\PYGZus{}i include in Thi}

        \PYG{c+c1}{// Fespace}
        \PYG{k+kt}{fespace} \PYG{n}{Phii}\PYG{p}{(}\PYG{n}{Thii}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{fespace} \PYG{n+nf}{Vhii}\PYG{p}{(}\PYG{n}{Thii}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vhi} \PYG{n}{sumphi} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{Vhii} \PYG{n}{phii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

        \PYG{n}{jpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{njpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{nlayer} \PYG{o}{=} \PYG{n}{RAS} \PYG{o}{?} \PYG{l+m+mi}{1} \PYG{o}{:} \PYG{n}{sizeoverlaps}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nlayer = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nlayer} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{n}{pii} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{unssd}\PYG{o}{\PYGZhy{}}\PYG{n}{nnn}\PYG{o}{+}\PYG{n}{nlayer}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nlayer}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{pii}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ 0000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ summ 0000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{real} \PYG{n}{epsmes} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{o}{*}\PYG{n}{Thii}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{npart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ipart}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{Phii} \PYG{n}{suppii} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{part}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.2}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{suppii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{AddLayers}\PYG{p}{(}\PYG{n}{Thii}\PYG{p}{,} \PYG{n}{suppii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nlayer}\PYG{p}{,} \PYG{n}{phii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{phii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{real} \PYG{n}{interij} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{phii}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{interij} \PYG{o}{\PYGZgt{}} \PYG{n}{epsmes}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                    \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{phii}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
                        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ***** }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{phii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
                    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
                        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ j = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{i} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
                        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ sum j = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{i} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{njpart}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
            \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{jpart}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
            \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ipart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ number of jpart }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{njpart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
                \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
            \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum min }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e\PYGZhy{}6} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Thii is remove here}
\PYG{c+c1}{// end of the construction of the local partition of the unity ...}
\PYG{c+c1}{// on Thi}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End build partition}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Computation of number of intersection}
\PYG{c+c1}{//here pii and the pij is the local partition of the unit on}
\PYG{c+c1}{//Thi (mesh with overlap)}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{dplot}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ j=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{j}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//Partition of the unity on Thi}
\PYG{c+c1}{//computation of message}
\PYG{c+c1}{//all j \PYGZgt{} we have to receive}
\PYG{c+c1}{//data on intersection of the support of pij[0] and pij[j]}
\PYG{n}{settt}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
    \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pi\PYGZus{}i}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{aThij}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Pii}\PYG{p}{;}
\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//M of send to j}
\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//M to recv from j}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whi}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{Thi}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whij}\PYG{p}{(}\PYG{n}{Thij}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//}

\PYG{c+c1}{//construction of the mesh intersect i,j part}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}
    \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//mesh of the supp of pij}

\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}
    \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{n}{ksplit}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Thi} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{n}{ksplit}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{settt}

\PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End build mesh intersection}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Construction of transfert matrix}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Whi} \PYG{n}{wpii} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{;}
    \PYG{n}{Pii} \PYG{o}{=} \PYG{n}{wpii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{matrix} \PYG{n}{I} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whji \PYGZlt{}\PYGZhy{} Whi}
        \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n}{I}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;} \PYG{c+c1}{//Whi \PYGZhy{}\PYGZgt{} s Whij}
        \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whji \PYGZhy{}\PYGZgt{} Whi}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{p}{\PYGZob{}}\PYG{n}{Whi} \PYG{n}{uuu}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{Whij} \PYG{n}{vvv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{I}\PYG{o}{*}\PYG{n}{uuu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jp} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZpc{}\PYGZpc{}\PYGZpc{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZob{}}\PYG{n}{Whi} \PYG{n}{uuu}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{Whij} \PYG{n}{vvv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{rMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{uuu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jp} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZsh{}\PYGZsh{}\PYGZsh{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End build transfert matrix}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Allocate array of send and recv data}
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Usend}\PYG{p}{)} \PYG{c+c1}{//initU(n, Vh, Th, aTh, U)}
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Vrecv}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End init data for send/revc}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{Whi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{vi}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{Update}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ui}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{vi}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{n}{Usend}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;}
    \PYG{n}{SendRecvUV}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{jpart}\PYG{p}{,} \PYG{n}{Usend}\PYG{p}{,} \PYG{n}{Vrecv}\PYG{p}{)}
    \PYG{n}{vi} \PYG{o}{=} \PYG{n}{Pii}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{n}{vi} \PYG{o}{+}\PYG{o}{=} \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Vrecv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{return} \PYG{k+kr}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Definition of the Problem}
\PYG{k+kt}{func} \PYG{n}{G} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{F} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{varf} \PYG{n}{vBC} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{G}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPb} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{F}\PYG{o}{*}\PYG{n}{V}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{G}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPbC} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{ThC}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPbon} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPbon10only} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//remark the order is important we want 0 part on 10 and 1}

\PYG{k+kt}{matrix} \PYG{n}{Ai} \PYG{o}{=} \PYG{n}{vPb}\PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{AC}\PYG{p}{,} \PYG{n}{Rci}\PYG{p}{,} \PYG{n}{Pci}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{AC} \PYG{o}{=} \PYG{n}{vPbC}\PYG{p}{(}\PYG{n}{VhC}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Pci} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Rci} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onG10} \PYG{o}{=} \PYG{n}{vPbon10only}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onG} \PYG{o}{=} \PYG{n}{vPbon}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Bi}\PYG{o}{=}\PYG{n}{vPb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{kiter} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{CoarseSolve}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{V}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{,} \PYG{k+kt}{mpiComm} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//solving the coarse probleme}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uc}\PYG{p}{(}\PYG{n}{Rci}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{Rci}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n+nf}{mpiReduce}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{mpiSUM}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{AC}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{Bc}\PYG{p}{;}
    \PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Uc}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{*}\PYG{n}{Uc}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{o}{+}\PYG{o}{+}\PYG{n}{kiter}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{onG10} \PYG{o}{?} \PYG{l+m+mf}{0.}\PYG{o}{:} \PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//remove internal boundary}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG10} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{CoarseSolve}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//\PYGZhy{}C2*Uo}
    \PYG{n}{U} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//U = (I\PYGZhy{}A C2) Uo}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG10} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{U} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{// (C1( I \PYGZhy{}A C2) Uo}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{U} \PYG{o}{\PYGZhy{}}\PYG{n}{V}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ0}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{o}{+}\PYG{o}{+}\PYG{n}{kiter}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{U}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Whi} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{p}{\PYGZob{}} \PYG{c+c1}{//verification}
    \PYG{n}{Whi} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{settt}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vBC}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set u with tgv BC value}

\PYG{k+kt}{real} \PYG{n}{epss} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rgmres} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPIAffineGMRES}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi}\PYG{p}{;}
    \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJC}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{c+c1}{//algo Shwarz for demo}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}

        \PYG{n}{Update}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
            \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

        \PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{umax} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{aa} \PYG{o}{=} \PYG{p}{[}\PYG{k+kp}{err}\PYG{p}{,} \PYG{n}{umax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{mpiAllReduce}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{k+kp}{errg} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{umaxg} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ipart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{errg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ u. max }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{umaxg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{k+kp}{errg} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
    \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u\PYGZhy{}final}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{settt}

\PYG{k+kt}{real} \PYG{k+kp}{errg} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{umaxg}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{umax} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{,} \PYG{n}{umaxg}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{aa} \PYG{o}{=} \PYG{p}{[}\PYG{n}{umax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{mpiAllReduce}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{errg} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{umax global = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Wtime = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{ittt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{ittt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ s }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{kiter} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{sff} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{ff}\PYG{p}{(}\PYG{n}{sff}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{append}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ++++ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{o}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpisize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ k=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ n= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sizeoverlaps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ it= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{kiter}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ittt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{epss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{n}{nbcoef} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+cm}{/*}
\PYG{c+cm}{    1 mpirank}
\PYG{c+cm}{    2 mpisize}
\PYG{c+cm}{    3 ksplit}
\PYG{c+cm}{    4 nloc}
\PYG{c+cm}{    5 sizeoverlaps}
\PYG{c+cm}{    6 kiter}
\PYG{c+cm}{    7 mesh \PYGZam{} part build}
\PYG{c+cm}{    8 build the partion}
\PYG{c+cm}{    9 build mesh, transfere , and the fine mesh ..}
\PYG{c+cm}{    10 build the matrix, the trans matrix, factorizatioon}
\PYG{c+cm}{    11 GMRES}
\PYG{c+cm}{    */}

    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpisize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sPk} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sizeoverlaps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{kiter}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ittt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{epss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{n}{nbcoef} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{gmres} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MPIGMRES2D}.png}
\caption{Results}\label{\detokenize{example/parallelization:id1}}\end{figure}


\subsection{MPI-GMRES 3D}
\label{\detokenize{example/parallelization:mpi-gmres-3d}}\label{\detokenize{example/parallelization:examplempigmres3d}}
\begin{sphinxadmonition}{note}{\label{example/parallelization:index-0}Todo:}
todo
\end{sphinxadmonition}


\subsection{Direct solvers}
\label{\detokenize{example/parallelization:direct-solvers}}\label{\detokenize{example/parallelization:exampledirectsolvers}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MUMPS\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}SuperLU\PYGZus{}DIST\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kr}{default} \PYG{k+kp}{solver}\PYG{o}{:} \PYG{k+kt}{real}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{SuperLU\PYGZus{}DIST}\PYG{p}{,} \PYG{k+kt}{complex} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{MUMPS}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}pastix\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} pastix, complex \PYGZhy{}\PYGZgt{} MUMPS}

\PYG{c+c1}{// Solving with pastix}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10} \PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffpastix\PYGZus{}iparm\PYGZus{}dparm.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with SuperLU\PYGZus{}DIST}
\PYG{n}{realdefaulttoSuperLUdist}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} SuperLU\PYGZus{}DIST, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10} \PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffsuperlu\PYGZus{}dist\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with MUMPS}
\PYG{n}{defaulttoMUMPS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10} \PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solving solution}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Solver MUMPS}
\label{\detokenize{example/parallelization:solver-mumps}}\label{\detokenize{example/parallelization:examplesolvermumps}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MUMPS\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ICNTL}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//declaration of ICNTL parameter for MUMPS}

\PYG{c+c1}{//get value of ICNTL from file}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ifstream} \PYG{n}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{string} \PYG{n}{line}\PYG{p}{;}
    \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{40}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{ff} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ICNTL}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]}\PYG{p}{;}
        \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ICNTL}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Given data of MUMPS solver in array lparams(SYM, PAR, ICNTL)}
\PYG{c+c1}{// There is no symmetric storage for a matrix associated with a sparse solver.}
\PYG{c+c1}{// Therefore, the matrix will be considered unsymmetric for parallel sparse solver even if symmetric.}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{int} \PYG{n}{SYM} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{PAR} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}
            \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}
        \PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Construction of integer parameter for MUMPS}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{MumpsLParams}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{MumpsLParams}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{SYM}\PYG{p}{;}
    \PYG{n}{MumpsLParams}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PAR}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{40}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{MumpsLParams}\PYG{p}{[}\PYG{n}{ii}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ICNTL}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//ICNTL begin with index 0 here}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{MumpsLParams}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//we take the default value for CNTL MUMPS parameter}

    \PYG{c+c1}{// Solve}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Read parameter of MUMPS solver in file ffmumps\PYGZus{}fileparam.txt}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}
            \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}
        \PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7000}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Solver superLU\_DIST}
\label{\detokenize{example/parallelization:solver-superlu-dist}}\label{\detokenize{example/parallelization:examplesolversuperludist}}
\begin{sphinxadmonition}{note}{\label{example/parallelization:index-1}Todo:}
write code (SuperLU\_DIST seems to have a bug)
\end{sphinxadmonition}


\subsection{Solver PaStiX}
\label{\detokenize{example/parallelization:solver-pastix}}\label{\detokenize{example/parallelization:examplesolverpastix}}
\begin{sphinxadmonition}{note}{\label{example/parallelization:index-2}Todo:}
write code (PaStiX seems to have a bug)
\end{sphinxadmonition}


\section{Developers}
\label{\detokenize{example/developers:developers}}\label{\detokenize{example/developers:exampledevelopers}}\label{\detokenize{example/developers::doc}}

\subsection{FFT}
\label{\detokenize{example/developers:fft}}\label{\detokenize{example/developers:examplefft}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{dfft}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{l+m+mi}{32}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ny} \PYG{o}{=} \PYG{l+m+mi}{16}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{N} \PYG{o}{=} \PYG{n}{nx}\PYG{o}{*}\PYG{n}{ny}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{c+c1}{//warning: the fourier space is not exactly the unit square due to periodic condition}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{nx}\PYG{p}{,} \PYG{p}{(}\PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{/}\PYG{n}{ny}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//warning: the numbering of the vertices (x,y) is}
\PYG{c+c1}{//given by i = x/nx + nx*y/ny}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{u} \PYG{o}{=} \PYG{n}{f1}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{w} \PYG{o}{=} \PYG{n}{f1}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ur}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{;}

\PYG{c+c1}{// FFT}
\PYG{c+c1}{//in dfft the matrix n, m is in row\PYGZhy{}major order and array n, m is}
\PYG{c+c1}{//store j + m*i (the transpose of the square numbering)}
\PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{}u\textbar{}\textbar{}\PYGZus{}}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{infty }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{N}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{}u\textbar{}\textbar{}\PYGZus{}}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{infty }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{ur} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{ur}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{v} \PYG{o}{=} \PYG{n}{w} \PYG{o}{\PYGZhy{}} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{diff = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n}{norm}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{norm}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Other example}
\PYG{c+c1}{//FFT Lapacian}
\PYG{c+c1}{//\PYGZhy{}\PYGZbs{}Delta u = f with biperiodic condition}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{13.}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the exact solution}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{ff} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{fhat}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{wij}\PYG{p}{;}

\PYG{c+c1}{// FFT}
\PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ny}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//warning in fact we take mode between \PYGZhy{}nx/2, nx/2 and \PYGZhy{}ny/2, ny/2}
\PYG{c+c1}{//thanks to the operator ?:}
\PYG{n}{wij} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(} \PYG{k+kr}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{o}{?}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nl}{nx}\PYG{o}{:}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{nx}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{o}{?}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nl}{ny}\PYG{o}{:}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{ny}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{;} \PYG{c+c1}{//to remove div / 0}
\PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{/}\PYG{o}{=} \PYG{k+kt}{complex}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ur} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the solution}
\PYG{n}{w} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{ue}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the exact solution}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{ur}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ue}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{ur}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{w}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{w}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{fftwplan} \PYG{n}{p1} \PYG{o}{=} \PYG{n}{plandfft}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{fftwplan} \PYG{n}{p2} \PYG{o}{=} \PYG{n}{plandfft}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ccc} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ny = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ny} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{map}\PYG{p}{(}\PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{n}{ccc}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{wij}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wij}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Complex}
\label{\detokenize{example/developers:complex}}\label{\detokenize{example/developers:examplecomplex}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{2.45}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{5.33}\PYG{p}{;}
\PYG{k+kt}{complex} \PYG{n}{z1} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{,} \PYG{n}{z2} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{k+kt}{string} \PYG{n+nf}{pc}\PYG{p}{(}\PYG{k+kt}{complex} \PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{string} \PYG{n}{r} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{k+kt}{real}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{imag}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{r} \PYG{o}{=} \PYG{n}{r} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{r} \PYG{o}{+} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{i)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{string} \PYG{n+nf}{toPolar}\PYG{p}{(}\PYG{k+kt}{complex} \PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}\PYG{c+c1}{//abs(z) + \PYGZdq{}*(cos(\PYGZdq{} + arg(z) + \PYGZdq{})+i*sin(\PYGZdq{} + arg(z) + \PYGZdq{}))\PYGZdq{};}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Standard output of the complex }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ is the pair: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{z1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ + }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{+}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZhy{}}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ * }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{*}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ / }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{/}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Real part of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Imaginary part of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abs(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Polar coordinates of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{toPolar}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{de Moivre formula: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZca{}3 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{toPolar}\PYG{p}{(}\PYG{n}{z2}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ and polar(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{arg}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n+nf}{polar}\PYG{p}{(}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{arg}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Conjugate of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n+nf}{conj}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZca{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZca{}}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

Output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Standard output of the complex \PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} is the pair: \PYG{o}{(}\PYG{l+m}{2}.45,5.33\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} + \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{4}.9+6.74421i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYGZhy{} \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{0}+3.91579i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} * \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYGZhy{}1.53526+16.5233i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} / \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{1}.692+1.19883i\PYG{o}{)}
Real part of \PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{2}.45
Imaginary part of \PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{5}.33
abs\PYG{o}{(}\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)}\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{5}.86612
Polar coordinates of \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=}
de Moivre formula: \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)}\PYGZca{}3 \PYG{o}{=}
 and polar\PYG{o}{(}\PYG{l+m}{2}.82887, \PYG{l+m}{0}.523509\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)}
Conjugate of \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{2}.45\PYGZhy{}1.41421i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYGZca{} \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{8}.37072\PYGZhy{}12.7078i\PYG{o}{)}
\end{sphinxVerbatim}


\subsection{String}
\label{\detokenize{example/developers:string}}\label{\detokenize{example/developers:examplestring}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Concatenation}
\PYG{k+kt}{string} \PYG{n}{tt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto1}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{} 77}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Append}
\PYG{k+kt}{string} \PYG{n}{t1} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0123456789}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{t1}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcdefghijk\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Sub string}
\PYG{k+kt}{string} \PYG{n}{t55} \PYG{o}{=} \PYG{n}{t1}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{:}\PYG{l+m+mi}{14}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tt = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tt} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.find(abc) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.rfind(abc) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{rfind}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.find(abc, 10) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.ffind(abc, 10) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{rfind}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.length = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{length} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t55 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t55} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{tt} \PYG{o}{=} toto11 \PYGZhy{}\PYGZhy{} \PYG{l+m}{77}
\PYG{n+nv}{t1} \PYG{o}{=} 0123abcdefghijk\PYGZhy{}456789
t1.find\PYG{o}{(}abc\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{4}
t1.rfind\PYG{o}{(}abc\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{4}
t1.find\PYG{o}{(}abc, \PYG{l+m}{10}\PYG{o}{)} \PYG{o}{=} \PYGZhy{}1
t1.ffind\PYG{o}{(}abc, \PYG{l+m}{10}\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{4}
t1.length \PYG{o}{=} \PYG{l+m}{22}
\PYG{n+nv}{t55} \PYG{o}{=} abcdefghijk
\end{sphinxVerbatim}


\subsection{Elementary function}
\label{\detokenize{example/developers:elementary-function}}\label{\detokenize{example/developers:exampleelementaryfunction}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{phix}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{phiy}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{phix}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{phiy}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{ElementaryFunction}.png}
\caption{Mesh}\label{\detokenize{example/developers:id1}}\end{figure}


\subsection{Array}
\label{\detokenize{example/developers:array}}\label{\detokenize{example/developers:examplearray}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{tab}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{tab1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2 array of 10 real}
\PYG{c+c1}{//real[int] tab2; //bug: array with no size}

\PYG{n}{tab} \PYG{o}{=} \PYG{l+m+mf}{1.03}\PYG{p}{;} \PYG{c+c1}{//set all the array to 1.03}
\PYG{n}{tab}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{2.15}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tab: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab}\PYG{p}{.}\PYG{k+kr}{sum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{tab}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//change the size of array tab to 12 with preserving first value}
\PYG{n}{tab}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{:}\PYG{l+m+mi}{11}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{3.14}\PYG{p}{;} \PYG{c+c1}{//set values 10 \PYGZam{} 11}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{resized tab: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{tab}\PYG{p}{.}\PYG{n+nf}{sort} \PYG{p}{;} \PYG{c+c1}{//sort the array tab}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sorted tab:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{tt}\PYG{p}{;} \PYG{c+c1}{//array with string index}
\PYG{n}{tt}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tt[}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tt}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tt[}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{o}{+}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tt}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{c} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1 : d[i] = a[i] ? b[i] : c[i]}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ d = ( a ? b : c ) is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{l+m+mi}{1} \PYG{o}{:} \PYG{n}{c} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1: d[i] = a[i] ? 1 : c[i]}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1: d[i] = a[i] ? b[i] : 0}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{l+m+mi}{1} \PYG{o}{:} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1: d[i] = a[i] ? 0 : 1}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ii}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n+nf}{d}\PYG{p}{.}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set array ii to 0, 1, ..., d.n\PYGZhy{}1}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{c+c1}{//set d to \PYGZhy{}1, \PYGZhy{}2, ..., \PYGZhy{}5}

\PYG{n+nf}{sort}\PYG{p}{(}\PYG{n+nf}{d}\PYG{p}{,} \PYG{n}{ii}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//sort array d and ii in parallel}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{d: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ii: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 3, 4, 5, 6, 7, 8, 9, 10}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{A2}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 5, 8}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A1(2:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A2(2:3:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{A1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1:2:5 =\PYGZgt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 3, 4, 5, 6, 7, 8, 9, 10}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{A2}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 5, 8}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A1(2:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A2(2:3:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{A1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{:}\PYG{l+m+mf}{0.5}\PYG{o}{:}\PYG{l+m+mf}{3.999}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.:0.5:3.999 =\PYGZgt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{n+nl}{i}\PYG{o}{:}\PYG{l+m+mf}{10.}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 3, 4, 5, 6, 7, 8, 9, 10}
    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{A2}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{:}\PYG{l+m+mf}{3.}\PYG{o}{:}\PYG{l+m+mf}{10.}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 5, 8}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A1(2.+0i:10.+0i): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A2(2.:3.:10.)= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{A2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A1.re real part array: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1}\PYG{p}{.}\PYG{k+kr}{re} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}
    \PYG{c+c1}{// he real part array of the complex array}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A1.im imag part array: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1}\PYG{p}{.}\PYG{k+kr}{im} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}
    \PYG{c+c1}{//the imaginary part array of the complex array}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Integer array operators}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{4}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = a + a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b += a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b += 2*a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ b /= 2: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{p}{.}\PYG{o}{*}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{// same as b = b .* a}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b .*= a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{p}{.}\PYG{o}{/}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{//same as b = b ./ a}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b ./= a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a + b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = 2*a + 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a + 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = \PYGZhy{}a + 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = \PYGZhy{}a \PYGZhy{} 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = \PYGZhy{}a \PYGZhy{}b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{p}{.}\PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a .* b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{p}{.}\PYG{o}{/} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a ./ b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = 2 * b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{b} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = b * 2: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//this operator do not exist}
    \PYG{c+c1}{//c = b/2;}
    \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}c = b / 2: \PYGZdq{} \PYGZlt{}\PYGZlt{} c \PYGZlt{}\PYGZlt{} endl;}

    \PYG{c+c1}{//Array methods}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{}a\textbar{}\textbar{}\PYGZus{}1 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{l1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{}a\textbar{}\textbar{}\PYGZus{}2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{}a\textbar{}\textbar{}\PYGZus{}infty = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum a\PYGZus{}i = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{sum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max a\PYGZus{}i = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ a[ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{[}\PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imax}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min a\PYGZus{}i = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ a[ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{[}\PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imin}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a\PYGZsq{} * a = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a quantile 0.2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{quantile}\PYG{p}{(}\PYG{l+m+mf}{0.2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//Array mapping}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{I} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for (i = 0; i \PYGZlt{} b.n; i++) if (I[i] \PYGZgt{}= 0) b[i] = a[I[i]];}
    \PYG{n}{c}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)} \PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{//for (i = 0; i \PYGZlt{} I.n; i++) if (I[i] \PYGZgt{}= 0) C(I[i]) = a[i];}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = a(I) : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c(I) = a }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{//for (i = 0; i \PYGZlt{} I.n; i++) if (I[i] \PYGZgt{}= 0) C(I[i]) += a[i];}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = a(I) : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c(I) = a }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Array versus matrix}
    \PYG{k+kt}{int} \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{M} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{n}{M}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{n}{M}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{cb} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cc} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}

    \PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{I} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{J} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//set all the matrix}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{c+c1}{//the full line 2}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{o}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{c+c1}{//the full column 1}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{k+kr}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//set the column 2}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{c+c1}{//set the line 1 from 0 to 2}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//outer product}
    \PYG{n}{C} \PYG{o}{=} \PYG{n}{cb} \PYG{o}{*} \PYG{n}{cc}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{n}{C} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{cb} \PYG{o}{*} \PYG{n}{cc}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{n}{C} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{n}{i} \PYG{o}{*} \PYG{n}{cb} \PYG{o}{*} \PYG{n}{cc}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{C} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//this transforms an array into a sparse matrix}
    \PYG{k+kt}{matrix} \PYG{k+kp}{B}\PYG{p}{;}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{;}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//B(i, j) = A(I(i), J(j))}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{I}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{J}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//B(I(i), J(j)) = A(i,j)}

    \PYG{c+c1}{//outer product}
    \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{b} \PYG{o}{*} \PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{;} \PYG{c+c1}{//outer product B(i, j) = b(i)*c(j)}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{;} \PYG{c+c1}{//outer product B(i, j) = b(i)*c(j)}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{(}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//outer product B(i, j) = b(I(i))*c(J(j))}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{(}\PYG{n}{I}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{J}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//outer product B(I(i), J(j)) = b(i)*c(j)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{B = (3.*b*c\PYGZsq{})(I\PYGZca{}\PYGZhy{}1,J\PYGZca{}\PYGZhy{}1) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{B} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//row and column of the maximal coefficient of A}
    \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{ii}\PYG{p}{,} \PYG{n}{jj}\PYG{p}{;}
    \PYG{n}{ijmax}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{ii}\PYG{p}{,} \PYG{n}{jj}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{i} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{imax}\PYG{p}{;}
    \PYG{n}{j} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{n}{jmax}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Max }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//row and column of the minimal coefficient of A}
    \PYG{n}{ijmin}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{ii} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{imin}\PYG{p}{;}
    \PYG{n}{jj} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{n}{jmin}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Min }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jj} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The output os this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
tab: \PYG{l+m}{10}
    \PYG{l+m}{1}.03    \PYG{l+m}{2}.15    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03

min: \PYG{l+m}{1}.03
max: \PYG{l+m}{2}.15
sum: \PYG{l+m}{11}.42
resized tab: \PYG{l+m}{12}
    \PYG{l+m}{1}.03    \PYG{l+m}{2}.15    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{3}.14    \PYG{l+m}{3}.14
sorted tab:12
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{2}.15
    \PYG{l+m}{3}.14    \PYG{l+m}{3}.14
tt\PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}a\PYGZdq{}}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{0}
tt\PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}+\PYGZdq{}}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}.5
 \PYG{n+nv}{d} \PYG{o}{=} \PYG{o}{(} a ? b : c \PYG{o}{)} is \PYG{l+m}{5}
      \PYG{l+m}{2}   \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{2}   \PYG{l+m}{2}

d: \PYG{l+m}{5}
     \PYGZhy{}5  \PYGZhy{}4  \PYGZhy{}3  \PYGZhy{}2  \PYGZhy{}1

ii: \PYG{l+m}{5}
      \PYG{l+m}{4}   \PYG{l+m}{3}   \PYG{l+m}{2}   \PYG{l+m}{1}   \PYG{l+m}{0}

A1\PYG{o}{(}\PYG{l+m}{2}:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
A2\PYG{o}{(}\PYG{l+m}{2}:3:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
\PYG{l+m}{1}:2:5 \PYG{o}{=}\PYGZgt{} \PYG{l+m}{3}
      \PYG{l+m}{1}   \PYG{l+m}{3}   \PYG{l+m}{5}
A1\PYG{o}{(}\PYG{l+m}{2}:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
A2\PYG{o}{(}\PYG{l+m}{2}:3:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
\PYG{l+m}{1}.:0.5:3.999 \PYG{o}{=}\PYGZgt{} \PYG{l+m}{6}
      \PYG{l+m}{1} \PYG{l+m}{1}.5   \PYG{l+m}{2} \PYG{l+m}{2}.5   \PYG{l+m}{3}
    \PYG{l+m}{3}.5
 A1\PYG{o}{(}\PYG{l+m}{2}.+0i:10.+0i\PYG{o}{)}: \PYG{l+m}{9}
    \PYG{o}{(}\PYG{l+m}{2},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{3},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{4},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{5},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{6},0\PYG{o}{)}
    \PYG{o}{(}\PYG{l+m}{7},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{8},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{9},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{10},0\PYG{o}{)}
 A2\PYG{o}{(}\PYG{l+m}{2}.:3.:10.\PYG{o}{)}\PYG{o}{=} \PYG{l+m}{3}
    \PYG{o}{(}\PYG{l+m}{2},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{5},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{8},0\PYG{o}{)}
 A1.re real part array: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
 A1.im imag part array: \PYG{l+m}{9}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
a: \PYG{l+m}{5}
      \PYG{l+m}{2}   \PYG{l+m}{1}   \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{4}

\PYG{n+nv}{b} \PYG{o}{=} a + a: \PYG{l+m}{5}
      \PYG{l+m}{4}   \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{8}   \PYG{l+m}{8}

\PYG{n+nv}{b} \PYG{o}{+=} a: \PYG{l+m}{5}
      \PYG{l+m}{6}   \PYG{l+m}{3}   \PYG{l+m}{6}  \PYG{l+m}{12}  \PYG{l+m}{12}

\PYG{n+nv}{b} \PYG{o}{+=} \PYG{l+m}{2}*a: \PYG{l+m}{5}
     \PYG{l+m}{10}   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{20}  \PYG{l+m}{20}

 b /\PYG{o}{=} \PYG{l+m}{2}: \PYG{l+m}{5}
      \PYG{l+m}{5} \PYG{l+m}{2}.5   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{10}

b .*\PYG{o}{=} a: \PYG{l+m}{5}
     \PYG{l+m}{10} \PYG{l+m}{2}.5  \PYG{l+m}{10}  \PYG{l+m}{40}  \PYG{l+m}{40}

b ./\PYG{o}{=} a: \PYG{l+m}{5}
      \PYG{l+m}{5} \PYG{l+m}{2}.5   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{10}

\PYG{n+nv}{c} \PYG{o}{=} a + b: \PYG{l+m}{5}
      \PYG{l+m}{7} \PYG{l+m}{3}.5   \PYG{l+m}{7}  \PYG{l+m}{14}  \PYG{l+m}{14}

\PYG{n+nv}{c} \PYG{o}{=} \PYG{l+m}{2}*a + 4b: \PYG{l+m}{5}
     \PYG{l+m}{24}  \PYG{l+m}{12}  \PYG{l+m}{24}  \PYG{l+m}{48}  \PYG{l+m}{48}

\PYG{n+nv}{c} \PYG{o}{=} a + 4b: \PYG{l+m}{5}
     \PYG{l+m}{22}  \PYG{l+m}{11}  \PYG{l+m}{22}  \PYG{l+m}{44}  \PYG{l+m}{44}

\PYG{n+nv}{c} \PYG{o}{=} \PYGZhy{}a + 4b: \PYG{l+m}{5}
     \PYG{l+m}{18}   \PYG{l+m}{9}  \PYG{l+m}{18}  \PYG{l+m}{36}  \PYG{l+m}{36}

\PYG{n+nv}{c} \PYG{o}{=} \PYGZhy{}a \PYGZhy{} 4b: \PYG{l+m}{5}
    \PYGZhy{}22 \PYGZhy{}11 \PYGZhy{}22 \PYGZhy{}44 \PYGZhy{}44

\PYG{n+nv}{c} \PYG{o}{=} \PYGZhy{}a \PYGZhy{}b: \PYG{l+m}{5}
     \PYGZhy{}7 \PYGZhy{}3.5     \PYGZhy{}7 \PYGZhy{}14 \PYGZhy{}14

\PYG{n+nv}{c} \PYG{o}{=} a .* b: \PYG{l+m}{5}
     \PYG{l+m}{10} \PYG{l+m}{2}.5  \PYG{l+m}{10}  \PYG{l+m}{40}  \PYG{l+m}{40}

\PYG{n+nv}{c} \PYG{o}{=} a ./ b: \PYG{l+m}{5}
    \PYG{l+m}{0}.4 \PYG{l+m}{0}.4 \PYG{l+m}{0}.4 \PYG{l+m}{0}.4 \PYG{l+m}{0}.4

\PYG{n+nv}{c} \PYG{o}{=} \PYG{l+m}{2} * b: \PYG{l+m}{5}
     \PYG{l+m}{10}   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{20}  \PYG{l+m}{20}

\PYG{n+nv}{c} \PYG{o}{=} b * \PYG{l+m}{2}: \PYG{l+m}{5}
     \PYG{l+m}{10}   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{20}  \PYG{l+m}{20}

\PYG{o}{\textbar{}\textbar{}}a\PYG{o}{\textbar{}\textbar{}}\PYG{n+nv}{\PYGZus{}1} \PYG{o}{=} \PYG{l+m}{13}
\PYG{o}{\textbar{}\textbar{}}a\PYG{o}{\textbar{}\textbar{}}\PYG{n+nv}{\PYGZus{}2} \PYG{o}{=} \PYG{l+m}{6}.40312
\PYG{o}{\textbar{}\textbar{}}a\PYG{o}{\textbar{}\textbar{}}\PYG{n+nv}{\PYGZus{}infty} \PYG{o}{=} \PYG{l+m}{4}
sum \PYG{n+nv}{a\PYGZus{}i} \PYG{o}{=} \PYG{l+m}{13}
max \PYG{n+nv}{a\PYGZus{}i} \PYG{o}{=} \PYG{l+m}{4} a\PYG{o}{[} \PYG{l+m}{3} \PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}
min \PYG{n+nv}{a\PYGZus{}i} \PYG{o}{=} \PYG{l+m}{1} a\PYG{o}{[} \PYG{l+m}{1} \PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}
a\PYG{l+s+s1}{\PYGZsq{} * a = 41}
\PYG{l+s+s1}{a quantile 0.2 = 2}
\PYG{l+s+s1}{b = a(I) : 5}
\PYG{l+s+s1}{      2   4   4  \PYGZhy{}3   4}

\PYG{l+s+s1}{c(I) = a 5}
\PYG{l+s+s1}{     \PYGZhy{}3  \PYGZhy{}3   2   4   2}

\PYG{l+s+s1}{b = a(I) : 5}
\PYG{l+s+s1}{      2   4   4  \PYGZhy{}3   4}

\PYG{l+s+s1}{c(I) = a 5}
\PYG{l+s+s1}{     \PYGZhy{}3  \PYGZhy{}3   4   9   4}

\PYG{l+s+s1}{A = 3 4}
\PYG{l+s+s1}{       1   5   2   1}
\PYG{l+s+s1}{       3   3   3   1}
\PYG{l+s+s1}{       4   5   2   4}

\PYG{l+s+s1}{C = 3 4}
\PYG{l+s+s1}{     (\PYGZhy{}50,\PYGZhy{}40) (\PYGZhy{}100,\PYGZhy{}80) (\PYGZhy{}150,\PYGZhy{}120) (\PYGZhy{}200,\PYGZhy{}160)}
\PYG{l+s+s1}{     (\PYGZhy{}100,\PYGZhy{}80) (\PYGZhy{}200,\PYGZhy{}160) (\PYGZhy{}300,\PYGZhy{}240) (\PYGZhy{}400,\PYGZhy{}320)}
\PYG{l+s+s1}{     (\PYGZhy{}150,\PYGZhy{}120) (\PYGZhy{}300,\PYGZhy{}240) (\PYGZhy{}450,\PYGZhy{}360) (\PYGZhy{}600,\PYGZhy{}480)}

\PYG{l+s+s1}{A = 3 4}
\PYG{l+s+s1}{       8  10  12  14}
\PYG{l+s+s1}{      16  20  24  28}
\PYG{l+s+s1}{      24  30  36  42}

\PYG{l+s+s1}{B = (3.*b*c\PYGZsq{}}\PYG{o}{)}\PYG{o}{(}I\PYGZca{}\PYGZhy{}1,J\PYGZca{}\PYGZhy{}1\PYG{o}{)} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{3} \PYG{l+m}{4} \PYG{l+m}{0}  \PYG{l+m}{12}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYG{l+m}{10}
        \PYG{l+m}{1}         \PYG{l+m}{2} \PYG{l+m}{12}
        \PYG{l+m}{1}         \PYG{l+m}{3} \PYG{l+m}{8}
        \PYG{l+m}{1}         \PYG{l+m}{4} \PYG{l+m}{14}
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYG{l+m}{15}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{l+m}{18}
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYG{l+m}{12}
        \PYG{l+m}{2}         \PYG{l+m}{4} \PYG{l+m}{21}
        \PYG{l+m}{3}         \PYG{l+m}{1} \PYG{l+m}{5}
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYG{l+m}{6}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{l+m}{4}
        \PYG{l+m}{3}         \PYG{l+m}{4} \PYG{l+m}{7}
\end{sphinxVerbatim}


\subsection{Block matrix}
\label{\detokenize{example/developers:block-matrix}}\label{\detokenize{example/developers:exampleblockmatrix}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{f2} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n}{Th2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Uh1}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh1} \PYG{n}{u1}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Uh2}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh2} \PYG{n}{u2}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n}{vPoisson1} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f1} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vPoisson2} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f1} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Poisson1} \PYG{o}{=} \PYG{n}{vPoisson1}\PYG{p}{(}\PYG{n}{Uh1}\PYG{p}{,} \PYG{n}{Uh1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Poisson1b} \PYG{o}{=} \PYG{n}{vPoisson1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Uh1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Poisson2} \PYG{o}{=} \PYG{n}{vPoisson2}\PYG{p}{(}\PYG{n}{Uh2}\PYG{p}{,} \PYG{n}{Uh2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Poisson2b} \PYG{o}{=} \PYG{n}{vPoisson2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Uh2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//block matrix}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{G} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{Poisson1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Poisson2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{G}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//block right hand side}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Gb} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Poisson1b}\PYG{p}{,} \PYG{n}{Poisson2b}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sol} \PYG{o}{=} \PYG{n}{G}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{Gb}\PYG{p}{;}

\PYG{c+c1}{// Dispatch}
\PYG{p}{[}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sol}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{BlockMatrix}.png}
\caption{Result}\label{\detokenize{example/developers:id2}}\end{figure}


\subsection{Matrix operations}
\label{\detokenize{example/developers:matrix-operations}}\label{\detokenize{example/developers:examplematrixoperations}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{f}\PYG{p}{,} \PYG{n}{g}\PYG{p}{;}
\PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{n}{g} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{ff}\PYG{p}{,} \PYG{n}{gg}\PYG{p}{;} \PYG{c+c1}{//a complex valued finite element function}
\PYG{n}{ff}\PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gg} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{mat} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{mati} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
         \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{n}{i}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{mat}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{AA} \PYG{o}{=} \PYG{n}{mati}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//a complex sparse matrix}

\PYG{c+c1}{// Operations}
\PYG{n}{Vh} \PYG{n}{m0}\PYG{p}{;} \PYG{n}{m0}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{m01}\PYG{p}{;} \PYG{n}{m01}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{m1}\PYG{p}{;} \PYG{n}{m1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{*}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{m2}\PYG{p}{;} \PYG{n}{m2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{/}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{g = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{g}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m0 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m0}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m01 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m01}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m1 = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m2 = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dot Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hermitien Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ff}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{gg}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{outer Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{o}{*}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hermitien outer Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{AA}\PYG{o}{=}\PYG{n}{ff}\PYG{p}{[}\PYG{p}{]}\PYG{o}{*}\PYG{n}{gg}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Diagonal}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{diagofA}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{diagofA} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag}\PYG{p}{;} \PYG{c+c1}{//get the diagonal of the matrix}
\PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag} \PYG{o}{=} \PYG{n}{diagofA} \PYG{p}{;} \PYG{c+c1}{//set the diagonal of the matrix}

\PYG{c+c1}{// Sparse matrix set}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{I}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{J}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{[}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{,} \PYG{n}{C}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{;} \PYG{c+c1}{//get the sparse term of the matrix A (the array are resized)}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{C} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{[}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{,} \PYG{n}{C}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//set a new matrix}
\PYG{k+kt}{matrix} \PYG{n}{D} \PYG{o}{=} \PYG{p}{[}\PYG{n}{diagofA}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//set a diagonal matrix D from the array diagofA}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{D = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{D} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{f} \PYG{o}{=} \PYG{l+m}{6}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0} \PYG{l+m}{0}.5
      \PYG{l+m}{1}
\PYG{n+nv}{g} \PYG{o}{=} \PYG{l+m}{6}
      \PYG{l+m}{0}   \PYG{l+m}{1} \PYG{l+m}{1}.224646799e\PYGZhy{}16   \PYG{l+m}{0}   \PYG{l+m}{1}
    \PYG{l+m}{1}.224646799e\PYGZhy{}16
\PYG{n+nv}{A} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{0}  \PYG{l+m}{24}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{1}         \PYG{l+m}{2} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{1}         \PYG{l+m}{4} \PYG{l+m}{0}
        \PYG{l+m}{1}         \PYG{l+m}{5} \PYGZhy{}2.5
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYG{l+m}{0}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{2}         \PYG{l+m}{5} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{2}         \PYG{l+m}{6} \PYGZhy{}2.5
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYG{l+m}{0}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{3}         \PYG{l+m}{6} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{4}         \PYG{l+m}{1} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{4}         \PYG{l+m}{4} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{4}         \PYG{l+m}{5} \PYG{l+m}{0}
        \PYG{l+m}{5}         \PYG{l+m}{1} \PYGZhy{}2.5
        \PYG{l+m}{5}         \PYG{l+m}{2} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{5}         \PYG{l+m}{4} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{5}         \PYG{l+m}{6} \PYG{l+m}{0}
        \PYG{l+m}{6}         \PYG{l+m}{2} \PYGZhy{}2.5
        \PYG{l+m}{6}         \PYG{l+m}{3} \PYG{l+m}{0}
        \PYG{l+m}{6}         \PYG{l+m}{5} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{l+m}{1}.0000000000000000199e+30

\PYG{n+nv}{m0} \PYG{o}{=} \PYG{l+m}{6}
    \PYGZhy{}1.25   \PYGZhy{}2.25   \PYG{l+m}{0}.5   \PYG{l+m}{0} 5e+29
    1e+30
\PYG{n+nv}{m01} \PYG{o}{=} \PYG{l+m}{6}
    \PYGZhy{}1.25   \PYGZhy{}2.25     \PYG{l+m}{0} \PYG{l+m}{0}.25    5e+29
    1e+30
\PYG{n+nv}{m1} \PYG{o}{=} \PYG{l+m}{6}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0} \PYG{l+m}{0}.5
    \PYG{l+m}{1}.224646799e\PYGZhy{}16
\PYG{n+nv}{m2} \PYG{o}{=} \PYG{l+m}{6}
    \PYGZhy{}nan      \PYG{l+m}{0}   \PYG{l+m}{0} \PYGZhy{}nan    \PYG{l+m}{0}.5
    \PYG{l+m}{8}.165619677e+15
dot \PYG{n+nv}{Product} \PYG{o}{=} \PYG{l+m}{0}.5
hermitien \PYG{n+nv}{Product} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{1}.11022e\PYGZhy{}16,2.5\PYG{o}{)}
outer \PYG{n+nv}{Product} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{0}  \PYG{l+m}{8}
        \PYG{l+m}{5}         \PYG{l+m}{2} \PYG{l+m}{0}.5
        \PYG{l+m}{5}         \PYG{l+m}{3} \PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{l+m}{0}.5
        \PYG{l+m}{5}         \PYG{l+m}{6} \PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17
        \PYG{l+m}{6}         \PYG{l+m}{2} \PYG{l+m}{1}
        \PYG{l+m}{6}         \PYG{l+m}{3} \PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16
        \PYG{l+m}{6}         \PYG{l+m}{5} \PYG{l+m}{1}
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16

hermitien outer \PYG{n+nv}{Product} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{0}  \PYG{l+m}{24}
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{0},0.5\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{0}.5,3.0616169978683830179e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYG{o}{(}\PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17,\PYGZhy{}0.5\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{0},0.5\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{0}.5,3.0616169978683830179e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{6} \PYG{o}{(}\PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17,\PYGZhy{}0.5\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{0},1\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{1},6.1232339957367660359e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{o}{(}\PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16,\PYGZhy{}1\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{0},1\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{1},6.1232339957367660359e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{6} \PYG{o}{(}\PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16,\PYGZhy{}1\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{0}.5,0.5\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{0}.5,\PYGZhy{}0.49999999999999994449\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{3} \PYG{o}{(}\PYGZhy{}0.49999999999999994449,\PYGZhy{}0.50000000000000011102\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{0}.5,0.5\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{0}.5,\PYGZhy{}0.49999999999999994449\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{6} \PYG{o}{(}\PYGZhy{}0.49999999999999994449,\PYGZhy{}0.50000000000000011102\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{1},1\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{1},\PYGZhy{}0.99999999999999988898\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{3} \PYG{o}{(}\PYGZhy{}0.99999999999999988898,\PYGZhy{}1.000000000000000222\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{1},1\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{1},\PYGZhy{}0.99999999999999988898\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{o}{(}\PYGZhy{}0.99999999999999988898,\PYGZhy{}1.000000000000000222\PYG{o}{)}

\PYG{n+nv}{I} \PYG{o}{=} \PYG{l+m}{8}
      \PYG{l+m}{4}   \PYG{l+m}{4}   \PYG{l+m}{4}   \PYG{l+m}{4}   \PYG{l+m}{5}
      \PYG{l+m}{5}   \PYG{l+m}{5}   \PYG{l+m}{5}
\PYG{n+nv}{J} \PYG{o}{=} \PYG{l+m}{8}
      \PYG{l+m}{1}   \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{1}
      \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{5}
\PYG{n+nv}{C} \PYG{o}{=} \PYG{l+m}{8}
    \PYG{l+m}{0}.5 \PYG{l+m}{6}.123233996e\PYGZhy{}17 \PYG{l+m}{0}.5 \PYG{l+m}{6}.123233996e\PYGZhy{}17   \PYG{l+m}{1}
    \PYG{l+m}{1}.224646799e\PYGZhy{}16   \PYG{l+m}{1} \PYG{l+m}{1}.224646799e\PYGZhy{}16
  \PYGZhy{}\PYGZhy{} Raw Matrix    \PYG{n+nv}{nxm}  \PYG{o}{=}6x6 nb  none zero coef. \PYG{l+m}{8}
  \PYGZhy{}\PYGZhy{} Raw Matrix    \PYG{n+nv}{nxm}  \PYG{o}{=}6x6 nb  none zero coef. \PYG{l+m}{6}
\PYG{n+nv}{D} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{1}  \PYG{l+m}{6}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYG{l+m}{0}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{l+m}{0}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{l+m}{0}
        \PYG{l+m}{4}         \PYG{l+m}{4} \PYG{l+m}{0}
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{l+m}{0}.5
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
Due to \sphinxcode{\sphinxupquote{Fortran}} indices starting at one, the output of a diagonal matrix \sphinxcode{\sphinxupquote{D}} is indexed from 1. but in \sphinxstylestrong{FreeFem++}, the indices start from 0.
\end{sphinxadmonition}


\subsection{Matrix inversion}
\label{\detokenize{example/developers:matrix-inversion}}\label{\detokenize{example/developers:examplematrixinversion}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lapack}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fflapack}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Matrix}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{n}{j}\PYG{p}{)} \PYG{o}{?} \PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Inversion (lapack)}
\PYG{k+kp}{A1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//def in \PYGZdq{}lapack\PYGZdq{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kp}{B} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
            \PYG{k+kp}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{A1}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{B} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Inversion (fflapack)}
\PYG{n}{inv}\PYG{p}{(}\PYG{k+kp}{A1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def in \PYGZdq{}fflapack\PYGZdq{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{5} \PYG{l+m}{5}
       \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}

\PYG{l+m}{5} \PYG{l+m}{5}
     \PYG{l+m}{0}.18 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYG{l+m}{0}.18 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYGZhy{}0.02 \PYG{l+m}{0}.18 \PYGZhy{}0.02 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYG{l+m}{0}.18 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYG{l+m}{0}.18

\PYG{l+m}{5} \PYG{l+m}{5}
       \PYG{l+m}{1} \PYG{l+m}{1}.040834086e\PYGZhy{}17 \PYG{l+m}{1}.040834086e\PYGZhy{}17 \PYG{l+m}{1}.734723476e\PYGZhy{}17 \PYG{l+m}{2}.775557562e\PYGZhy{}17
     \PYG{l+m}{3}.469446952e\PYGZhy{}18   \PYG{l+m}{1} \PYGZhy{}1.734723476e\PYGZhy{}17 \PYG{l+m}{1}.734723476e\PYGZhy{}17 \PYG{l+m}{2}.775557562e\PYGZhy{}17
     \PYG{l+m}{2}.428612866e\PYGZhy{}17 \PYGZhy{}3.122502257e\PYGZhy{}17   \PYG{l+m}{1} \PYG{l+m}{1}.734723476e\PYGZhy{}17 \PYG{l+m}{2}.775557562e\PYGZhy{}17
     \PYG{l+m}{2}.081668171e\PYGZhy{}17 \PYGZhy{}6.938893904e\PYGZhy{}17 \PYGZhy{}3.469446952e\PYGZhy{}17   \PYG{l+m}{1}   \PYG{l+m}{0}
     \PYG{l+m}{2}.775557562e\PYGZhy{}17 \PYGZhy{}4.163336342e\PYGZhy{}17 \PYGZhy{}2.775557562e\PYGZhy{}17   \PYG{l+m}{0}   \PYG{l+m}{1}

\PYG{l+m}{5} \PYG{l+m}{5}
       \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
To compile \sphinxcode{\sphinxupquote{lapack.cpp}} and \sphinxcode{\sphinxupquote{fflapack.cpp}}, you must have the \sphinxcode{\sphinxupquote{lapack}} library on your system and compile the plugin with the command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}c++ lapack.cpp \PYGZhy{}llapack     ff\PYGZhy{}c++ fflapack.cpp \PYGZhy{}llapack
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{FE array}
\label{\detokenize{example/developers:fe-array}}\label{\detokenize{example/developers:examplefearray}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{f}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{uu}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//an array of FE function}
\PYG{c+c1}{// Solve problem 1}
\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{c+c1}{// Solve problem 2}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{c+c1}{// Solve problem 3}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{FEArray1}.png}
\caption{First result}\label{\detokenize{example/developers:id3}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{FEArray2}.png}
\caption{Second result}\label{\detokenize{example/developers:id4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{FEArray3}.png}
\caption{Third result}\label{\detokenize{example/developers:id5}}\end{subfigure}
\caption{Finite element array}

\end{figure}



\subsection{Loop}
\label{\detokenize{example/developers:loop}}\label{\detokenize{example/developers:exampleloop}}\label{\detokenize{example/developers:FEArray}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{=}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{k+kp}{eps} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kp}{eps} \PYG{o}{=} \PYG{k+kp}{eps}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{)}
        \PYG{k}{break}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{k}{continue}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{j = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Implicit loop}
\label{\detokenize{example/developers:implicit-loop}}\label{\detokenize{example/developers:exampleimplicitloop}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n+nl}{bi} \PYG{o}{:} \PYG{n}{b}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{n}{bi} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bi} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n+nl}{aij} \PYG{o}{:} \PYG{n}{a}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{n}{aij} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{aij}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.2}\PYG{p}{)} \PYG{n}{aij} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{;}
\PYG{k+kt}{string}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{ss}\PYG{p}{;} \PYG{c+c1}{//a map}
\PYG{n}{ss}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{ss}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{ss}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n+nl}{bi} \PYG{o}{:} \PYG{n}{ss}\PYG{p}{]}
    \PYG{n}{bi} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{6} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dddd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ss = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{si}\PYG{p}{;}
\PYG{n}{si}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{si}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n+nl}{vi} \PYG{o}{:} \PYG{n}{si}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ i }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{setw}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{setw}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vi} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{vi} \PYG{o}{=} \PYG{n+nf}{atoi}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{si = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{si} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n+nl}{aij} \PYG{o}{:} \PYG{k+kp}{A}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{aij} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{aij} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{aij}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{0} \PYG{l+m}{1}
\PYG{l+m}{1} \PYG{l+m}{2}
\PYG{l+m}{2} \PYG{l+m}{3}
\PYG{l+m}{3} \PYG{l+m}{4}
\PYG{l+m}{4} \PYG{l+m}{5}
\PYG{l+m}{5} \PYG{l+m}{6}
\PYG{l+m}{6} \PYG{l+m}{7}
\PYG{l+m}{7} \PYG{l+m}{8}
\PYG{l+m}{8} \PYG{l+m}{9}
\PYG{l+m}{9} \PYG{l+m}{10}
\PYG{n+nv}{b} \PYG{o}{=} \PYG{l+m}{10}
      \PYG{l+m}{1}   \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}
      \PYG{l+m}{6}   \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}

\PYG{n+nv}{a} \PYG{o}{=} \PYG{l+m}{10} \PYG{l+m}{10}
     \PYG{l+m}{0}.5 \PYG{l+m}{0}.3333333333 \PYG{l+m}{0}.25 \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
     \PYG{l+m}{0}.3333333333 \PYG{l+m}{0}.25 \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
     \PYG{l+m}{0}.25 \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
     \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}

\PYG{n+nv}{ss} \PYG{o}{=} \PYG{l+m}{1} \PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{2}
\PYG{l+m}{3} \PYG{l+m}{5}

 i   \PYG{l+m}{1}          \PYG{l+m}{2}
 i  \PYG{l+m}{50}          \PYG{l+m}{1}
\PYG{n+nv}{si} \PYG{o}{=} \PYG{l+m}{1} \PYG{l+m}{2}
\PYG{l+m}{50} \PYG{l+m}{100}

\PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0}.5
\PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{0}.333333
\PYG{l+m}{0} \PYG{l+m}{2} \PYG{l+m}{0}.25
\PYG{l+m}{0} \PYG{l+m}{3} \PYG{l+m}{0}.2
\PYG{l+m}{1} \PYG{l+m}{0} \PYG{l+m}{0}.333333
\PYG{l+m}{1} \PYG{l+m}{1} \PYG{l+m}{0}.25
\PYG{l+m}{1} \PYG{l+m}{2} \PYG{l+m}{0}.2
\PYG{l+m}{2} \PYG{l+m}{0} \PYG{l+m}{0}.25
\PYG{l+m}{2} \PYG{l+m}{1} \PYG{l+m}{0}.2
\PYG{l+m}{3} \PYG{l+m}{0} \PYG{l+m}{0}.2
\PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{10} \PYG{l+m}{10} \PYG{l+m}{0}  \PYG{l+m}{10}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYGZhy{}0.5
        \PYG{l+m}{1}         \PYG{l+m}{2} \PYGZhy{}0.33333333333333331483
        \PYG{l+m}{1}         \PYG{l+m}{3} \PYGZhy{}0.25
        \PYG{l+m}{1}         \PYG{l+m}{4} \PYGZhy{}0.2000000000000000111
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYGZhy{}0.33333333333333331483
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYGZhy{}0.25
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYGZhy{}0.2000000000000000111
        \PYG{l+m}{3}         \PYG{l+m}{1} \PYGZhy{}0.25
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYGZhy{}0.2000000000000000111
        \PYG{l+m}{4}         \PYG{l+m}{1} \PYGZhy{}0.2000000000000000111
\end{sphinxVerbatim}


\subsection{I/O}
\label{\detokenize{example/developers:i-o}}\label{\detokenize{example/developers:exampleio}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{std\PYGZhy{}out}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ enter i = ?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{i}\PYG{p}{;}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hello world\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//close the file f because the variable f is delete}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ifstream} \PYG{n}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{append}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//to append to the existing file \PYGZdq{}toto.txt\PYGZdq{}}
    \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hello world\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//close the file f because the variable f is delete}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{File stream}
\label{\detokenize{example/developers:file-stream}}\label{\detokenize{example/developers:examplefilestream}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{where}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{f} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{g}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{binary}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{precision}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{where} \PYG{o}{=} \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{tellp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.1} \PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Where in file }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{where} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZsh{} comment bla bla ... 0.3 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{flush}\PYG{p}{;} \PYG{c+c1}{//to flush the buffer of file}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//Function to skip comment starting with \PYGZsh{} in a file}
\PYG{k+kt}{func} \PYG{k+kt}{ifstream} \PYG{n}{skipcomment}\PYG{p}{(}\PYG{k+kt}{ifstream} \PYG{o}{\PYGZam{}}\PYG{n}{ff}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{where} \PYG{o}{=} \PYG{n}{ff}\PYG{p}{.}\PYG{n+nf}{tellg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//store file position}
        \PYG{k+kt}{string} \PYG{n}{comment}\PYG{p}{;}
        \PYG{n}{ff} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{comment}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{ff}\PYG{p}{.}\PYG{k+kr}{good}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{comment}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZsh{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{comment}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{} \PYGZsh{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{comment} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}\PYG{p}{\PYGZob{}}
            \PYG{n}{ff}\PYG{p}{.}\PYG{n+nf}{seekg}\PYG{p}{(}\PYG{n}{where}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//restore file position}
            \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{ff}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kt}{ifstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{binary}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Where }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{seekg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{seekg}\PYG{p}{(}\PYG{n}{where}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ good ? }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{good}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{xx} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{skipcomment}\PYG{p}{(}\PYG{k+kp}{file}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{xx}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{xx} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{seekg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//rewind}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Where }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{tellg}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{good}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{g}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Command line arguments}
\label{\detokenize{example/developers:command-line-arguments}}\label{\detokenize{example/developers:examplecommandlinearguments}}
When using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
FreeFem++ script.edp arg1 arg2
\end{sphinxVerbatim}

The arguments can be used in the script with:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

When using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
FreeFem++ script.edp \PYGZhy{}n \PYG{l+m}{10} \PYGZhy{}a \PYG{l+m}{1}. \PYGZhy{}d \PYG{l+m}{42}.
\end{sphinxVerbatim}

The arguments can be used in the script with:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{getARGV.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Macro}
\label{\detokenize{example/developers:macro}}\label{\detokenize{example/developers:examplemacro}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Macro without parameters}
\PYG{k+kt}{macro} \PYG{n+nf}{xxx}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{c+c1}{//}

\PYG{n}{xxx}

\PYG{c+c1}{// Macro with parameters}
\PYG{k+kt}{macro} \PYG{n}{toto}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{n}{i} \PYG{c+c1}{//}

\PYG{n}{toto}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{// Macro as parameter of a macro}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n+nf}{VIL6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{VIL3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{[}
    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{VV3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{k+kt}{func} \PYG{n}{C5x5} \PYG{o}{=} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{VIL6}\PYG{p}{,} \PYG{n}{CC}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{E5x2} \PYG{o}{=} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{VIL3}\PYG{p}{,} \PYG{n}{EE}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{Eps} \PYG{o}{=} \PYG{n}{VV3}\PYG{p}{(}\PYG{n}{VIL3}\PYG{p}{,} \PYG{n}{EEps}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Macro concatenation}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{Ux}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{div}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Verify the quoting}
\PYG{k+kt}{macro} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)} \PYG{n}{i} \PYG{n}{j} \PYG{n}{k} \PYG{c+c1}{//}
\PYG{n}{foo}\PYG{p}{(}\PYG{p}{,} \PYG{p}{,} \PYG{p}{)}
\PYG{n}{foo}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{//NewMacro \PYGZhy{} EndMacro}
\PYG{k+kt}{NewMacro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{k+kt}{EndMacro}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// IFMACRO \PYGZhy{} ENDIFMACRO}
\PYG{k+kt}{macro} \PYG{n}{AA} \PYG{n}{CAS1} \PYG{c+c1}{//}

\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,}\PYG{n}{CAS1} \PYG{p}{)}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{AA = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n}{CASE} \PYG{n}{file1}\PYG{p}{.}\PYG{n}{edp}\PYG{c+c1}{//}
\PYG{c+cp}{ENDIFMACRO}
\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{n}{CAS2}\PYG{p}{)}
\PYG{k+kt}{macro} \PYG{n}{CASE} \PYG{n}{file2}\PYG{p}{.}\PYG{n}{edp}\PYG{c+c1}{//}
\PYG{c+cp}{ENDIFMACRO}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CASE = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{CASE}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{CASE}\PYG{p}{)}
\PYG{c+cp}{include} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{CASE}\PYG{p}{)}
\PYG{c+cp}{ENDIFMACRO}

\PYG{c+c1}{// FILE \PYGZhy{} LINE}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{FILE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, line }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{LINE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output script generated with macros is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{c+c1}{// Macro without parameters}
\PYG{l+m+mi}{2} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{xxx} \PYG{p}{\PYGZob{}}
\PYG{l+m+mi}{3} \PYG{o}{:}     \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{4} \PYG{o}{:}     \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{5} \PYG{o}{:}     \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{6} \PYG{o}{:} \PYG{p}{\PYGZcb{}}\PYG{c+c1}{//}
\PYG{l+m+mi}{7} \PYG{o}{:}
\PYG{l+m+mi}{8} \PYG{o}{:}
\PYG{l+m+mi}{1} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{3} \PYG{o}{:}
\PYG{l+m+mi}{4} \PYG{o}{:}  \PYG{p}{\PYGZob{}}
\PYG{l+m+mi}{1} \PYG{o}{:}     \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{2} \PYG{o}{:}     \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{3} \PYG{o}{:}     \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{4} \PYG{o}{:} \PYG{p}{\PYGZcb{}}
\PYG{l+m+mi}{9} \PYG{o}{:}
\PYG{l+m+mi}{10} \PYG{o}{:} \PYG{c+c1}{// Macro with parameters}
\PYG{l+m+mi}{11} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{toto}\PYG{p}{(}\PYG{n}{i} \PYG{p}{)}   \PYG{n}{i} \PYG{c+c1}{//}
\PYG{l+m+mi}{12} \PYG{o}{:}
\PYG{l+m+mi}{13} \PYG{o}{:}                    \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{14} \PYG{o}{:}
\PYG{l+m+mi}{15} \PYG{o}{:} \PYG{c+c1}{// Macro as parameter of a macro}
\PYG{l+m+mi}{16} \PYG{o}{:} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{17} \PYG{o}{:}
\PYG{l+m+mi}{18} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VIL6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{i} \PYG{p}{)}   \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{19} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VIL3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{i} \PYG{p}{)}   \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{20} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{vv} \PYG{p}{)}   \PYG{p}{[}
\PYG{l+m+mi}{21} \PYG{o}{:}    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mi}{22} \PYG{o}{:}    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mi}{23} \PYG{o}{:}    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{24} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VV3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{vv} \PYG{p}{)}   \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{25} \PYG{o}{:}
\PYG{l+m+mi}{26} \PYG{o}{:} \PYG{k+kt}{func} \PYG{n}{C5x5} \PYG{o}{=}
\PYG{l+m+mi}{1} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{3} \PYG{o}{:}       \PYG{p}{[}
\PYG{l+m+mi}{1} \PYG{o}{:}             \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}         \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{2} \PYG{o}{:}             \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}         \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{3} \PYG{o}{:}             \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{p}{]} \PYG{p}{;}
\PYG{l+m+mi}{27} \PYG{o}{:} \PYG{k+kt}{func} \PYG{n}{E5x2} \PYG{o}{=}
\PYG{l+m+mi}{1} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{3} \PYG{o}{:}       \PYG{p}{[}
\PYG{l+m+mi}{1} \PYG{o}{:}          \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}      \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{2} \PYG{o}{:}          \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}      \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{3} \PYG{o}{:}          \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{p}{]} \PYG{p}{;}
\PYG{l+m+mi}{28} \PYG{o}{:} \PYG{k+kt}{func} \PYG{n}{Eps} \PYG{o}{=}      \PYG{p}{[}     \PYG{p}{[} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}      \PYG{p}{[} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{p}{]} \PYG{p}{;}
\PYG{l+m+mi}{29} \PYG{o}{:}
\PYG{l+m+mi}{30} \PYG{o}{:} \PYG{c+c1}{// Macro concatenation}
\PYG{l+m+mi}{31} \PYG{o}{:} \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{32} \PYG{o}{:} \PYG{k+kt}{fespace} \PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{33} \PYG{o}{:} \PYG{n}{Vh} \PYG{n}{Ux}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{l+m+mi}{34} \PYG{o}{:}
\PYG{l+m+mi}{35} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{V} \PYG{p}{)}   \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{l+m+mi}{36} \PYG{o}{:}
\PYG{l+m+mi}{37} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}     \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{38} \PYG{o}{:}
\PYG{l+m+mi}{39} \PYG{o}{:} \PYG{c+c1}{// Verify the quoting}
\PYG{l+m+mi}{40} \PYG{o}{:}    \PYG{k+kt}{macro} \PYG{n}{foo}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k} \PYG{p}{)}   \PYG{n}{i} \PYG{n}{j} \PYG{n}{k} \PYG{c+c1}{//}
\PYG{l+m+mi}{41} \PYG{o}{:}
\PYG{l+m+mi}{42} \PYG{o}{:}         \PYG{k+kt}{int}\PYG{p}{[} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10} \PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{43} \PYG{o}{:}
\PYG{l+m+mi}{44} \PYG{o}{:} \PYG{c+c1}{//NewMacro \PYGZhy{} EndMacro}
\PYG{l+m+mi}{45} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u} \PYG{p}{)}   \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}
\PYG{l+m+mi}{46} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}    \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{]} \PYG{o}{\PYGZsq{}} \PYG{o}{*}     \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{]} \PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{47} \PYG{o}{:}
\PYG{l+m+mi}{48} \PYG{o}{:} \PYG{c+c1}{// IFMACRO \PYGZhy{} ENDIFMACRO}
\PYG{l+m+mi}{49} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{AACAS1} \PYG{c+c1}{//}
\PYG{l+m+mi}{50} \PYG{o}{:}
\PYG{l+m+mi}{51} \PYG{o}{:}
\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{AA = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(} \PYG{n}{CAS1} \PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{2} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{CASEfile1}\PYG{p}{.}\PYG{n}{edp}\PYG{c+c1}{//}
\PYG{l+m+mi}{3} \PYG{o}{:}
\PYG{l+m+mi}{52} \PYG{o}{:}
\PYG{l+m+mi}{53} \PYG{o}{:}
\PYG{l+m+mi}{54} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CASE = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{file1}\PYG{p}{.}\PYG{n}{edp}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{55} \PYG{o}{:}
\PYG{l+m+mi}{56} \PYG{o}{:}
\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{c+cp}{include} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{file1}\PYG{p}{.}\PYG{n}{edp}\PYG{p}{)}\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This is the file 1}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{57} \PYG{o}{:}
\PYG{l+m+mi}{58} \PYG{o}{:} \PYG{c+c1}{// FILE \PYGZhy{} LINE}
\PYG{l+m+mi}{59} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{FILE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, line }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{LINE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output os this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{AA} \PYG{o}{=} CAS1
\PYG{n+nv}{CASE} \PYG{o}{=} file1.edp
This is the file \PYG{l+m}{1}
In Macro.edp, line \PYG{l+m}{59}
\end{sphinxVerbatim}


\subsection{Basic error handling}
\label{\detokenize{example/developers:basic-error-handling}}\label{\detokenize{example/developers:examplebasicerrorhandling}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a}\PYG{p}{;}
\PYG{k}{try}\PYG{p}{\PYGZob{}}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{catch} \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{c+c1}{//all exceptions can be caught}
\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Catch an ExecError}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{1}/0 : d d d
  current \PYG{n+nv}{line} \PYG{o}{=} \PYG{l+m}{3}
Exec error :  Div by \PYG{l+m}{0}
   \PYGZhy{}\PYGZhy{} number :1
Catch an ExecError
\end{sphinxVerbatim}


\subsection{Error handling}
\label{\detokenize{example/developers:error-handling}}\label{\detokenize{example/developers:exampleerrorhandling}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//right hand side function}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//boundary condition function}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{cpu} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{laplace} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{tolpivot}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{vh}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k}{try}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Try Cholesky}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{laplace}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Display}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{laplacian Cholesky }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nn} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, x\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nn} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZhy{}}\PYG{n}{cpu}\PYG{o}{+}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ s, max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{//catch all error}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Catch cholesky PB }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Try Cholesky
ERREUR choleskypivot \PYG{o}{(}\PYG{l+m}{35}\PYG{o}{)}\PYG{o}{=} \PYGZhy{}6.43929e\PYGZhy{}15 \PYGZlt{} 1e\PYGZhy{}06
  current \PYG{n+nv}{line} \PYG{o}{=} \PYG{l+m}{29}
Exec error : FATAL ERREUR dans ./../femlib/MatriceCreuse\PYGZus{}tpl.hpp
cholesky line:
   \PYGZhy{}\PYGZhy{} number :688
 catch an erreur in  \PYG{n+nv}{solve}  \PYG{o}{=}\PYGZgt{}  \PYG{n+nb}{set}  \PYG{n+nv}{sol} \PYG{o}{=} \PYG{l+m}{0} !!!!!!!
 Catch cholesky PB
\end{sphinxVerbatim}

\begin{sphinxthebibliography}{STROUSTR}
\bibitem[PIRONNEAU1998]{reference:pironneau1998}
PIRONNEAU, Olivier and LUCQUIN-DESREUX, Brigitte. Introduction to scientific computing. Wiley, 1998.
\bibitem[WÄCHTER2006]{reference:wachter2006}
WÄCHTER, Andreas and BIEGLER, Lorenz T. On the implementation of an interior-point filter line-search algorithm for large-scale nonlinear programming. Mathematical programming, 2006, vol. 106, no 1, p. 25-57.
\bibitem[FORSGREN2002]{reference:forsgren2002}
FORSGREN, Anders, GILL, Philip E., and WRIGHT, Margaret H. Interior methods for nonlinear optimization. SIAM review, 2002, vol. 44, no 4, p. 525-597.
\bibitem[GEORGE1996]{reference:george1996}
GEORGE, P. L. and BOROUCHAKI, H. Automatic triangulation. 1996.
\bibitem[HECHT1998]{reference:hecht1998}
HECHT, F. The mesh adapting software: bamg. INRIA report, 1998, vol. 250, p. 252.
\bibitem[PREPARATA1985]{reference:preparata1985}
PREPARATA, F. P. and SHAMOS, M. I. Computational Geometry Springer-Verlag. New York, 1985.
\bibitem[STROUSTRUP2000]{reference:stroustrup2000}
STROUSTRUP, Bjarne. The C++ programming language. Pearson Education India, 2000.
\bibitem[HECHT2002]{reference:hecht2002}
HECHT, Frédéric. C++ Tools to construct our user-level language. ESAIM: Mathematical Modelling and Numerical Analysis, 2002, vol. 36, no 5, p. 809-836.
\bibitem[HANG2006]{reference:hang2006}
SI, Hang. TetGen Users’ guide: A quality tetrahedral mesh generator and three-dimensional delaunay triangulator. 2006
\bibitem[SHEWCHUK1998]{reference:shewchuk1998}
SHEWCHUK, Jonathan Richard. Tetrahedral mesh generation by Delaunay refinement. In : Proceedings of the fourteenth annual symposium on Computational geometry. ACM, 1998. p. 86-95.
\bibitem[HECHT1992]{reference:hecht1992}
HECHT, F. Outils et algorithmes pour la méthode des éléments finis. HdR, Université Pierre et Marie Curie, France, 1992.
\bibitem[HECHT1998\_2]{reference:hecht1998-2}
HECHT, Frédéric. BAMG: bidimensional anisotropic mesh generator. User Guide. INRIA, Rocquencourt, 1998.
\bibitem[KARYPIS1995]{reference:karypis1995}
KARYPIS, George and KUMAR, Vipin. METIS\textendash{}unstructured graph partitioning and sparse matrix ordering system, version 2.0. 1995.
\bibitem[CAI1989]{reference:cai1989}
CAI, Xiao-Chuan. Some domain decomposition algorithms for nonselfadjoint elliptic and parabolic partial differential equations. 1989.
\bibitem[SAAD2003]{reference:saad2003}
SAAD, Yousef. Iterative methods for sparse linear systems. siam, 2003.
\bibitem[SMITH1996]{reference:smith1996}
SMITH, B. P. Bj rstad and W. Gropp, Domain Decomposition. 1996.
\bibitem[OGDEN1984]{reference:ogden1984}
OGDEN, Ray W. Non-linear elastic deformations. 1984.
\bibitem[RAVIART1998]{reference:raviart1998}
RAVIART, Pierre-Arnaud, THOMAS, Jean-Marie, CIARLET, Philippe G., et al. Introduction à l’analyse numérique des équations aux dérivées partielles. Paris : Dunod, 1998.
\bibitem[HORGAN2004]{reference:horgan2004}
HORGAN, Cornelius O. and SACCOMANDI, Giuseppe. Constitutive models for compressible nonlinearly elastic materials with limiting chain extensibility. Journal of Elasticity, 2004, vol. 77, no 2, p. 123-138.
\bibitem[LEHOUCQ1998]{reference:lehoucq1998}
LEHOUCQ, Richard B., SORENSEN, Danny C., and YANG, Chao. ARPACK users’ guide: solution of large-scale eigenvalue problems with implicitly restarted Arnoldi methods. Siam, 1998.
\bibitem[NECAS2017]{reference:necas2017}
NECAS, Jindrich and HLAVÁCEK, Ivan. Mathematical theory of elastic and elasto-plastic bodies: an introduction. Elsevier, 2017.
\bibitem[OHTSUKA2000]{reference:ohtsuka2000}
OHTSUKA, K. Theoretical and Numerical analysis of energy release rate in 2D fracture. INFORMATION, 2000, vol. 3, p. 303-315.
\bibitem[TABATA1994]{reference:tabata1994}
TABATA, M. Numerical solutions of partial differential equations II. Iwanami Applied Math, 1994.
\bibitem[LUCQUIN1998]{reference:lucquin1998}
PIRONNEAU, O. and LUCQUIN-DESREUX, B. Introduction to scientific computing. Wiley, 1998.
\bibitem[WILMOTT1995]{reference:wilmott1995}
WILMOTT, Paul, HOWISON, Sam and DEWYNNE, Jeff. A student introduction to mathematical finance. 1995.
\bibitem[ACHDOU2005]{reference:achdou2005}
ACHDOU, Yves and PIRONNEAU, Olivier. Computational methods for option pricing. Siam, 2005.
\bibitem[TEMAM1977]{reference:temam1977}
TEMAM, Roger. Navier-Stokes equations: theory and numerical analysis. 1977.
\bibitem[ROBERTS1993]{reference:roberts1993}
ROBERTS, J. E. and THOMAS, J. M. Mixed and Hybrid Methods, Handbook of Numerical Anaysis, Vol. II. North-Holland, 1993, vol. 183, p. 184.
\bibitem[GLOWINSKI1979]{reference:glowinski1979}
GLOWINSKI, R. and PIRONNEAU, O. On numerical methods for the Stokes problem. In: Energy methods in finite element analysis.(A79-53076 24-39) Chichester, Sussex, England, Wiley-Interscience, 1979, p. 243-264., 1979, p. 243-264.
\bibitem[GLOWINSKI1985]{reference:glowinski1985}
GLOWINSKI, Roland and ODEN, J. Tinsley. Numerical methods for nonlinear variational problems. Journal of Applied Mechanics, 1985, vol. 52, p. 739.
\bibitem[GLOWINSKI2003]{reference:glowinski2003}
GLOWINSKI, Roland. Finite element methods for incompressible viscous flow. Handbook of numerical analysis, 2003, vol. 9, p. 3-1176.
\bibitem[ITO2003]{reference:ito2003}
ITO, Kazufumi and KUNISCH, Karl. Semi\textendash{}smooth Newton methods for variational inequalities of the first kind. ESAIM: Mathematical Modelling and Numerical Analysis, 2003, vol. 37, no 1, p. 41-62.
\bibitem[OXBORROW2007]{reference:oxborrow2007}
OXBORROW, Mark. Traceable 2-D finite-element simulation of the whispering-gallery modes of axisymmetric electromagnetic resonators. IEEE Transactions on Microwave Theory and Techniques, 2007, vol. 55, no 6, p. 1209-1218.
\bibitem[GRUDININ2012]{reference:grudinin2012}
GRUDININ, Ivan S. and YU, Nan. Finite-element modeling of coupled optical microdisk resonators for displacement sensing. JOSA B, 2012, vol. 29, no 11, p. 3010-3014.
\bibitem[ERN2006]{reference:ern2006}
ERN, A. and GUERMOND, J. L. Discontinuous Galerkin methods for Friedrichs’ symmetric systems. I. General theory. SIAM J. Numer. Anal.
\bibitem[BERNADOU1980]{reference:bernadou1980}
BERNADOU, Michel, BOISSERIE, Jean-Marie and HASSAN, Kamal. Sur l’implémentation des éléments finis de Hsieh-Clough-Tocher complet et réduit. 1980. Thèse de doctorat. INRIA.
\bibitem[BERNARDI1985]{reference:bernardi1985}
BERNARDI, Christine and RAUGEL, Genevieve. Analysis of some finite elements for the Stokes problem. Mathematics of Computation, 1985, p. 71-79.
\bibitem[THOMASSET2012]{reference:thomasset2012}
THOMASSET, François. Implementation of finite element methods for Navier-Stokes equations. Springer Science \& Business Media, 2012.
\bibitem[CROUZEIX1984]{reference:crouzeix1984}
CROUZEIX, Michel and MIGNOT, Alain L. Analyse numérique des équations différentielles. Masson, 1984.
\bibitem[TAYLOR2005]{reference:taylor2005}
TAYLOR, Mark A., WINGATE, Beth A. and BOS, Len P. Several new quadrature formulas for polynomial integration in the triangle. arXiv preprint math/0501496, 2005.
\bibitem[CHOW1997]{reference:chow1997}
CHOW, Edmond and SAAD, Yousef. Parallel Approximate Inverse Preconditioners. In : PPSC. 1997.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}